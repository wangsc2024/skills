{
  "title": "Functional API: Minimal changes to existing code",
  "content": "from langgraph.func import entrypoint, task\n\n@task\ndef process_user_input(user_input: str) -> dict:\n    # Existing function with minimal changes\n    return {\"processed\": user_input.lower().strip()}\n\n@entrypoint(checkpointer=checkpointer)\ndef workflow(user_input: str) -> str:\n    # Standard Python control flow\n    processed = process_user_input(user_input).result()\n\nif \"urgent\" in processed[\"processed\"]:\n        response = handle_urgent_request(processed).result()\n    else:\n        response = handle_normal_request(processed).result()\n\nreturn response\npython  theme={null}\n@entrypoint(checkpointer=checkpointer)\ndef essay_workflow(topic: str) -> dict:\n    # Linear flow with simple branching\n    outline = create_outline(topic).result()\n\nif len(outline[\"points\"]) < 3:\n        outline = expand_outline(outline).result()\n\ndraft = write_draft(outline).result()\n\n# Human review checkpoint\n    feedback = interrupt({\"draft\": draft, \"action\": \"Please review\"})\n\nif feedback == \"approve\":\n        final_essay = draft\n    else:\n        final_essay = revise_essay(draft, feedback).result()\n\nreturn {\"essay\": final_essay}\npython  theme={null}\n@entrypoint(checkpointer=checkpointer)\ndef quick_prototype(data: dict) -> dict:\n    # Fast iteration - no state schema needed\n    step1_result = process_step1(data).result()\n    step2_result = process_step2(step1_result).result()\n\nreturn {\"final_result\": step2_result}\npython  theme={null}\n@task\ndef analyze_document(document: str) -> dict:\n    # Local state management within function\n    sections = extract_sections(document)\n    summaries = [summarize(section) for section in sections]\n    key_points = extract_key_points(summaries)\n\nreturn {\n        \"sections\": len(sections),\n        \"summaries\": summaries,\n        \"key_points\": key_points\n    }\n\n@entrypoint(checkpointer=checkpointer)\ndef document_processor(document: str) -> dict:\n    analysis = analyze_document(document).result()\n    # State is passed between functions as needed\n    return generate_report(analysis).result()\npython  theme={null}\nfrom langgraph.graph import StateGraph\nfrom langgraph.func import entrypoint",
  "code_samples": [
    {
      "code": "**2. Linear workflows with simple logic**\n\nWhen your workflow is primarily sequential with straightforward conditional logic.",
      "language": "unknown"
    },
    {
      "code": "**3. Rapid prototyping**\n\nWhen you want to quickly test ideas without the overhead of defining state schemas and graph structures.",
      "language": "unknown"
    },
    {
      "code": "**4. Function-scoped state management**\n\nWhen your state is naturally scoped to individual functions and doesn't need to be shared broadly.",
      "language": "unknown"
    },
    {
      "code": "## Combining both APIs\n\nYou can use both APIs together in the same application. This is useful when different parts of your system have different requirements.",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Combining both APIs",
      "id": "combining-both-apis"
    }
  ],
  "url": "llms-txt#functional-api:-minimal-changes-to-existing-code",
  "links": []
}