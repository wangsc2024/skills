{
  "title": "Main agent with subagent as a tool  # [!code highlight]",
  "content": "main_agent = create_agent(model=\"...\", tools=[call_subagent])  # [!code highlight]\nmermaid  theme={null}\ngraph LR\n    A[User] --> B[Main Agent]\n    B --> C{task<br/>agent_name, description}\n    C -->|research| D[Research Agent]\n    C -->|writer| E[Writer Agent]\n    C -->|reviewer| F[Reviewer Agent]\n    D --> C\n    E --> C\n    F --> C\n    C --> B\n    B --> G[User response]\npython  theme={null}\n  from langchain.tools import tool\n  from langchain.agents import create_agent\n\n# Sub-agents developed by different teams\n  research_agent = create_agent(\n      model=\"gpt-4o\",\n      prompt=\"You are a research specialist...\"\n  )\n\nwriter_agent = create_agent(\n      model=\"gpt-4o\",\n      prompt=\"You are a writing specialist...\"\n  )\n\n# Registry of available sub-agents\n  SUBAGENTS = {\n      \"research\": research_agent,\n      \"writer\": writer_agent,\n  }\n\n@tool\n  def task(\n      agent_name: str,\n      description: str\n  ) -> str:\n      \"\"\"Launch an ephemeral subagent for a task.\n\nAvailable agents:\n      - research: Research and fact-finding\n      - writer: Content creation and editing\n      \"\"\"\n      agent = SUBAGENTS[agent_name]\n      result = agent.invoke({\n          \"messages\": [\n              {\"role\": \"user\", \"content\": description}\n          ]\n      })\n      return result[\"messages\"][-1].content\n\n# Main coordinator agent\n  main_agent = create_agent(\n      model=\"gpt-4o\",\n      tools=[task],\n      system_prompt=(\n          \"You coordinate specialized sub-agents. \"\n          \"Available: research (fact-finding), \"\n          \"writer (content creation). \"\n          \"Use the task tool to delegate work.\"\n      ),\n  )\n  python Subagent inputs example expandable theme={null}\nfrom langchain.agents import AgentState\nfrom langchain.tools import tool, ToolRuntime\n\nclass CustomState(AgentState):\n    example_state_key: str\n\n@tool(\n    \"subagent1_name\",\n    description=\"subagent1_description\"\n)\ndef call_subagent1(query: str, runtime: ToolRuntime[None, CustomState]):\n    # Apply any logic needed to transform the messages into a suitable input\n    subagent_input = some_logic(query, runtime.state[\"messages\"])\n    result = subagent1.invoke({\n        \"messages\": subagent_input,\n        # You could also pass other state keys here as needed.\n        # Make sure to define these in both the main and subagent's\n        # state schemas.\n        \"example_state_key\": runtime.state[\"example_state_key\"]\n    })\n    return result[\"messages\"][-1].content\npython Subagent outputs example expandable theme={null}\nfrom typing import Annotated\nfrom langchain.agents import AgentState\nfrom langchain.tools import InjectedToolCallId\nfrom langgraph.types import Command\n\n@tool(\n    \"subagent1_name\",\n    description=\"subagent1_description\"\n)\ndef call_subagent1(\n    query: str,\n    tool_call_id: Annotated[str, InjectedToolCallId],\n) -> Command:\n    result = subagent1.invoke({\n        \"messages\": [{\"role\": \"user\", \"content\": query}]\n    })\n    return Command(update={\n        # Pass back additional state from the subagent\n        \"example_state_key\": result[\"example_state_key\"],\n        \"messages\": [\n            ToolMessage(\n                content=result[\"messages\"][-1].content,\n                tool_call_id=tool_call_id\n            )\n        ]\n    })\n```\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit this page on GitHub](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/multi-agent/subagents.mdx) or [file an issue](https://github.com/langchain-ai/docs/issues/new/choose).\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "code_samples": [
    {
      "code": "The main agent invokes the subagent tool when it decides the task matches the subagent's description, receives the result, and continues orchestration. See [Context engineering](#context-engineering) for fine-grained control.\n\n### Single dispatch tool\n\nAn alternative approach uses a single parameterized tool to invoke ephemeral sub-agents for independent tasks. Unlike the [tool per agent](#tool-per-agent) approach where each sub-agent is wrapped as a separate tool, this uses a convention-based approach with a single `task` tool: the task description is passed as a human message to the sub-agent, and the sub-agent's final message is returned as the tool result.\n\nUse this approach when you want to distribute agent development across multiple teams, need to isolate complex tasks into separate context windows, need a scalable way to add new agents without modifying the coordinator, or prefer convention over customization. This approach trades flexibility in context engineering for simplicity in agent composition and strong context isolation.",
      "language": "unknown"
    },
    {
      "code": "**Key characteristics:**\n\n* Single task tool: One parameterized tool that can invoke any registered sub-agent by name\n* Convention-based invocation: Agent selected by name, task passed as human message, final message returned as tool result\n* Team distribution: Different teams can develop and deploy agents independently\n* Agent discovery: Sub-agents can be discovered via system prompt (listing available agents) or through [progressive disclosure](/oss/python/langchain/multi-agent/skills-sql-assistant) (loading agent information on-demand via tools)\n\n<Tip>\n  An interesting aspect of this approach is that sub-agents may have the exact same capabilities as the main agent. In such cases, invoking a sub-agent is **really about context isolation** as the primary reason—allowing complex, multi-step tasks to run in isolated context windows without bloating the main agent's conversation history. The sub-agent completes its work autonomously and returns only a concise summary, keeping the main thread focused and efficient.\n</Tip>\n\n<Accordion title=\"Agent registry with task dispatcher\">",
      "language": "unknown"
    },
    {
      "code": "</Accordion>\n\n## Context engineering\n\nControl how context flows between the main agent and its subagents:\n\n| Category                                  | Purpose                                                  | Impacts                      |\n| ----------------------------------------- | -------------------------------------------------------- | ---------------------------- |\n| [**Subagent specs**](#subagent-specs)     | Ensure subagents are invoked when they should be         | Main agent routing decisions |\n| [**Subagent inputs**](#subagent-inputs)   | Ensure subagents can execute well with optimized context | Subagent performance         |\n| [**Subagent outputs**](#subagent-outputs) | Ensure the supervisor can act on subagent results        | Main agent performance       |\n\nSee also our comprehensive guide on [context engineering](/oss/python/langchain/context-engineering) for agents.\n\n### Subagent specs\n\nThe **names** and **descriptions** associated with subagents are the primary way the main agent knows which subagents to invoke.\nThese are prompting levers—choose them carefully.\n\n* **Name**: How the main agent refers to the sub-agent. Keep it clear and action-oriented (e.g., `research_agent`, `code_reviewer`).\n* **Description**: What the main agent knows about the sub-agent's capabilities. Be specific about what tasks it handles and when to use it.\n\nFor the [single dispatch tool](#single-dispatch-tool) design, the main agent needs to call the `task` tool with the name of the subagent to invoke. The available tools can be provided to the main agent via one of the following methods:\n\n* **System prompt enumeration**: List available agents in the system prompt.\n* **Enum constraint on dispatch tool**: For small agent lists, add an enum to the `agent_name` field.\n* **Tool-based discovery**: For large or dynamic agent registries, provide a separate tool (e.g., `list_agents` or `search_agents`) that returns available agents.\n\n### Subagent inputs\n\nCustomize what context the subagent receives to execute its task. Add input that isn't practical to capture in a static prompt—full message history, prior results, or task metadata—by pulling from the agent's state.",
      "language": "unknown"
    },
    {
      "code": "### Subagent outputs\n\nCustomize what the main agent receives back so it can make good decisions. Two strategies:\n\n1. **Prompt the sub-agent**: Specify exactly what should be returned. A common failure mode is that the sub-agent performs tool calls or reasoning but doesn't include results in its final message—remind it that the supervisor only sees the final output.\n2. **Format in code**: Adjust or enrich the response before returning it. For example, pass specific state keys back in addition to the final text using a [`Command`](/oss/python/langgraph/graph-api#command).",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h3",
      "text": "Single dispatch tool",
      "id": "single-dispatch-tool"
    },
    {
      "level": "h2",
      "text": "Context engineering",
      "id": "context-engineering"
    },
    {
      "level": "h3",
      "text": "Subagent specs",
      "id": "subagent-specs"
    },
    {
      "level": "h3",
      "text": "Subagent inputs",
      "id": "subagent-inputs"
    },
    {
      "level": "h3",
      "text": "Subagent outputs",
      "id": "subagent-outputs"
    }
  ],
  "url": "llms-txt#main-agent-with-subagent-as-a-tool--#-[!code-highlight]",
  "links": []
}