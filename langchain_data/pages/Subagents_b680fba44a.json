{
  "title": "Subagents",
  "content": "Source: https://docs.langchain.com/oss/python/langchain/multi-agent/subagents\n\nIn the **subagents** architecture, a central main [agent](/oss/python/langchain/agents) (often referred to as a **supervisor**) coordinates subagents by calling them as [tools](/oss/python/langchain/tools). The main agent decides which subagent to invoke, what input to provide, and how to combine results. Subagents are statelessâ€”they don't remember past interactions, with all conversation memory maintained by the main agent. This provides [context](/oss/python/langchain/context-engineering) isolation: each subagent invocation works in a clean context window, preventing context bloat in the main conversation.\n\n## Key characteristics\n\n* Centralized control: All routing passes through the main agent\n* No direct user interaction: Subagents return results to the main agent, not the user (though you can use [interrupts](/oss/python/langgraph/human-in-the-loop#interrupt) within a subagent to allow user interaction)\n* Subagents via tools: Subagents are invoked via tools\n* Parallel execution: The main agent can invoke multiple subagents in a single turn\n\n<Note>\n  **Supervisor vs. Router**: A supervisor agent (this pattern) is different from a [router](/oss/python/langchain/multi-agent/router). The supervisor is a full agent that maintains conversation context and dynamically decides which subagents to call across multiple turns. A router is typically a single classification step that dispatches to agents without maintaining ongoing conversation state.\n</Note>\n\nUse the subagents pattern when you have multiple distinct domains (e.g., calendar, email, CRM, database), subagents don't need to converse directly with users, or you want centralized workflow control. For simpler cases with just a few [tools](/oss/python/langchain/tools), use a [single agent](/oss/python/langchain/agents).\n\n<Tip>\n  **Need user interaction within a subagent?** While subagents typically return results to the main agent rather than conversing directly with users, you can use [interrupts](/oss/python/langgraph/human-in-the-loop#interrupt) within a subagent to pause execution and gather user input. This is useful when a subagent needs clarification or approval before proceeding. The main agent remains the orchestrator, but the subagent can collect information from the user mid-task.\n</Tip>\n\n## Basic implementation\n\nThe core mechanism wraps a subagent as a tool that the main agent can call:\n\n```python  theme={null}\nfrom langchain.tools import tool\nfrom langchain.agents import create_agent",
  "code_samples": [
    {
      "code": "## Key characteristics\n\n* Centralized control: All routing passes through the main agent\n* No direct user interaction: Subagents return results to the main agent, not the user (though you can use [interrupts](/oss/python/langgraph/human-in-the-loop#interrupt) within a subagent to allow user interaction)\n* Subagents via tools: Subagents are invoked via tools\n* Parallel execution: The main agent can invoke multiple subagents in a single turn\n\n<Note>\n  **Supervisor vs. Router**: A supervisor agent (this pattern) is different from a [router](/oss/python/langchain/multi-agent/router). The supervisor is a full agent that maintains conversation context and dynamically decides which subagents to call across multiple turns. A router is typically a single classification step that dispatches to agents without maintaining ongoing conversation state.\n</Note>\n\n## When to use\n\nUse the subagents pattern when you have multiple distinct domains (e.g., calendar, email, CRM, database), subagents don't need to converse directly with users, or you want centralized workflow control. For simpler cases with just a few [tools](/oss/python/langchain/tools), use a [single agent](/oss/python/langchain/agents).\n\n<Tip>\n  **Need user interaction within a subagent?** While subagents typically return results to the main agent rather than conversing directly with users, you can use [interrupts](/oss/python/langgraph/human-in-the-loop#interrupt) within a subagent to pause execution and gather user input. This is useful when a subagent needs clarification or approval before proceeding. The main agent remains the orchestrator, but the subagent can collect information from the user mid-task.\n</Tip>\n\n## Basic implementation\n\nThe core mechanism wraps a subagent as a tool that the main agent can call:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Key characteristics",
      "id": "key-characteristics"
    },
    {
      "level": "h2",
      "text": "When to use",
      "id": "when-to-use"
    },
    {
      "level": "h2",
      "text": "Basic implementation",
      "id": "basic-implementation"
    }
  ],
  "url": "llms-txt#subagents",
  "links": []
}