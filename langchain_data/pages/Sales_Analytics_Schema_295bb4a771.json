{
  "title": "Sales Analytics Schema",
  "content": "### customers\n- customer_id (PRIMARY KEY)\n- name\n- email\n- signup_date\n- status (active/inactive)\n- customer_tier (bronze/silver/gold/platinum)\n\n### orders\n- order_id (PRIMARY KEY)\n- customer_id (FOREIGN KEY -> customers)\n- order_date\n- status (pending/completed/cancelled/refunded)\n- total_amount\n- sales_region (north/south/east/west)\n\n[... rest of schema ...]\n\n**High-value orders**: Orders with `total_amount > 1000`\n**Revenue calculation**: Only count orders with `status = 'completed'`\n\n================================== Ai Message ==================================\n\nHere's a SQL query to find all customers who made orders over $1000 in the last month:\n\n\\`\\`\\`sql\nSELECT DISTINCT\n    c.customer_id,\n    c.name,\n    c.email,\n    c.customer_tier\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nWHERE o.total_amount > 1000\n  AND o.status = 'completed'\n  AND o.order_date >= CURRENT_DATE - INTERVAL '1 month'\nORDER BY c.customer_id;\n\\`\\`\\`\n\nThis query:\n- Joins customers with their orders\n- Filters for high-value orders (>$1000) using the total_amount field\n- Only includes completed orders (as per the business logic)\n- Restricts to orders from the last month\n- Returns distinct customers to avoid duplicates if they made multiple qualifying orders\npython  theme={null}\n  from langchain.agents.middleware import AgentState\n\nclass CustomState(AgentState):  # [!code highlight]\n      skills_loaded: NotRequired[list[str]]  # Track which skills have been loaded  # [!code highlight]\n  python  theme={null}\n  from langgraph.types import Command  # [!code highlight]\n  from langchain.tools import tool, ToolRuntime\n  from langchain.messages import ToolMessage  # [!code highlight]\n\n@tool\n  def load_skill(skill_name: str, runtime: ToolRuntime) -> Command:  # [!code highlight]\n      \"\"\"Load the full content of a skill into the agent's context.\n\nUse this when you need detailed information about how to handle a specific\n      type of request. This will provide you with comprehensive instructions,\n      policies, and guidelines for the skill area.\n\nArgs:\n          skill_name: The name of the skill to load\n      \"\"\"\n      # Find and return the requested skill\n      for skill in SKILLS:\n          if skill[\"name\"] == skill_name:\n              skill_content = f\"Loaded skill: {skill_name}\\n\\n{skill['content']}\"\n\n# Update state to track loaded skill\n              return Command(  # [!code highlight]\n                  update={  # [!code highlight]\n                      \"messages\": [  # [!code highlight]\n                          ToolMessage(  # [!code highlight]\n                              content=skill_content,  # [!code highlight]\n                              tool_call_id=runtime.tool_call_id,  # [!code highlight]\n                          )  # [!code highlight]\n                      ],  # [!code highlight]\n                      \"skills_loaded\": [skill_name],  # [!code highlight]\n                  }  # [!code highlight]\n              )  # [!code highlight]\n\n# Skill not found\n      available = \", \".join(s[\"name\"] for s in SKILLS)\n      return Command(\n          update={\n              \"messages\": [\n                  ToolMessage(\n                      content=f\"Skill '{skill_name}' not found. Available skills: {available}\",\n                      tool_call_id=runtime.tool_call_id,\n                  )\n              ]\n          }\n      )\n  `python  theme={null}\n  @tool\n  def write_sql_query(  # [!code highlight]\n      query: str,\n      vertical: str,\n      runtime: ToolRuntime,\n  ) -> str:\n      \"\"\"Write and validate a SQL query for a specific business vertical.\n\nThis tool helps format and validate SQL queries. You must load the\n      appropriate skill first to understand the database schema.\n\nArgs:\n          query: The SQL query to write\n          vertical: The business vertical (sales_analytics or inventory_management)\n      \"\"\"\n      # Check if the required skill has been loaded\n      skills_loaded = runtime.state.get(\"skills_loaded\", [])  # [!code highlight]\n\nif vertical not in skills_loaded:  # [!code highlight]\n          return (  # [!code highlight]\n              f\"Error: You must load the '{vertical}' skill first \"  # [!code highlight]\n              f\"to understand the database schema before writing queries. \"  # [!code highlight]\n              f\"Use load_skill('{vertical}') to load the schema.\"  # [!code highlight]\n          )  # [!code highlight]\n\n# Validate and format the query\n      return (\n          f\"SQL Query for {vertical}:\\n\\n\"\n          f\"\\n\\n\"\n          f\"âœ“ Query validated against {vertical} schema\\n\"\n          f\"Ready to execute against the database.\"\n      )\n  python  theme={null}\n  class SkillMiddleware(AgentMiddleware[CustomState]):  # [!code highlight]\n      \"\"\"Middleware that injects skill descriptions into the system prompt.\"\"\"\n\nstate_schema = CustomState  # [!code highlight]\n      tools = [load_skill, write_sql_query]  # [!code highlight]\n\n# ... rest of the middleware implementation stays the same\n  python  theme={null}\n  agent = create_agent(\n      model,\n      system_prompt=(\n          \"You are a SQL query assistant that helps users \"\n          \"write queries against business databases.\"\n      ),\n      middleware=[SkillMiddleware()],  # [!code highlight]\n      checkpointer=InMemorySaver(),\n  )\n  python  theme={null}\n  import uuid\n  from typing import TypedDict, NotRequired\n  from langchain.tools import tool\n  from langchain.agents import create_agent\n  from langchain.agents.middleware import ModelRequest, ModelResponse, AgentMiddleware\n  from langchain.messages import SystemMessage\n  from langgraph.checkpoint.memory import InMemorySaver\n  from typing import Callable\n\n# Define skill structure\n  class Skill(TypedDict):\n      \"\"\"A skill that can be progressively disclosed to the agent.\"\"\"\n      name: str\n      description: str\n      content: str\n\n# Define skills with schemas and business logic\n  SKILLS: list[Skill] = [\n      {\n          \"name\": \"sales_analytics\",\n          \"description\": \"Database schema and business logic for sales data analysis including customers, orders, and revenue.\",\n          \"content\": \"\"\"# Sales Analytics Schema\n\n### customers\n  - customer_id (PRIMARY KEY)\n  - name\n  - email\n  - signup_date\n  - status (active/inactive)\n  - customer_tier (bronze/silver/gold/platinum)\n\n### orders\n  - order_id (PRIMARY KEY)\n  - customer_id (FOREIGN KEY -> customers)\n  - order_date\n  - status (pending/completed/cancelled/refunded)\n  - total_amount\n  - sales_region (north/south/east/west)\n\n### order_items\n  - item_id (PRIMARY KEY)\n  - order_id (FOREIGN KEY -> orders)\n  - product_id\n  - quantity\n  - unit_price\n  - discount_percent\n\n**Active customers**: status = 'active' AND signup_date <= CURRENT_DATE - INTERVAL '90 days'\n\n**Revenue calculation**: Only count orders with status = 'completed'. Use total_amount from orders table, which already accounts for discounts.\n\n**Customer lifetime value (CLV)**: Sum of all completed order amounts for a customer.\n\n**High-value orders**: Orders with total_amount > 1000\n\n-- Get top 10 customers by revenue in the last quarter\n  SELECT\n      c.customer_id,\n      c.name,\n      c.customer_tier,\n      SUM(o.total_amount) as total_revenue\n  FROM customers c\n  JOIN orders o ON c.customer_id = o.customer_id\n  WHERE o.status = 'completed'\n    AND o.order_date >= CURRENT_DATE - INTERVAL '3 months'\n  GROUP BY c.customer_id, c.name, c.customer_tier\n  ORDER BY total_revenue DESC\n  LIMIT 10;\n  \"\"\",\n      },\n      {\n          \"name\": \"inventory_management\",\n          \"description\": \"Database schema and business logic for inventory tracking including products, warehouses, and stock levels.\",\n          \"content\": \"\"\"# Inventory Management Schema\n\n### products\n  - product_id (PRIMARY KEY)\n  - product_name\n  - sku\n  - category\n  - unit_cost\n  - reorder_point (minimum stock level before reordering)\n  - discontinued (boolean)\n\n### warehouses\n  - warehouse_id (PRIMARY KEY)\n  - warehouse_name\n  - location\n  - capacity\n\n### inventory\n  - inventory_id (PRIMARY KEY)\n  - product_id (FOREIGN KEY -> products)\n  - warehouse_id (FOREIGN KEY -> warehouses)\n  - quantity_on_hand\n  - last_updated\n\n### stock_movements\n  - movement_id (PRIMARY KEY)\n  - product_id (FOREIGN KEY -> products)\n  - warehouse_id (FOREIGN KEY -> warehouses)\n  - movement_type (inbound/outbound/transfer/adjustment)\n  - quantity (positive for inbound, negative for outbound)\n  - movement_date\n  - reference_number\n\n**Available stock**: quantity_on_hand from inventory table where quantity_on_hand > 0\n\n**Products needing reorder**: Products where total quantity_on_hand across all warehouses is less than or equal to the product's reorder_point\n\n**Active products only**: Exclude products where discontinued = true unless specifically analyzing discontinued items\n\n**Stock valuation**: quantity_on_hand * unit_cost for each product\n\n-- Find products below reorder point across all warehouses\n  SELECT\n      p.product_id,\n      p.product_name,\n      p.reorder_point,\n      SUM(i.quantity_on_hand) as total_stock,\n      p.unit_cost,\n      (p.reorder_point - SUM(i.quantity_on_hand)) as units_to_reorder\n  FROM products p\n  JOIN inventory i ON p.product_id = i.product_id\n  WHERE p.discontinued = false\n  GROUP BY p.product_id, p.product_name, p.reorder_point, p.unit_cost\n  HAVING SUM(i.quantity_on_hand) <= p.reorder_point\n  ORDER BY units_to_reorder DESC;\n  \"\"\",\n      },\n  ]\n\n# Create skill loading tool\n  @tool\n  def load_skill(skill_name: str) -> str:\n      \"\"\"Load the full content of a skill into the agent's context.\n\nUse this when you need detailed information about how to handle a specific\n      type of request. This will provide you with comprehensive instructions,\n      policies, and guidelines for the skill area.\n\nArgs:\n          skill_name: The name of the skill to load (e.g., \"sales_analytics\", \"inventory_management\")\n      \"\"\"\n      # Find and return the requested skill\n      for skill in SKILLS:\n          if skill[\"name\"] == skill_name:\n              return f\"Loaded skill: {skill_name}\\n\\n{skill['content']}\"\n\n# Skill not found\n      available = \", \".join(s[\"name\"] for s in SKILLS)\n      return f\"Skill '{skill_name}' not found. Available skills: {available}\"\n\n# Create skill middleware\n  class SkillMiddleware(AgentMiddleware):\n      \"\"\"Middleware that injects skill descriptions into the system prompt.\"\"\"\n\n# Register the load_skill tool as a class variable\n      tools = [load_skill]\n\ndef __init__(self):\n          \"\"\"Initialize and generate the skills prompt from SKILLS.\"\"\"\n          # Build skills prompt from the SKILLS list\n          skills_list = []\n          for skill in SKILLS:\n              skills_list.append(\n                  f\"- **{skill['name']}**: {skill['description']}\"\n              )\n          self.skills_prompt = \"\\n\".join(skills_list)\n\ndef wrap_model_call(\n          self,\n          request: ModelRequest,\n          handler: Callable[[ModelRequest], ModelResponse],\n      ) -> ModelResponse:\n          \"\"\"Sync: Inject skill descriptions into system prompt.\"\"\"\n          # Build the skills addendum\n          skills_addendum = (\n              f\"\\n\\n## Available Skills\\n\\n{self.skills_prompt}\\n\\n\"\n              \"Use the load_skill tool when you need detailed information \"\n              \"about handling a specific type of request.\"\n          )\n\n# Append to system message content blocks\n          new_content = list(request.system_message.content_blocks) + [\n              {\"type\": \"text\", \"text\": skills_addendum}\n          ]\n          new_system_message = SystemMessage(content=new_content)\n          modified_request = request.override(system_message=new_system_message)\n          return handler(modified_request)\n\n# Initialize your chat model (replace with your model)\n  # Example: from langchain_anthropic import ChatAnthropic\n  # model = ChatAnthropic(model=\"claude-3-5-sonnet-20241022\")\n  from langchain_openai import ChatOpenAI\n  model = ChatOpenAI(model=\"gpt-4\")\n\n# Create the agent with skill support\n  agent = create_agent(\n      model,\n      system_prompt=(\n          \"You are a SQL query assistant that helps users \"\n          \"write queries against business databases.\"\n      ),\n      middleware=[SkillMiddleware()],\n      checkpointer=InMemorySaver(),\n  )\n\n# Example usage\n  if __name__ == \"__main__\":\n      # Configuration for this conversation thread\n      thread_id = str(uuid.uuid4())\n      config = {\"configurable\": {\"thread_id\": thread_id}}\n\n# Ask for a SQL query\n      result = agent.invoke(\n          {\n              \"messages\": [\n                  {\n                      \"role\": \"user\",\n                      \"content\": (\n                          \"Write a SQL query to find all customers \"\n                          \"who made orders over $1000 in the last month\"\n                      ),\n                  }\n              ]\n          },\n          config\n      )\n\n# Print the conversation\n      for message in result[\"messages\"]:\n          if hasattr(message, 'pretty_print'):\n              message.pretty_print()\n          else:\n              print(f\"{message.type}: {message.content}\")\n  ```\n\nThis complete example includes:\n\n* Skill definitions with full database schemas\n  * The `load_skill` tool for on-demand loading\n  * `SkillMiddleware` that injects skill descriptions into the system prompt\n  * Agent creation with middleware and checkpointer\n  * Example usage showing how the agent loads skills and writes SQL queries\n\nTo run this, you'll need to:\n\n1. Install required packages: `pip install langchain langchain-openai langgraph`\n  2. Set your API key (e.g., `export OPENAI_API_KEY=...`)\n  3. Replace the model initialization with your preferred LLM provider\n</Accordion>\n\n## Implementation variations\n\n<Accordion title=\"View implementation options and trade-offs\">\n  This tutorial implemented skills as in-memory Python dictionaries loaded through tool calls. However, there are several ways to implement progressive disclosure with skills:\n\n**Storage backends:**\n\n* **In-memory** (this tutorial): Skills defined as Python data structures, fast access, no I/O overhead\n  * **File system** (Claude Code approach): Skills as directories with files, discovered via file operations like `read_file`\n  * **Remote storage**: Skills in S3, databases, Notion, or APIs, fetched on-demand\n\n**Skill discovery** (how the agent learns which skills exist):\n\n* **System prompt listing**: Skill descriptions in system prompt (used in this tutorial)\n  * **File-based**: Discover skills by scanning directories (Claude Code approach)\n  * **Registry-based**: Query a skill registry service or API for available skills\n  * **Dynamic lookup**: List available skills via a tool call\n\n**Progressive disclosure strategies** (how skill content is loaded):\n\n* **Single load**: Load entire skill content in one tool call (used in this tutorial)\n  * **Paginated**: Load skill content in multiple pages/chunks for large skills\n  * **Search-based**: Search within a specific skill's content for relevant sections (e.g., using grep/read operations on skill files)\n  * **Hierarchical**: Load skill overview first, then drill into specific subsections\n\n**Size considerations** (uncalibrated mental model - optimize for your system):\n\n* **Small skills** (\\< 1K tokens / \\~750 words): Can be included directly in system prompt and cached with prompt caching for cost savings and faster responses\n  * **Medium skills** (1-10K tokens / \\~750-7.5K words): Benefit from on-demand loading to avoid context overhead (this tutorial)\n  * **Large skills** (> 10K tokens / \\~7.5K words, or > 5-10% of context window): Should use progressive disclosure techniques like pagination, search-based loading, or hierarchical exploration to avoid consuming excessive context\n\nThe choice depends on your requirements: in-memory is fastest but requires redeployment for skill updates, while file-based or remote storage enables dynamic skill management without code changes.\n</Accordion>\n\n## Progressive disclosure and context engineering\n\n<Accordion title=\"Combining with few-shot prompting and other techniques\">\n  Progressive disclosure is fundamentally a **[context engineering](/oss/python/langchain/context-engineering) technique** - you're managing what information is available to the agent and when. This tutorial focused on loading database schemas, but the same principles apply to other types of context.\n\n### Combining with few-shot prompting\n\nFor the SQL query use case, you could extend progressive disclosure to dynamically load **few-shot examples** that match the user's query:\n\n**Example approach:**\n\n1. User asks: \"Find customers who haven't ordered in 6 months\"\n  2. Agent loads `sales_analytics` schema (as shown in this tutorial)\n  3. Agent also loads 2-3 relevant example queries (via semantic search or tag-based lookup):\n     * Query for finding inactive customers\n     * Query with date-based filtering\n     * Query joining customers and orders tables\n  4. Agent writes query using both schema knowledge AND example patterns\n\nThis combination of progressive disclosure (loading schemas on-demand) and dynamic few-shot prompting (loading relevant examples) creates a powerful context engineering pattern that scales to large knowledge bases while providing high-quality, grounded outputs.\n</Accordion>\n\n* Learn about [middleware](/oss/python/langchain/middleware) for more dynamic agent behaviors\n* Explore [context engineering](/oss/python/langchain/context-engineering) techniques for managing agent context\n* Explore the [handoffs pattern](/oss/python/langchain/multi-agent/handoffs-customer-support) for sequential workflows\n* Read the [subagents pattern](/oss/python/langchain/multi-agent/subagents-personal-assistant) for parallel task routing\n* See [multi-agent patterns](/oss/python/langchain/multi-agent) for other approaches to specialized agents\n* Use [LangSmith](https://smith.langchain.com) to debug and monitor skill loading\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit this page on GitHub](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/multi-agent/skills-sql-assistant.mdx) or [file an issue](https://github.com/langchain-ai/docs/issues/new/choose).\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "code_samples": [
    {
      "code": "The agent saw the lightweight skill description in its system prompt, recognized the question required sales database knowledge, called `load_skill(\"sales_analytics\")` to get the full schema and business logic, and then used that information to write a correct query following the database conventions.\n\n## 6. Advanced: Add constraints with custom state\n\n<Accordion title=\"Optional: Track loaded skills and enforce tool constraints\">\n  You can add constraints to enforce that certain tools are only available after specific skills have been loaded. This requires tracking which skills have been loaded in custom agent state.\n\n  ### Define custom state\n\n  First, extend the agent state to track loaded skills:",
      "language": "unknown"
    },
    {
      "code": "### Update load\\_skill to modify state\n\n  Modify the `load_skill` tool to update state when a skill is loaded:",
      "language": "unknown"
    },
    {
      "code": "### Create constrained tool\n\n  Create a tool that's only usable after a specific skill has been loaded:",
      "language": "unknown"
    },
    {
      "code": "### Update middleware and agent\n\n  Update the middleware to use the custom state schema:",
      "language": "unknown"
    },
    {
      "code": "Create the agent with the middleware that registers the constrained tool:",
      "language": "unknown"
    },
    {
      "code": "Now if the agent tries to use `write_sql_query` before loading the required skill, it will receive an error message prompting it to load the appropriate skill (e.g., `sales_analytics` or `inventory_management`) first. This ensures the agent has the necessary schema knowledge before attempting to validate queries.\n</Accordion>\n\n## Complete example\n\n<Accordion title=\"View complete runnable script\">\n  Here's a complete, runnable implementation combining all the pieces from this tutorial:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Tables",
      "id": "tables"
    },
    {
      "level": "h3",
      "text": "customers",
      "id": "customers"
    },
    {
      "level": "h3",
      "text": "orders",
      "id": "orders"
    },
    {
      "level": "h2",
      "text": "Business Logic",
      "id": "business-logic"
    },
    {
      "level": "h2",
      "text": "6. Advanced: Add constraints with custom state",
      "id": "6.-advanced:-add-constraints-with-custom-state"
    },
    {
      "level": "h2",
      "text": "Complete example",
      "id": "complete-example"
    },
    {
      "level": "h2",
      "text": "Implementation variations",
      "id": "implementation-variations"
    },
    {
      "level": "h2",
      "text": "Progressive disclosure and context engineering",
      "id": "progressive-disclosure-and-context-engineering"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    }
  ],
  "url": "llms-txt#sales-analytics-schema",
  "links": []
}