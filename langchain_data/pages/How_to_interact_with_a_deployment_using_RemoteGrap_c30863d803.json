{
  "title": "How to interact with a deployment using RemoteGraph",
  "content": "Source: https://docs.langchain.com/langsmith/use-remote-graph\n\n[`RemoteGraph`](https://reference.langchain.com/python/langsmith/deployment/remote_graph/) is a client-side interface that allows you to interact with your [deployment](/langsmith/deployments) as if it were a local graph. It provides API parity with [`CompiledGraph`](/oss/python/langgraph/graph-api#compiling-your-graph), which means that you can use the same methods (`invoke()`, `stream()`, `get_state()`, etc.) in your development and production environments. This page describes how to initialize a `RemoteGraph` and interact with it.\n\n`RemoteGraph` is useful for the following:\n\n* Separation of development and deployment: Build and test a graph locally with `CompiledGraph`, deploy it to LangSmith, and then [use `RemoteGraph`](#initialize-the-graph) to call it in production while working with the same API interface.\n* Thread-level persistence: [Persist and fetch the state](#persist-state-at-the-thread-level) of a conversation across calls with a thread ID.\n* Subgraph embedding: Compose modular graphs for a multi-agent workflow by embedding a `RemoteGraph` as a [subgraph](#use-as-a-subgraph) within another graph.\n* Reusable workflows: Use deployed graphs as nodes or [tools](https://reference.langchain.com/python/langsmith/deployment/remote_graph/#langgraph.pregel.remote.RemoteGraph.as_tool), so that you can reuse and expose complex logic.\n\n<Warning>\n  **Important: Avoid calling the same deployment**\n\n`RemoteGraph` is designed to call graphs on other deployments. Do not use `RemoteGraph` to call itself or another graph on the same deployment, as this can lead to deadlocks and resource exhaustion. Instead, use local graph composition or [subgraphs](/oss/python/langgraph/use-subgraphs) for graphs within the same deployment.\n</Warning>\n\nBefore getting started with `RemoteGraph`, make sure you have:\n\n* Access to [LangSmith](/langsmith/home), where your graphs are developed and managed.\n* A running [Agent Server](/langsmith/agent-server), which hosts your deployed graphs for remote interaction.\n\n## Initialize the graph\n\nWhen initializing a `RemoteGraph`, you must always specify:\n\n* `name`: The name of the graph you want to interact with **or** an assistant ID. If you specify a graph name, the default assistant will be used. If you specify an assistant ID, that specific assistant will be used. The graph name is the same name you use in the `langgraph.json` configuration file for your deployment.\n* `api_key`: A valid [LangSmith API key](/langsmith/create-account-api-key). You can set as an environment variable (`LANGSMITH_API_KEY`) or pass directly in the `api_key` argument. You can also provide the API key in the `client` / `sync_client` arguments, if `LangGraphClient` / `SyncLangGraphClient` was initialized with the `api_key` argument.\n\nAdditionally, you have to provide one of the following:\n\n* [`url`](#use-a-url): The URL of the deployment you want to interact with. If you pass the `url` argument, both sync and async clients will be created using the provided URL, headers (if provided), and default configuration values (e.g., timeout).\n* [`client`](#use-a-client): A `LangGraphClient` instance for interacting with the deployment asynchronously (e.g., using `.astream()`, `.ainvoke()`, `.aget_state()`, `.aupdate_state()`).\n* `sync_client`: A `SyncLangGraphClient` instance for interacting with the deployment synchronously (e.g., using `.stream()`, `.invoke()`, `.get_state()`, `.update_state()`).\n\n<Note>\n  If you pass both `client` or `sync_client` as well as the `url` argument, they will take precedence over the `url` argument. If none of the `client` / `sync_client` / `url` arguments are provided, `RemoteGraph` will raise a `ValueError` at runtime.\n</Note>\n\n`RemoteGraph` implements the same Runnable interface as `CompiledGraph`, so you can use it in the same way as a compiled graph. It supports the full set of standard methods, including `.invoke()`, `.stream()`, `.get_state()`, and `.update_state()`, as well as their asynchronous variants.\n\n<Note>\n  To use the graph asynchronously, you must provide either the `url` or `client` when initializing the `RemoteGraph`.\n</Note>\n\n<Note>\n  To use the graph synchronously, you must provide either the `url` or `sync_client` when initializing the `RemoteGraph`.\n</Note>\n\n<CodeGroup>\n  \n</CodeGroup>\n\n## Persist state at the thread level\n\nBy default, graph runs (for example, calls made with `.invoke()` or `.stream()`) are stateless, which means that intermediate checkpoints and the final state are not persisted after a run.\n\nIf you want to preserve the outputs of a run—for example, to support human-in-the-loop workflows—you can create a thread and pass its ID through the `config` argument. This works the same way as with a regular compiled graph:\n\n<Note>\n  If you need to use a `checkpointer` with a graph that has a `RemoteGraph` subgraph node, make sure to use UUIDs as thread IDs.\n</Note>\n\nA graph can also call out to multiple `RemoteGraph` instances as [*subgraph*](/oss/python/langgraph/use-subgraphs) nodes. This allows for modular, scalable workflows where different responsibilities are split across separate graphs.\n\n`RemoteGraph` exposes the same interface as a regular `CompiledGraph`, so you can use it directly as a subgraph inside another graph. For example:\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit this page on GitHub](https://github.com/langchain-ai/docs/edit/main/src/langsmith/use-remote-graph.mdx) or [file an issue](https://github.com/langchain-ai/docs/issues/new/choose).\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "code_samples": [
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n### Use a client\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n## Invoke the graph\n\n`RemoteGraph` implements the same Runnable interface as `CompiledGraph`, so you can use it in the same way as a compiled graph. It supports the full set of standard methods, including `.invoke()`, `.stream()`, `.get_state()`, and `.update_state()`, as well as their asynchronous variants.\n\n### Asynchronously\n\n<Note>\n  To use the graph asynchronously, you must provide either the `url` or `client` when initializing the `RemoteGraph`.\n</Note>\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n### Synchronously\n\n<Note>\n  To use the graph synchronously, you must provide either the `url` or `sync_client` when initializing the `RemoteGraph`.\n</Note>\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n## Persist state at the thread level\n\nBy default, graph runs (for example, calls made with `.invoke()` or `.stream()`) are stateless, which means that intermediate checkpoints and the final state are not persisted after a run.\n\nIf you want to preserve the outputs of a run—for example, to support human-in-the-loop workflows—you can create a thread and pass its ID through the `config` argument. This works the same way as with a regular compiled graph:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n## Use as a subgraph\n\n<Note>\n  If you need to use a `checkpointer` with a graph that has a `RemoteGraph` subgraph node, make sure to use UUIDs as thread IDs.\n</Note>\n\nA graph can also call out to multiple `RemoteGraph` instances as [*subgraph*](/oss/python/langgraph/use-subgraphs) nodes. This allows for modular, scalable workflows where different responsibilities are split across separate graphs.\n\n`RemoteGraph` exposes the same interface as a regular `CompiledGraph`, so you can use it directly as a subgraph inside another graph. For example:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Initialize the graph",
      "id": "initialize-the-graph"
    },
    {
      "level": "h3",
      "text": "Use a URL",
      "id": "use-a-url"
    },
    {
      "level": "h3",
      "text": "Use a client",
      "id": "use-a-client"
    },
    {
      "level": "h2",
      "text": "Invoke the graph",
      "id": "invoke-the-graph"
    },
    {
      "level": "h3",
      "text": "Asynchronously",
      "id": "asynchronously"
    },
    {
      "level": "h3",
      "text": "Synchronously",
      "id": "synchronously"
    },
    {
      "level": "h2",
      "text": "Persist state at the thread level",
      "id": "persist-state-at-the-thread-level"
    },
    {
      "level": "h2",
      "text": "Use as a subgraph",
      "id": "use-as-a-subgraph"
    }
  ],
  "url": "llms-txt#how-to-interact-with-a-deployment-using-remotegraph",
  "links": []
}