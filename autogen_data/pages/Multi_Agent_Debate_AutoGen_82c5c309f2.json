{
  "url": "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/multi-agent-debate.html",
  "title": "Multi-Agent Debate — AutoGen",
  "content": "Multi-Agent Debate is a multi-agent design pattern that simulates a multi-turn interaction where in each turn, agents exchange their responses with each other, and refine their responses based on the responses from other agents.\n\nThis example shows an implementation of the multi-agent debate pattern for solving math problems from the GSM8K benchmark.\n\nThere are of two types of agents in this pattern: solver agents and an aggregator agent. The solver agents are connected in a sparse manner following the technique described in Improving Multi-Agent Debate with Sparse Communication Topology. The solver agents are responsible for solving math problems and exchanging responses with each other. The aggregator agent is responsible for distributing math problems to the solver agents, waiting for their final responses, and aggregating the responses to get the final answer.\n\nThe pattern works as follows:\n\nUser sends a math problem to the aggregator agent.\n\nThe aggregator agent distributes the problem to the solver agents.\n\nEach solver agent processes the problem, and publishes a response to its neighbors.\n\nEach solver agent uses the responses from its neighbors to refine its response, and publishes a new response.\n\nRepeat step 4 for a fixed number of rounds. In the final round, each solver agent publishes a final response.\n\nThe aggregator agent uses majority voting to aggregate the final responses from all solver agents to get a final answer, and publishes the answer.\n\nWe will be using the broadcast API, i.e., publish_message(), and we will be using topic and subscription to implement the communication topology. Read about Topics and Subscriptions to understand how they work.\n\nFirst, we define the messages used by the agents. IntermediateSolverResponse is the message exchanged among the solver agents in each round, and FinalSolverResponse is the message published by the solver agents in the final round.\n\nThe solver agent is responsible for solving math problems and exchanging responses with other solver agents. Upon receiving a SolverRequest, the solver agent uses an LLM to generate an answer. Then, it publishes a IntermediateSolverResponse or a FinalSolverResponse based on the round number.\n\nThe solver agent is given a topic type, which is used to indicate the topic to which the agent should publish intermediate responses. This topic is subscribed to by its neighbors to receive responses from this agent – we will show how this is done later.\n\nWe use default_subscription() to let solver agents subscribe to the default topic, which is used by the aggregator agent to collect the final responses from the solver agents.\n\nThe aggregator agent is responsible for handling user question and distributing math problems to the solver agents.\n\nThe aggregator subscribes to the default topic using default_subscription(). The default topic is used to recieve user question, receive the final responses from the solver agents, and publish the final answer back to the user.\n\nIn a more complex application when you want to isolate the multi-agent debate into a sub-component, you should use type_subscription() to set a specific topic type for the aggregator-solver communication, and have the both the solver and aggregator publish and subscribe to that topic type.\n\nWe will now set up a multi-agent debate with 4 solver agents and 1 aggregator agent. The solver agents will be connected in a sparse manner as illustrated in the figure below:\n\nEach solver agent is connected to two other solver agents. For example, agent A is connected to agents B and C.\n\nLet’s first create a runtime and register the agent types.\n\nNow we will create the solver agent topology using TypeSubscription, which maps each solver agent’s publishing topic type to its neighbors’ agent types.\n\nNow let’s run the debate to solve a math problem. We publish a SolverRequest to the default topic, and the aggregator agent will start the debate.",
  "headings": [
    {
      "level": "h1",
      "text": "Multi-Agent Debate#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Message Protocol#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Solver Agent#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Aggregator Agent#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Setting Up a Debate#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Solving Math Problems#",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "import re\nfrom dataclasses import dataclass\nfrom typing import Dict, List\n\nfrom autogen_core import (\n    DefaultTopicId,\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    TypeSubscription,\n    default_subscription,\n    message_handler,\n)\nfrom autogen_core.models import (\n    AssistantMessage,\n    ChatCompletionClient,\n    LLMMessage,\n    SystemMessage,\n    UserMessage,\n)\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient",
      "language": "python"
    },
    {
      "code": "import re\nfrom dataclasses import dataclass\nfrom typing import Dict, List\n\nfrom autogen_core import (\n    DefaultTopicId,\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    TypeSubscription,\n    default_subscription,\n    message_handler,\n)\nfrom autogen_core.models import (\n    AssistantMessage,\n    ChatCompletionClient,\n    LLMMessage,\n    SystemMessage,\n    UserMessage,\n)\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass Question:\n    content: str\n\n\n@dataclass\nclass Answer:\n    content: str\n\n\n@dataclass\nclass SolverRequest:\n    content: str\n    question: str\n\n\n@dataclass\nclass IntermediateSolverResponse:\n    content: str\n    question: str\n    answer: str\n    round: int\n\n\n@dataclass\nclass FinalSolverResponse:\n    answer: str",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass Question:\n    content: str\n\n\n@dataclass\nclass Answer:\n    content: str\n\n\n@dataclass\nclass SolverRequest:\n    content: str\n    question: str\n\n\n@dataclass\nclass IntermediateSolverResponse:\n    content: str\n    question: str\n    answer: str\n    round: int\n\n\n@dataclass\nclass FinalSolverResponse:\n    answer: str",
      "language": "python"
    },
    {
      "code": "@default_subscription\nclass MathSolver(RoutedAgent):\n    def __init__(self, model_client: ChatCompletionClient, topic_type: str, num_neighbors: int, max_round: int) -> None:\n        super().__init__(\"A debator.\")\n        self._topic_type = topic_type\n        self._model_client = model_client\n        self._num_neighbors = num_neighbors\n        self._history: List[LLMMessage] = []\n        self._buffer: Dict[int, List[IntermediateSolverResponse]] = {}\n        self._system_messages = [\n            SystemMessage(\n                content=(\n                    \"You are a helpful assistant with expertise in mathematics and reasoning. \"\n                    \"Your task is to assist in solving a math reasoning problem by providing \"\n                    \"a clear and detailed solution. Limit your output within 100 words, \"\n                    \"and your final answer should be a single numerical number, \"\n                    \"in the form of {{answer}}, at the end of your response. \"\n                    \"For example, 'The answer is {{42}}.'\"\n                )\n            )\n        ]\n        self._round = 0\n        self._max_round = max_round\n\n    @message_handler\n    async def handle_request(self, message: SolverRequest, ctx: MessageContext) -> None:\n        # Add the question to the memory.\n        self._history.append(UserMessage(content=message.content, source=\"user\"))\n        # Make an inference using the model.\n        model_result = await self._model_client.create(self._system_messages + self._history)\n        assert isinstance(model_result.content, str)\n        # Add the response to the memory.\n        self._history.append(AssistantMessage(content=model_result.content, source=self.metadata[\"type\"]))\n        print(f\"{'-'*80}\\nSolver {self.id} round {self._round}:\\n{model_result.content}\")\n        # Extract the answer from the response.\n        match = re.search(r\"\\{\\{(\\-?\\d+(\\.\\d+)?)\\}\\}\", model_result.content)\n        if match is None:\n            raise ValueError(\"The model response does not contain the answer.\")\n        answer = match.group(1)\n        # Increment the counter.\n        self._round += 1\n        if self._round == self._max_round:\n            # If the counter reaches the maximum round, publishes a final response.\n            await self.publish_message(FinalSolverResponse(answer=answer), topic_id=DefaultTopicId())\n        else:\n            # Publish intermediate response to the topic associated with this solver.\n            await self.publish_message(\n                IntermediateSolverResponse(\n                    content=model_result.content,\n                    question=message.question,\n                    answer=answer,\n                    round=self._round,\n                ),\n                topic_id=DefaultTopicId(type=self._topic_type),\n            )\n\n    @message_handler\n    async def handle_response(self, message: IntermediateSolverResponse, ctx: MessageContext) -> None:\n        # Add neighbor's response to the buffer.\n        self._buffer.setdefault(message.round, []).append(message)\n        # Check if all neighbors have responded.\n        if len(self._buffer[message.round]) == self._num_neighbors:\n            print(\n                f\"{'-'*80}\\nSolver {self.id} round {message.round}:\\nReceived all responses from {self._num_neighbors} neighbors.\"\n            )\n            # Prepare the prompt for the next question.\n            prompt = \"These are the solutions to the problem from other agents:\\n\"\n            for resp in self._buffer[message.round]:\n                prompt += f\"One agent solution: {resp.content}\\n\"\n            prompt += (\n                \"Using the solutions from other agents as additional information, \"\n                \"can you provide your answer to the math problem? \"\n                f\"The original math problem is {message.question}. \"\n                \"Your final answer should be a single numerical number, \"\n                \"in the form of {{answer}}, at the end of your response.\"\n            )\n            # Send the question to the agent itself to solve.\n            await self.send_message(SolverRequest(content=prompt, question=message.question), self.id)\n            # Clear the buffer.\n            self._buffer.pop(message.round)",
      "language": "python"
    },
    {
      "code": "@default_subscription\nclass MathSolver(RoutedAgent):\n    def __init__(self, model_client: ChatCompletionClient, topic_type: str, num_neighbors: int, max_round: int) -> None:\n        super().__init__(\"A debator.\")\n        self._topic_type = topic_type\n        self._model_client = model_client\n        self._num_neighbors = num_neighbors\n        self._history: List[LLMMessage] = []\n        self._buffer: Dict[int, List[IntermediateSolverResponse]] = {}\n        self._system_messages = [\n            SystemMessage(\n                content=(\n                    \"You are a helpful assistant with expertise in mathematics and reasoning. \"\n                    \"Your task is to assist in solving a math reasoning problem by providing \"\n                    \"a clear and detailed solution. Limit your output within 100 words, \"\n                    \"and your final answer should be a single numerical number, \"\n                    \"in the form of {{answer}}, at the end of your response. \"\n                    \"For example, 'The answer is {{42}}.'\"\n                )\n            )\n        ]\n        self._round = 0\n        self._max_round = max_round\n\n    @message_handler\n    async def handle_request(self, message: SolverRequest, ctx: MessageContext) -> None:\n        # Add the question to the memory.\n        self._history.append(UserMessage(content=message.content, source=\"user\"))\n        # Make an inference using the model.\n        model_result = await self._model_client.create(self._system_messages + self._history)\n        assert isinstance(model_result.content, str)\n        # Add the response to the memory.\n        self._history.append(AssistantMessage(content=model_result.content, source=self.metadata[\"type\"]))\n        print(f\"{'-'*80}\\nSolver {self.id} round {self._round}:\\n{model_result.content}\")\n        # Extract the answer from the response.\n        match = re.search(r\"\\{\\{(\\-?\\d+(\\.\\d+)?)\\}\\}\", model_result.content)\n        if match is None:\n            raise ValueError(\"The model response does not contain the answer.\")\n        answer = match.group(1)\n        # Increment the counter.\n        self._round += 1\n        if self._round == self._max_round:\n            # If the counter reaches the maximum round, publishes a final response.\n            await self.publish_message(FinalSolverResponse(answer=answer), topic_id=DefaultTopicId())\n        else:\n            # Publish intermediate response to the topic associated with this solver.\n            await self.publish_message(\n                IntermediateSolverResponse(\n                    content=model_result.content,\n                    question=message.question,\n                    answer=answer,\n                    round=self._round,\n                ),\n                topic_id=DefaultTopicId(type=self._topic_type),\n            )\n\n    @message_handler\n    async def handle_response(self, message: IntermediateSolverResponse, ctx: MessageContext) -> None:\n        # Add neighbor's response to the buffer.\n        self._buffer.setdefault(message.round, []).append(message)\n        # Check if all neighbors have responded.\n        if len(self._buffer[message.round]) == self._num_neighbors:\n            print(\n                f\"{'-'*80}\\nSolver {self.id} round {message.round}:\\nReceived all responses from {self._num_neighbors} neighbors.\"\n            )\n            # Prepare the prompt for the next question.\n            prompt = \"These are the solutions to the problem from other agents:\\n\"\n            for resp in self._buffer[message.round]:\n                prompt += f\"One agent solution: {resp.content}\\n\"\n            prompt += (\n                \"Using the solutions from other agents as additional information, \"\n                \"can you provide your answer to the math problem? \"\n                f\"The original math problem is {message.question}. \"\n                \"Your final answer should be a single numerical number, \"\n                \"in the form of {{answer}}, at the end of your response.\"\n            )\n            # Send the question to the agent itself to solve.\n            await self.send_message(SolverRequest(content=prompt, question=message.question), self.id)\n            # Clear the buffer.\n            self._buffer.pop(message.round)",
      "language": "python"
    },
    {
      "code": "@default_subscription\nclass MathAggregator(RoutedAgent):\n    def __init__(self, num_solvers: int) -> None:\n        super().__init__(\"Math Aggregator\")\n        self._num_solvers = num_solvers\n        self._buffer: List[FinalSolverResponse] = []\n\n    @message_handler\n    async def handle_question(self, message: Question, ctx: MessageContext) -> None:\n        print(f\"{'-'*80}\\nAggregator {self.id} received question:\\n{message.content}\")\n        prompt = (\n            f\"Can you solve the following math problem?\\n{message.content}\\n\"\n            \"Explain your reasoning. Your final answer should be a single numerical number, \"\n            \"in the form of {{answer}}, at the end of your response.\"\n        )\n        print(f\"{'-'*80}\\nAggregator {self.id} publishes initial solver request.\")\n        await self.publish_message(SolverRequest(content=prompt, question=message.content), topic_id=DefaultTopicId())\n\n    @message_handler\n    async def handle_final_solver_response(self, message: FinalSolverResponse, ctx: MessageContext) -> None:\n        self._buffer.append(message)\n        if len(self._buffer) == self._num_solvers:\n            print(f\"{'-'*80}\\nAggregator {self.id} received all final answers from {self._num_solvers} solvers.\")\n            # Find the majority answer.\n            answers = [resp.answer for resp in self._buffer]\n            majority_answer = max(set(answers), key=answers.count)\n            # Publish the aggregated response.\n            await self.publish_message(Answer(content=majority_answer), topic_id=DefaultTopicId())\n            # Clear the responses.\n            self._buffer.clear()\n            print(f\"{'-'*80}\\nAggregator {self.id} publishes final answer:\\n{majority_answer}\")",
      "language": "python"
    },
    {
      "code": "@default_subscription\nclass MathAggregator(RoutedAgent):\n    def __init__(self, num_solvers: int) -> None:\n        super().__init__(\"Math Aggregator\")\n        self._num_solvers = num_solvers\n        self._buffer: List[FinalSolverResponse] = []\n\n    @message_handler\n    async def handle_question(self, message: Question, ctx: MessageContext) -> None:\n        print(f\"{'-'*80}\\nAggregator {self.id} received question:\\n{message.content}\")\n        prompt = (\n            f\"Can you solve the following math problem?\\n{message.content}\\n\"\n            \"Explain your reasoning. Your final answer should be a single numerical number, \"\n            \"in the form of {{answer}}, at the end of your response.\"\n        )\n        print(f\"{'-'*80}\\nAggregator {self.id} publishes initial solver request.\")\n        await self.publish_message(SolverRequest(content=prompt, question=message.content), topic_id=DefaultTopicId())\n\n    @message_handler\n    async def handle_final_solver_response(self, message: FinalSolverResponse, ctx: MessageContext) -> None:\n        self._buffer.append(message)\n        if len(self._buffer) == self._num_solvers:\n            print(f\"{'-'*80}\\nAggregator {self.id} received all final answers from {self._num_solvers} solvers.\")\n            # Find the majority answer.\n            answers = [resp.answer for resp in self._buffer]\n            majority_answer = max(set(answers), key=answers.count)\n            # Publish the aggregated response.\n            await self.publish_message(Answer(content=majority_answer), topic_id=DefaultTopicId())\n            # Clear the responses.\n            self._buffer.clear()\n            print(f\"{'-'*80}\\nAggregator {self.id} publishes final answer:\\n{majority_answer}\")",
      "language": "python"
    },
    {
      "code": "A --- B\n|     |\n|     |\nD --- C",
      "language": "yaml"
    },
    {
      "code": "A --- B\n|     |\n|     |\nD --- C",
      "language": "yaml"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\n\nmodel_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\")\n\nawait MathSolver.register(\n    runtime,\n    \"MathSolverA\",\n    lambda: MathSolver(\n        model_client=model_client,\n        topic_type=\"MathSolverA\",\n        num_neighbors=2,\n        max_round=3,\n    ),\n)\nawait MathSolver.register(\n    runtime,\n    \"MathSolverB\",\n    lambda: MathSolver(\n        model_client=model_client,\n        topic_type=\"MathSolverB\",\n        num_neighbors=2,\n        max_round=3,\n    ),\n)\nawait MathSolver.register(\n    runtime,\n    \"MathSolverC\",\n    lambda: MathSolver(\n        model_client=model_client,\n        topic_type=\"MathSolverC\",\n        num_neighbors=2,\n        max_round=3,\n    ),\n)\nawait MathSolver.register(\n    runtime,\n    \"MathSolverD\",\n    lambda: MathSolver(\n        model_client=model_client,\n        topic_type=\"MathSolverD\",\n        num_neighbors=2,\n        max_round=3,\n    ),\n)\nawait MathAggregator.register(runtime, \"MathAggregator\", lambda: MathAggregator(num_solvers=4))",
      "language": "csharp"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\n\nmodel_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\")\n\nawait MathSolver.register(\n    runtime,\n    \"MathSolverA\",\n    lambda: MathSolver(\n        model_client=model_client,\n        topic_type=\"MathSolverA\",\n        num_neighbors=2,\n        max_round=3,\n    ),\n)\nawait MathSolver.register(\n    runtime,\n    \"MathSolverB\",\n    lambda: MathSolver(\n        model_client=model_client,\n        topic_type=\"MathSolverB\",\n        num_neighbors=2,\n        max_round=3,\n    ),\n)\nawait MathSolver.register(\n    runtime,\n    \"MathSolverC\",\n    lambda: MathSolver(\n        model_client=model_client,\n        topic_type=\"MathSolverC\",\n        num_neighbors=2,\n        max_round=3,\n    ),\n)\nawait MathSolver.register(\n    runtime,\n    \"MathSolverD\",\n    lambda: MathSolver(\n        model_client=model_client,\n        topic_type=\"MathSolverD\",\n        num_neighbors=2,\n        max_round=3,\n    ),\n)\nawait MathAggregator.register(runtime, \"MathAggregator\", lambda: MathAggregator(num_solvers=4))",
      "language": "csharp"
    },
    {
      "code": "AgentType(type='MathAggregator')",
      "language": "unknown"
    },
    {
      "code": "AgentType(type='MathAggregator')",
      "language": "unknown"
    },
    {
      "code": "# Subscriptions for topic published to by MathSolverA.\nawait runtime.add_subscription(TypeSubscription(\"MathSolverA\", \"MathSolverD\"))\nawait runtime.add_subscription(TypeSubscription(\"MathSolverA\", \"MathSolverB\"))\n\n# Subscriptions for topic published to by MathSolverB.\nawait runtime.add_subscription(TypeSubscription(\"MathSolverB\", \"MathSolverA\"))\nawait runtime.add_subscription(TypeSubscription(\"MathSolverB\", \"MathSolverC\"))\n\n# Subscriptions for topic published to by MathSolverC.\nawait runtime.add_subscription(TypeSubscription(\"MathSolverC\", \"MathSolverB\"))\nawait runtime.add_subscription(TypeSubscription(\"MathSolverC\", \"MathSolverD\"))\n\n# Subscriptions for topic published to by MathSolverD.\nawait runtime.add_subscription(TypeSubscription(\"MathSolverD\", \"MathSolverC\"))\nawait runtime.add_subscription(TypeSubscription(\"MathSolverD\", \"MathSolverA\"))\n\n# All solvers and the aggregator subscribe to the default topic.",
      "language": "markdown"
    },
    {
      "code": "# Subscriptions for topic published to by MathSolverA.\nawait runtime.add_subscription(TypeSubscription(\"MathSolverA\", \"MathSolverD\"))\nawait runtime.add_subscription(TypeSubscription(\"MathSolverA\", \"MathSolverB\"))\n\n# Subscriptions for topic published to by MathSolverB.\nawait runtime.add_subscription(TypeSubscription(\"MathSolverB\", \"MathSolverA\"))\nawait runtime.add_subscription(TypeSubscription(\"MathSolverB\", \"MathSolverC\"))\n\n# Subscriptions for topic published to by MathSolverC.\nawait runtime.add_subscription(TypeSubscription(\"MathSolverC\", \"MathSolverB\"))\nawait runtime.add_subscription(TypeSubscription(\"MathSolverC\", \"MathSolverD\"))\n\n# Subscriptions for topic published to by MathSolverD.\nawait runtime.add_subscription(TypeSubscription(\"MathSolverD\", \"MathSolverC\"))\nawait runtime.add_subscription(TypeSubscription(\"MathSolverD\", \"MathSolverA\"))\n\n# All solvers and the aggregator subscribe to the default topic.",
      "language": "markdown"
    },
    {
      "code": "question = \"Natalia sold clips to 48 of her friends in April, and then she sold half as many clips in May. How many clips did Natalia sell altogether in April and May?\"\nruntime.start()\nawait runtime.publish_message(Question(content=question), DefaultTopicId())\n# Wait for the runtime to stop when idle.\nawait runtime.stop_when_idle()\n# Close the connection to the model client.\nawait model_client.close()",
      "language": "markdown"
    },
    {
      "code": "question = \"Natalia sold clips to 48 of her friends in April, and then she sold half as many clips in May. How many clips did Natalia sell altogether in April and May?\"\nruntime.start()\nawait runtime.publish_message(Question(content=question), DefaultTopicId())\n# Wait for the runtime to stop when idle.\nawait runtime.stop_when_idle()\n# Close the connection to the model client.\nawait model_client.close()",
      "language": "markdown"
    },
    {
      "code": "--------------------------------------------------------------------------------\nAggregator MathAggregator:default received question:\nNatalia sold clips to 48 of her friends in April, and then she sold half as many clips in May. How many clips did Natalia sell altogether in April and May?\n--------------------------------------------------------------------------------\nAggregator MathAggregator:default publishes initial solver request.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 0:\nIn April, Natalia sold 48 clips. In May, she sold half as many, which is 48 / 2 = 24 clips. To find the total number of clips sold in April and May, we add the amounts: 48 (April) + 24 (May) = 72 clips. \n\nThus, the total number of clips sold by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 0:\nIn April, Natalia sold 48 clips. In May, she sold half as many clips, which is 48 / 2 = 24 clips. To find the total clips sold in April and May, we add both amounts: \n\n48 (April) + 24 (May) = 72.\n\nThus, the total number of clips sold altogether is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 0:\nNatalia sold 48 clips in April. In May, she sold half as many, which is \\( \\frac{48}{2} = 24 \\) clips. To find the total clips sold in both months, we add the clips sold in April and May together:\n\n\\[ 48 + 24 = 72 \\]\n\nThus, Natalia sold a total of 72 clips.\n\nThe answer is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 1:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 1:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 0:\nIn April, Natalia sold clips to 48 friends. In May, she sold half as many, which is calculated as follows:\n\nHalf of 48 is \\( 48 \\div 2 = 24 \\).\n\nNow, to find the total clips sold in April and May, we add the totals from both months:\n\n\\( 48 + 24 = 72 \\).\n\nThus, the total number of clips Natalia sold altogether in April and May is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 1:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 1:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 1:\nIn April, Natalia sold 48 clips. In May, she sold half as many, which is 48 / 2 = 24 clips. The total number of clips sold in April and May is calculated by adding the two amounts: 48 (April) + 24 (May) = 72 clips. \n\nTherefore, the answer is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 1:\nIn April, Natalia sold 48 clips. In May, she sold half of that amount, which is 48 / 2 = 24 clips. To find the total clips sold in both months, we sum the clips from April and May: \n\n48 (April) + 24 (May) = 72.\n\nThus, Natalia sold a total of {{72}} clips. \n\nThe answer is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 2:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 2:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 1:\nNatalia sold 48 clips in April. In May, she sold half of that, which is \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold, we add the clips sold in both months:\n\n\\[ 48 + 24 = 72 \\]\n\nTherefore, the total number of clips sold by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 1:\nIn April, Natalia sold 48 clips. In May, she sold half that amount, which is 48 / 2 = 24 clips. To find the total clips sold in both months, we add the amounts: \n\n48 (April) + 24 (May) = 72.\n\nTherefore, the total number of clips sold altogether by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 2:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 2:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 2:\nIn April, Natalia sold 48 clips. In May, she sold half of that amount, which is \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold in both months, we add the amounts from April and May:\n\n\\( 48 + 24 = 72 \\).\n\nThus, the total number of clips sold by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 2:\nIn April, Natalia sold 48 clips. In May, she sold half of that amount, which is \\( 48 \\div 2 = 24 \\) clips. To find the total number of clips sold in both months, we add the clips sold in April and May: \n\n48 (April) + 24 (May) = 72. \n\nThus, the total number of clips sold altogether by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 2:\nIn April, Natalia sold 48 clips. In May, she sold half as many, calculated as \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold over both months, we sum the totals: \n\n\\( 48 (April) + 24 (May) = 72 \\).\n\nTherefore, the total number of clips Natalia sold is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 2:\nTo solve the problem, we know that Natalia sold 48 clips in April. In May, she sold half that amount, which is calculated as \\( 48 \\div 2 = 24 \\) clips. To find the total number of clips sold over both months, we add the two amounts together:\n\n\\[ 48 + 24 = 72 \\]\n\nThus, the total number of clips sold by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nAggregator MathAggregator:default received all final answers from 4 solvers.\n--------------------------------------------------------------------------------\nAggregator MathAggregator:default publishes final answer:\n72",
      "language": "sql"
    },
    {
      "code": "--------------------------------------------------------------------------------\nAggregator MathAggregator:default received question:\nNatalia sold clips to 48 of her friends in April, and then she sold half as many clips in May. How many clips did Natalia sell altogether in April and May?\n--------------------------------------------------------------------------------\nAggregator MathAggregator:default publishes initial solver request.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 0:\nIn April, Natalia sold 48 clips. In May, she sold half as many, which is 48 / 2 = 24 clips. To find the total number of clips sold in April and May, we add the amounts: 48 (April) + 24 (May) = 72 clips. \n\nThus, the total number of clips sold by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 0:\nIn April, Natalia sold 48 clips. In May, she sold half as many clips, which is 48 / 2 = 24 clips. To find the total clips sold in April and May, we add both amounts: \n\n48 (April) + 24 (May) = 72.\n\nThus, the total number of clips sold altogether is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 0:\nNatalia sold 48 clips in April. In May, she sold half as many, which is \\( \\frac{48}{2} = 24 \\) clips. To find the total clips sold in both months, we add the clips sold in April and May together:\n\n\\[ 48 + 24 = 72 \\]\n\nThus, Natalia sold a total of 72 clips.\n\nThe answer is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 1:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 1:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 0:\nIn April, Natalia sold clips to 48 friends. In May, she sold half as many, which is calculated as follows:\n\nHalf of 48 is \\( 48 \\div 2 = 24 \\).\n\nNow, to find the total clips sold in April and May, we add the totals from both months:\n\n\\( 48 + 24 = 72 \\).\n\nThus, the total number of clips Natalia sold altogether in April and May is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 1:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 1:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 1:\nIn April, Natalia sold 48 clips. In May, she sold half as many, which is 48 / 2 = 24 clips. The total number of clips sold in April and May is calculated by adding the two amounts: 48 (April) + 24 (May) = 72 clips. \n\nTherefore, the answer is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 1:\nIn April, Natalia sold 48 clips. In May, she sold half of that amount, which is 48 / 2 = 24 clips. To find the total clips sold in both months, we sum the clips from April and May: \n\n48 (April) + 24 (May) = 72.\n\nThus, Natalia sold a total of {{72}} clips. \n\nThe answer is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 2:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 2:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 1:\nNatalia sold 48 clips in April. In May, she sold half of that, which is \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold, we add the clips sold in both months:\n\n\\[ 48 + 24 = 72 \\]\n\nTherefore, the total number of clips sold by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 1:\nIn April, Natalia sold 48 clips. In May, she sold half that amount, which is 48 / 2 = 24 clips. To find the total clips sold in both months, we add the amounts: \n\n48 (April) + 24 (May) = 72.\n\nTherefore, the total number of clips sold altogether by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 2:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 2:\nReceived all responses from 2 neighbors.\n--------------------------------------------------------------------------------\nSolver MathSolverA:default round 2:\nIn April, Natalia sold 48 clips. In May, she sold half of that amount, which is \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold in both months, we add the amounts from April and May:\n\n\\( 48 + 24 = 72 \\).\n\nThus, the total number of clips sold by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverC:default round 2:\nIn April, Natalia sold 48 clips. In May, she sold half of that amount, which is \\( 48 \\div 2 = 24 \\) clips. To find the total number of clips sold in both months, we add the clips sold in April and May: \n\n48 (April) + 24 (May) = 72. \n\nThus, the total number of clips sold altogether by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverB:default round 2:\nIn April, Natalia sold 48 clips. In May, she sold half as many, calculated as \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold over both months, we sum the totals: \n\n\\( 48 (April) + 24 (May) = 72 \\).\n\nTherefore, the total number of clips Natalia sold is {{72}}.\n--------------------------------------------------------------------------------\nSolver MathSolverD:default round 2:\nTo solve the problem, we know that Natalia sold 48 clips in April. In May, she sold half that amount, which is calculated as \\( 48 \\div 2 = 24 \\) clips. To find the total number of clips sold over both months, we add the two amounts together:\n\n\\[ 48 + 24 = 72 \\]\n\nThus, the total number of clips sold by Natalia is {{72}}.\n--------------------------------------------------------------------------------\nAggregator MathAggregator:default received all final answers from 4 solvers.\n--------------------------------------------------------------------------------\nAggregator MathAggregator:default publishes final answer:\n72",
      "language": "sql"
    }
  ],
  "patterns": [
    {
      "description": "Core Multi-Agent Debate Multi-Agent Debate# Multi-Agent Debate is a multi-agent design pattern that simulates a multi-turn interaction where in each turn, agents exchange their responses with each other, and refine their responses based on the responses from other agents. This example shows an implementation of the multi-agent debate pattern for solving math problems from the GSM8K benchmark. There are of two types of agents in this pattern: solver agents and an aggregator agent. The solver agents are connected in a sparse manner following the technique described in Improving Multi-Agent Debate with Sparse Communication Topology. The solver agents are responsible for solving math problems and exchanging responses with each other. The aggregator agent is responsible for distributing math problems to the solver agents, waiting for their final responses, and aggregating the responses to get the final answer. The pattern works as follows: User sends a math problem to the aggregator agent. The aggregator agent distributes the problem to the solver agents. Each solver agent processes the problem, and publishes a response to its neighbors. Each solver agent uses the responses from its neighbors to refine its response, and publishes a new response. Repeat step 4 for a fixed number of rounds. In the final round, each solver agent publishes a final response. The aggregator agent uses majority voting to aggregate the final responses from all solver agents to get a final answer, and publishes the answer. We will be using the broadcast API, i.e., publish_message(), and we will be using topic and subscription to implement the communication topology. Read about Topics and Subscriptions to understand how they work. import re from dataclasses import dataclass from typing import Dict, List from autogen_core import ( DefaultTopicId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, TypeSubscription, default_subscription, message_handler, ) from autogen_core.models import ( AssistantMessage, ChatCompletionClient, LLMMessage, SystemMessage, UserMessage, ) from autogen_ext.models.openai import OpenAIChatCompletionClient Message Protocol# First, we define the messages used by the agents. IntermediateSolverResponse is the message exchanged among the solver agents in each round, and FinalSolverResponse is the message published by the solver agents in the final round. @dataclass class Question: content: str @dataclass class Answer: content: str @dataclass class SolverRequest: content: str question: str @dataclass class IntermediateSolverResponse: content: str question: str answer: str round: int @dataclass class FinalSolverResponse: answer: str Solver Agent# The solver agent is responsible for solving math problems and exchanging responses with other solver agents. Upon receiving a SolverRequest, the solver agent uses an LLM to generate an answer. Then, it publishes a IntermediateSolverResponse or a FinalSolverResponse based on the round number. The solver agent is given a topic type, which is used to indicate the topic to which the agent should publish intermediate responses. This topic is subscribed to by its neighbors to receive responses from this agent – we will show how this is done later. We use default_subscription() to let solver agents subscribe to the default topic, which is used by the aggregator agent to collect the final responses from the solver agents. @default_subscription class MathSolver(RoutedAgent): def __init__(self, model_client: ChatCompletionClient, topic_type: str, num_neighbors: int, max_round: int) -> None: super().__init__(\"A debator.\") self._topic_type = topic_type self._model_client = model_client self._num_neighbors = num_neighbors self._history: List[LLMMessage] = [] self._buffer: Dict[int, List[IntermediateSolverResponse]] = {} self._system_messages = [ SystemMessage( content=( \"You are a helpful assistant with expertise in mathematics and reasoning. \" \"Your task is to assist in solving a math reasoning problem by providing \" \"a clear and detailed solution. Limit your output within 100 words, \" \"and your final answer should be a single numerical number, \" \"in the form of {{answer}}, at the end of your response. \" \"For example, 'The answer is {{42}}.'\" ) ) ] self._round = 0 self._max_round = max_round @message_handler async def handle_request(self, message: SolverRequest, ctx: MessageContext) -> None: # Add the question to the memory. self._history.append(UserMessage(content=message.content, source=\"user\")) # Make an inference using the model. model_result = await self._model_client.create(self._system_messages + self._history) assert isinstance(model_result.content, str) # Add the response to the memory. self._history.append(AssistantMessage(content=model_result.content, source=self.metadata[\"type\"])) print(f\"{'-'*80}\\nSolver {self.id} round {self._round}:\\n{model_result.content}\") # Extract the answer from the response. match = re.search(r\"\\{\\{(\\-?\\d+(\\.\\d+)?)\\}\\}\", model_result.content) if match is None: raise ValueError(\"The model response does not contain the answer.\") answer = match.group(1) # Increment the counter. self._round += 1 if self._round == self._max_round: # If the counter reaches the maximum round, publishes a final response. await self.publish_message(FinalSolverResponse(answer=answer), topic_id=DefaultTopicId()) else: # Publish intermediate response to the topic associated with this solver. await self.publish_message( IntermediateSolverResponse( content=model_result.content, question=message.question, answer=answer, round=self._round, ), topic_id=DefaultTopicId(type=self._topic_type), ) @message_handler async def handle_response(self, message: IntermediateSolverResponse, ctx: MessageContext) -> None: # Add neighbor's response to the buffer. self._buffer.setdefault(message.round, []).append(message) # Check if all neighbors have responded. if len(self._buffer[message.round]) == self._num_neighbors: print( f\"{'-'*80}\\nSolver {self.id} round {message.round}:\\nReceived all responses from {self._num_neighbors} neighbors.\" ) # Prepare the prompt for the next question. prompt = \"These are the solutions to the problem from other agents:\\n\" for resp in self._buffer[message.round]: prompt += f\"One agent solution: {resp.content}\\n\" prompt += ( \"Using the solutions from other agents as additional information, \" \"can you provide your answer to the math problem? \" f\"The original math problem is {message.question}. \" \"Your final answer should be a single numerical number, \" \"in the form of {{answer}}, at the end of your response.\" ) # Send the question to the agent itself to solve. await self.send_message(SolverRequest(content=prompt, question=message.question), self.id) # Clear the buffer. self._buffer.pop(message.round) Aggregator Agent# The aggregator agent is responsible for handling user question and distributing math problems to the solver agents. The aggregator subscribes to the default topic using default_subscription(). The default topic is used to recieve user question, receive the final responses from the solver agents, and publish the final answer back to the user. In a more complex application when you want to isolate the multi-agent debate into a sub-component, you should use type_subscription() to set a specific topic type for the aggregator-solver communication, and have the both the solver and aggregator publish and subscribe to that topic type. @default_subscription class MathAggregator(RoutedAgent): def __init__(self, num_solvers: int) -> None: super().__init__(\"Math Aggregator\") self._num_solvers = num_solvers self._buffer: List[FinalSolverResponse] = [] @message_handler async def handle_question(self, message: Question, ctx: MessageContext) -> None: print(f\"{'-'*80}\\nAggregator {self.id} received question:\\n{message.content}\") prompt = ( f\"Can you solve the following math problem?\\n{message.content}\\n\" \"Explain your reasoning. Your final answer should be a single numerical number, \" \"in the form of {{answer}}, at the end of your response.\" ) print(f\"{'-'*80}\\nAggregator {self.id} publishes initial solver request.\") await self.publish_message(SolverRequest(content=prompt, question=message.content), topic_id=DefaultTopicId()) @message_handler async def handle_final_solver_response(self, message: FinalSolverResponse, ctx: MessageContext) -> None: self._buffer.append(message) if len(self._buffer) == self._num_solvers: print(f\"{'-'*80}\\nAggregator {self.id} received all final answers from {self._num_solvers} solvers.\") # Find the majority answer. answers = [resp.answer for resp in self._buffer] majority_answer = max(set(answers), key=answers.count) # Publish the aggregated response. await self.publish_message(Answer(content=majority_answer), topic_id=DefaultTopicId()) # Clear the responses. self._buffer.clear() print(f\"{'-'*80}\\nAggregator {self.id} publishes final answer:\\n{majority_answer}\") Setting Up a Debate# We will now set up a multi-agent debate with 4 solver agents and 1 aggregator agent. The solver agents will be connected in a sparse manner as illustrated in the figure below: A --- B | | | | D --- C Each solver agent is connected to two other solver agents. For example, agent A is connected to agents B and C. Let’s first create a runtime and register the agent types. runtime = SingleThreadedAgentRuntime() model_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\") await MathSolver.register( runtime, \"MathSolverA\", lambda: MathSolver( model_client=model_client, topic_type=\"MathSolverA\", num_neighbors=2, max_round=3, ), ) await MathSolver.register( runtime, \"MathSolverB\", lambda: MathSolver( model_client=model_client, topic_type=\"MathSolverB\", num_neighbors=2, max_round=3, ), ) await MathSolver.register( runtime, \"MathSolverC\", lambda: MathSolver( model_client=model_client, topic_type=\"MathSolverC\", num_neighbors=2, max_round=3, ), ) await MathSolver.register( runtime, \"MathSolverD\", lambda: MathSolver( model_client=model_client, topic_type=\"MathSolverD\", num_neighbors=2, max_round=3, ), ) await MathAggregator.register(runtime, \"MathAggregator\", lambda: MathAggregator(num_solvers=4)) AgentType(type='MathAggregator') Now we will create the solver agent topology using TypeSubscription, which maps each solver agent’s publishing topic type to its neighbors’ agent types. # Subscriptions for topic published to by MathSolverA. await runtime.add_subscription(TypeSubscription(\"MathSolverA\", \"MathSolverD\")) await runtime.add_subscription(TypeSubscription(\"MathSolverA\", \"MathSolverB\")) # Subscriptions for topic published to by MathSolverB. await runtime.add_subscription(TypeSubscription(\"MathSolverB\", \"MathSolverA\")) await runtime.add_subscription(TypeSubscription(\"MathSolverB\", \"MathSolverC\")) # Subscriptions for topic published to by MathSolverC. await runtime.add_subscription(TypeSubscription(\"MathSolverC\", \"MathSolverB\")) await runtime.add_subscription(TypeSubscription(\"MathSolverC\", \"MathSolverD\")) # Subscriptions for topic published to by MathSolverD. await runtime.add_subscription(TypeSubscription(\"MathSolverD\", \"MathSolverC\")) await runtime.add_subscription(TypeSubscription(\"MathSolverD\", \"MathSolverA\")) # All solvers and the aggregator subscribe to the default topic. Solving Math Problems# Now let’s run the debate to solve a math problem. We publish a SolverRequest to the default topic, and the aggregator agent will start the debate. question = \"Natalia sold clips to 48 of her friends in April, and then she sold half as many clips in May. How many clips did Natalia sell altogether in April and May?\" runtime.start() await runtime.publish_message(Question(content=question), DefaultTopicId()) # Wait for the runtime to stop when idle. await runtime.stop_when_idle() # Close the connection to the model client. await model_client.close() -------------------------------------------------------------------------------- Aggregator MathAggregator:default received question: Natalia sold clips to 48 of her friends in April, and then she sold half as many clips in May. How many clips did Natalia sell altogether in April and May? -------------------------------------------------------------------------------- Aggregator MathAggregator:default publishes initial solver request. -------------------------------------------------------------------------------- Solver MathSolverC:default round 0: In April, Natalia sold 48 clips. In May, she sold half as many, which is 48 / 2 = 24 clips. To find the total number of clips sold in April and May, we add the amounts: 48 (April) + 24 (May) = 72 clips. Thus, the total number of clips sold by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverB:default round 0: In April, Natalia sold 48 clips. In May, she sold half as many clips, which is 48 / 2 = 24 clips. To find the total clips sold in April and May, we add both amounts: 48 (April) + 24 (May) = 72. Thus, the total number of clips sold altogether is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverD:default round 0: Natalia sold 48 clips in April. In May, she sold half as many, which is \\( \\frac{48}{2} = 24 \\) clips. To find the total clips sold in both months, we add the clips sold in April and May together: \\[ 48 + 24 = 72 \\] Thus, Natalia sold a total of 72 clips. The answer is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverC:default round 1: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverA:default round 1: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverA:default round 0: In April, Natalia sold clips to 48 friends. In May, she sold half as many, which is calculated as follows: Half of 48 is \\( 48 \\div 2 = 24 \\). Now, to find the total clips sold in April and May, we add the totals from both months: \\( 48 + 24 = 72 \\). Thus, the total number of clips Natalia sold altogether in April and May is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverD:default round 1: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverB:default round 1: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverC:default round 1: In April, Natalia sold 48 clips. In May, she sold half as many, which is 48 / 2 = 24 clips. The total number of clips sold in April and May is calculated by adding the two amounts: 48 (April) + 24 (May) = 72 clips. Therefore, the answer is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverA:default round 1: In April, Natalia sold 48 clips. In May, she sold half of that amount, which is 48 / 2 = 24 clips. To find the total clips sold in both months, we sum the clips from April and May: 48 (April) + 24 (May) = 72. Thus, Natalia sold a total of {{72}} clips. The answer is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverD:default round 2: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverB:default round 2: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverD:default round 1: Natalia sold 48 clips in April. In May, she sold half of that, which is \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold, we add the clips sold in both months: \\[ 48 + 24 = 72 \\] Therefore, the total number of clips sold by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverB:default round 1: In April, Natalia sold 48 clips. In May, she sold half that amount, which is 48 / 2 = 24 clips. To find the total clips sold in both months, we add the amounts: 48 (April) + 24 (May) = 72. Therefore, the total number of clips sold altogether by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverA:default round 2: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverC:default round 2: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverA:default round 2: In April, Natalia sold 48 clips. In May, she sold half of that amount, which is \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold in both months, we add the amounts from April and May: \\( 48 + 24 = 72 \\). Thus, the total number of clips sold by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverC:default round 2: In April, Natalia sold 48 clips. In May, she sold half of that amount, which is \\( 48 \\div 2 = 24 \\) clips. To find the total number of clips sold in both months, we add the clips sold in April and May: 48 (April) + 24 (May) = 72. Thus, the total number of clips sold altogether by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverB:default round 2: In April, Natalia sold 48 clips. In May, she sold half as many, calculated as \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold over both months, we sum the totals: \\( 48 (April) + 24 (May) = 72 \\). Therefore, the total number of clips Natalia sold is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverD:default round 2: To solve the problem, we know that Natalia sold 48 clips in April. In May, she sold half that amount, which is calculated as \\( 48 \\div 2 = 24 \\) clips. To find the total number of clips sold over both months, we add the two amounts together: \\[ 48 + 24 = 72 \\] Thus, the total number of clips sold by Natalia is {{72}}. -------------------------------------------------------------------------------- Aggregator MathAggregator:default received all final answers from 4 solvers. -------------------------------------------------------------------------------- Aggregator MathAggregator:default publishes final answer: 72 previous Mixture of Agents next Reflection On this page Message Protocol Solver Agent Aggregator Agent Setting Up a Debate Solving Math Problems Edit on GitHub Show Source",
      "code": "publish_message()"
    },
    {
      "description": "Core Multi-Agent Debate Multi-Agent Debate# Multi-Agent Debate is a multi-agent design pattern that simulates a multi-turn interaction where in each turn, agents exchange their responses with each other, and refine their responses based on the responses from other agents. This example shows an implementation of the multi-agent debate pattern for solving math problems from the GSM8K benchmark. There are of two types of agents in this pattern: solver agents and an aggregator agent. The solver agents are connected in a sparse manner following the technique described in Improving Multi-Agent Debate with Sparse Communication Topology. The solver agents are responsible for solving math problems and exchanging responses with each other. The aggregator agent is responsible for distributing math problems to the solver agents, waiting for their final responses, and aggregating the responses to get the final answer. The pattern works as follows: User sends a math problem to the aggregator agent. The aggregator agent distributes the problem to the solver agents. Each solver agent processes the problem, and publishes a response to its neighbors. Each solver agent uses the responses from its neighbors to refine its response, and publishes a new response. Repeat step 4 for a fixed number of rounds. In the final round, each solver agent publishes a final response. The aggregator agent uses majority voting to aggregate the final responses from all solver agents to get a final answer, and publishes the answer. We will be using the broadcast API, i.e., publish_message(), and we will be using topic and subscription to implement the communication topology. Read about Topics and Subscriptions to understand how they work. import re from dataclasses import dataclass from typing import Dict, List from autogen_core import ( DefaultTopicId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, TypeSubscription, default_subscription, message_handler, ) from autogen_core.models import ( AssistantMessage, ChatCompletionClient, LLMMessage, SystemMessage, UserMessage, ) from autogen_ext.models.openai import OpenAIChatCompletionClient Message Protocol# First, we define the messages used by the agents. IntermediateSolverResponse is the message exchanged among the solver agents in each round, and FinalSolverResponse is the message published by the solver agents in the final round. @dataclass class Question: content: str @dataclass class Answer: content: str @dataclass class SolverRequest: content: str question: str @dataclass class IntermediateSolverResponse: content: str question: str answer: str round: int @dataclass class FinalSolverResponse: answer: str Solver Agent# The solver agent is responsible for solving math problems and exchanging responses with other solver agents. Upon receiving a SolverRequest, the solver agent uses an LLM to generate an answer. Then, it publishes a IntermediateSolverResponse or a FinalSolverResponse based on the round number. The solver agent is given a topic type, which is used to indicate the topic to which the agent should publish intermediate responses. This topic is subscribed to by its neighbors to receive responses from this agent – we will show how this is done later. We use default_subscription() to let solver agents subscribe to the default topic, which is used by the aggregator agent to collect the final responses from the solver agents. @default_subscription class MathSolver(RoutedAgent): def __init__(self, model_client: ChatCompletionClient, topic_type: str, num_neighbors: int, max_round: int) -> None: super().__init__(\"A debator.\") self._topic_type = topic_type self._model_client = model_client self._num_neighbors = num_neighbors self._history: List[LLMMessage] = [] self._buffer: Dict[int, List[IntermediateSolverResponse]] = {} self._system_messages = [ SystemMessage( content=( \"You are a helpful assistant with expertise in mathematics and reasoning. \" \"Your task is to assist in solving a math reasoning problem by providing \" \"a clear and detailed solution. Limit your output within 100 words, \" \"and your final answer should be a single numerical number, \" \"in the form of {{answer}}, at the end of your response. \" \"For example, 'The answer is {{42}}.'\" ) ) ] self._round = 0 self._max_round = max_round @message_handler async def handle_request(self, message: SolverRequest, ctx: MessageContext) -> None: # Add the question to the memory. self._history.append(UserMessage(content=message.content, source=\"user\")) # Make an inference using the model. model_result = await self._model_client.create(self._system_messages + self._history) assert isinstance(model_result.content, str) # Add the response to the memory. self._history.append(AssistantMessage(content=model_result.content, source=self.metadata[\"type\"])) print(f\"{'-'*80}\\nSolver {self.id} round {self._round}:\\n{model_result.content}\") # Extract the answer from the response. match = re.search(r\"\\{\\{(\\-?\\d+(\\.\\d+)?)\\}\\}\", model_result.content) if match is None: raise ValueError(\"The model response does not contain the answer.\") answer = match.group(1) # Increment the counter. self._round += 1 if self._round == self._max_round: # If the counter reaches the maximum round, publishes a final response. await self.publish_message(FinalSolverResponse(answer=answer), topic_id=DefaultTopicId()) else: # Publish intermediate response to the topic associated with this solver. await self.publish_message( IntermediateSolverResponse( content=model_result.content, question=message.question, answer=answer, round=self._round, ), topic_id=DefaultTopicId(type=self._topic_type), ) @message_handler async def handle_response(self, message: IntermediateSolverResponse, ctx: MessageContext) -> None: # Add neighbor's response to the buffer. self._buffer.setdefault(message.round, []).append(message) # Check if all neighbors have responded. if len(self._buffer[message.round]) == self._num_neighbors: print( f\"{'-'*80}\\nSolver {self.id} round {message.round}:\\nReceived all responses from {self._num_neighbors} neighbors.\" ) # Prepare the prompt for the next question. prompt = \"These are the solutions to the problem from other agents:\\n\" for resp in self._buffer[message.round]: prompt += f\"One agent solution: {resp.content}\\n\" prompt += ( \"Using the solutions from other agents as additional information, \" \"can you provide your answer to the math problem? \" f\"The original math problem is {message.question}. \" \"Your final answer should be a single numerical number, \" \"in the form of {{answer}}, at the end of your response.\" ) # Send the question to the agent itself to solve. await self.send_message(SolverRequest(content=prompt, question=message.question), self.id) # Clear the buffer. self._buffer.pop(message.round) Aggregator Agent# The aggregator agent is responsible for handling user question and distributing math problems to the solver agents. The aggregator subscribes to the default topic using default_subscription(). The default topic is used to recieve user question, receive the final responses from the solver agents, and publish the final answer back to the user. In a more complex application when you want to isolate the multi-agent debate into a sub-component, you should use type_subscription() to set a specific topic type for the aggregator-solver communication, and have the both the solver and aggregator publish and subscribe to that topic type. @default_subscription class MathAggregator(RoutedAgent): def __init__(self, num_solvers: int) -> None: super().__init__(\"Math Aggregator\") self._num_solvers = num_solvers self._buffer: List[FinalSolverResponse] = [] @message_handler async def handle_question(self, message: Question, ctx: MessageContext) -> None: print(f\"{'-'*80}\\nAggregator {self.id} received question:\\n{message.content}\") prompt = ( f\"Can you solve the following math problem?\\n{message.content}\\n\" \"Explain your reasoning. Your final answer should be a single numerical number, \" \"in the form of {{answer}}, at the end of your response.\" ) print(f\"{'-'*80}\\nAggregator {self.id} publishes initial solver request.\") await self.publish_message(SolverRequest(content=prompt, question=message.content), topic_id=DefaultTopicId()) @message_handler async def handle_final_solver_response(self, message: FinalSolverResponse, ctx: MessageContext) -> None: self._buffer.append(message) if len(self._buffer) == self._num_solvers: print(f\"{'-'*80}\\nAggregator {self.id} received all final answers from {self._num_solvers} solvers.\") # Find the majority answer. answers = [resp.answer for resp in self._buffer] majority_answer = max(set(answers), key=answers.count) # Publish the aggregated response. await self.publish_message(Answer(content=majority_answer), topic_id=DefaultTopicId()) # Clear the responses. self._buffer.clear() print(f\"{'-'*80}\\nAggregator {self.id} publishes final answer:\\n{majority_answer}\") Setting Up a Debate# We will now set up a multi-agent debate with 4 solver agents and 1 aggregator agent. The solver agents will be connected in a sparse manner as illustrated in the figure below: A --- B | | | | D --- C Each solver agent is connected to two other solver agents. For example, agent A is connected to agents B and C. Let’s first create a runtime and register the agent types. runtime = SingleThreadedAgentRuntime() model_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\") await MathSolver.register( runtime, \"MathSolverA\", lambda: MathSolver( model_client=model_client, topic_type=\"MathSolverA\", num_neighbors=2, max_round=3, ), ) await MathSolver.register( runtime, \"MathSolverB\", lambda: MathSolver( model_client=model_client, topic_type=\"MathSolverB\", num_neighbors=2, max_round=3, ), ) await MathSolver.register( runtime, \"MathSolverC\", lambda: MathSolver( model_client=model_client, topic_type=\"MathSolverC\", num_neighbors=2, max_round=3, ), ) await MathSolver.register( runtime, \"MathSolverD\", lambda: MathSolver( model_client=model_client, topic_type=\"MathSolverD\", num_neighbors=2, max_round=3, ), ) await MathAggregator.register(runtime, \"MathAggregator\", lambda: MathAggregator(num_solvers=4)) AgentType(type='MathAggregator') Now we will create the solver agent topology using TypeSubscription, which maps each solver agent’s publishing topic type to its neighbors’ agent types. # Subscriptions for topic published to by MathSolverA. await runtime.add_subscription(TypeSubscription(\"MathSolverA\", \"MathSolverD\")) await runtime.add_subscription(TypeSubscription(\"MathSolverA\", \"MathSolverB\")) # Subscriptions for topic published to by MathSolverB. await runtime.add_subscription(TypeSubscription(\"MathSolverB\", \"MathSolverA\")) await runtime.add_subscription(TypeSubscription(\"MathSolverB\", \"MathSolverC\")) # Subscriptions for topic published to by MathSolverC. await runtime.add_subscription(TypeSubscription(\"MathSolverC\", \"MathSolverB\")) await runtime.add_subscription(TypeSubscription(\"MathSolverC\", \"MathSolverD\")) # Subscriptions for topic published to by MathSolverD. await runtime.add_subscription(TypeSubscription(\"MathSolverD\", \"MathSolverC\")) await runtime.add_subscription(TypeSubscription(\"MathSolverD\", \"MathSolverA\")) # All solvers and the aggregator subscribe to the default topic. Solving Math Problems# Now let’s run the debate to solve a math problem. We publish a SolverRequest to the default topic, and the aggregator agent will start the debate. question = \"Natalia sold clips to 48 of her friends in April, and then she sold half as many clips in May. How many clips did Natalia sell altogether in April and May?\" runtime.start() await runtime.publish_message(Question(content=question), DefaultTopicId()) # Wait for the runtime to stop when idle. await runtime.stop_when_idle() # Close the connection to the model client. await model_client.close() -------------------------------------------------------------------------------- Aggregator MathAggregator:default received question: Natalia sold clips to 48 of her friends in April, and then she sold half as many clips in May. How many clips did Natalia sell altogether in April and May? -------------------------------------------------------------------------------- Aggregator MathAggregator:default publishes initial solver request. -------------------------------------------------------------------------------- Solver MathSolverC:default round 0: In April, Natalia sold 48 clips. In May, she sold half as many, which is 48 / 2 = 24 clips. To find the total number of clips sold in April and May, we add the amounts: 48 (April) + 24 (May) = 72 clips. Thus, the total number of clips sold by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverB:default round 0: In April, Natalia sold 48 clips. In May, she sold half as many clips, which is 48 / 2 = 24 clips. To find the total clips sold in April and May, we add both amounts: 48 (April) + 24 (May) = 72. Thus, the total number of clips sold altogether is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverD:default round 0: Natalia sold 48 clips in April. In May, she sold half as many, which is \\( \\frac{48}{2} = 24 \\) clips. To find the total clips sold in both months, we add the clips sold in April and May together: \\[ 48 + 24 = 72 \\] Thus, Natalia sold a total of 72 clips. The answer is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverC:default round 1: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverA:default round 1: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverA:default round 0: In April, Natalia sold clips to 48 friends. In May, she sold half as many, which is calculated as follows: Half of 48 is \\( 48 \\div 2 = 24 \\). Now, to find the total clips sold in April and May, we add the totals from both months: \\( 48 + 24 = 72 \\). Thus, the total number of clips Natalia sold altogether in April and May is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverD:default round 1: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverB:default round 1: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverC:default round 1: In April, Natalia sold 48 clips. In May, she sold half as many, which is 48 / 2 = 24 clips. The total number of clips sold in April and May is calculated by adding the two amounts: 48 (April) + 24 (May) = 72 clips. Therefore, the answer is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverA:default round 1: In April, Natalia sold 48 clips. In May, she sold half of that amount, which is 48 / 2 = 24 clips. To find the total clips sold in both months, we sum the clips from April and May: 48 (April) + 24 (May) = 72. Thus, Natalia sold a total of {{72}} clips. The answer is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverD:default round 2: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverB:default round 2: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverD:default round 1: Natalia sold 48 clips in April. In May, she sold half of that, which is \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold, we add the clips sold in both months: \\[ 48 + 24 = 72 \\] Therefore, the total number of clips sold by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverB:default round 1: In April, Natalia sold 48 clips. In May, she sold half that amount, which is 48 / 2 = 24 clips. To find the total clips sold in both months, we add the amounts: 48 (April) + 24 (May) = 72. Therefore, the total number of clips sold altogether by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverA:default round 2: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverC:default round 2: Received all responses from 2 neighbors. -------------------------------------------------------------------------------- Solver MathSolverA:default round 2: In April, Natalia sold 48 clips. In May, she sold half of that amount, which is \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold in both months, we add the amounts from April and May: \\( 48 + 24 = 72 \\). Thus, the total number of clips sold by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverC:default round 2: In April, Natalia sold 48 clips. In May, she sold half of that amount, which is \\( 48 \\div 2 = 24 \\) clips. To find the total number of clips sold in both months, we add the clips sold in April and May: 48 (April) + 24 (May) = 72. Thus, the total number of clips sold altogether by Natalia is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverB:default round 2: In April, Natalia sold 48 clips. In May, she sold half as many, calculated as \\( 48 \\div 2 = 24 \\) clips. To find the total clips sold over both months, we sum the totals: \\( 48 (April) + 24 (May) = 72 \\). Therefore, the total number of clips Natalia sold is {{72}}. -------------------------------------------------------------------------------- Solver MathSolverD:default round 2: To solve the problem, we know that Natalia sold 48 clips in April. In May, she sold half that amount, which is calculated as \\( 48 \\div 2 = 24 \\) clips. To find the total number of clips sold over both months, we add the two amounts together: \\[ 48 + 24 = 72 \\] Thus, the total number of clips sold by Natalia is {{72}}. -------------------------------------------------------------------------------- Aggregator MathAggregator:default received all final answers from 4 solvers. -------------------------------------------------------------------------------- Aggregator MathAggregator:default publishes final answer: 72 previous Mixture of Agents next Reflection",
      "code": "publish_message()"
    },
    {
      "description": "There are of two types of agents in this pattern: solver agents and an aggregator agent. The solver agents are connected in a sparse manner following the technique described in Improving Multi-Agent Debate with Sparse Communication Topology. The solver agents are responsible for solving math problems and exchanging responses with each other. The aggregator agent is responsible for distributing math problems to the solver agents, waiting for their final responses, and aggregating the responses to get the final answer.",
      "code": "publish_message()"
    }
  ],
  "links": [
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/multi-agent-debate.html",
    "https://microsoft.github.io/autogen/stable/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/extensions-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/autogenstudio-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/reference/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/installation.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/quickstart.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-and-multi-agent-application.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/architecture.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/application-stack.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-identity-and-lifecycle.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/topic-and-subscription.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/agent-and-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/message-and-communication.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/logging.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/telemetry.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/distributed-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/component-config.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-clients.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-context.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/tools.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/workbench.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/command-line-code-executors.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/intro.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/concurrent-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/sequential-workflow.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/group-chat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/handoffs.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/mixture-of-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/reflection.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/code-execution-groupchat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/azure-openai-with-aad-auth.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/termination-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/tool-use-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/extracting-results-with-an-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/openai-assistant-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/langgraph-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llamaindex-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/local-llms-ollama-litellm.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/instrumenting.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/topic-subscription-scenarios.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/structured-output-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llm-usage-logger.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/faqs.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html"
  ]
}