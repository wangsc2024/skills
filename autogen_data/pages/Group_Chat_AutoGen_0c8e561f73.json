{
  "url": "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/group-chat.html",
  "title": "Group Chat — AutoGen",
  "content": "Group chat is a design pattern where a group of agents share a common thread of messages: they all subscribe and publish to the same topic. Each participant agent is specialized for a particular task, such as writer, illustrator, and editor in a collaborative writing task. You can also include an agent to represent a human user to help guide the agents when needed.\n\nIn a group chat, participants take turn to publish a message, and the process is sequential – only one agent is working at a time. Under the hood, the order of turns is maintained by a Group Chat Manager agent, which selects the next agent to speak upon receiving a message. The exact algorithm for selecting the next agent can vary based on your application requirements. Typically, a round-robin algorithm or a selector with an LLM model is used.\n\nGroup chat is useful for dynamically decomposing a complex task into smaller ones that can be handled by specialized agents with well-defined roles. It is also possible to nest group chats into a hierarchy with each participant a recursive group chat.\n\nIn this example, we use AutoGen’s Core API to implement the group chat pattern using event-driven agents. Please first read about Topics and Subscriptions to understand the concepts and then Messages and Communication to learn the API usage for pub-sub. We will demonstrate a simple example of a group chat with a LLM-based selector for the group chat manager, to create content for a children’s story book.\n\nWhile this example illustrates the group chat mechanism, it is complex and represents a starting point from which you can build your own group chat system with custom agents and speaker selection algorithms. The AgentChat API has a built-in implementation of selector group chat. You can use that if you do not want to use the Core API.\n\nWe will be using the rich library to display the messages in a nice format.\n\nThe message protocol for the group chat pattern is simple.\n\nTo start, user or an external agent publishes a GroupChatMessage message to the common topic of all participants.\n\nThe group chat manager selects the next speaker, sends out a RequestToSpeak message to that agent.\n\nThe agent publishes a GroupChatMessage message to the common topic upon receiving the RequestToSpeak message.\n\nThis process continues until a termination condition is reached at the group chat manager, which then stops issuing RequestToSpeak message, and the group chat ends.\n\nThe following diagram illustrates steps 2 to 4 above.\n\nLet’s first define the agent class that only uses LLM models to generate text. This is will be used as the base class for all AI agents in the group chat.\n\nUsing the base class, we can define the writer and editor agents with different system messages.\n\nNow let’s define the IllustratorAgent which uses a DALL-E model to generate an illustration based on the description provided. We set up the image generator as a tool using FunctionTool wrapper, and use a model client to make the tool call.\n\nWith all the AI agents defined, we can now define the user agent that will take the role of the human user in the group chat.\n\nThe UserAgent implementation uses console input to get the user’s input. In a real-world scenario, you can replace this by communicating with a frontend, and subscribe to responses from the frontend.\n\nLastly, we define the GroupChatManager agent which manages the group chat and selects the next agent to speak using an LLM. The group chat manager checks if the editor has approved the draft by looking for the \"APPORVED\" keyword in the message. If the editor has approved the draft, the group chat manager stops selecting the next speaker, and the group chat ends.\n\nThe group chat manager’s constructor takes a list of participants’ topic types as an argument. To prompt the next speaker to work, the GroupChatManager agent publishes a RequestToSpeak message to the next participant’s topic.\n\nIn this example, we also make sure the group chat manager always picks a different participant to speak next, by keeping track of the previous speaker. This helps to ensure the group chat is not dominated by a single participant.\n\nTo set up the group chat, we create a SingleThreadedAgentRuntime and register the agents’ factories and subscriptions.\n\nEach participant agent subscribes to both the group chat topic as well as its own topic in order to receive RequestToSpeak messages, while the group chat manager agent only subcribes to the group chat topic.\n\nWe start the runtime and publish a GroupChatMessage for the task to start the group chat.\n\nFrom the output, you can see the writer, illustrator, and editor agents taking turns to speak and collaborate to generate a picture book, before asking for final approval from the user.\n\nThis example showcases a simple implementation of the group chat pattern – it is not meant to be used in real applications. You can improve the speaker selection algorithm. For example, you can avoid using LLM when simple rules are sufficient and more reliable: you can use a rule that the editor always speaks after the writer.\n\nThe AgentChat API provides a high-level API for selector group chat. It has more features but mostly shares the same design as this implementation.",
  "headings": [
    {
      "level": "h1",
      "text": "Group Chat#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Message Protocol#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Base Group Chat Agent#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Writer and Editor Agents#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Illustrator Agent with Image Generation#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "User Agent#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Group Chat Manager#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Creating the Group Chat#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Running the Group Chat#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Next Steps#",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "# ! pip install rich",
      "language": "markdown"
    },
    {
      "code": "# ! pip install rich",
      "language": "markdown"
    },
    {
      "code": "import json\nimport string\nimport uuid\nfrom typing import List\n\nimport openai\nfrom autogen_core import (\n    DefaultTopicId,\n    FunctionCall,\n    Image,\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    TopicId,\n    TypeSubscription,\n    message_handler,\n)\nfrom autogen_core.models import (\n    AssistantMessage,\n    ChatCompletionClient,\n    LLMMessage,\n    SystemMessage,\n    UserMessage,\n)\nfrom autogen_core.tools import FunctionTool\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nfrom IPython.display import display  # type: ignore\nfrom pydantic import BaseModel\nfrom rich.console import Console\nfrom rich.markdown import Markdown",
      "language": "python"
    },
    {
      "code": "import json\nimport string\nimport uuid\nfrom typing import List\n\nimport openai\nfrom autogen_core import (\n    DefaultTopicId,\n    FunctionCall,\n    Image,\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    TopicId,\n    TypeSubscription,\n    message_handler,\n)\nfrom autogen_core.models import (\n    AssistantMessage,\n    ChatCompletionClient,\n    LLMMessage,\n    SystemMessage,\n    UserMessage,\n)\nfrom autogen_core.tools import FunctionTool\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nfrom IPython.display import display  # type: ignore\nfrom pydantic import BaseModel\nfrom rich.console import Console\nfrom rich.markdown import Markdown",
      "language": "python"
    },
    {
      "code": "class GroupChatMessage(BaseModel):\n    body: UserMessage\n\n\nclass RequestToSpeak(BaseModel):\n    pass",
      "language": "php"
    },
    {
      "code": "class GroupChatMessage(BaseModel):\n    body: UserMessage\n\n\nclass RequestToSpeak(BaseModel):\n    pass",
      "language": "php"
    },
    {
      "code": "class BaseGroupChatAgent(RoutedAgent):\n    \"\"\"A group chat participant using an LLM.\"\"\"\n\n    def __init__(\n        self,\n        description: str,\n        group_chat_topic_type: str,\n        model_client: ChatCompletionClient,\n        system_message: str,\n    ) -> None:\n        super().__init__(description=description)\n        self._group_chat_topic_type = group_chat_topic_type\n        self._model_client = model_client\n        self._system_message = SystemMessage(content=system_message)\n        self._chat_history: List[LLMMessage] = []\n\n    @message_handler\n    async def handle_message(self, message: GroupChatMessage, ctx: MessageContext) -> None:\n        self._chat_history.extend(\n            [\n                UserMessage(content=f\"Transferred to {message.body.source}\", source=\"system\"),\n                message.body,\n            ]\n        )\n\n    @message_handler\n    async def handle_request_to_speak(self, message: RequestToSpeak, ctx: MessageContext) -> None:\n        # print(f\"\\n{'-'*80}\\n{self.id.type}:\", flush=True)\n        Console().print(Markdown(f\"### {self.id.type}: \"))\n        self._chat_history.append(\n            UserMessage(content=f\"Transferred to {self.id.type}, adopt the persona immediately.\", source=\"system\")\n        )\n        completion = await self._model_client.create([self._system_message] + self._chat_history)\n        assert isinstance(completion.content, str)\n        self._chat_history.append(AssistantMessage(content=completion.content, source=self.id.type))\n        Console().print(Markdown(completion.content))\n        # print(completion.content, flush=True)\n        await self.publish_message(\n            GroupChatMessage(body=UserMessage(content=completion.content, source=self.id.type)),\n            topic_id=DefaultTopicId(type=self._group_chat_topic_type),\n        )",
      "language": "python"
    },
    {
      "code": "class BaseGroupChatAgent(RoutedAgent):\n    \"\"\"A group chat participant using an LLM.\"\"\"\n\n    def __init__(\n        self,\n        description: str,\n        group_chat_topic_type: str,\n        model_client: ChatCompletionClient,\n        system_message: str,\n    ) -> None:\n        super().__init__(description=description)\n        self._group_chat_topic_type = group_chat_topic_type\n        self._model_client = model_client\n        self._system_message = SystemMessage(content=system_message)\n        self._chat_history: List[LLMMessage] = []\n\n    @message_handler\n    async def handle_message(self, message: GroupChatMessage, ctx: MessageContext) -> None:\n        self._chat_history.extend(\n            [\n                UserMessage(content=f\"Transferred to {message.body.source}\", source=\"system\"),\n                message.body,\n            ]\n        )\n\n    @message_handler\n    async def handle_request_to_speak(self, message: RequestToSpeak, ctx: MessageContext) -> None:\n        # print(f\"\\n{'-'*80}\\n{self.id.type}:\", flush=True)\n        Console().print(Markdown(f\"### {self.id.type}: \"))\n        self._chat_history.append(\n            UserMessage(content=f\"Transferred to {self.id.type}, adopt the persona immediately.\", source=\"system\")\n        )\n        completion = await self._model_client.create([self._system_message] + self._chat_history)\n        assert isinstance(completion.content, str)\n        self._chat_history.append(AssistantMessage(content=completion.content, source=self.id.type))\n        Console().print(Markdown(completion.content))\n        # print(completion.content, flush=True)\n        await self.publish_message(\n            GroupChatMessage(body=UserMessage(content=completion.content, source=self.id.type)),\n            topic_id=DefaultTopicId(type=self._group_chat_topic_type),\n        )",
      "language": "python"
    },
    {
      "code": "class WriterAgent(BaseGroupChatAgent):\n    def __init__(self, description: str, group_chat_topic_type: str, model_client: ChatCompletionClient) -> None:\n        super().__init__(\n            description=description,\n            group_chat_topic_type=group_chat_topic_type,\n            model_client=model_client,\n            system_message=\"You are a Writer. You produce good work.\",\n        )\n\n\nclass EditorAgent(BaseGroupChatAgent):\n    def __init__(self, description: str, group_chat_topic_type: str, model_client: ChatCompletionClient) -> None:\n        super().__init__(\n            description=description,\n            group_chat_topic_type=group_chat_topic_type,\n            model_client=model_client,\n            system_message=\"You are an Editor. Plan and guide the task given by the user. Provide critical feedbacks to the draft and illustration produced by Writer and Illustrator. \"\n            \"Approve if the task is completed and the draft and illustration meets user's requirements.\",\n        )",
      "language": "python"
    },
    {
      "code": "class WriterAgent(BaseGroupChatAgent):\n    def __init__(self, description: str, group_chat_topic_type: str, model_client: ChatCompletionClient) -> None:\n        super().__init__(\n            description=description,\n            group_chat_topic_type=group_chat_topic_type,\n            model_client=model_client,\n            system_message=\"You are a Writer. You produce good work.\",\n        )\n\n\nclass EditorAgent(BaseGroupChatAgent):\n    def __init__(self, description: str, group_chat_topic_type: str, model_client: ChatCompletionClient) -> None:\n        super().__init__(\n            description=description,\n            group_chat_topic_type=group_chat_topic_type,\n            model_client=model_client,\n            system_message=\"You are an Editor. Plan and guide the task given by the user. Provide critical feedbacks to the draft and illustration produced by Writer and Illustrator. \"\n            \"Approve if the task is completed and the draft and illustration meets user's requirements.\",\n        )",
      "language": "python"
    },
    {
      "code": "class IllustratorAgent(BaseGroupChatAgent):\n    def __init__(\n        self,\n        description: str,\n        group_chat_topic_type: str,\n        model_client: ChatCompletionClient,\n        image_client: openai.AsyncClient,\n    ) -> None:\n        super().__init__(\n            description=description,\n            group_chat_topic_type=group_chat_topic_type,\n            model_client=model_client,\n            system_message=\"You are an Illustrator. You use the generate_image tool to create images given user's requirement. \"\n            \"Make sure the images have consistent characters and style.\",\n        )\n        self._image_client = image_client\n        self._image_gen_tool = FunctionTool(\n            self._image_gen, name=\"generate_image\", description=\"Call this to generate an image. \"\n        )\n\n    async def _image_gen(\n        self, character_appearence: str, style_attributes: str, worn_and_carried: str, scenario: str\n    ) -> str:\n        prompt = f\"Digital painting of a {character_appearence} character with {style_attributes}. Wearing {worn_and_carried}, {scenario}.\"\n        response = await self._image_client.images.generate(\n            prompt=prompt, model=\"dall-e-3\", response_format=\"b64_json\", size=\"1024x1024\"\n        )\n        return response.data[0].b64_json  # type: ignore\n\n    @message_handler\n    async def handle_request_to_speak(self, message: RequestToSpeak, ctx: MessageContext) -> None:  # type: ignore\n        Console().print(Markdown(f\"### {self.id.type}: \"))\n        self._chat_history.append(\n            UserMessage(content=f\"Transferred to {self.id.type}, adopt the persona immediately.\", source=\"system\")\n        )\n        # Ensure that the image generation tool is used.\n        completion = await self._model_client.create(\n            [self._system_message] + self._chat_history,\n            tools=[self._image_gen_tool],\n            extra_create_args={\"tool_choice\": \"required\"},\n            cancellation_token=ctx.cancellation_token,\n        )\n        assert isinstance(completion.content, list) and all(\n            isinstance(item, FunctionCall) for item in completion.content\n        )\n        images: List[str | Image] = []\n        for tool_call in completion.content:\n            arguments = json.loads(tool_call.arguments)\n            Console().print(arguments)\n            result = await self._image_gen_tool.run_json(arguments, ctx.cancellation_token)\n            image = Image.from_base64(self._image_gen_tool.return_value_as_string(result))\n            image = Image.from_pil(image.image.resize((256, 256)))\n            display(image.image)  # type: ignore\n            images.append(image)\n        await self.publish_message(\n            GroupChatMessage(body=UserMessage(content=images, source=self.id.type)),\n            DefaultTopicId(type=self._group_chat_topic_type),\n        )",
      "language": "python"
    },
    {
      "code": "class IllustratorAgent(BaseGroupChatAgent):\n    def __init__(\n        self,\n        description: str,\n        group_chat_topic_type: str,\n        model_client: ChatCompletionClient,\n        image_client: openai.AsyncClient,\n    ) -> None:\n        super().__init__(\n            description=description,\n            group_chat_topic_type=group_chat_topic_type,\n            model_client=model_client,\n            system_message=\"You are an Illustrator. You use the generate_image tool to create images given user's requirement. \"\n            \"Make sure the images have consistent characters and style.\",\n        )\n        self._image_client = image_client\n        self._image_gen_tool = FunctionTool(\n            self._image_gen, name=\"generate_image\", description=\"Call this to generate an image. \"\n        )\n\n    async def _image_gen(\n        self, character_appearence: str, style_attributes: str, worn_and_carried: str, scenario: str\n    ) -> str:\n        prompt = f\"Digital painting of a {character_appearence} character with {style_attributes}. Wearing {worn_and_carried}, {scenario}.\"\n        response = await self._image_client.images.generate(\n            prompt=prompt, model=\"dall-e-3\", response_format=\"b64_json\", size=\"1024x1024\"\n        )\n        return response.data[0].b64_json  # type: ignore\n\n    @message_handler\n    async def handle_request_to_speak(self, message: RequestToSpeak, ctx: MessageContext) -> None:  # type: ignore\n        Console().print(Markdown(f\"### {self.id.type}: \"))\n        self._chat_history.append(\n            UserMessage(content=f\"Transferred to {self.id.type}, adopt the persona immediately.\", source=\"system\")\n        )\n        # Ensure that the image generation tool is used.\n        completion = await self._model_client.create(\n            [self._system_message] + self._chat_history,\n            tools=[self._image_gen_tool],\n            extra_create_args={\"tool_choice\": \"required\"},\n            cancellation_token=ctx.cancellation_token,\n        )\n        assert isinstance(completion.content, list) and all(\n            isinstance(item, FunctionCall) for item in completion.content\n        )\n        images: List[str | Image] = []\n        for tool_call in completion.content:\n            arguments = json.loads(tool_call.arguments)\n            Console().print(arguments)\n            result = await self._image_gen_tool.run_json(arguments, ctx.cancellation_token)\n            image = Image.from_base64(self._image_gen_tool.return_value_as_string(result))\n            image = Image.from_pil(image.image.resize((256, 256)))\n            display(image.image)  # type: ignore\n            images.append(image)\n        await self.publish_message(\n            GroupChatMessage(body=UserMessage(content=images, source=self.id.type)),\n            DefaultTopicId(type=self._group_chat_topic_type),\n        )",
      "language": "python"
    },
    {
      "code": "class UserAgent(RoutedAgent):\n    def __init__(self, description: str, group_chat_topic_type: str) -> None:\n        super().__init__(description=description)\n        self._group_chat_topic_type = group_chat_topic_type\n\n    @message_handler\n    async def handle_message(self, message: GroupChatMessage, ctx: MessageContext) -> None:\n        # When integrating with a frontend, this is where group chat message would be sent to the frontend.\n        pass\n\n    @message_handler\n    async def handle_request_to_speak(self, message: RequestToSpeak, ctx: MessageContext) -> None:\n        user_input = input(\"Enter your message, type 'APPROVE' to conclude the task: \")\n        Console().print(Markdown(f\"### User: \\n{user_input}\"))\n        await self.publish_message(\n            GroupChatMessage(body=UserMessage(content=user_input, source=self.id.type)),\n            DefaultTopicId(type=self._group_chat_topic_type),\n        )",
      "language": "python"
    },
    {
      "code": "class UserAgent(RoutedAgent):\n    def __init__(self, description: str, group_chat_topic_type: str) -> None:\n        super().__init__(description=description)\n        self._group_chat_topic_type = group_chat_topic_type\n\n    @message_handler\n    async def handle_message(self, message: GroupChatMessage, ctx: MessageContext) -> None:\n        # When integrating with a frontend, this is where group chat message would be sent to the frontend.\n        pass\n\n    @message_handler\n    async def handle_request_to_speak(self, message: RequestToSpeak, ctx: MessageContext) -> None:\n        user_input = input(\"Enter your message, type 'APPROVE' to conclude the task: \")\n        Console().print(Markdown(f\"### User: \\n{user_input}\"))\n        await self.publish_message(\n            GroupChatMessage(body=UserMessage(content=user_input, source=self.id.type)),\n            DefaultTopicId(type=self._group_chat_topic_type),\n        )",
      "language": "python"
    },
    {
      "code": "class GroupChatManager(RoutedAgent):\n    def __init__(\n        self,\n        participant_topic_types: List[str],\n        model_client: ChatCompletionClient,\n        participant_descriptions: List[str],\n    ) -> None:\n        super().__init__(\"Group chat manager\")\n        self._participant_topic_types = participant_topic_types\n        self._model_client = model_client\n        self._chat_history: List[UserMessage] = []\n        self._participant_descriptions = participant_descriptions\n        self._previous_participant_topic_type: str | None = None\n\n    @message_handler\n    async def handle_message(self, message: GroupChatMessage, ctx: MessageContext) -> None:\n        assert isinstance(message.body, UserMessage)\n        self._chat_history.append(message.body)\n        # If the message is an approval message from the user, stop the chat.\n        if message.body.source == \"User\":\n            assert isinstance(message.body.content, str)\n            if message.body.content.lower().strip(string.punctuation).endswith(\"approve\"):\n                return\n        # Format message history.\n        messages: List[str] = []\n        for msg in self._chat_history:\n            if isinstance(msg.content, str):\n                messages.append(f\"{msg.source}: {msg.content}\")\n            elif isinstance(msg.content, list):\n                line: List[str] = []\n                for item in msg.content:\n                    if isinstance(item, str):\n                        line.append(item)\n                    else:\n                        line.append(\"[Image]\")\n                messages.append(f\"{msg.source}: {', '.join(line)}\")\n        history = \"\\n\".join(messages)\n        # Format roles.\n        roles = \"\\n\".join(\n            [\n                f\"{topic_type}: {description}\".strip()\n                for topic_type, description in zip(\n                    self._participant_topic_types, self._participant_descriptions, strict=True\n                )\n                if topic_type != self._previous_participant_topic_type\n            ]\n        )\n        selector_prompt = \"\"\"You are in a role play game. The following roles are available:\n{roles}.\nRead the following conversation. Then select the next role from {participants} to play. Only return the role.\n\n{history}\n\nRead the above conversation. Then select the next role from {participants} to play. Only return the role.\n\"\"\"\n        system_message = SystemMessage(\n            content=selector_prompt.format(\n                roles=roles,\n                history=history,\n                participants=str(\n                    [\n                        topic_type\n                        for topic_type in self._participant_topic_types\n                        if topic_type != self._previous_participant_topic_type\n                    ]\n                ),\n            )\n        )\n        completion = await self._model_client.create([system_message], cancellation_token=ctx.cancellation_token)\n        assert isinstance(completion.content, str)\n        selected_topic_type: str\n        for topic_type in self._participant_topic_types:\n            if topic_type.lower() in completion.content.lower():\n                selected_topic_type = topic_type\n                self._previous_participant_topic_type = selected_topic_type\n                await self.publish_message(RequestToSpeak(), DefaultTopicId(type=selected_topic_type))\n                return\n        raise ValueError(f\"Invalid role selected: {completion.content}\")",
      "language": "python"
    },
    {
      "code": "class GroupChatManager(RoutedAgent):\n    def __init__(\n        self,\n        participant_topic_types: List[str],\n        model_client: ChatCompletionClient,\n        participant_descriptions: List[str],\n    ) -> None:\n        super().__init__(\"Group chat manager\")\n        self._participant_topic_types = participant_topic_types\n        self._model_client = model_client\n        self._chat_history: List[UserMessage] = []\n        self._participant_descriptions = participant_descriptions\n        self._previous_participant_topic_type: str | None = None\n\n    @message_handler\n    async def handle_message(self, message: GroupChatMessage, ctx: MessageContext) -> None:\n        assert isinstance(message.body, UserMessage)\n        self._chat_history.append(message.body)\n        # If the message is an approval message from the user, stop the chat.\n        if message.body.source == \"User\":\n            assert isinstance(message.body.content, str)\n            if message.body.content.lower().strip(string.punctuation).endswith(\"approve\"):\n                return\n        # Format message history.\n        messages: List[str] = []\n        for msg in self._chat_history:\n            if isinstance(msg.content, str):\n                messages.append(f\"{msg.source}: {msg.content}\")\n            elif isinstance(msg.content, list):\n                line: List[str] = []\n                for item in msg.content:\n                    if isinstance(item, str):\n                        line.append(item)\n                    else:\n                        line.append(\"[Image]\")\n                messages.append(f\"{msg.source}: {', '.join(line)}\")\n        history = \"\\n\".join(messages)\n        # Format roles.\n        roles = \"\\n\".join(\n            [\n                f\"{topic_type}: {description}\".strip()\n                for topic_type, description in zip(\n                    self._participant_topic_types, self._participant_descriptions, strict=True\n                )\n                if topic_type != self._previous_participant_topic_type\n            ]\n        )\n        selector_prompt = \"\"\"You are in a role play game. The following roles are available:\n{roles}.\nRead the following conversation. Then select the next role from {participants} to play. Only return the role.\n\n{history}\n\nRead the above conversation. Then select the next role from {participants} to play. Only return the role.\n\"\"\"\n        system_message = SystemMessage(\n            content=selector_prompt.format(\n                roles=roles,\n                history=history,\n                participants=str(\n                    [\n                        topic_type\n                        for topic_type in self._participant_topic_types\n                        if topic_type != self._previous_participant_topic_type\n                    ]\n                ),\n            )\n        )\n        completion = await self._model_client.create([system_message], cancellation_token=ctx.cancellation_token)\n        assert isinstance(completion.content, str)\n        selected_topic_type: str\n        for topic_type in self._participant_topic_types:\n            if topic_type.lower() in completion.content.lower():\n                selected_topic_type = topic_type\n                self._previous_participant_topic_type = selected_topic_type\n                await self.publish_message(RequestToSpeak(), DefaultTopicId(type=selected_topic_type))\n                return\n        raise ValueError(f\"Invalid role selected: {completion.content}\")",
      "language": "python"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\n\neditor_topic_type = \"Editor\"\nwriter_topic_type = \"Writer\"\nillustrator_topic_type = \"Illustrator\"\nuser_topic_type = \"User\"\ngroup_chat_topic_type = \"group_chat\"\n\neditor_description = \"Editor for planning and reviewing the content.\"\nwriter_description = \"Writer for creating any text content.\"\nuser_description = \"User for providing final approval.\"\nillustrator_description = \"An illustrator for creating images.\"\n\nmodel_client = OpenAIChatCompletionClient(\n    model=\"gpt-4o-2024-08-06\",\n    # api_key=\"YOUR_API_KEY\",\n)\n\neditor_agent_type = await EditorAgent.register(\n    runtime,\n    editor_topic_type,  # Using topic type as the agent type.\n    lambda: EditorAgent(\n        description=editor_description,\n        group_chat_topic_type=group_chat_topic_type,\n        model_client=model_client,\n    ),\n)\nawait runtime.add_subscription(TypeSubscription(topic_type=editor_topic_type, agent_type=editor_agent_type.type))\nawait runtime.add_subscription(TypeSubscription(topic_type=group_chat_topic_type, agent_type=editor_agent_type.type))\n\nwriter_agent_type = await WriterAgent.register(\n    runtime,\n    writer_topic_type,  # Using topic type as the agent type.\n    lambda: WriterAgent(\n        description=writer_description,\n        group_chat_topic_type=group_chat_topic_type,\n        model_client=model_client,\n    ),\n)\nawait runtime.add_subscription(TypeSubscription(topic_type=writer_topic_type, agent_type=writer_agent_type.type))\nawait runtime.add_subscription(TypeSubscription(topic_type=group_chat_topic_type, agent_type=writer_agent_type.type))\n\nillustrator_agent_type = await IllustratorAgent.register(\n    runtime,\n    illustrator_topic_type,\n    lambda: IllustratorAgent(\n        description=illustrator_description,\n        group_chat_topic_type=group_chat_topic_type,\n        model_client=model_client,\n        image_client=openai.AsyncClient(\n            # api_key=\"YOUR_API_KEY\",\n        ),\n    ),\n)\nawait runtime.add_subscription(\n    TypeSubscription(topic_type=illustrator_topic_type, agent_type=illustrator_agent_type.type)\n)\nawait runtime.add_subscription(\n    TypeSubscription(topic_type=group_chat_topic_type, agent_type=illustrator_agent_type.type)\n)\n\nuser_agent_type = await UserAgent.register(\n    runtime,\n    user_topic_type,\n    lambda: UserAgent(description=user_description, group_chat_topic_type=group_chat_topic_type),\n)\nawait runtime.add_subscription(TypeSubscription(topic_type=user_topic_type, agent_type=user_agent_type.type))\nawait runtime.add_subscription(TypeSubscription(topic_type=group_chat_topic_type, agent_type=user_agent_type.type))\n\ngroup_chat_manager_type = await GroupChatManager.register(\n    runtime,\n    \"group_chat_manager\",\n    lambda: GroupChatManager(\n        participant_topic_types=[writer_topic_type, illustrator_topic_type, editor_topic_type, user_topic_type],\n        model_client=model_client,\n        participant_descriptions=[writer_description, illustrator_description, editor_description, user_description],\n    ),\n)\nawait runtime.add_subscription(\n    TypeSubscription(topic_type=group_chat_topic_type, agent_type=group_chat_manager_type.type)\n)",
      "language": "julia"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\n\neditor_topic_type = \"Editor\"\nwriter_topic_type = \"Writer\"\nillustrator_topic_type = \"Illustrator\"\nuser_topic_type = \"User\"\ngroup_chat_topic_type = \"group_chat\"\n\neditor_description = \"Editor for planning and reviewing the content.\"\nwriter_description = \"Writer for creating any text content.\"\nuser_description = \"User for providing final approval.\"\nillustrator_description = \"An illustrator for creating images.\"\n\nmodel_client = OpenAIChatCompletionClient(\n    model=\"gpt-4o-2024-08-06\",\n    # api_key=\"YOUR_API_KEY\",\n)\n\neditor_agent_type = await EditorAgent.register(\n    runtime,\n    editor_topic_type,  # Using topic type as the agent type.\n    lambda: EditorAgent(\n        description=editor_description,\n        group_chat_topic_type=group_chat_topic_type,\n        model_client=model_client,\n    ),\n)\nawait runtime.add_subscription(TypeSubscription(topic_type=editor_topic_type, agent_type=editor_agent_type.type))\nawait runtime.add_subscription(TypeSubscription(topic_type=group_chat_topic_type, agent_type=editor_agent_type.type))\n\nwriter_agent_type = await WriterAgent.register(\n    runtime,\n    writer_topic_type,  # Using topic type as the agent type.\n    lambda: WriterAgent(\n        description=writer_description,\n        group_chat_topic_type=group_chat_topic_type,\n        model_client=model_client,\n    ),\n)\nawait runtime.add_subscription(TypeSubscription(topic_type=writer_topic_type, agent_type=writer_agent_type.type))\nawait runtime.add_subscription(TypeSubscription(topic_type=group_chat_topic_type, agent_type=writer_agent_type.type))\n\nillustrator_agent_type = await IllustratorAgent.register(\n    runtime,\n    illustrator_topic_type,\n    lambda: IllustratorAgent(\n        description=illustrator_description,\n        group_chat_topic_type=group_chat_topic_type,\n        model_client=model_client,\n        image_client=openai.AsyncClient(\n            # api_key=\"YOUR_API_KEY\",\n        ),\n    ),\n)\nawait runtime.add_subscription(\n    TypeSubscription(topic_type=illustrator_topic_type, agent_type=illustrator_agent_type.type)\n)\nawait runtime.add_subscription(\n    TypeSubscription(topic_type=group_chat_topic_type, agent_type=illustrator_agent_type.type)\n)\n\nuser_agent_type = await UserAgent.register(\n    runtime,\n    user_topic_type,\n    lambda: UserAgent(description=user_description, group_chat_topic_type=group_chat_topic_type),\n)\nawait runtime.add_subscription(TypeSubscription(topic_type=user_topic_type, agent_type=user_agent_type.type))\nawait runtime.add_subscription(TypeSubscription(topic_type=group_chat_topic_type, agent_type=user_agent_type.type))\n\ngroup_chat_manager_type = await GroupChatManager.register(\n    runtime,\n    \"group_chat_manager\",\n    lambda: GroupChatManager(\n        participant_topic_types=[writer_topic_type, illustrator_topic_type, editor_topic_type, user_topic_type],\n        model_client=model_client,\n        participant_descriptions=[writer_description, illustrator_description, editor_description, user_description],\n    ),\n)\nawait runtime.add_subscription(\n    TypeSubscription(topic_type=group_chat_topic_type, agent_type=group_chat_manager_type.type)\n)",
      "language": "julia"
    },
    {
      "code": "runtime.start()\nsession_id = str(uuid.uuid4())\nawait runtime.publish_message(\n    GroupChatMessage(\n        body=UserMessage(\n            content=\"Please write a short story about the gingerbread man with up to 3 photo-realistic illustrations.\",\n            source=\"User\",\n        )\n    ),\n    TopicId(type=group_chat_topic_type, source=session_id),\n)\nawait runtime.stop_when_idle()\nawait model_client.close()",
      "language": "csharp"
    },
    {
      "code": "runtime.start()\nsession_id = str(uuid.uuid4())\nawait runtime.publish_message(\n    GroupChatMessage(\n        body=UserMessage(\n            content=\"Please write a short story about the gingerbread man with up to 3 photo-realistic illustrations.\",\n            source=\"User\",\n        )\n    ),\n    TopicId(type=group_chat_topic_type, source=session_id),\n)\nawait runtime.stop_when_idle()\nawait model_client.close()",
      "language": "csharp"
    },
    {
      "code": "Title: The Escape of the Gingerbread Man                                                                           \n\nIllustration 1: A Rustic Kitchen Scene In a quaint little cottage at the edge of an enchanted forest, an elderly   \nwoman, with flour-dusted hands, carefully shapes gingerbread dough on a wooden counter. The aroma of ginger,       \ncinnamon, and cloves wafts through the air as a warm breeze from the open window dances with fluttering curtains.  \nThe sunlight gently permeates the cozy kitchen, casting a golden hue over the flour-dusted surfaces and the rolling\npin. Heartfelt trinkets and rustic decorations adorn the shelves - signs of a lived-in, lovingly nurtured home.    \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nStory:                                                                                                             \n\nOnce there was an old woman who lived alone in a charming cottage, her days filled with the joyful art of baking.  \nOne sunny afternoon, she decided to make a special gingerbread man to keep her company. As she shaped him tenderly \nand placed him in the oven, she couldn't help but smile at the delight he might bring.                             \n\nBut to her astonishment, once she opened the oven door to check on her creation, the gingerbread man leapt out,    \nsuddenly alive. His eyes were bright as beads, and his smile cheeky and wide. \"Run, run, as fast as you can! You   \ncan't catch me, I'm the Gingerbread Man!\" he laughed, darting towards the door.                                    \n\nThe old woman, chuckling at the unexpected mischief, gave chase, but her footsteps were slow with the weight of    \nage. The Gingerbread Man raced out of the door and into the sunny afternoon.                                       \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nIllustration 2: A Frolic Through the Meadow The Gingerbread Man darts through a vibrant meadow, his arms swinging  \njoyously by his sides. Behind him trails the old woman, her apron flapping in the wind as she gently tries to catch\nup. Wildflowers of every color bloom vividly under the radiant sky, painting the scene with shades of nature's     \nbrilliance. Birds flit through the sky and a stream babbles nearby, oblivious to the chase taking place below.     \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nContinuing his sprint, the Gingerbread Man encountered a cow grazing peacefully. Intrigued, the cow trotted        \nforward. \"Stop, Gingerbread Man! I wish to eat you!\" she called, but the Gingerbread Man only twirled in a teasing \njig, flashing his icing smile before darting off again.                                                            \n\n\"Run, run, as fast as you can! You can't catch me, I'm the Gingerbread Man!\" he taunted, leaving the cow in his    \nspicy wake.                                                                                                        \n\nAs he zoomed across the meadow, he spied a cautious horse in a nearby paddock, who neighed, \"Oh! You look          \ndelicious! I want to eat you!\" But the Gingerbread Man only laughed, his feet barely touching the earth. The horse \njoined the trail, hooves pounding, but even he couldn't match the Gingerbread Man's pace.                          \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nIllustration 3: A Bridge Over a Sparkling River Arriving at a wooden bridge across a shimmering river, the         \nGingerbread Man pauses momentarily, his silhouette against the glistening water. Sunlight sparkles off the water's \nsoft ripples casting reflections that dance like small constellations. A sly fox emerges from the shadows of a     \nblooming willow on the riverbank, his eyes alight with cunning and curiosity.                                      \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nThe Gingerbread Man bounded onto the bridge and skirted past a sly, watching fox. \"Foolish Gingerbread Man,\" the   \nfox mused aloud, \"you might have outrun them all, but you can't possibly swim across that river.\"                  \n\nPausing, the Gingerbread Man considered this dilemma. But the fox, oh so clever, offered a dangerous solution.     \n\"Climb on my back, and I'll carry you across safely,\" he suggested with a sly smile.                               \n\nGingerbread thought himself smarter than that but hesitated, fearing the water or being pursued by the tired,      \nhungry crowd now gathering. \"Promise you won't eat me?\" he ventured.                                               \n\n\"Of course,\" the fox reassured, a gleam in his eyes that the others pondered from a distance.                      \n\nAs they crossed the river, the gingerbread man confident on his ride, the old woman, cow, and horse hoped for his  \nsafety. Yet, nearing the middle, the crafty fox tilted his chin and swiftly snapped, swallowing the gingerbread man\nwhole.                                                                                                             \n\nBewildered but awed by the clever twist they had witnessed, the old woman hung her head while the cow and horse    \nambled away, pondering the fate of the boisterous Gingerbread Man.                                                 \n\nThe fox, licking his lips, ambled along the river, savoring his victory, leaving an air of mystery hovering above  \nthe shimmering waters, where the memory of the Gingerbread Man's spirited run lingered long after.",
      "language": "sql"
    },
    {
      "code": "Thank you for submitting the draft and illustrations for the short story, \"The Escape of the Gingerbread Man.\"     \nLet's go through the story and illustrations critically:                                                           \n\n                                                  Story Feedback:                                                  \n\n 1 Plot & Structure:                                                                                               \n    • The story follows the traditional gingerbread man tale closely, which might appeal to readers looking for a  \n      classic retelling. Consider adding a unique twist or additional layer to make it stand out.                  \n 2 Character Development:                                                                                          \n    • The gingerbread man is depicted with a cheeky personality, which is consistent throughout. However, for the  \n      old woman, cow, horse, and fox, incorporating a bit more personality might enrich the narrative.             \n 3 Pacing:                                                                                                         \n    • The story moves at a brisk pace, fitting for the short story format. Ensure that each scene provides enough  \n      space to breathe, especially during the climactic encounter with the fox.                                    \n 4 Tone & Language:                                                                                                \n    • The tone is playful and suitable for a fairy-tale audience. The language is accessible, though some richer   \n      descriptive elements could enhance the overall atmosphere.                                                   \n 5 Moral/Lesson:                                                                                                   \n    • The ending carries the traditional moral of caution against naivety. Consider if there are other themes you  \n      wish to explore or highlight within the story.                                                               \n\n                                              Illustration Feedback:                                               \n\n 1 Illustration 1: A Rustic Kitchen Scene                                                                          \n    • The visual captures the essence of a cozy, magical kitchen well. Adding small whimsical elements that hint at\n      the gingerbread man’s impending animation might spark more curiosity.                                        \n 2 Illustration 2: A Frolic Through the Meadow                                                                     \n    • The vibrant colors and dynamic composition effectively convey the chase scene. Make sure the sense of speed  \n      and energy of the Gingerbread Man is accentuated, possibly with more expressive motion lines or postures.    \n 3 Illustration 3: A Bridge Over a Sparkling River                                                                 \n    • The river and reflection are beautifully rendered. The fox, however, could benefit from a more cunning       \n      appearance, with sharper features that emphasize its sly nature.                                             \n\n                                                    Conclusion:                                                    \n\nOverall, the draft is well-structured, and the illustrations complement the story effectively. With slight         \nenhancements in the narrative's depth and character detail, along with minor adjustments to the illustrations, the \nproject will meet the user's requirements admirably.                                                               \n\nPlease make the suggested revisions, and once those are implemented, the story should be ready for approval. Let me\nknow if you have any questions or need further guidance!",
      "language": "sql"
    },
    {
      "code": "Illustrator:",
      "language": "yaml"
    },
    {
      "code": "{\n    'character_appearence': 'An elderly woman with flour-dusted hands shaping gingerbread dough. Sunlight casts a \ngolden hue in the cozy kitchen, with rustic decorations and trinkets on shelves.',\n    'style_attributes': 'Photo-realistic with warm and golden hues.',\n    'worn_and_carried': 'The woman wears a flour-covered apron and a gentle smile.',\n    'scenario': 'An old woman baking gingerbread in a warm, rustic cottage kitchen.'\n}",
      "language": "json"
    },
    {
      "code": "{\n    'character_appearence': 'A gingerbread man with bright bead-like eyes and a wide smile, running joyfully.',\n    'style_attributes': 'Photo-realistic with vibrant and lively colors.',\n    'worn_and_carried': 'The gingerbread man has white icing features and a cheeky appearance.',\n    'scenario': 'The gingerbread man running through a colorful meadow, followed by an old woman, cow, and horse.'\n}",
      "language": "json"
    },
    {
      "code": "{\n    'character_appearence': 'A sly fox with cunning eyes, engaging with the gingerbread man.',\n    'style_attributes': 'Photo-realistic with a focus on sly and clever features.',\n    'worn_and_carried': 'The fox has sharp features and a lolled tail.',\n    'scenario': 'The gingerbread man on a wooden bridge, facing a sly fox by a sparkling river under sunlight.'\n}",
      "language": "json"
    },
    {
      "code": "Certainly! Here’s the final version of the short story with the enhanced illustrations for \"The Escape of the      \nGingerbread Man.\"                                                                                                  \n\nTitle: The Escape of the Gingerbread Man                                                                           \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nIllustration 1: A Rustic Kitchen Scene In a quaint little cottage at the edge of an enchanted forest, an elderly   \nwoman, with flour-dusted hands, carefully shapes gingerbread dough on a wooden counter. The aroma of ginger,       \ncinnamon, and cloves wafts through the air as a warm breeze from the open window dances with fluttering curtains.  \nThe sunlight gently permeates the cozy kitchen, casting a golden hue over the flour-dusted surfaces and the rolling\npin. Heartfelt trinkets and rustic decorations adorn the shelves—a sign of a lived-in, lovingly nurtured home.     \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nStory:                                                                                                             \n\nOnce there was an old woman who lived alone in a charming cottage, her days filled with the joyful art of baking.  \nOne sunny afternoon, she decided to make a special gingerbread man to keep her company. As she shaped him tenderly \nand placed him in the oven, she couldn't help but smile at the delight he might bring.                             \n\nBut to her astonishment, once she opened the oven door to check on her creation, the gingerbread man leapt out,    \nsuddenly alive. His eyes were bright as beads, and his smile cheeky and wide. \"Run, run, as fast as you can! You   \ncan't catch me, I'm the Gingerbread Man!\" he laughed, darting towards the door.                                    \n\nThe old woman, chuckling at the unexpected mischief, gave chase, but her footsteps were slow with the weight of    \nage. The Gingerbread Man raced out of the door and into the sunny afternoon.                                       \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nIllustration 2: A Frolic Through the Meadow The Gingerbread Man darts through a vibrant meadow, his arms swinging  \njoyously by his sides. Behind him trails the old woman, her apron flapping in the wind as she gently tries to catch\nup. Wildflowers of every color bloom vividly under the radiant sky, painting the scene with shades of nature's     \nbrilliance. Birds flit through the sky and a stream babbles nearby, oblivious to the chase taking place below.     \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nContinuing his sprint, the Gingerbread Man encountered a cow grazing peacefully. Intrigued, the cow trotted        \nforward. \"Stop, Gingerbread Man! I wish to eat you!\" she called, but the Gingerbread Man only twirled in a teasing \njig, flashing his icing smile before darting off again.                                                            \n\n\"Run, run, as fast as you can! You can't catch me, I'm the Gingerbread Man!\" he taunted, leaving the cow in his    \nspicy wake.                                                                                                        \n\nAs he zoomed across the meadow, he spied a cautious horse in a nearby paddock, who neighed, \"Oh! You look          \ndelicious! I want to eat you!\" But the Gingerbread Man only laughed, his feet barely touching the earth. The horse \njoined the trail, hooves pounding, but even he couldn't match the Gingerbread Man's pace.                          \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nIllustration 3: A Bridge Over a Sparkling River Arriving at a wooden bridge across a shimmering river, the         \nGingerbread Man pauses momentarily, his silhouette against the glistening water. Sunlight sparkles off the water's \nsoft ripples casting reflections that dance like small constellations. A sly fox emerges from the shadows of a     \nblooming willow on the riverbank, his eyes alight with cunning and curiosity.                                      \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nThe Gingerbread Man bounded onto the bridge and skirted past a sly, watching fox. \"Foolish Gingerbread Man,\" the   \nfox mused aloud, \"you might have outrun them all, but you can't possibly swim across that river.\"                  \n\nPausing, the Gingerbread Man considered this dilemma. But the fox, oh so clever, offered a dangerous solution.     \n\"Climb on my back, and I'll carry you across safely,\" he suggested with a sly smile.                               \n\nGingerbread thought himself smarter than that but hesitated, fearing the water or being pursued by the tired,      \nhungry crowd now gathering. \"Promise you won't eat me?\" he ventured.                                               \n\n\"Of course,\" the fox reassured, a gleam in his eyes that the others pondered from a distance.                      \n\nAs they crossed the river, the gingerbread man confident on his ride, the old woman, cow, and horse hoped for his  \nsafety. Yet, nearing the middle, the crafty fox tilted his chin and swiftly snapped, swallowing the gingerbread man\nwhole.                                                                                                             \n\nBewildered but awed by the clever twist they had witnessed, the old woman hung her head while the cow and horse    \nambled away, pondering the fate of the boisterous Gingerbread Man.                                                 \n\nThe fox, licking his lips, ambled along the river, savoring his victory, leaving an air of mystery hovering above  \nthe shimmering waters, where the memory of the Gingerbread Man's spirited run lingered long after.                 \n\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nI hope you enjoy the enhanced version of the tale!",
      "language": "sql"
    },
    {
      "code": "User:                                                       \n\napprove",
      "language": "yaml"
    }
  ],
  "patterns": [],
  "links": [
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/group-chat.html",
    "https://microsoft.github.io/autogen/stable/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/extensions-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/autogenstudio-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/reference/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/installation.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/quickstart.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-and-multi-agent-application.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/architecture.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/application-stack.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-identity-and-lifecycle.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/topic-and-subscription.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/agent-and-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/message-and-communication.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/logging.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/telemetry.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/distributed-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/component-config.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-clients.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-context.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/tools.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/workbench.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/command-line-code-executors.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/intro.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/concurrent-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/sequential-workflow.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/handoffs.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/mixture-of-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/multi-agent-debate.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/reflection.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/code-execution-groupchat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/azure-openai-with-aad-auth.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/termination-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/tool-use-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/extracting-results-with-an-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/openai-assistant-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/langgraph-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llamaindex-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/local-llms-ollama-litellm.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/instrumenting.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/topic-subscription-scenarios.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/structured-output-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llm-usage-logger.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/faqs.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.tools.html"
  ]
}