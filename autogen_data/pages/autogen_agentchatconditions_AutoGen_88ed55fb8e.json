{
  "url": "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.conditions.html",
  "title": "autogen_agentchat.conditions — AutoGen",
  "content": "This module provides various termination conditions for controlling the behavior of multi-agent teams.\n\nBases: TerminationCondition, Component[MaxMessageTerminationConfig]\n\nTerminate the conversation after a maximum number of messages have been exchanged.\n\nmax_messages – The maximum number of messages allowed in the conversation.\n\ninclude_agent_event – If True, include BaseAgentEvent in the message count. Otherwise, only include BaseChatMessage. Defaults to False.\n\nalias of MaxMessageTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[TextMentionTerminationConfig]\n\nTerminate the conversation if a specific text is mentioned.\n\ntext – The text to look for in the messages.\n\nsources – Check only messages of the specified agents for the text to look for.\n\nalias of TextMentionTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[StopMessageTerminationConfig]\n\nTerminate the conversation if a StopMessage is received.\n\nalias of StopMessageTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[TokenUsageTerminationConfig]\n\nTerminate the conversation if a token usage limit is reached.\n\nmax_total_token – The maximum total number of tokens allowed in the conversation.\n\nmax_prompt_token – The maximum number of prompt tokens allowed in the conversation.\n\nmax_completion_token – The maximum number of completion tokens allowed in the conversation.\n\nValueError – If none of max_total_token, max_prompt_token, or max_completion_token is provided.\n\nalias of TokenUsageTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[HandoffTerminationConfig]\n\nTerminate the conversation if a HandoffMessage with the given target is received.\n\ntarget (str) – The target of the handoff message.\n\nalias of HandoffTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[TimeoutTerminationConfig]\n\nTerminate the conversation after a specified duration has passed.\n\ntimeout_seconds – The maximum duration in seconds before terminating the conversation.\n\nalias of TimeoutTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[ExternalTerminationConfig]\n\nA termination condition that is externally controlled by calling the set() method.\n\nalias of ExternalTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nSet the termination condition to terminated.\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[SourceMatchTerminationConfig]\n\nTerminate the conversation after a specific source responds.\n\nsources (List[str]) – List of source names to terminate the conversation.\n\nTerminatedException – If the termination condition has already been reached.\n\nalias of SourceMatchTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[TextMessageTerminationConfig]\n\nTerminate the conversation if a TextMessage is received.\n\nThis termination condition checks for TextMessage instances in the message sequence. When a TextMessage is found, it terminates the conversation if either: - No source was specified (terminates on any TextMessage) - The message source matches the specified source\n\nsource (str | None, optional) – The source name to match against incoming messages. If None, matches any source. Defaults to None.\n\nalias of TextMessageTerminationConfig\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition, Component[FunctionCallTerminationConfig]\n\nTerminate the conversation if a FunctionExecutionResult with a specific name was received.\n\nfunction_name (str) – The name of the function to look for in the messages.\n\nTerminatedException – If the termination condition has already been reached.\n\nalias of FunctionCallTerminationConfig\n\nThe schema for the component configuration.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nBases: TerminationCondition\n\nTerminate the conversation if an functional expression is met.\n\nfunc (Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]]) – A function that takes a sequence of messages and returns True if the termination condition is met, False otherwise. The function can be a callable or an async callable.\n\nCheck if the termination condition has been reached\n\nReset the termination condition.\n\nautogen_agentchat.base\n\nautogen_agentchat.messages",
  "headings": [
    {
      "level": "h1",
      "text": "autogen_agentchat.conditions#",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "from autogen_agentchat.conditions import ExternalTermination\n\ntermination = ExternalTermination()\n\n# Run the team in an asyncio task.\n...\n\n# Set the termination condition externally\ntermination.set()",
      "language": "sql"
    },
    {
      "code": "from autogen_agentchat.conditions import ExternalTermination\n\ntermination = ExternalTermination()\n\n# Run the team in an asyncio task.\n...\n\n# Set the termination condition externally\ntermination.set()",
      "language": "sql"
    },
    {
      "code": "import asyncio\nfrom typing import Sequence\n\nfrom autogen_agentchat.conditions import FunctionalTermination\nfrom autogen_agentchat.messages import BaseAgentEvent, BaseChatMessage, StopMessage\n\n\ndef expression(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> bool:\n    # Check if the last message is a stop message\n    return isinstance(messages[-1], StopMessage)\n\n\ntermination = FunctionalTermination(expression)\n\n\nasync def run() -> None:\n    messages = [\n        StopMessage(source=\"agent1\", content=\"Stop\"),\n    ]\n    result = await termination(messages)\n    print(result)\n\n\nasyncio.run(run())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom typing import Sequence\n\nfrom autogen_agentchat.conditions import FunctionalTermination\nfrom autogen_agentchat.messages import BaseAgentEvent, BaseChatMessage, StopMessage\n\n\ndef expression(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> bool:\n    # Check if the last message is a stop message\n    return isinstance(messages[-1], StopMessage)\n\n\ntermination = FunctionalTermination(expression)\n\n\nasync def run() -> None:\n    messages = [\n        StopMessage(source=\"agent1\", content=\"Stop\"),\n    ]\n    result = await termination(messages)\n    print(result)\n\n\nasyncio.run(run())",
      "language": "python"
    },
    {
      "code": "StopMessage(source=\"FunctionalTermination\", content=\"Functional termination condition met\")",
      "language": "unknown"
    },
    {
      "code": "StopMessage(source=\"FunctionalTermination\", content=\"Functional termination condition met\")",
      "language": "unknown"
    }
  ],
  "patterns": [
    {
      "description": "API Reference autogen_agentchat.conditions autogen_agentchat.conditions# This module provides various termination conditions for controlling the behavior of multi-agent teams. class MaxMessageTermination(max_messages: int, include_agent_event: bool = False)[source]# Bases: TerminationCondition, Component[MaxMessageTerminationConfig] Terminate the conversation after a maximum number of messages have been exchanged. Parameters: max_messages – The maximum number of messages allowed in the conversation. include_agent_event – If True, include BaseAgentEvent in the message count. Otherwise, only include BaseChatMessage. Defaults to False. component_config_schema# alias of MaxMessageTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.MaxMessageTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → MaxMessageTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: MaxMessageTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class TextMentionTermination(text: str, sources: Sequence[str] | None = None)[source]# Bases: TerminationCondition, Component[TextMentionTerminationConfig] Terminate the conversation if a specific text is mentioned. Parameters: text – The text to look for in the messages. sources – Check only messages of the specified agents for the text to look for. component_config_schema# alias of TextMentionTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TextMentionTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → TextMentionTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: TextMentionTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class StopMessageTermination[source]# Bases: TerminationCondition, Component[StopMessageTerminationConfig] Terminate the conversation if a StopMessage is received. component_config_schema# alias of StopMessageTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.StopMessageTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → StopMessageTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: StopMessageTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class TokenUsageTermination(max_total_token: int | None = None, max_prompt_token: int | None = None, max_completion_token: int | None = None)[source]# Bases: TerminationCondition, Component[TokenUsageTerminationConfig] Terminate the conversation if a token usage limit is reached. Parameters: max_total_token – The maximum total number of tokens allowed in the conversation. max_prompt_token – The maximum number of prompt tokens allowed in the conversation. max_completion_token – The maximum number of completion tokens allowed in the conversation. Raises: ValueError – If none of max_total_token, max_prompt_token, or max_completion_token is provided. component_config_schema# alias of TokenUsageTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TokenUsageTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → TokenUsageTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: TokenUsageTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class HandoffTermination(target: str)[source]# Bases: TerminationCondition, Component[HandoffTerminationConfig] Terminate the conversation if a HandoffMessage with the given target is received. Parameters: target (str) – The target of the handoff message. component_config_schema# alias of HandoffTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.HandoffTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → HandoffTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: HandoffTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class TimeoutTermination(timeout_seconds: float)[source]# Bases: TerminationCondition, Component[TimeoutTerminationConfig] Terminate the conversation after a specified duration has passed. Parameters: timeout_seconds – The maximum duration in seconds before terminating the conversation. component_config_schema# alias of TimeoutTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TimeoutTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → TimeoutTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: TimeoutTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class ExternalTermination[source]# Bases: TerminationCondition, Component[ExternalTerminationConfig] A termination condition that is externally controlled by calling the set() method. Example: from autogen_agentchat.conditions import ExternalTermination termination = ExternalTermination() # Run the team in an asyncio task. ... # Set the termination condition externally termination.set() component_config_schema# alias of ExternalTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.ExternalTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached set() → None[source]# Set the termination condition to terminated. async reset() → None[source]# Reset the termination condition. _to_config() → ExternalTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: ExternalTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class SourceMatchTermination(sources: List[str])[source]# Bases: TerminationCondition, Component[SourceMatchTerminationConfig] Terminate the conversation after a specific source responds. Parameters: sources (List[str]) – List of source names to terminate the conversation. Raises: TerminatedException – If the termination condition has already been reached. component_config_schema# alias of SourceMatchTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.SourceMatchTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → SourceMatchTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: SourceMatchTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class TextMessageTermination(source: str | None = None)[source]# Bases: TerminationCondition, Component[TextMessageTerminationConfig] Terminate the conversation if a TextMessage is received. This termination condition checks for TextMessage instances in the message sequence. When a TextMessage is found, it terminates the conversation if either: - No source was specified (terminates on any TextMessage) - The message source matches the specified source Parameters: source (str | None, optional) – The source name to match against incoming messages. If None, matches any source. Defaults to None. component_config_schema# alias of TextMessageTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TextMessageTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → TextMessageTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: TextMessageTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class FunctionCallTermination(function_name: str)[source]# Bases: TerminationCondition, Component[FunctionCallTerminationConfig] Terminate the conversation if a FunctionExecutionResult with a specific name was received. Parameters: function_name (str) – The name of the function to look for in the messages. Raises: TerminatedException – If the termination condition has already been reached. component_config_schema# alias of FunctionCallTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.FunctionCallTermination'# The schema for the component configuration. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → FunctionCallTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: FunctionCallTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class FunctionalTermination(func: Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]])[source]# Bases: TerminationCondition Terminate the conversation if an functional expression is met. Parameters: func (Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]]) – A function that takes a sequence of messages and returns True if the termination condition is met, False otherwise. The function can be a callable or an async callable. Example import asyncio from typing import Sequence from autogen_agentchat.conditions import FunctionalTermination from autogen_agentchat.messages import BaseAgentEvent, BaseChatMessage, StopMessage def expression(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> bool: # Check if the last message is a stop message return isinstance(messages[-1], StopMessage) termination = FunctionalTermination(expression) async def run() -> None: messages = [ StopMessage(source=\"agent1\", content=\"Stop\"), ] result = await termination(messages) print(result) asyncio.run(run()) StopMessage(source=\"FunctionalTermination\", content=\"Functional termination condition met\") property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. previous autogen_agentchat.base next autogen_agentchat.messages On this page MaxMessageTermination MaxMessageTermination.component_config_schema MaxMessageTermination.component_provider_override MaxMessageTermination.terminated MaxMessageTermination.reset() MaxMessageTermination._to_config() MaxMessageTermination._from_config() TextMentionTermination TextMentionTermination.component_config_schema TextMentionTermination.component_provider_override TextMentionTermination.terminated TextMentionTermination.reset() TextMentionTermination._to_config() TextMentionTermination._from_config() StopMessageTermination StopMessageTermination.component_config_schema StopMessageTermination.component_provider_override StopMessageTermination.terminated StopMessageTermination.reset() StopMessageTermination._to_config() StopMessageTermination._from_config() TokenUsageTermination TokenUsageTermination.component_config_schema TokenUsageTermination.component_provider_override TokenUsageTermination.terminated TokenUsageTermination.reset() TokenUsageTermination._to_config() TokenUsageTermination._from_config() HandoffTermination HandoffTermination.component_config_schema HandoffTermination.component_provider_override HandoffTermination.terminated HandoffTermination.reset() HandoffTermination._to_config() HandoffTermination._from_config() TimeoutTermination TimeoutTermination.component_config_schema TimeoutTermination.component_provider_override TimeoutTermination.terminated TimeoutTermination.reset() TimeoutTermination._to_config() TimeoutTermination._from_config() ExternalTermination ExternalTermination.component_config_schema ExternalTermination.component_provider_override ExternalTermination.terminated ExternalTermination.set() ExternalTermination.reset() ExternalTermination._to_config() ExternalTermination._from_config() SourceMatchTermination SourceMatchTermination.component_config_schema SourceMatchTermination.component_provider_override SourceMatchTermination.terminated SourceMatchTermination.reset() SourceMatchTermination._to_config() SourceMatchTermination._from_config() TextMessageTermination TextMessageTermination.component_config_schema TextMessageTermination.component_provider_override TextMessageTermination.terminated TextMessageTermination.reset() TextMessageTermination._to_config() TextMessageTermination._from_config() FunctionCallTermination FunctionCallTermination.component_config_schema FunctionCallTermination.component_provider_override FunctionCallTermination.terminated FunctionCallTermination.reset() FunctionCallTermination._to_config() FunctionCallTermination._from_config() FunctionalTermination FunctionalTermination.terminated FunctionalTermination.reset() Edit on GitHub Show Source",
      "code": "TerminationCondition"
    },
    {
      "description": "API Reference autogen_agentchat.conditions autogen_agentchat.conditions# This module provides various termination conditions for controlling the behavior of multi-agent teams. class MaxMessageTermination(max_messages: int, include_agent_event: bool = False)[source]# Bases: TerminationCondition, Component[MaxMessageTerminationConfig] Terminate the conversation after a maximum number of messages have been exchanged. Parameters: max_messages – The maximum number of messages allowed in the conversation. include_agent_event – If True, include BaseAgentEvent in the message count. Otherwise, only include BaseChatMessage. Defaults to False. component_config_schema# alias of MaxMessageTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.MaxMessageTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → MaxMessageTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: MaxMessageTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class TextMentionTermination(text: str, sources: Sequence[str] | None = None)[source]# Bases: TerminationCondition, Component[TextMentionTerminationConfig] Terminate the conversation if a specific text is mentioned. Parameters: text – The text to look for in the messages. sources – Check only messages of the specified agents for the text to look for. component_config_schema# alias of TextMentionTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TextMentionTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → TextMentionTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: TextMentionTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class StopMessageTermination[source]# Bases: TerminationCondition, Component[StopMessageTerminationConfig] Terminate the conversation if a StopMessage is received. component_config_schema# alias of StopMessageTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.StopMessageTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → StopMessageTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: StopMessageTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class TokenUsageTermination(max_total_token: int | None = None, max_prompt_token: int | None = None, max_completion_token: int | None = None)[source]# Bases: TerminationCondition, Component[TokenUsageTerminationConfig] Terminate the conversation if a token usage limit is reached. Parameters: max_total_token – The maximum total number of tokens allowed in the conversation. max_prompt_token – The maximum number of prompt tokens allowed in the conversation. max_completion_token – The maximum number of completion tokens allowed in the conversation. Raises: ValueError – If none of max_total_token, max_prompt_token, or max_completion_token is provided. component_config_schema# alias of TokenUsageTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TokenUsageTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → TokenUsageTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: TokenUsageTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class HandoffTermination(target: str)[source]# Bases: TerminationCondition, Component[HandoffTerminationConfig] Terminate the conversation if a HandoffMessage with the given target is received. Parameters: target (str) – The target of the handoff message. component_config_schema# alias of HandoffTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.HandoffTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → HandoffTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: HandoffTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class TimeoutTermination(timeout_seconds: float)[source]# Bases: TerminationCondition, Component[TimeoutTerminationConfig] Terminate the conversation after a specified duration has passed. Parameters: timeout_seconds – The maximum duration in seconds before terminating the conversation. component_config_schema# alias of TimeoutTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TimeoutTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → TimeoutTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: TimeoutTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class ExternalTermination[source]# Bases: TerminationCondition, Component[ExternalTerminationConfig] A termination condition that is externally controlled by calling the set() method. Example: from autogen_agentchat.conditions import ExternalTermination termination = ExternalTermination() # Run the team in an asyncio task. ... # Set the termination condition externally termination.set() component_config_schema# alias of ExternalTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.ExternalTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached set() → None[source]# Set the termination condition to terminated. async reset() → None[source]# Reset the termination condition. _to_config() → ExternalTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: ExternalTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class SourceMatchTermination(sources: List[str])[source]# Bases: TerminationCondition, Component[SourceMatchTerminationConfig] Terminate the conversation after a specific source responds. Parameters: sources (List[str]) – List of source names to terminate the conversation. Raises: TerminatedException – If the termination condition has already been reached. component_config_schema# alias of SourceMatchTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.SourceMatchTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → SourceMatchTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: SourceMatchTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class TextMessageTermination(source: str | None = None)[source]# Bases: TerminationCondition, Component[TextMessageTerminationConfig] Terminate the conversation if a TextMessage is received. This termination condition checks for TextMessage instances in the message sequence. When a TextMessage is found, it terminates the conversation if either: - No source was specified (terminates on any TextMessage) - The message source matches the specified source Parameters: source (str | None, optional) – The source name to match against incoming messages. If None, matches any source. Defaults to None. component_config_schema# alias of TextMessageTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TextMessageTermination'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → TextMessageTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: TextMessageTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class FunctionCallTermination(function_name: str)[source]# Bases: TerminationCondition, Component[FunctionCallTerminationConfig] Terminate the conversation if a FunctionExecutionResult with a specific name was received. Parameters: function_name (str) – The name of the function to look for in the messages. Raises: TerminatedException – If the termination condition has already been reached. component_config_schema# alias of FunctionCallTerminationConfig component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.FunctionCallTermination'# The schema for the component configuration. property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. _to_config() → FunctionCallTerminationConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: FunctionCallTerminationConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class FunctionalTermination(func: Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]])[source]# Bases: TerminationCondition Terminate the conversation if an functional expression is met. Parameters: func (Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]]) – A function that takes a sequence of messages and returns True if the termination condition is met, False otherwise. The function can be a callable or an async callable. Example import asyncio from typing import Sequence from autogen_agentchat.conditions import FunctionalTermination from autogen_agentchat.messages import BaseAgentEvent, BaseChatMessage, StopMessage def expression(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> bool: # Check if the last message is a stop message return isinstance(messages[-1], StopMessage) termination = FunctionalTermination(expression) async def run() -> None: messages = [ StopMessage(source=\"agent1\", content=\"Stop\"), ] result = await termination(messages) print(result) asyncio.run(run()) StopMessage(source=\"FunctionalTermination\", content=\"Functional termination condition met\") property terminated: bool# Check if the termination condition has been reached async reset() → None[source]# Reset the termination condition. previous autogen_agentchat.base next autogen_agentchat.messages",
      "code": "TerminationCondition"
    },
    {
      "description": "Example:",
      "code": "from autogen_agentchat.conditions import ExternalTermination\n\ntermination = ExternalTermination()\n\n# Run the team in an asyncio task.\n...\n\n# Set the termination condition externally\ntermination.set()"
    }
  ],
  "links": [
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.conditions.html",
    "https://microsoft.github.io/autogen/stable/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/extensions-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/autogenstudio-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/reference/index.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.agents.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.base.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.messages.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.state.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.teams.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.tools.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.ui.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.utils.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.code_executor.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.exceptions.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.logging.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.memory.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.model_context.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.models.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.tool_agent.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.tools.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.utils.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.cache_store.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.experimental.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.teams.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.ui.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.file_surfer.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.magentic_one.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.openai.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.video_surfer.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.web_surfer.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.auth.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.cache_store.diskcache.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.cache_store.redis.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.docker.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.docker_jupyter.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.jupyter.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.local.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.experimental.task_centric_memory.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.canvas.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.chromadb.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.mem0.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.redis.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.anthropic.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.cache.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.llama_cpp.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.ollama.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.openai.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.replay.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.semantic_kernel.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.teams.magentic_one.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.code_execution.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.graphrag.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.http.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.langchain.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.mcp.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.semantic_kernel.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.video_surfer.tools.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.web_surfer.playwright_controller.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.experimental.task_centric_memory.utils.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.anthropic.config.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.azure.config.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.ollama.config.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.openai.config.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.agent_worker_pb2.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.agent_worker_pb2_grpc.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.cloudevent_pb2.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.cloudevent_pb2_grpc.html"
  ]
}