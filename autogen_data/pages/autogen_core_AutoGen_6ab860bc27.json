{
  "url": "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html",
  "title": "autogen_core — AutoGen",
  "content": "Metadata of the agent.\n\nFunction used to bind an Agent instance to an AgentRuntime.\n\nagent_id (AgentId) – ID of the agent.\n\nruntime (AgentRuntime) – AgentRuntime instance to bind the agent to.\n\nMessage handler for the agent. This should only be called by the runtime, not by other agents.\n\nmessage (Any) – Received message. Type is one of the types in subscriptions.\n\nctx (MessageContext) – Context of the message.\n\nAny – Response to the message. Can be None.\n\nCancelledError – If the message was cancelled.\n\nCantHandleException – If the agent cannot handle the message.\n\nSave the state of the agent. The result must be JSON serializable.\n\nLoad in the state of the agent obtained from save_state.\n\nstate (Mapping[str, Any]) – State of the agent. Must be JSON serializable.\n\nCalled when the runtime is closed\n\nAgent ID uniquely identifies an agent instance within an agent runtime - including distributed runtime. It is the ‘address’ of the agent instance for receiving messages.\n\nSee here for more information: Agent Identity and Lifecycle\n\nConvert a string of the format type/key into an AgentId\n\nAn identifier that associates an agent with a specific factory function.\n\nStrings may only be composed of alphanumeric letters (a-z) and (0-9), or underscores (_).\n\nAgent instance identifier.\n\nStrings may only be composed of alphanumeric letters (a-z) and (0-9), or underscores (_).\n\nA helper class that allows you to use an AgentId in place of its associated Agent\n\nTarget agent for this proxy\n\nMetadata of the agent.\n\nSave the state of the agent. The result must be JSON serializable.\n\nLoad in the state of the agent obtained from save_state.\n\nstate (Mapping[str, Any]) – State of the agent. Must be JSON serializable.\n\nSend a message to an agent and get a response.\n\nmessage (Any) – The message to send.\n\nrecipient (AgentId) – The agent to send the message to.\n\nsender (AgentId | None, optional) – Agent which sent the message. Should only be None if this was sent from no agent, such as directly to the runtime externally. Defaults to None.\n\ncancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress . Defaults to None.\n\nCantHandleException – If the recipient cannot handle the message.\n\nUndeliverableException – If the message cannot be delivered.\n\nOther – Any other exception raised by the recipient.\n\nAny – The response from the agent.\n\nPublish a message to all agents in the given namespace, or if no namespace is provided, the namespace of the sender.\n\nNo responses are expected from publishing.\n\nmessage (Any) – The message to publish.\n\ntopic_id (TopicId) – The topic to publish the message to.\n\nsender (AgentId | None, optional) – The agent which sent the message. Defaults to None.\n\ncancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress. Defaults to None.\n\nmessage_id (str | None, optional) – The message id. If None, a new message id will be generated. Defaults to None. This message id must be unique. and is recommended to be a UUID.\n\nUndeliverableException – If the message cannot be delivered.\n\nRegister an agent factory with the runtime associated with a specific type. The type must be unique. This API does not add any subscriptions.\n\nThis is a low level API and usually the agent class’s register method should be used instead, as this also handles subscriptions automatically.\n\ntype (str) – The type of agent this factory creates. It is not the same as agent class name. The type parameter is used to differentiate between different factory functions rather than agent classes.\n\nagent_factory (Callable[[], T]) – The factory that creates the agent, where T is a concrete Agent type. Inside the factory, use autogen_core.AgentInstantiationContext to access variables like the current runtime and agent ID.\n\nexpected_class (type[T] | None, optional) – The expected class of the agent, used for runtime validation of the factory. Defaults to None. If None, no validation is performed.\n\nRegister an agent instance with the runtime. The type may be reused, but each agent_id must be unique. All agent instances within a type must be of the same object type. This API does not add any subscriptions.\n\nThis is a low level API and usually the agent class’s register_instance method should be used instead, as this also handles subscriptions automatically.\n\nagent_instance (Agent) – A concrete instance of the agent.\n\nagent_id (AgentId) – The agent’s identifier. The agent’s type is agent_id.type.\n\nTry to get the underlying agent instance by name and namespace. This is generally discouraged (hence the long name), but can be useful in some cases.\n\nIf the underlying agent is not accessible, this will raise an exception.\n\nid (AgentId) – The agent id.\n\ntype (Type[T], optional) – The expected type of the agent. Defaults to Agent.\n\nT – The concrete agent instance.\n\nLookupError – If the agent is not found.\n\nNotAccessibleError – If the agent is not accessible, for example if it is located remotely.\n\nTypeError – If the agent is not of the expected type.\n\nSave the state of the entire runtime, including all hosted agents. The only way to restore the state is to pass it to load_state().\n\nThe structure of the state is implementation defined and can be any JSON serializable object.\n\nMapping[str, Any] – The saved state.\n\nLoad the state of the entire runtime, including all hosted agents. The state should be the same as the one returned by save_state().\n\nstate (Mapping[str, Any]) – The saved state.\n\nGet the metadata for an agent.\n\nagent (AgentId) – The agent id.\n\nAgentMetadata – The agent metadata.\n\nSave the state of a single agent.\n\nThe structure of the state is implementation defined and can be any JSON serializable object.\n\nagent (AgentId) – The agent id.\n\nMapping[str, Any] – The saved state.\n\nLoad the state of a single agent.\n\nagent (AgentId) – The agent id.\n\nstate (Mapping[str, Any]) – The saved state.\n\nAdd a new subscription that the runtime should fulfill when processing published messages\n\nsubscription (Subscription) – The subscription to add\n\nRemove a subscription from the runtime\n\nid (str) – id of the subscription to remove\n\nLookupError – If the subscription does not exist\n\nAdd a new message serialization serializer to the runtime\n\nNote: This will deduplicate serializers based on the type_name and data_content_type properties\n\nserializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – The serializer/s to add\n\nMetadata of the agent.\n\nFunction used to bind an Agent instance to an AgentRuntime.\n\nagent_id (AgentId) – ID of the agent.\n\nruntime (AgentRuntime) – AgentRuntime instance to bind the agent to.\n\nMessage handler for the agent. This should only be called by the runtime, not by other agents.\n\nmessage (Any) – Received message. Type is one of the types in subscriptions.\n\nctx (MessageContext) – Context of the message.\n\nAny – Response to the message. Can be None.\n\nCancelledError – If the message was cancelled.\n\nCantHandleException – If the agent cannot handle the message.\n\nSee autogen_core.AgentRuntime.send_message() for more information.\n\nSave the state of the agent. The result must be JSON serializable.\n\nLoad in the state of the agent obtained from save_state.\n\nstate (Mapping[str, Any]) – State of the agent. Must be JSON serializable.\n\nCalled when the runtime is closed\n\nThis function is similar to register but is used for registering an instance of an agent. A subscription based on the agent ID is created and added to the runtime.\n\nRegister a virtual subclass of an ABC.\n\nReturns the subclass, to allow usage as a class decorator.\n\nBases: ABC, Generic[T], ComponentBase[BaseModel]\n\nThis protocol defines the basic interface for store/cache operations.\n\nSub-classes should handle the lifecycle of underlying storage.\n\nThe logical type of the component.\n\nRetrieve an item from the store.\n\nkey – The key identifying the item in the store.\n\ndefault (optional) – The default value to return if the key is not found. Defaults to None.\n\nThe value associated with the key if found, else the default value.\n\nSet an item in the store.\n\nkey – The key under which the item is to be stored.\n\nvalue – The value to be stored in the store.\n\nBases: CacheStore[T], Component[InMemoryStoreConfig]\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nalias of InMemoryStoreConfig\n\nRetrieve an item from the store.\n\nkey – The key identifying the item in the store.\n\ndefault (optional) – The default value to return if the key is not found. Defaults to None.\n\nThe value associated with the key if found, else the default value.\n\nSet an item in the store.\n\nkey – The key under which the item is to be stored.\n\nvalue – The value to be stored in the store.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nA token used to cancel pending async calls\n\nCancel pending async calls linked to this cancellation token.\n\nCheck if the CancellationToken has been used\n\nAttach a callback that will be called when cancel is invoked\n\nLink a pending async call to a token to allow its cancellation\n\nA static class that provides context for agent instantiation.\n\nThis static class can be used to access the current runtime and agent ID during agent instantiation – inside the factory function or the agent’s class constructor.\n\nGet the current runtime and agent ID inside the factory function and the agent’s constructor:\n\nTopicId defines the scope of a broadcast message. In essence, agent runtime implements a publish-subscribe model through its broadcast API: when publishing a message, the topic must be specified.\n\nSee here for more information: Topic\n\nType of the event that this topic_id contains. Adhere’s to the cloud event spec.\n\nMust match the pattern: ^[w-.:=]+Z\n\nLearn more here: cloudevents/spec\n\nIdentifies the context in which an event happened. Adhere’s to the cloud event spec.\n\nLearn more here: cloudevents/spec\n\nConvert a string of the format type/source into a TopicId\n\nSubscriptions define the topics that an agent is interested in.\n\nGet the ID of the subscription.\n\nImplementations should return a unique ID for the subscription. Usually this is a UUID.\n\nstr – ID of the subscription.\n\nCheck if a given topic_id matches the subscription.\n\ntopic_id (TopicId) – TopicId to check.\n\nbool – True if the topic_id matches the subscription, False otherwise.\n\nMap a topic_id to an agent. Should only be called if is_match returns True for the given topic_id.\n\ntopic_id (TopicId) – TopicId to map.\n\nAgentId – ID of the agent that should handle the topic_id.\n\nCantHandleException – If the subscription cannot handle the topic_id.\n\nString representation of this agent type.\n\nLoading an image from a URL:\n\nA base class for agents that route messages to handlers based on the type of the message and optional matching functions.\n\nTo create a routed agent, subclass this class and add message handlers as methods decorated with either event() or rpc() decorator.\n\nHandle a message by routing it to the appropriate message handler. Do not override this method in subclasses. Instead, add message handlers as methods decorated with either the event() or rpc() decorator.\n\nCalled when a message is received that does not have a matching message handler. The default implementation logs an info message.\n\nBases: BaseAgent, ClosureContext\n\nMetadata of the agent.\n\nClosure agents do not have state. So this method always returns an empty dictionary.\n\nClosure agents do not have state. So this method does nothing.\n\nThe closure agent allows you to define an agent using a closure, or function without needing to define a class. It allows values to be extracted out of the runtime.\n\nThe closure can define the type of message which is expected, or Any can be used to accept any type of message.\n\nruntime (AgentRuntime) – Runtime to register the agent to\n\ntype (str) – Agent type of registered agent\n\nclosure (Callable[[ClosureContext, T, MessageContext], Awaitable[Any]]) – Closure to handle messages\n\nunknown_type_policy (Literal[\"error\", \"warn\", \"ignore\"], optional) – What to do if a type is encountered that does not match the closure type. Defaults to “warn”.\n\nskip_direct_message_subscription (bool, optional) – Do not add direct message subscription for this agent. Defaults to False.\n\ndescription (str, optional) – Description of what agent does. Defaults to “”.\n\nsubscriptions (Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None, optional) – List of subscriptions for this closure agent. Defaults to None.\n\nAgentType – Type of the agent that was registered\n\nDecorator for generic message handlers.\n\nAdd this decorator to methods in a RoutedAgent class that are intended to handle both event and RPC messages. These methods must have a specific signature that needs to be followed for it to be valid:\n\nThe method must be an async method.\n\nThe method must be decorated with the @message_handler decorator.\n\nmessage: The message to be handled, this must be type-hinted with the message type that it is intended to handle.\n\nctx: A autogen_core.MessageContext object.\n\nThe method must be type hinted with what message types it can return as a response, or it can return None if it does not return anything.\n\nHandlers can handle more than one message type by accepting a Union of the message types. It can also return more than one message type by returning a Union of the message types.\n\nfunc – The function to be decorated.\n\nstrict – If True, the handler will raise an exception if the message type or return type is not in the target types. If False, it will log a warning instead.\n\nmatch – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called.\n\nDecorator for event message handlers.\n\nAdd this decorator to methods in a RoutedAgent class that are intended to handle event messages. These methods must have a specific signature that needs to be followed for it to be valid:\n\nThe method must be an async method.\n\nThe method must be decorated with the @message_handler decorator.\n\nmessage: The event message to be handled, this must be type-hinted with the message type that it is intended to handle.\n\nctx: A autogen_core.MessageContext object.\n\nThe method must return None.\n\nHandlers can handle more than one message type by accepting a Union of the message types.\n\nfunc – The function to be decorated.\n\nstrict – If True, the handler will raise an exception if the message type is not in the target types. If False, it will log a warning instead.\n\nmatch – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called.\n\nDecorator for RPC message handlers.\n\nAdd this decorator to methods in a RoutedAgent class that are intended to handle RPC messages. These methods must have a specific signature that needs to be followed for it to be valid:\n\nThe method must be an async method.\n\nThe method must be decorated with the @message_handler decorator.\n\nmessage: The message to be handled, this must be type-hinted with the message type that it is intended to handle.\n\nctx: A autogen_core.MessageContext object.\n\nThe method must be type hinted with what message types it can return as a response, or it can return None if it does not return anything.\n\nHandlers can handle more than one message type by accepting a Union of the message types. It can also return more than one message type by returning a Union of the message types.\n\nfunc – The function to be decorated.\n\nstrict – If True, the handler will raise an exception if the message type or return type is not in the target types. If False, it will log a warning instead.\n\nmatch – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called.\n\nThis subscription matches on topics based on the type and maps to agents using the source of the topic as the agent key.\n\nThis subscription causes each source to have its own agent instance.\n\nA topic_id with type t1 and source s1 will be handled by an agent of type a1 with key s1\n\nA topic_id with type t1 and source s2 will be handled by an agent of type a1 with key s2.\n\ntopic_type (str) – Topic type to match against\n\nagent_type (str) – Agent type to handle this subscription\n\nGet the ID of the subscription.\n\nImplementations should return a unique ID for the subscription. Usually this is a UUID.\n\nstr – ID of the subscription.\n\nCheck if a given topic_id matches the subscription.\n\ntopic_id (TopicId) – TopicId to check.\n\nbool – True if the topic_id matches the subscription, False otherwise.\n\nMap a topic_id to an agent. Should only be called if is_match returns True for the given topic_id.\n\ntopic_id (TopicId) – TopicId to map.\n\nAgentId – ID of the agent that should handle the topic_id.\n\nCantHandleException – If the subscription cannot handle the topic_id.\n\nBases: TypeSubscription\n\nThe default subscription is designed to be a sensible default for applications that only need global scope for agents.\n\nThis topic by default uses the “default” topic type and attempts to detect the agent type to use based on the instantiation context.\n\ntopic_type (str, optional) – The topic type to subscribe to. Defaults to “default”.\n\nagent_type (str, optional) – The agent type to use for the subscription. Defaults to None, in which case it will attempt to detect the agent type based on the instantiation context.\n\nDefaultTopicId provides a sensible default for the topic_id and source fields of a TopicId.\n\nIf created in the context of a message handler, the source will be set to the agent_id of the message handler, otherwise it will be set to “default”.\n\ntype (str, optional) – Topic type to publish message to. Defaults to “default”.\n\nsource (str | None, optional) – Topic source to publish message to. If None, the source will be set to the agent_id of the message handler if in the context of a message handler, otherwise it will be set to “default”. Defaults to None.\n\nThis subscription matches on topics based on a prefix of the type and maps to agents using the source of the topic as the agent key.\n\nThis subscription causes each source to have its own agent instance.\n\nA topic_id with type t1 and source s1 will be handled by an agent of type a1 with key s1\n\nA topic_id with type t1 and source s2 will be handled by an agent of type a1 with key s2.\n\nA topic_id with type t1SUFFIX and source s2 will be handled by an agent of type a1 with key s2.\n\ntopic_type_prefix (str) – Topic type prefix to match against\n\nagent_type (str) – Agent type to handle this subscription\n\nGet the ID of the subscription.\n\nImplementations should return a unique ID for the subscription. Usually this is a UUID.\n\nstr – ID of the subscription.\n\nCheck if a given topic_id matches the subscription.\n\ntopic_id (TopicId) – TopicId to check.\n\nbool – True if the topic_id matches the subscription, False otherwise.\n\nMap a topic_id to an agent. Should only be called if is_match returns True for the given topic_id.\n\ntopic_id (TopicId) – TopicId to map.\n\nAgentId – ID of the agent that should handle the topic_id.\n\nCantHandleException – If the subscription cannot handle the topic_id.\n\nThe content type for JSON data.\n\nThe content type for Protobuf data.\n\nA single-threaded agent runtime that processes all messages using a single asyncio queue. Messages are delivered in the order they are received, and the runtime processes each message in a separate asyncio task concurrently.\n\nThis runtime is suitable for development and standalone applications. It is not suitable for high-throughput or high-concurrency scenarios.\n\nintervention_handlers (List[InterventionHandler], optional) – A list of intervention handlers that can intercept messages before they are sent or published. Defaults to None.\n\ntracer_provider (TracerProvider, optional) – The tracer provider to use for tracing. Defaults to None. Additionally, you can set environment variable AUTOGEN_DISABLE_RUNTIME_TRACING to true to disable the agent runtime telemetry if you don’t have access to the runtime constructor. For example, if you are using ComponentConfig.\n\nignore_unhandled_exceptions (bool, optional) – Whether to ignore unhandled exceptions in that occur in agent event handlers. Any background exceptions will be raised on the next call to process_next or from an awaited stop, stop_when_idle or stop_when. Note, this does not apply to RPC handlers. Defaults to True.\n\nA simple example of creating a runtime, registering an agent, sending a message and stopping the runtime:\n\nAn example of creating a runtime, registering an agent, publishing a message and stopping the runtime:\n\nSend a message to an agent and get a response.\n\nmessage (Any) – The message to send.\n\nrecipient (AgentId) – The agent to send the message to.\n\nsender (AgentId | None, optional) – Agent which sent the message. Should only be None if this was sent from no agent, such as directly to the runtime externally. Defaults to None.\n\ncancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress . Defaults to None.\n\nCantHandleException – If the recipient cannot handle the message.\n\nUndeliverableException – If the message cannot be delivered.\n\nOther – Any other exception raised by the recipient.\n\nAny – The response from the agent.\n\nPublish a message to all agents in the given namespace, or if no namespace is provided, the namespace of the sender.\n\nNo responses are expected from publishing.\n\nmessage (Any) – The message to publish.\n\ntopic_id (TopicId) – The topic to publish the message to.\n\nsender (AgentId | None, optional) – The agent which sent the message. Defaults to None.\n\ncancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress. Defaults to None.\n\nmessage_id (str | None, optional) – The message id. If None, a new message id will be generated. Defaults to None. This message id must be unique. and is recommended to be a UUID.\n\nUndeliverableException – If the message cannot be delivered.\n\nSave the state of all instantiated agents.\n\nThis method calls the save_state() method on each agent and returns a dictionary mapping agent IDs to their state.\n\nThis method does not currently save the subscription state. We will add this in the future.\n\nA dictionary mapping agent IDs to their state.\n\nLoad the state of all instantiated agents.\n\nThis method calls the load_state() method on each agent with the state provided in the dictionary. The keys of the dictionary are the agent IDs, and the values are the state dictionaries returned by the save_state() method.\n\nThis method does not currently load the subscription state. We will add this in the future.\n\nProcess the next message in the queue.\n\nIf there is an unhandled exception in the background task, it will be raised here. process_next cannot be called again after an unhandled exception is raised.\n\nStart the runtime message processing loop. This runs in a background task.\n\nCalls stop() if applicable and the Agent.close() method on all instantiated agents\n\nImmediately stop the runtime message processing loop. The currently processing message will be completed, but all others following it will be discarded.\n\nStop the runtime message processing loop when there is no outstanding message being processed or queued. This is the most common way to stop the runtime.\n\nStop the runtime message processing loop when the condition is met.\n\nThis method is not recommended to be used, and is here for legacy reasons. It will spawn a busy loop to continually check the condition. It is much more efficient to call stop_when_idle or stop instead. If you need to stop the runtime based on a condition, consider using a background task and asyncio.Event to signal when the condition is met and the background task should call stop.\n\nGet the metadata for an agent.\n\nagent (AgentId) – The agent id.\n\nAgentMetadata – The agent metadata.\n\nSave the state of a single agent.\n\nThe structure of the state is implementation defined and can be any JSON serializable object.\n\nagent (AgentId) – The agent id.\n\nMapping[str, Any] – The saved state.\n\nLoad the state of a single agent.\n\nagent (AgentId) – The agent id.\n\nstate (Mapping[str, Any]) – The saved state.\n\nRegister an agent factory with the runtime associated with a specific type. The type must be unique. This API does not add any subscriptions.\n\nThis is a low level API and usually the agent class’s register method should be used instead, as this also handles subscriptions automatically.\n\ntype (str) – The type of agent this factory creates. It is not the same as agent class name. The type parameter is used to differentiate between different factory functions rather than agent classes.\n\nagent_factory (Callable[[], T]) – The factory that creates the agent, where T is a concrete Agent type. Inside the factory, use autogen_core.AgentInstantiationContext to access variables like the current runtime and agent ID.\n\nexpected_class (type[T] | None, optional) – The expected class of the agent, used for runtime validation of the factory. Defaults to None. If None, no validation is performed.\n\nRegister an agent instance with the runtime. The type may be reused, but each agent_id must be unique. All agent instances within a type must be of the same object type. This API does not add any subscriptions.\n\nThis is a low level API and usually the agent class’s register_instance method should be used instead, as this also handles subscriptions automatically.\n\nagent_instance (Agent) – A concrete instance of the agent.\n\nagent_id (AgentId) – The agent’s identifier. The agent’s type is agent_id.type.\n\nTry to get the underlying agent instance by name and namespace. This is generally discouraged (hence the long name), but can be useful in some cases.\n\nIf the underlying agent is not accessible, this will raise an exception.\n\nid (AgentId) – The agent id.\n\ntype (Type[T], optional) – The expected type of the agent. Defaults to Agent.\n\nT – The concrete agent instance.\n\nLookupError – If the agent is not found.\n\nNotAccessibleError – If the agent is not accessible, for example if it is located remotely.\n\nTypeError – If the agent is not of the expected type.\n\nAdd a new subscription that the runtime should fulfill when processing published messages\n\nsubscription (Subscription) – The subscription to add\n\nRemove a subscription from the runtime\n\nid (str) – id of the subscription to remove\n\nLookupError – If the subscription does not exist\n\nAdd a new message serialization serializer to the runtime\n\nNote: This will deduplicate serializers based on the type_name and data_content_type properties\n\nserializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – The serializer/s to add\n\nThe name of the root logger.\n\nThe name of the logger used for structured events.\n\nLogger name used for developer intended trace logging. The content and format of this log should not be depended upon.\n\nBases: ComponentFromConfig[ConfigT], ComponentSchemaType[ConfigT], Generic[ConfigT]\n\nTo create a component class, inherit from this class for the concrete class and ComponentBase on the interface. Then implement two class variables:\n\ncomponent_config_schema - A Pydantic model class which represents the configuration of the component. This is also the type parameter of Component.\n\ncomponent_type - What is the logical type of the component.\n\nBases: ComponentToConfig[ConfigT], ComponentLoader, Generic[ConfigT]\n\nBases: Generic[FromConfigT]\n\nCreate a new instance of the component from a configuration object.\n\nconfig (T) – The configuration object.\n\nSelf – The new instance of the component.\n\nCreate a new instance of the component from a previous version of the configuration object.\n\nThis is only called when the version of the configuration object is less than the current version, since in this case the schema is not known.\n\nconfig (Dict[str, Any]) – The configuration object.\n\nversion (int) – The version of the configuration object.\n\nSelf – The new instance of the component.\n\nLoad a component from a model. Intended to be used with the return type of autogen_core.ComponentConfig.dump_component().\n\nmodel (ComponentModel) – The model to load the component from.\n\nmodel – _description_\n\nexpected (Type[ExpectedType] | None, optional) – Explicit type only if used directly on ComponentLoader. Defaults to None.\n\nSelf – The loaded component.\n\nValueError – If the provider string is invalid.\n\nTypeError – Provider is not a subclass of ComponentConfigImpl, or the expected type does not match.\n\nSelf | ExpectedType – The loaded component.\n\nModel class for a component. Contains all information required to instantiate a component.\n\nShow JSON schema{ \"title\": \"ComponentModel\", \"description\": \"Model class for a component. Contains all information required to instantiate a component.\", \"type\": \"object\", \"properties\": { \"provider\": { \"title\": \"Provider\", \"type\": \"string\" }, \"component_type\": { \"anyOf\": [ { \"enum\": [ \"model\", \"agent\", \"tool\", \"termination\", \"token_provider\", \"workbench\" ], \"type\": \"string\" }, { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Component Type\" }, \"version\": { \"anyOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Version\" }, \"component_version\": { \"anyOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Component Version\" }, \"description\": { \"anyOf\": [ { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Description\" }, \"label\": { \"anyOf\": [ { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Label\" }, \"config\": { \"title\": \"Config\", \"type\": \"object\" } }, \"required\": [ \"provider\", \"config\" ] }\n\ncomponent_type (Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str | None)\n\ncomponent_version (int | None)\n\nconfig (dict[str, Any])\n\ndescription (str | None)\n\nDescribes how the component can be instantiated.\n\nLogical type of the component. If missing, the component assumes the default type of the provider.\n\nVersion of the component specification. If missing, the component assumes whatever is the current version of the library used to load it. This is obviously dangerous and should be used for user authored ephmeral config. For all other configs version should be specified.\n\nVersion of the component. If missing, the component assumes the default version of the provider.\n\nDescription of the component.\n\nHuman readable label for the component. If missing the component assumes the class name of the provider.\n\nThe schema validated config field is passed to a given class’s implmentation of autogen_core.ComponentConfigImpl._from_config() to create a new instance of the component class.\n\nBases: Generic[ConfigT]\n\nThe Pydantic model class which represents the configuration of the component.\n\nBases: Generic[ToConfigT]\n\nThe two methods a class must implement to be a component.\n\nProtocol (ConfigT) – Type which derives from pydantic.BaseModel.\n\nThe logical type of the component.\n\nThe version of the component, if schema incompatibilities are introduced this should be updated.\n\nOverride the provider string for the component. This should be used to prevent internal module names being a part of the module name.\n\nA description of the component. If not provided, the docstring of the class will be used.\n\nA human readable label for the component. If not provided, the component class name will be used.\n\nDump the configuration that would be requite to create a new instance of a component matching the configuration of this instance.\n\nT – The configuration of the component.\n\nDump the component to a model that can be loaded back in.\n\nTypeError – If the component is a local class.\n\nComponentModel – The model representing the component.\n\nMarker type for signalling that a message should be dropped by an intervention handler. The type itself should be returned from the handler.\n\nAn intervention handler is a class that can be used to modify, log or drop messages that are being processed by the autogen_core.base.AgentRuntime.\n\nThe handler is called when the message is submitted to the runtime.\n\nCurrently the only runtime which supports this is the autogen_core.base.SingleThreadedAgentRuntime.\n\nNote: Returning None from any of the intervention handler methods will result in a warning being issued and treated as “no change”. If you intend to drop a message, you should return DropMessage explicitly.\n\nCalled when a message is submitted to the AgentRuntime using autogen_core.base.AgentRuntime.send_message().\n\nCalled when a message is published to the AgentRuntime using autogen_core.base.AgentRuntime.publish_message().\n\nCalled when a response is received by the AgentRuntime from an Agent’s message handler returning a value.\n\nBases: InterventionHandler\n\nSimple class that provides a default implementation for all intervention handler methods, that simply returns the message unchanged. Allows for easy subclassing to override only the desired methods.\n\nCalled when a message is submitted to the AgentRuntime using autogen_core.base.AgentRuntime.send_message().\n\nCalled when a message is published to the AgentRuntime using autogen_core.base.AgentRuntime.publish_message().\n\nCalled when a response is received by the AgentRuntime from an Agent’s message handler returning a value.\n\nContext manager to create a span for agent creation following the OpenTelemetry Semantic conventions for generative AI systems.\n\nSee the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions\n\nThe GenAI Semantic Conventions are still in incubation and subject to changes in future releases.\n\nagent_name (str) – The name of the agent being created.\n\ntracer (Optional[trace.Tracer]) – The tracer to use for creating the span.\n\nparent (Optional[Span]) – The parent span to link this span to.\n\nagent_id (Optional[str]) – The unique identifier for the agent.\n\nagent_description (Optional[str]) – A description of the agent.\n\nContext manager to create a span for invoking an agent following the OpenTelemetry Semantic conventions for generative AI systems.\n\nSee the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions\n\nThe GenAI Semantic Conventions are still in incubation and subject to changes in future releases.\n\nagent_name (str) – The name of the agent being invoked.\n\ntracer (Optional[trace.Tracer]) – The tracer to use for creating the span.\n\nparent (Optional[Span]) – The parent span to link this span to.\n\nagent_id (Optional[str]) – The unique identifier for the agent.\n\nagent_description (Optional[str]) – A description of the agent.\n\nContext manager to create a span for tool execution following the OpenTelemetry Semantic conventions for generative AI systems.\n\nSee the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions\n\nThe GenAI Semantic Conventions are still in incubation and subject to changes in future releases.\n\ntool_name (str) – The name of the tool being executed.\n\ntracer (Optional[trace.Tracer]) – The tracer to use for creating the span.\n\nparent (Optional[Span]) – The parent span to link this span to.\n\ntool_description (Optional[str]) – A description of the tool.\n\ntool_call_id (Optional[str]) – A unique identifier for the tool call.\n\nautogen_agentchat.utils\n\nautogen_core.code_executor",
  "headings": [
    {
      "level": "h1",
      "text": "autogen_core#",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def my_agent_factory():\n    return MyAgent()\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    await runtime.register_factory(\"my_agent\", lambda: MyAgent())\n\n\nimport asyncio\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def my_agent_factory():\n    return MyAgent()\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    await runtime.register_factory(\"my_agent\", lambda: MyAgent())\n\n\nimport asyncio\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    agent = MyAgent()\n    await runtime.register_agent_instance(\n        agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\")\n    )\n\n\nimport asyncio\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    agent = MyAgent()\n    await runtime.register_agent_instance(\n        agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\")\n    )\n\n\nimport asyncio\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\n\nfrom autogen_core import (\n    AgentId,\n    AgentInstantiationContext,\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    message_handler,\n)\n\n\n@dataclass\nclass TestMessage:\n    content: str\n\n\nclass TestAgent(RoutedAgent):\n    def __init__(self, description: str):\n        super().__init__(description)\n        # Get the current runtime -- we don't use it here, but it's available.\n        _ = AgentInstantiationContext.current_runtime()\n        # Get the current agent ID.\n        agent_id = AgentInstantiationContext.current_agent_id()\n        print(f\"Current AgentID from constructor: {agent_id}\")\n\n    @message_handler\n    async def handle_test_message(self, message: TestMessage, ctx: MessageContext) -> None:\n        print(f\"Received message: {message.content}\")\n\n\ndef test_agent_factory() -> TestAgent:\n    # Get the current runtime -- we don't use it here, but it's available.\n    _ = AgentInstantiationContext.current_runtime()\n    # Get the current agent ID.\n    agent_id = AgentInstantiationContext.current_agent_id()\n    print(f\"Current AgentID from factory: {agent_id}\")\n    return TestAgent(description=\"Test agent\")\n\n\nasync def main() -> None:\n    # Create a SingleThreadedAgentRuntime instance.\n    runtime = SingleThreadedAgentRuntime()\n\n    # Start the runtime.\n    runtime.start()\n\n    # Register the agent type with a factory function.\n    await runtime.register_factory(\"test_agent\", test_agent_factory)\n\n    # Send a message to the agent. The runtime will instantiate the agent and call the message handler.\n    await runtime.send_message(TestMessage(content=\"Hello, world!\"), AgentId(\"test_agent\", \"default\"))\n\n    # Stop the runtime.\n    await runtime.stop()\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\n\nfrom autogen_core import (\n    AgentId,\n    AgentInstantiationContext,\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    message_handler,\n)\n\n\n@dataclass\nclass TestMessage:\n    content: str\n\n\nclass TestAgent(RoutedAgent):\n    def __init__(self, description: str):\n        super().__init__(description)\n        # Get the current runtime -- we don't use it here, but it's available.\n        _ = AgentInstantiationContext.current_runtime()\n        # Get the current agent ID.\n        agent_id = AgentInstantiationContext.current_agent_id()\n        print(f\"Current AgentID from constructor: {agent_id}\")\n\n    @message_handler\n    async def handle_test_message(self, message: TestMessage, ctx: MessageContext) -> None:\n        print(f\"Received message: {message.content}\")\n\n\ndef test_agent_factory() -> TestAgent:\n    # Get the current runtime -- we don't use it here, but it's available.\n    _ = AgentInstantiationContext.current_runtime()\n    # Get the current agent ID.\n    agent_id = AgentInstantiationContext.current_agent_id()\n    print(f\"Current AgentID from factory: {agent_id}\")\n    return TestAgent(description=\"Test agent\")\n\n\nasync def main() -> None:\n    # Create a SingleThreadedAgentRuntime instance.\n    runtime = SingleThreadedAgentRuntime()\n\n    # Start the runtime.\n    runtime.start()\n\n    # Register the agent type with a factory function.\n    await runtime.register_factory(\"test_agent\", test_agent_factory)\n\n    # Send a message to the agent. The runtime will instantiate the agent and call the message handler.\n    await runtime.send_message(TestMessage(content=\"Hello, world!\"), AgentId(\"test_agent\", \"default\"))\n\n    # Stop the runtime.\n    await runtime.stop()\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from autogen_core import Image\nfrom PIL import Image as PILImage\nimport aiohttp\nimport asyncio\n\n\nasync def from_url(url: str) -> Image:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            content = await response.read()\n            return Image.from_pil(PILImage.open(content))\n\n\nimage = asyncio.run(from_url(\"https://example.com/image\"))",
      "language": "python"
    },
    {
      "code": "from autogen_core import Image\nfrom PIL import Image as PILImage\nimport aiohttp\nimport asyncio\n\n\nasync def from_url(url: str) -> Image:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            content = await response.read()\n            return Image.from_pil(PILImage.open(content))\n\n\nimage = asyncio.run(from_url(\"https://example.com/image\"))",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\nfrom autogen_core import MessageContext\nfrom autogen_core import RoutedAgent, event, rpc\n\n\n@dataclass\nclass Message:\n    pass\n\n\n@dataclass\nclass MessageWithContent:\n    content: str\n\n\n@dataclass\nclass Response:\n    pass\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self):\n        super().__init__(\"MyAgent\")\n\n    @event\n    async def handle_event_message(self, message: Message, ctx: MessageContext) -> None:\n        assert ctx.topic_id is not None\n        await self.publish_message(MessageWithContent(\"event handled\"), ctx.topic_id)\n\n    @rpc(match=lambda message, ctx: message.content == \"special\")  # type: ignore\n    async def handle_special_rpc_message(self, message: MessageWithContent, ctx: MessageContext) -> Response:\n        return Response()",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\nfrom autogen_core import MessageContext\nfrom autogen_core import RoutedAgent, event, rpc\n\n\n@dataclass\nclass Message:\n    pass\n\n\n@dataclass\nclass MessageWithContent:\n    content: str\n\n\n@dataclass\nclass Response:\n    pass\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self):\n        super().__init__(\"MyAgent\")\n\n    @event\n    async def handle_event_message(self, message: Message, ctx: MessageContext) -> None:\n        assert ctx.topic_id is not None\n        await self.publish_message(MessageWithContent(\"event handled\"), ctx.topic_id)\n\n    @rpc(match=lambda message, ctx: message.content == \"special\")  # type: ignore\n    async def handle_special_rpc_message(self, message: MessageWithContent, ctx: MessageContext) -> Response:\n        return Response()",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom autogen_core import SingleThreadedAgentRuntime, MessageContext, ClosureAgent, ClosureContext\nfrom dataclasses import dataclass\n\nfrom autogen_core._default_subscription import DefaultSubscription\nfrom autogen_core._default_topic import DefaultTopicId\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nasync def main():\n    queue = asyncio.Queue[MyMessage]()\n\n    async def output_result(_ctx: ClosureContext, message: MyMessage, ctx: MessageContext) -> None:\n        await queue.put(message)\n\n    runtime = SingleThreadedAgentRuntime()\n    await ClosureAgent.register_closure(\n        runtime, \"output_result\", output_result, subscriptions=lambda: [DefaultSubscription()]\n    )\n\n    runtime.start()\n    await runtime.publish_message(MyMessage(\"Hello, world!\"), DefaultTopicId())\n    await runtime.stop_when_idle()\n\n    result = await queue.get()\n    print(result)\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom autogen_core import SingleThreadedAgentRuntime, MessageContext, ClosureAgent, ClosureContext\nfrom dataclasses import dataclass\n\nfrom autogen_core._default_subscription import DefaultSubscription\nfrom autogen_core._default_topic import DefaultTopicId\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nasync def main():\n    queue = asyncio.Queue[MyMessage]()\n\n    async def output_result(_ctx: ClosureContext, message: MyMessage, ctx: MessageContext) -> None:\n        await queue.put(message)\n\n    runtime = SingleThreadedAgentRuntime()\n    await ClosureAgent.register_closure(\n        runtime, \"output_result\", output_result, subscriptions=lambda: [DefaultSubscription()]\n    )\n\n    runtime.start()\n    await runtime.publish_message(MyMessage(\"Hello, world!\"), DefaultTopicId())\n    await runtime.stop_when_idle()\n\n    result = await queue.get()\n    print(result)\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from autogen_core import TypeSubscription\n\nsubscription = TypeSubscription(topic_type=\"t1\", agent_type=\"a1\")",
      "language": "python"
    },
    {
      "code": "from autogen_core import TypeSubscription\n\nsubscription = TypeSubscription(topic_type=\"t1\", agent_type=\"a1\")",
      "language": "python"
    },
    {
      "code": "from autogen_core import TypePrefixSubscription\n\nsubscription = TypePrefixSubscription(topic_type_prefix=\"t1\", agent_type=\"a1\")",
      "language": "python"
    },
    {
      "code": "from autogen_core import TypePrefixSubscription\n\nsubscription = TypePrefixSubscription(topic_type_prefix=\"t1\", agent_type=\"a1\")",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\n\nfrom autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    @message_handler\n    async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None:\n        print(f\"Received message: {message.content}\")\n\n\nasync def main() -> None:\n    # Create a runtime and register the agent\n    runtime = SingleThreadedAgentRuntime()\n    await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My agent\"))\n\n    # Start the runtime, send a message and stop the runtime\n    runtime.start()\n    await runtime.send_message(MyMessage(\"Hello, world!\"), recipient=AgentId(\"my_agent\", \"default\"))\n    await runtime.stop()\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\n\nfrom autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    @message_handler\n    async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None:\n        print(f\"Received message: {message.content}\")\n\n\nasync def main() -> None:\n    # Create a runtime and register the agent\n    runtime = SingleThreadedAgentRuntime()\n    await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My agent\"))\n\n    # Start the runtime, send a message and stop the runtime\n    runtime.start()\n    await runtime.send_message(MyMessage(\"Hello, world!\"), recipient=AgentId(\"my_agent\", \"default\"))\n    await runtime.stop()\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\n\nfrom autogen_core import (\n    DefaultTopicId,\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    default_subscription,\n    message_handler,\n)\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\n# The agent is subscribed to the default topic.\n@default_subscription\nclass MyAgent(RoutedAgent):\n    @message_handler\n    async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None:\n        print(f\"Received message: {message.content}\")\n\n\nasync def main() -> None:\n    # Create a runtime and register the agent\n    runtime = SingleThreadedAgentRuntime()\n    await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My agent\"))\n\n    # Start the runtime.\n    runtime.start()\n    # Publish a message to the default topic that the agent is subscribed to.\n    await runtime.publish_message(MyMessage(\"Hello, world!\"), DefaultTopicId())\n    # Wait for the message to be processed and then stop the runtime.\n    await runtime.stop_when_idle()\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\n\nfrom autogen_core import (\n    DefaultTopicId,\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    default_subscription,\n    message_handler,\n)\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\n# The agent is subscribed to the default topic.\n@default_subscription\nclass MyAgent(RoutedAgent):\n    @message_handler\n    async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None:\n        print(f\"Received message: {message.content}\")\n\n\nasync def main() -> None:\n    # Create a runtime and register the agent\n    runtime = SingleThreadedAgentRuntime()\n    await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My agent\"))\n\n    # Start the runtime.\n    runtime.start()\n    # Publish a message to the default topic that the agent is subscribed to.\n    await runtime.publish_message(MyMessage(\"Hello, world!\"), DefaultTopicId())\n    # Wait for the message to be processed and then stop the runtime.\n    await runtime.stop_when_idle()\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom autogen_core import SingleThreadedAgentRuntime\n\n\nasync def main() -> None:\n    runtime = SingleThreadedAgentRuntime()\n    runtime.start()\n\n    # ... do other things ...\n\n    await runtime.stop()\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom autogen_core import SingleThreadedAgentRuntime\n\n\nasync def main() -> None:\n    runtime = SingleThreadedAgentRuntime()\n    runtime.start()\n\n    # ... do other things ...\n\n    await runtime.stop()\n\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def my_agent_factory():\n    return MyAgent()\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    await runtime.register_factory(\"my_agent\", lambda: MyAgent())\n\n\nimport asyncio\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def my_agent_factory():\n    return MyAgent()\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    await runtime.register_factory(\"my_agent\", lambda: MyAgent())\n\n\nimport asyncio\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    agent = MyAgent()\n    await runtime.register_agent_instance(\n        agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\")\n    )\n\n\nimport asyncio\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    agent = MyAgent()\n    await runtime.register_agent_instance(\n        agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\")\n    )\n\n\nimport asyncio\n\nasyncio.run(main())",
      "language": "python"
    },
    {
      "code": "from __future__ import annotations\n\nfrom pydantic import BaseModel\nfrom autogen_core import Component\n\n\nclass Config(BaseModel):\n    value: str\n\n\nclass MyComponent(Component[Config]):\n    component_type = \"custom\"\n    component_config_schema = Config\n\n    def __init__(self, value: str):\n        self.value = value\n\n    def _to_config(self) -> Config:\n        return Config(value=self.value)\n\n    @classmethod\n    def _from_config(cls, config: Config) -> MyComponent:\n        return cls(value=config.value)",
      "language": "python"
    },
    {
      "code": "from __future__ import annotations\n\nfrom pydantic import BaseModel\nfrom autogen_core import Component\n\n\nclass Config(BaseModel):\n    value: str\n\n\nclass MyComponent(Component[Config]):\n    component_type = \"custom\"\n    component_config_schema = Config\n\n    def __init__(self, value: str):\n        self.value = value\n\n    def _to_config(self) -> Config:\n        return Config(value=self.value)\n\n    @classmethod\n    def _from_config(cls, config: Config) -> MyComponent:\n        return cls(value=config.value)",
      "language": "python"
    },
    {
      "code": "from autogen_core import ComponentModel\nfrom autogen_core.models import ChatCompletionClient\n\ncomponent: ComponentModel = ...  # type: ignore\n\nmodel_client = ChatCompletionClient.load_component(component)",
      "language": "yaml"
    },
    {
      "code": "from autogen_core import ComponentModel\nfrom autogen_core.models import ChatCompletionClient\n\ncomponent: ComponentModel = ...  # type: ignore\n\nmodel_client = ChatCompletionClient.load_component(component)",
      "language": "yaml"
    },
    {
      "code": "{\n   \"title\": \"ComponentModel\",\n   \"description\": \"Model class for a component. Contains all information required to instantiate a component.\",\n   \"type\": \"object\",\n   \"properties\": {\n      \"provider\": {\n         \"title\": \"Provider\",\n         \"type\": \"string\"\n      },\n      \"component_type\": {\n         \"anyOf\": [\n            {\n               \"enum\": [\n                  \"model\",\n                  \"agent\",\n                  \"tool\",\n                  \"termination\",\n                  \"token_provider\",\n                  \"workbench\"\n               ],\n               \"type\": \"string\"\n            },\n            {\n               \"type\": \"string\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Component Type\"\n      },\n      \"version\": {\n         \"anyOf\": [\n            {\n               \"type\": \"integer\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Version\"\n      },\n      \"component_version\": {\n         \"anyOf\": [\n            {\n               \"type\": \"integer\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Component Version\"\n      },\n      \"description\": {\n         \"anyOf\": [\n            {\n               \"type\": \"string\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Description\"\n      },\n      \"label\": {\n         \"anyOf\": [\n            {\n               \"type\": \"string\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Label\"\n      },\n      \"config\": {\n         \"title\": \"Config\",\n         \"type\": \"object\"\n      }\n   },\n   \"required\": [\n      \"provider\",\n      \"config\"\n   ]\n}",
      "language": "json"
    },
    {
      "code": "{\n   \"title\": \"ComponentModel\",\n   \"description\": \"Model class for a component. Contains all information required to instantiate a component.\",\n   \"type\": \"object\",\n   \"properties\": {\n      \"provider\": {\n         \"title\": \"Provider\",\n         \"type\": \"string\"\n      },\n      \"component_type\": {\n         \"anyOf\": [\n            {\n               \"enum\": [\n                  \"model\",\n                  \"agent\",\n                  \"tool\",\n                  \"termination\",\n                  \"token_provider\",\n                  \"workbench\"\n               ],\n               \"type\": \"string\"\n            },\n            {\n               \"type\": \"string\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Component Type\"\n      },\n      \"version\": {\n         \"anyOf\": [\n            {\n               \"type\": \"integer\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Version\"\n      },\n      \"component_version\": {\n         \"anyOf\": [\n            {\n               \"type\": \"integer\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Component Version\"\n      },\n      \"description\": {\n         \"anyOf\": [\n            {\n               \"type\": \"string\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Description\"\n      },\n      \"label\": {\n         \"anyOf\": [\n            {\n               \"type\": \"string\"\n            },\n            {\n               \"type\": \"null\"\n            }\n         ],\n         \"default\": null,\n         \"title\": \"Label\"\n      },\n      \"config\": {\n         \"title\": \"Config\",\n         \"type\": \"object\"\n      }\n   },\n   \"required\": [\n      \"provider\",\n      \"config\"\n   ]\n}",
      "language": "json"
    },
    {
      "code": "from autogen_core import DefaultInterventionHandler, MessageContext, AgentId, SingleThreadedAgentRuntime\nfrom dataclasses import dataclass\nfrom typing import Any\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyInterventionHandler(DefaultInterventionHandler):\n    async def on_send(self, message: Any, *, message_context: MessageContext, recipient: AgentId) -> MyMessage:\n        if isinstance(message, MyMessage):\n            message.content = message.content.upper()\n        return message\n\n\nruntime = SingleThreadedAgentRuntime(intervention_handlers=[MyInterventionHandler()])",
      "language": "python"
    },
    {
      "code": "from autogen_core import DefaultInterventionHandler, MessageContext, AgentId, SingleThreadedAgentRuntime\nfrom dataclasses import dataclass\nfrom typing import Any\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyInterventionHandler(DefaultInterventionHandler):\n    async def on_send(self, message: Any, *, message_context: MessageContext, recipient: AgentId) -> MyMessage:\n        if isinstance(message, MyMessage):\n            message.content = message.content.upper()\n        return message\n\n\nruntime = SingleThreadedAgentRuntime(intervention_handlers=[MyInterventionHandler()])",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "API Reference autogen_core autogen_core# class Agent(*args, **kwargs)[source]# Bases: Protocol property metadata: AgentMetadata# Metadata of the agent. property id: AgentId# ID of the agent. async bind_id_and_runtime(id: AgentId, runtime: AgentRuntime) → None[source]# Function used to bind an Agent instance to an AgentRuntime. Parameters: agent_id (AgentId) – ID of the agent. runtime (AgentRuntime) – AgentRuntime instance to bind the agent to. async on_message(message: Any, ctx: MessageContext) → Any[source]# Message handler for the agent. This should only be called by the runtime, not by other agents. Parameters: message (Any) – Received message. Type is one of the types in subscriptions. ctx (MessageContext) – Context of the message. Returns: Any – Response to the message. Can be None. Raises: CancelledError – If the message was cancelled. CantHandleException – If the agent cannot handle the message. async save_state() → Mapping[str, Any][source]# Save the state of the agent. The result must be JSON serializable. async load_state(state: Mapping[str, Any]) → None[source]# Load in the state of the agent obtained from save_state. Parameters: state (Mapping[str, Any]) – State of the agent. Must be JSON serializable. async close() → None[source]# Called when the runtime is closed class AgentId(type: str | AgentType, key: str)[source]# Bases: object Agent ID uniquely identifies an agent instance within an agent runtime - including distributed runtime. It is the ‘address’ of the agent instance for receiving messages. See here for more information: Agent Identity and Lifecycle classmethod from_str(agent_id: str) → Self[source]# Convert a string of the format type/key into an AgentId property type: str# An identifier that associates an agent with a specific factory function. Strings may only be composed of alphanumeric letters (a-z) and (0-9), or underscores (_). property key: str# Agent instance identifier. Strings may only be composed of alphanumeric letters (a-z) and (0-9), or underscores (_). class AgentProxy(agent: AgentId, runtime: AgentRuntime)[source]# Bases: object A helper class that allows you to use an AgentId in place of its associated Agent property id: AgentId# Target agent for this proxy property metadata: Awaitable[AgentMetadata]# Metadata of the agent. async send_message(message: Any, *, sender: AgentId, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# async save_state() → Mapping[str, Any][source]# Save the state of the agent. The result must be JSON serializable. async load_state(state: Mapping[str, Any]) → None[source]# Load in the state of the agent obtained from save_state. Parameters: state (Mapping[str, Any]) – State of the agent. Must be JSON serializable. class AgentMetadata[source]# Bases: TypedDict type: str# key: str# description: str# class AgentRuntime(*args, **kwargs)[source]# Bases: Protocol async send_message(message: Any, recipient: AgentId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# Send a message to an agent and get a response. Parameters: message (Any) – The message to send. recipient (AgentId) – The agent to send the message to. sender (AgentId | None, optional) – Agent which sent the message. Should only be None if this was sent from no agent, such as directly to the runtime externally. Defaults to None. cancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress . Defaults to None. Raises: CantHandleException – If the recipient cannot handle the message. UndeliverableException – If the message cannot be delivered. Other – Any other exception raised by the recipient. Returns: Any – The response from the agent. async publish_message(message: Any, topic_id: TopicId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → None[source]# Publish a message to all agents in the given namespace, or if no namespace is provided, the namespace of the sender. No responses are expected from publishing. Parameters: message (Any) – The message to publish. topic_id (TopicId) – The topic to publish the message to. sender (AgentId | None, optional) – The agent which sent the message. Defaults to None. cancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress. Defaults to None. message_id (str | None, optional) – The message id. If None, a new message id will be generated. Defaults to None. This message id must be unique. and is recommended to be a UUID. Raises: UndeliverableException – If the message cannot be delivered. async register_factory(type: str | AgentType, agent_factory: Callable[[], T | Awaitable[T]], *, expected_class: type[T] | None = None) → AgentType[source]# Register an agent factory with the runtime associated with a specific type. The type must be unique. This API does not add any subscriptions. Note This is a low level API and usually the agent class’s register method should be used instead, as this also handles subscriptions automatically. Example: from dataclasses import dataclass from autogen_core import AgentRuntime, MessageContext, RoutedAgent, event from autogen_core.models import UserMessage @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): def __init__(self) -> None: super().__init__(\"My core agent\") @event async def handler(self, message: UserMessage, context: MessageContext) -> None: print(\"Event received: \", message.content) async def my_agent_factory(): return MyAgent() async def main() -> None: runtime: AgentRuntime = ... # type: ignore await runtime.register_factory(\"my_agent\", lambda: MyAgent()) import asyncio asyncio.run(main()) Parameters: type (str) – The type of agent this factory creates. It is not the same as agent class name. The type parameter is used to differentiate between different factory functions rather than agent classes. agent_factory (Callable[[], T]) – The factory that creates the agent, where T is a concrete Agent type. Inside the factory, use autogen_core.AgentInstantiationContext to access variables like the current runtime and agent ID. expected_class (type[T] | None, optional) – The expected class of the agent, used for runtime validation of the factory. Defaults to None. If None, no validation is performed. async register_agent_instance(agent_instance: Agent, agent_id: AgentId) → AgentId[source]# Register an agent instance with the runtime. The type may be reused, but each agent_id must be unique. All agent instances within a type must be of the same object type. This API does not add any subscriptions. Note This is a low level API and usually the agent class’s register_instance method should be used instead, as this also handles subscriptions automatically. Example: from dataclasses import dataclass from autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event from autogen_core.models import UserMessage @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): def __init__(self) -> None: super().__init__(\"My core agent\") @event async def handler(self, message: UserMessage, context: MessageContext) -> None: print(\"Event received: \", message.content) async def main() -> None: runtime: AgentRuntime = ... # type: ignore agent = MyAgent() await runtime.register_agent_instance( agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\") ) import asyncio asyncio.run(main()) Parameters: agent_instance (Agent) – A concrete instance of the agent. agent_id (AgentId) – The agent’s identifier. The agent’s type is agent_id.type. async try_get_underlying_agent_instance(id: AgentId, type: Type[T] = Agent) → T[source]# Try to get the underlying agent instance by name and namespace. This is generally discouraged (hence the long name), but can be useful in some cases. If the underlying agent is not accessible, this will raise an exception. Parameters: id (AgentId) – The agent id. type (Type[T], optional) – The expected type of the agent. Defaults to Agent. Returns: T – The concrete agent instance. Raises: LookupError – If the agent is not found. NotAccessibleError – If the agent is not accessible, for example if it is located remotely. TypeError – If the agent is not of the expected type. async get(id: AgentId, /, *, lazy: bool = True) → AgentId[source]# async get(type: AgentType | str, /, key: str = 'default', *, lazy: bool = True) → AgentId async save_state() → Mapping[str, Any][source]# Save the state of the entire runtime, including all hosted agents. The only way to restore the state is to pass it to load_state(). The structure of the state is implementation defined and can be any JSON serializable object. Returns: Mapping[str, Any] – The saved state. async load_state(state: Mapping[str, Any]) → None[source]# Load the state of the entire runtime, including all hosted agents. The state should be the same as the one returned by save_state(). Parameters: state (Mapping[str, Any]) – The saved state. async agent_metadata(agent: AgentId) → AgentMetadata[source]# Get the metadata for an agent. Parameters: agent (AgentId) – The agent id. Returns: AgentMetadata – The agent metadata. async agent_save_state(agent: AgentId) → Mapping[str, Any][source]# Save the state of a single agent. The structure of the state is implementation defined and can be any JSON serializable object. Parameters: agent (AgentId) – The agent id. Returns: Mapping[str, Any] – The saved state. async agent_load_state(agent: AgentId, state: Mapping[str, Any]) → None[source]# Load the state of a single agent. Parameters: agent (AgentId) – The agent id. state (Mapping[str, Any]) – The saved state. async add_subscription(subscription: Subscription) → None[source]# Add a new subscription that the runtime should fulfill when processing published messages Parameters: subscription (Subscription) – The subscription to add async remove_subscription(id: str) → None[source]# Remove a subscription from the runtime Parameters: id (str) – id of the subscription to remove Raises: LookupError – If the subscription does not exist add_message_serializer(serializer: MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) → None[source]# Add a new message serialization serializer to the runtime Note: This will deduplicate serializers based on the type_name and data_content_type properties Parameters: serializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – The serializer/s to add class BaseAgent(description: str)[source]# Bases: ABC, Agent property metadata: AgentMetadata# Metadata of the agent. async bind_id_and_runtime(id: AgentId, runtime: AgentRuntime) → None[source]# Function used to bind an Agent instance to an AgentRuntime. Parameters: agent_id (AgentId) – ID of the agent. runtime (AgentRuntime) – AgentRuntime instance to bind the agent to. property type: str# property id: AgentId# ID of the agent. property runtime: AgentRuntime# final async on_message(message: Any, ctx: MessageContext) → Any[source]# Message handler for the agent. This should only be called by the runtime, not by other agents. Parameters: message (Any) – Received message. Type is one of the types in subscriptions. ctx (MessageContext) – Context of the message. Returns: Any – Response to the message. Can be None. Raises: CancelledError – If the message was cancelled. CantHandleException – If the agent cannot handle the message. abstract async on_message_impl(message: Any, ctx: MessageContext) → Any[source]# async send_message(message: Any, recipient: AgentId, *, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# See autogen_core.AgentRuntime.send_message() for more information. async publish_message(message: Any, topic_id: TopicId, *, cancellation_token: CancellationToken | None = None) → None[source]# async save_state() → Mapping[str, Any][source]# Save the state of the agent. The result must be JSON serializable. async load_state(state: Mapping[str, Any]) → None[source]# Load in the state of the agent obtained from save_state. Parameters: state (Mapping[str, Any]) – State of the agent. Must be JSON serializable. async close() → None[source]# Called when the runtime is closed async register_instance(runtime: AgentRuntime, agent_id: AgentId, *, skip_class_subscriptions: bool = True, skip_direct_message_subscription: bool = False) → AgentId[source]# This function is similar to register but is used for registering an instance of an agent. A subscription based on the agent ID is created and added to the runtime. async classmethod register(runtime: AgentRuntime, type: str, factory: Callable[[], Self | Awaitable[Self]], *, skip_class_subscriptions: bool = False, skip_direct_message_subscription: bool = False) → AgentType[source]# Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. class CacheStore[source]# Bases: ABC, Generic[T], ComponentBase[BaseModel] This protocol defines the basic interface for store/cache operations. Sub-classes should handle the lifecycle of underlying storage. component_type: ClassVar[ComponentType] = 'cache_store'# The logical type of the component. abstract get(key: str, default: T | None = None) → T | None[source]# Retrieve an item from the store. Parameters: key – The key identifying the item in the store. default (optional) – The default value to return if the key is not found. Defaults to None. Returns: The value associated with the key if found, else the default value. abstract set(key: str, value: T) → None[source]# Set an item in the store. Parameters: key – The key under which the item is to be stored. value – The value to be stored in the store. class InMemoryStore[source]# Bases: CacheStore[T], Component[InMemoryStoreConfig] component_provider_override: ClassVar[str | None] = 'autogen_core.InMemoryStore'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. component_config_schema# alias of InMemoryStoreConfig get(key: str, default: T | None = None) → T | None[source]# Retrieve an item from the store. Parameters: key – The key identifying the item in the store. default (optional) – The default value to return if the key is not found. Defaults to None. Returns: The value associated with the key if found, else the default value. set(key: str, value: T) → None[source]# Set an item in the store. Parameters: key – The key under which the item is to be stored. value – The value to be stored in the store. _to_config() → InMemoryStoreConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: InMemoryStoreConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class CancellationToken[source]# Bases: object A token used to cancel pending async calls cancel() → None[source]# Cancel pending async calls linked to this cancellation token. is_cancelled() → bool[source]# Check if the CancellationToken has been used add_callback(callback: Callable[[], None]) → None[source]# Attach a callback that will be called when cancel is invoked link_future(future: Future[Any]) → Future[Any][source]# Link a pending async call to a token to allow its cancellation class AgentInstantiationContext[source]# Bases: object A static class that provides context for agent instantiation. This static class can be used to access the current runtime and agent ID during agent instantiation – inside the factory function or the agent’s class constructor. Example Get the current runtime and agent ID inside the factory function and the agent’s constructor: import asyncio from dataclasses import dataclass from autogen_core import ( AgentId, AgentInstantiationContext, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler, ) @dataclass class TestMessage: content: str class TestAgent(RoutedAgent): def __init__(self, description: str): super().__init__(description) # Get the current runtime -- we don't use it here, but it's available. _ = AgentInstantiationContext.current_runtime() # Get the current agent ID. agent_id = AgentInstantiationContext.current_agent_id() print(f\"Current AgentID from constructor: {agent_id}\") @message_handler async def handle_test_message(self, message: TestMessage, ctx: MessageContext) -> None: print(f\"Received message: {message.content}\") def test_agent_factory() -> TestAgent: # Get the current runtime -- we don't use it here, but it's available. _ = AgentInstantiationContext.current_runtime() # Get the current agent ID. agent_id = AgentInstantiationContext.current_agent_id() print(f\"Current AgentID from factory: {agent_id}\") return TestAgent(description=\"Test agent\") async def main() -> None: # Create a SingleThreadedAgentRuntime instance. runtime = SingleThreadedAgentRuntime() # Start the runtime. runtime.start() # Register the agent type with a factory function. await runtime.register_factory(\"test_agent\", test_agent_factory) # Send a message to the agent. The runtime will instantiate the agent and call the message handler. await runtime.send_message(TestMessage(content=\"Hello, world!\"), AgentId(\"test_agent\", \"default\")) # Stop the runtime. await runtime.stop() asyncio.run(main()) classmethod current_runtime() → AgentRuntime[source]# classmethod current_agent_id() → AgentId[source]# classmethod is_in_factory_call() → bool[source]# class TopicId(type: str, source: str)[source]# Bases: object TopicId defines the scope of a broadcast message. In essence, agent runtime implements a publish-subscribe model through its broadcast API: when publishing a message, the topic must be specified. See here for more information: Topic type: str# Type of the event that this topic_id contains. Adhere’s to the cloud event spec. Must match the pattern: ^[w-.:=]+Z Learn more here: cloudevents/spec source: str# Identifies the context in which an event happened. Adhere’s to the cloud event spec. Learn more here: cloudevents/spec classmethod from_str(topic_id: str) → Self[source]# Convert a string of the format type/source into a TopicId class Subscription(*args, **kwargs)[source]# Bases: Protocol Subscriptions define the topics that an agent is interested in. property id: str# Get the ID of the subscription. Implementations should return a unique ID for the subscription. Usually this is a UUID. Returns: str – ID of the subscription. is_match(topic_id: TopicId) → bool[source]# Check if a given topic_id matches the subscription. Parameters: topic_id (TopicId) – TopicId to check. Returns: bool – True if the topic_id matches the subscription, False otherwise. map_to_agent(topic_id: TopicId) → AgentId[source]# Map a topic_id to an agent. Should only be called if is_match returns True for the given topic_id. Parameters: topic_id (TopicId) – TopicId to map. Returns: AgentId – ID of the agent that should handle the topic_id. Raises: CantHandleException – If the subscription cannot handle the topic_id. class MessageContext(sender: AgentId | None, topic_id: TopicId | None, is_rpc: bool, cancellation_token: CancellationToken, message_id: str)[source]# Bases: object sender: AgentId | None# topic_id: TopicId | None# is_rpc: bool# cancellation_token: CancellationToken# message_id: str# class AgentType(type: str)[source]# Bases: object type: str# String representation of this agent type. class SubscriptionInstantiationContext[source]# Bases: object classmethod agent_type() → AgentType[source]# class MessageHandlerContext[source]# Bases: object classmethod agent_id() → AgentId[source]# class MessageSerializer(*args, **kwargs)[source]# Bases: Protocol[T] property data_content_type: str# property type_name: str# deserialize(payload: bytes) → T[source]# serialize(message: T) → bytes[source]# class UnknownPayload(type_name: str, data_content_type: str, payload: bytes)[source]# Bases: object type_name: str# data_content_type: str# payload: bytes# class Image(image: Image)[source]# Bases: object Represents an image. Example Loading an image from a URL: from autogen_core import Image from PIL import Image as PILImage import aiohttp import asyncio async def from_url(url: str) -> Image: async with aiohttp.ClientSession() as session: async with session.get(url) as response: content = await response.read() return Image.from_pil(PILImage.open(content)) image = asyncio.run(from_url(\"https://example.com/image\")) classmethod from_pil(pil_image: Image) → Image[source]# classmethod from_uri(uri: str) → Image[source]# classmethod from_base64(base64_str: str) → Image[source]# to_base64() → str[source]# classmethod from_file(file_path: Path) → Image[source]# property data_uri: str# to_openai_format(detail: Literal['auto', 'low', 'high'] = 'auto') → Dict[str, Any][source]# class RoutedAgent(description: str)[source]# Bases: BaseAgent A base class for agents that route messages to handlers based on the type of the message and optional matching functions. To create a routed agent, subclass this class and add message handlers as methods decorated with either event() or rpc() decorator. Example: from dataclasses import dataclass from autogen_core import MessageContext from autogen_core import RoutedAgent, event, rpc @dataclass class Message: pass @dataclass class MessageWithContent: content: str @dataclass class Response: pass class MyAgent(RoutedAgent): def __init__(self): super().__init__(\"MyAgent\") @event async def handle_event_message(self, message: Message, ctx: MessageContext) -> None: assert ctx.topic_id is not None await self.publish_message(MessageWithContent(\"event handled\"), ctx.topic_id) @rpc(match=lambda message, ctx: message.content == \"special\") # type: ignore async def handle_special_rpc_message(self, message: MessageWithContent, ctx: MessageContext) -> Response: return Response() async on_message_impl(message: Any, ctx: MessageContext) → Any | None[source]# Handle a message by routing it to the appropriate message handler. Do not override this method in subclasses. Instead, add message handlers as methods decorated with either the event() or rpc() decorator. async on_unhandled_message(message: Any, ctx: MessageContext) → None[source]# Called when a message is received that does not have a matching message handler. The default implementation logs an info message. class ClosureAgent(description: str, closure: Callable[[ClosureContext, T, MessageContext], Awaitable[Any]], *, unknown_type_policy: Literal['error', 'warn', 'ignore'] = 'warn')[source]# Bases: BaseAgent, ClosureContext property metadata: AgentMetadata# Metadata of the agent. property id: AgentId# ID of the agent. property runtime: AgentRuntime# async on_message_impl(message: Any, ctx: MessageContext) → Any[source]# async save_state() → Mapping[str, Any][source]# Closure agents do not have state. So this method always returns an empty dictionary. async load_state(state: Mapping[str, Any]) → None[source]# Closure agents do not have state. So this method does nothing. async classmethod register_closure(runtime: AgentRuntime, type: str, closure: Callable[[ClosureContext, T, MessageContext], Awaitable[Any]], *, unknown_type_policy: Literal['error', 'warn', 'ignore'] = 'warn', skip_direct_message_subscription: bool = False, description: str = '', subscriptions: Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None = None) → AgentType[source]# The closure agent allows you to define an agent using a closure, or function without needing to define a class. It allows values to be extracted out of the runtime. The closure can define the type of message which is expected, or Any can be used to accept any type of message. Example: import asyncio from autogen_core import SingleThreadedAgentRuntime, MessageContext, ClosureAgent, ClosureContext from dataclasses import dataclass from autogen_core._default_subscription import DefaultSubscription from autogen_core._default_topic import DefaultTopicId @dataclass class MyMessage: content: str async def main(): queue = asyncio.Queue[MyMessage]() async def output_result(_ctx: ClosureContext, message: MyMessage, ctx: MessageContext) -> None: await queue.put(message) runtime = SingleThreadedAgentRuntime() await ClosureAgent.register_closure( runtime, \"output_result\", output_result, subscriptions=lambda: [DefaultSubscription()] ) runtime.start() await runtime.publish_message(MyMessage(\"Hello, world!\"), DefaultTopicId()) await runtime.stop_when_idle() result = await queue.get() print(result) asyncio.run(main()) Parameters: runtime (AgentRuntime) – Runtime to register the agent to type (str) – Agent type of registered agent closure (Callable[[ClosureContext, T, MessageContext], Awaitable[Any]]) – Closure to handle messages unknown_type_policy (Literal[\"error\", \"warn\", \"ignore\"], optional) – What to do if a type is encountered that does not match the closure type. Defaults to “warn”. skip_direct_message_subscription (bool, optional) – Do not add direct message subscription for this agent. Defaults to False. description (str, optional) – Description of what agent does. Defaults to “”. subscriptions (Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None, optional) – List of subscriptions for this closure agent. Defaults to None. Returns: AgentType – Type of the agent that was registered class ClosureContext(*args, **kwargs)[source]# Bases: Protocol property id: AgentId# async send_message(message: Any, recipient: AgentId, *, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# async publish_message(message: Any, topic_id: TopicId, *, cancellation_token: CancellationToken | None = None) → None[source]# message_handler(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]]], MessageHandler[AgentT, ReceivesT, ProducesT]] | MessageHandler[AgentT, ReceivesT, ProducesT][source]# Decorator for generic message handlers. Add this decorator to methods in a RoutedAgent class that are intended to handle both event and RPC messages. These methods must have a specific signature that needs to be followed for it to be valid: The method must be an async method. The method must be decorated with the @message_handler decorator. The method must have exactly 3 arguments: self message: The message to be handled, this must be type-hinted with the message type that it is intended to handle. ctx: A autogen_core.MessageContext object. The method must be type hinted with what message types it can return as a response, or it can return None if it does not return anything. Handlers can handle more than one message type by accepting a Union of the message types. It can also return more than one message type by returning a Union of the message types. Parameters: func – The function to be decorated. strict – If True, the handler will raise an exception if the message type or return type is not in the target types. If False, it will log a warning instead. match – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called. event(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, None]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, None]]], MessageHandler[AgentT, ReceivesT, None]] | MessageHandler[AgentT, ReceivesT, None][source]# Decorator for event message handlers. Add this decorator to methods in a RoutedAgent class that are intended to handle event messages. These methods must have a specific signature that needs to be followed for it to be valid: The method must be an async method. The method must be decorated with the @message_handler decorator. The method must have exactly 3 arguments: self message: The event message to be handled, this must be type-hinted with the message type that it is intended to handle. ctx: A autogen_core.MessageContext object. The method must return None. Handlers can handle more than one message type by accepting a Union of the message types. Parameters: func – The function to be decorated. strict – If True, the handler will raise an exception if the message type is not in the target types. If False, it will log a warning instead. match – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called. rpc(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]]], MessageHandler[AgentT, ReceivesT, ProducesT]] | MessageHandler[AgentT, ReceivesT, ProducesT][source]# Decorator for RPC message handlers. Add this decorator to methods in a RoutedAgent class that are intended to handle RPC messages. These methods must have a specific signature that needs to be followed for it to be valid: The method must be an async method. The method must be decorated with the @message_handler decorator. The method must have exactly 3 arguments: self message: The message to be handled, this must be type-hinted with the message type that it is intended to handle. ctx: A autogen_core.MessageContext object. The method must be type hinted with what message types it can return as a response, or it can return None if it does not return anything. Handlers can handle more than one message type by accepting a Union of the message types. It can also return more than one message type by returning a Union of the message types. Parameters: func – The function to be decorated. strict – If True, the handler will raise an exception if the message type or return type is not in the target types. If False, it will log a warning instead. match – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called. class FunctionCall(id: 'str', arguments: 'str', name: 'str')[source]# Bases: object id: str# arguments: str# name: str# class TypeSubscription(topic_type: str, agent_type: str | AgentType, id: str | None = None)[source]# Bases: Subscription This subscription matches on topics based on the type and maps to agents using the source of the topic as the agent key. This subscription causes each source to have its own agent instance. Example from autogen_core import TypeSubscription subscription = TypeSubscription(topic_type=\"t1\", agent_type=\"a1\") In this case: A topic_id with type t1 and source s1 will be handled by an agent of type a1 with key s1 A topic_id with type t1 and source s2 will be handled by an agent of type a1 with key s2. Parameters: topic_type (str) – Topic type to match against agent_type (str) – Agent type to handle this subscription property id: str# Get the ID of the subscription. Implementations should return a unique ID for the subscription. Usually this is a UUID. Returns: str – ID of the subscription. property topic_type: str# property agent_type: str# is_match(topic_id: TopicId) → bool[source]# Check if a given topic_id matches the subscription. Parameters: topic_id (TopicId) – TopicId to check. Returns: bool – True if the topic_id matches the subscription, False otherwise. map_to_agent(topic_id: TopicId) → AgentId[source]# Map a topic_id to an agent. Should only be called if is_match returns True for the given topic_id. Parameters: topic_id (TopicId) – TopicId to map. Returns: AgentId – ID of the agent that should handle the topic_id. Raises: CantHandleException – If the subscription cannot handle the topic_id. class DefaultSubscription(topic_type: str = 'default', agent_type: str | AgentType | None = None)[source]# Bases: TypeSubscription The default subscription is designed to be a sensible default for applications that only need global scope for agents. This topic by default uses the “default” topic type and attempts to detect the agent type to use based on the instantiation context. Parameters: topic_type (str, optional) – The topic type to subscribe to. Defaults to “default”. agent_type (str, optional) – The agent type to use for the subscription. Defaults to None, in which case it will attempt to detect the agent type based on the instantiation context. class DefaultTopicId(type: str = 'default', source: str | None = None)[source]# Bases: TopicId DefaultTopicId provides a sensible default for the topic_id and source fields of a TopicId. If created in the context of a message handler, the source will be set to the agent_id of the message handler, otherwise it will be set to “default”. Parameters: type (str, optional) – Topic type to publish message to. Defaults to “default”. source (str | None, optional) – Topic source to publish message to. If None, the source will be set to the agent_id of the message handler if in the context of a message handler, otherwise it will be set to “default”. Defaults to None. default_subscription(cls: Type[BaseAgentType] | None = None) → Callable[[Type[BaseAgentType]], Type[BaseAgentType]] | Type[BaseAgentType][source]# type_subscription(topic_type: str) → Callable[[Type[BaseAgentType]], Type[BaseAgentType]][source]# class TypePrefixSubscription(topic_type_prefix: str, agent_type: str | AgentType, id: str | None = None)[source]# Bases: Subscription This subscription matches on topics based on a prefix of the type and maps to agents using the source of the topic as the agent key. This subscription causes each source to have its own agent instance. Example from autogen_core import TypePrefixSubscription subscription = TypePrefixSubscription(topic_type_prefix=\"t1\", agent_type=\"a1\") In this case: A topic_id with type t1 and source s1 will be handled by an agent of type a1 with key s1 A topic_id with type t1 and source s2 will be handled by an agent of type a1 with key s2. A topic_id with type t1SUFFIX and source s2 will be handled by an agent of type a1 with key s2. Parameters: topic_type_prefix (str) – Topic type prefix to match against agent_type (str) – Agent type to handle this subscription property id: str# Get the ID of the subscription. Implementations should return a unique ID for the subscription. Usually this is a UUID. Returns: str – ID of the subscription. property topic_type_prefix: str# property agent_type: str# is_match(topic_id: TopicId) → bool[source]# Check if a given topic_id matches the subscription. Parameters: topic_id (TopicId) – TopicId to check. Returns: bool – True if the topic_id matches the subscription, False otherwise. map_to_agent(topic_id: TopicId) → AgentId[source]# Map a topic_id to an agent. Should only be called if is_match returns True for the given topic_id. Parameters: topic_id (TopicId) – TopicId to map. Returns: AgentId – ID of the agent that should handle the topic_id. Raises: CantHandleException – If the subscription cannot handle the topic_id. JSON_DATA_CONTENT_TYPE = 'application/json'# The content type for JSON data. PROTOBUF_DATA_CONTENT_TYPE = 'application/x-protobuf'# The content type for Protobuf data. class SingleThreadedAgentRuntime(*, intervention_handlers: List[InterventionHandler] | None = None, tracer_provider: TracerProvider | None = None, ignore_unhandled_exceptions: bool = True)[source]# Bases: AgentRuntime A single-threaded agent runtime that processes all messages using a single asyncio queue. Messages are delivered in the order they are received, and the runtime processes each message in a separate asyncio task concurrently. Note This runtime is suitable for development and standalone applications. It is not suitable for high-throughput or high-concurrency scenarios. Parameters: intervention_handlers (List[InterventionHandler], optional) – A list of intervention handlers that can intercept messages before they are sent or published. Defaults to None. tracer_provider (TracerProvider, optional) – The tracer provider to use for tracing. Defaults to None. Additionally, you can set environment variable AUTOGEN_DISABLE_RUNTIME_TRACING to true to disable the agent runtime telemetry if you don’t have access to the runtime constructor. For example, if you are using ComponentConfig. ignore_unhandled_exceptions (bool, optional) – Whether to ignore unhandled exceptions in that occur in agent event handlers. Any background exceptions will be raised on the next call to process_next or from an awaited stop, stop_when_idle or stop_when. Note, this does not apply to RPC handlers. Defaults to True. Examples A simple example of creating a runtime, registering an agent, sending a message and stopping the runtime: import asyncio from dataclasses import dataclass from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): @message_handler async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None: print(f\"Received message: {message.content}\") async def main() -> None: # Create a runtime and register the agent runtime = SingleThreadedAgentRuntime() await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My agent\")) # Start the runtime, send a message and stop the runtime runtime.start() await runtime.send_message(MyMessage(\"Hello, world!\"), recipient=AgentId(\"my_agent\", \"default\")) await runtime.stop() asyncio.run(main()) An example of creating a runtime, registering an agent, publishing a message and stopping the runtime: import asyncio from dataclasses import dataclass from autogen_core import ( DefaultTopicId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, default_subscription, message_handler, ) @dataclass class MyMessage: content: str # The agent is subscribed to the default topic. @default_subscription class MyAgent(RoutedAgent): @message_handler async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None: print(f\"Received message: {message.content}\") async def main() -> None: # Create a runtime and register the agent runtime = SingleThreadedAgentRuntime() await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My agent\")) # Start the runtime. runtime.start() # Publish a message to the default topic that the agent is subscribed to. await runtime.publish_message(MyMessage(\"Hello, world!\"), DefaultTopicId()) # Wait for the message to be processed and then stop the runtime. await runtime.stop_when_idle() asyncio.run(main()) property unprocessed_messages_count: int# async send_message(message: Any, recipient: AgentId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# Send a message to an agent and get a response. Parameters: message (Any) – The message to send. recipient (AgentId) – The agent to send the message to. sender (AgentId | None, optional) – Agent which sent the message. Should only be None if this was sent from no agent, such as directly to the runtime externally. Defaults to None. cancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress . Defaults to None. Raises: CantHandleException – If the recipient cannot handle the message. UndeliverableException – If the message cannot be delivered. Other – Any other exception raised by the recipient. Returns: Any – The response from the agent. async publish_message(message: Any, topic_id: TopicId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → None[source]# Publish a message to all agents in the given namespace, or if no namespace is provided, the namespace of the sender. No responses are expected from publishing. Parameters: message (Any) – The message to publish. topic_id (TopicId) – The topic to publish the message to. sender (AgentId | None, optional) – The agent which sent the message. Defaults to None. cancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress. Defaults to None. message_id (str | None, optional) – The message id. If None, a new message id will be generated. Defaults to None. This message id must be unique. and is recommended to be a UUID. Raises: UndeliverableException – If the message cannot be delivered. async save_state() → Mapping[str, Any][source]# Save the state of all instantiated agents. This method calls the save_state() method on each agent and returns a dictionary mapping agent IDs to their state. Note This method does not currently save the subscription state. We will add this in the future. Returns: A dictionary mapping agent IDs to their state. async load_state(state: Mapping[str, Any]) → None[source]# Load the state of all instantiated agents. This method calls the load_state() method on each agent with the state provided in the dictionary. The keys of the dictionary are the agent IDs, and the values are the state dictionaries returned by the save_state() method. Note This method does not currently load the subscription state. We will add this in the future. async process_next() → None[source]# Process the next message in the queue. If there is an unhandled exception in the background task, it will be raised here. process_next cannot be called again after an unhandled exception is raised. start() → None[source]# Start the runtime message processing loop. This runs in a background task. Example: import asyncio from autogen_core import SingleThreadedAgentRuntime async def main() -> None: runtime = SingleThreadedAgentRuntime() runtime.start() # ... do other things ... await runtime.stop() asyncio.run(main()) async close() → None[source]# Calls stop() if applicable and the Agent.close() method on all instantiated agents async stop() → None[source]# Immediately stop the runtime message processing loop. The currently processing message will be completed, but all others following it will be discarded. async stop_when_idle() → None[source]# Stop the runtime message processing loop when there is no outstanding message being processed or queued. This is the most common way to stop the runtime. async stop_when(condition: Callable[[], bool]) → None[source]# Stop the runtime message processing loop when the condition is met. Caution This method is not recommended to be used, and is here for legacy reasons. It will spawn a busy loop to continually check the condition. It is much more efficient to call stop_when_idle or stop instead. If you need to stop the runtime based on a condition, consider using a background task and asyncio.Event to signal when the condition is met and the background task should call stop. async agent_metadata(agent: AgentId) → AgentMetadata[source]# Get the metadata for an agent. Parameters: agent (AgentId) – The agent id. Returns: AgentMetadata – The agent metadata. async agent_save_state(agent: AgentId) → Mapping[str, Any][source]# Save the state of a single agent. The structure of the state is implementation defined and can be any JSON serializable object. Parameters: agent (AgentId) – The agent id. Returns: Mapping[str, Any] – The saved state. async agent_load_state(agent: AgentId, state: Mapping[str, Any]) → None[source]# Load the state of a single agent. Parameters: agent (AgentId) – The agent id. state (Mapping[str, Any]) – The saved state. async register_factory(type: str | AgentType, agent_factory: Callable[[], T | Awaitable[T]], *, expected_class: type[T] | None = None) → AgentType[source]# Register an agent factory with the runtime associated with a specific type. The type must be unique. This API does not add any subscriptions. Note This is a low level API and usually the agent class’s register method should be used instead, as this also handles subscriptions automatically. Example: from dataclasses import dataclass from autogen_core import AgentRuntime, MessageContext, RoutedAgent, event from autogen_core.models import UserMessage @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): def __init__(self) -> None: super().__init__(\"My core agent\") @event async def handler(self, message: UserMessage, context: MessageContext) -> None: print(\"Event received: \", message.content) async def my_agent_factory(): return MyAgent() async def main() -> None: runtime: AgentRuntime = ... # type: ignore await runtime.register_factory(\"my_agent\", lambda: MyAgent()) import asyncio asyncio.run(main()) Parameters: type (str) – The type of agent this factory creates. It is not the same as agent class name. The type parameter is used to differentiate between different factory functions rather than agent classes. agent_factory (Callable[[], T]) – The factory that creates the agent, where T is a concrete Agent type. Inside the factory, use autogen_core.AgentInstantiationContext to access variables like the current runtime and agent ID. expected_class (type[T] | None, optional) – The expected class of the agent, used for runtime validation of the factory. Defaults to None. If None, no validation is performed. async register_agent_instance(agent_instance: Agent, agent_id: AgentId) → AgentId[source]# Register an agent instance with the runtime. The type may be reused, but each agent_id must be unique. All agent instances within a type must be of the same object type. This API does not add any subscriptions. Note This is a low level API and usually the agent class’s register_instance method should be used instead, as this also handles subscriptions automatically. Example: from dataclasses import dataclass from autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event from autogen_core.models import UserMessage @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): def __init__(self) -> None: super().__init__(\"My core agent\") @event async def handler(self, message: UserMessage, context: MessageContext) -> None: print(\"Event received: \", message.content) async def main() -> None: runtime: AgentRuntime = ... # type: ignore agent = MyAgent() await runtime.register_agent_instance( agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\") ) import asyncio asyncio.run(main()) Parameters: agent_instance (Agent) – A concrete instance of the agent. agent_id (AgentId) – The agent’s identifier. The agent’s type is agent_id.type. async try_get_underlying_agent_instance(id: AgentId, type: Type[T] = Agent) → T[source]# Try to get the underlying agent instance by name and namespace. This is generally discouraged (hence the long name), but can be useful in some cases. If the underlying agent is not accessible, this will raise an exception. Parameters: id (AgentId) – The agent id. type (Type[T], optional) – The expected type of the agent. Defaults to Agent. Returns: T – The concrete agent instance. Raises: LookupError – If the agent is not found. NotAccessibleError – If the agent is not accessible, for example if it is located remotely. TypeError – If the agent is not of the expected type. async add_subscription(subscription: Subscription) → None[source]# Add a new subscription that the runtime should fulfill when processing published messages Parameters: subscription (Subscription) – The subscription to add async remove_subscription(id: str) → None[source]# Remove a subscription from the runtime Parameters: id (str) – id of the subscription to remove Raises: LookupError – If the subscription does not exist async get(id_or_type: AgentId | AgentType | str, /, key: str = 'default', *, lazy: bool = True) → AgentId[source]# add_message_serializer(serializer: MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) → None[source]# Add a new message serialization serializer to the runtime Note: This will deduplicate serializers based on the type_name and data_content_type properties Parameters: serializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – The serializer/s to add ROOT_LOGGER_NAME = 'autogen_core'# The name of the root logger. EVENT_LOGGER_NAME = 'autogen_core.events'# The name of the logger used for structured events. TRACE_LOGGER_NAME = 'autogen_core.trace'# Logger name used for developer intended trace logging. The content and format of this log should not be depended upon. class Component[source]# Bases: ComponentFromConfig[ConfigT], ComponentSchemaType[ConfigT], Generic[ConfigT] To create a component class, inherit from this class for the concrete class and ComponentBase on the interface. Then implement two class variables: component_config_schema - A Pydantic model class which represents the configuration of the component. This is also the type parameter of Component. component_type - What is the logical type of the component. Example: from __future__ import annotations from pydantic import BaseModel from autogen_core import Component class Config(BaseModel): value: str class MyComponent(Component[Config]): component_type = \"custom\" component_config_schema = Config def __init__(self, value: str): self.value = value def _to_config(self) -> Config: return Config(value=self.value) @classmethod def _from_config(cls, config: Config) -> MyComponent: return cls(value=config.value) class ComponentBase[source]# Bases: ComponentToConfig[ConfigT], ComponentLoader, Generic[ConfigT] class ComponentFromConfig[source]# Bases: Generic[FromConfigT] classmethod _from_config(config: FromConfigT) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. classmethod _from_config_past_version(config: Dict[str, Any], version: int) → Self[source]# Create a new instance of the component from a previous version of the configuration object. This is only called when the version of the configuration object is less than the current version, since in this case the schema is not known. Parameters: config (Dict[str, Any]) – The configuration object. version (int) – The version of the configuration object. Returns: Self – The new instance of the component. class ComponentLoader[source]# Bases: object classmethod load_component(model: ComponentModel | Dict[str, Any], expected: None = None) → Self[source]# classmethod load_component(model: ComponentModel | Dict[str, Any], expected: Type[ExpectedType]) → ExpectedType Load a component from a model. Intended to be used with the return type of autogen_core.ComponentConfig.dump_component(). Example from autogen_core import ComponentModel from autogen_core.models import ChatCompletionClient component: ComponentModel = ... # type: ignore model_client = ChatCompletionClient.load_component(component) Parameters: model (ComponentModel) – The model to load the component from. model – _description_ expected (Type[ExpectedType] | None, optional) – Explicit type only if used directly on ComponentLoader. Defaults to None. Returns: Self – The loaded component. Raises: ValueError – If the provider string is invalid. TypeError – Provider is not a subclass of ComponentConfigImpl, or the expected type does not match. Returns: Self | ExpectedType – The loaded component. pydantic model ComponentModel[source]# Bases: BaseModel Model class for a component. Contains all information required to instantiate a component. Show JSON schema{ \"title\": \"ComponentModel\", \"description\": \"Model class for a component. Contains all information required to instantiate a component.\", \"type\": \"object\", \"properties\": { \"provider\": { \"title\": \"Provider\", \"type\": \"string\" }, \"component_type\": { \"anyOf\": [ { \"enum\": [ \"model\", \"agent\", \"tool\", \"termination\", \"token_provider\", \"workbench\" ], \"type\": \"string\" }, { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Component Type\" }, \"version\": { \"anyOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Version\" }, \"component_version\": { \"anyOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Component Version\" }, \"description\": { \"anyOf\": [ { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Description\" }, \"label\": { \"anyOf\": [ { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Label\" }, \"config\": { \"title\": \"Config\", \"type\": \"object\" } }, \"required\": [ \"provider\", \"config\" ] } Fields: component_type (Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str | None) component_version (int | None) config (dict[str, Any]) description (str | None) label (str | None) provider (str) version (int | None) field provider: str [Required]# Describes how the component can be instantiated. field component_type: ComponentType | None = None# Logical type of the component. If missing, the component assumes the default type of the provider. field version: int | None = None# Version of the component specification. If missing, the component assumes whatever is the current version of the library used to load it. This is obviously dangerous and should be used for user authored ephmeral config. For all other configs version should be specified. field component_version: int | None = None# Version of the component. If missing, the component assumes the default version of the provider. field description: str | None = None# Description of the component. field label: str | None = None# Human readable label for the component. If missing the component assumes the class name of the provider. field config: dict[str, Any] [Required]# The schema validated config field is passed to a given class’s implmentation of autogen_core.ComponentConfigImpl._from_config() to create a new instance of the component class. class ComponentSchemaType[source]# Bases: Generic[ConfigT] component_config_schema: Type[ConfigT]# The Pydantic model class which represents the configuration of the component. required_class_vars = ['component_config_schema', 'component_type']# class ComponentToConfig[source]# Bases: Generic[ToConfigT] The two methods a class must implement to be a component. Parameters: Protocol (ConfigT) – Type which derives from pydantic.BaseModel. component_type: ClassVar[Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str]# The logical type of the component. component_version: ClassVar[int] = 1# The version of the component, if schema incompatibilities are introduced this should be updated. component_provider_override: ClassVar[str | None] = None# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. component_description: ClassVar[str | None] = None# A description of the component. If not provided, the docstring of the class will be used. component_label: ClassVar[str | None] = None# A human readable label for the component. If not provided, the component class name will be used. _to_config() → ToConfigT[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. dump_component() → ComponentModel[source]# Dump the component to a model that can be loaded back in. Raises: TypeError – If the component is a local class. Returns: ComponentModel – The model representing the component. is_component_class(cls: type) → TypeGuard[Type[_ConcreteComponent[BaseModel]]][source]# is_component_instance(cls: Any) → TypeGuard[_ConcreteComponent[BaseModel]][source]# final class DropMessage[source]# Bases: object Marker type for signalling that a message should be dropped by an intervention handler. The type itself should be returned from the handler. class InterventionHandler(*args, **kwargs)[source]# Bases: Protocol An intervention handler is a class that can be used to modify, log or drop messages that are being processed by the autogen_core.base.AgentRuntime. The handler is called when the message is submitted to the runtime. Currently the only runtime which supports this is the autogen_core.base.SingleThreadedAgentRuntime. Note: Returning None from any of the intervention handler methods will result in a warning being issued and treated as “no change”. If you intend to drop a message, you should return DropMessage explicitly. Example: from autogen_core import DefaultInterventionHandler, MessageContext, AgentId, SingleThreadedAgentRuntime from dataclasses import dataclass from typing import Any @dataclass class MyMessage: content: str class MyInterventionHandler(DefaultInterventionHandler): async def on_send(self, message: Any, *, message_context: MessageContext, recipient: AgentId) -> MyMessage: if isinstance(message, MyMessage): message.content = message.content.upper() return message runtime = SingleThreadedAgentRuntime(intervention_handlers=[MyInterventionHandler()]) async on_send(message: Any, *, message_context: MessageContext, recipient: AgentId) → Any | type[DropMessage][source]# Called when a message is submitted to the AgentRuntime using autogen_core.base.AgentRuntime.send_message(). async on_publish(message: Any, *, message_context: MessageContext) → Any | type[DropMessage][source]# Called when a message is published to the AgentRuntime using autogen_core.base.AgentRuntime.publish_message(). async on_response(message: Any, *, sender: AgentId, recipient: AgentId | None) → Any | type[DropMessage][source]# Called when a response is received by the AgentRuntime from an Agent’s message handler returning a value. class DefaultInterventionHandler(*args, **kwargs)[source]# Bases: InterventionHandler Simple class that provides a default implementation for all intervention handler methods, that simply returns the message unchanged. Allows for easy subclassing to override only the desired methods. async on_send(message: Any, *, message_context: MessageContext, recipient: AgentId) → Any | type[DropMessage][source]# Called when a message is submitted to the AgentRuntime using autogen_core.base.AgentRuntime.send_message(). async on_publish(message: Any, *, message_context: MessageContext) → Any | type[DropMessage][source]# Called when a message is published to the AgentRuntime using autogen_core.base.AgentRuntime.publish_message(). async on_response(message: Any, *, sender: AgentId, recipient: AgentId | None) → Any | type[DropMessage][source]# Called when a response is received by the AgentRuntime from an Agent’s message handler returning a value. trace_create_agent_span(agent_name: str, *, tracer: Tracer | None = None, parent: Span | None = None, agent_id: str | None = None, agent_description: str | None = None) → Generator[Span, Any, None][source]# Context manager to create a span for agent creation following the OpenTelemetry Semantic conventions for generative AI systems. See the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions Warning The GenAI Semantic Conventions are still in incubation and subject to changes in future releases. Parameters: agent_name (str) – The name of the agent being created. tracer (Optional[trace.Tracer]) – The tracer to use for creating the span. parent (Optional[Span]) – The parent span to link this span to. agent_id (Optional[str]) – The unique identifier for the agent. agent_description (Optional[str]) – A description of the agent. trace_invoke_agent_span(agent_name: str, *, tracer: Tracer | None = None, parent: Span | None = None, agent_id: str | None = None, agent_description: str | None = None) → Generator[Span, Any, None][source]# Context manager to create a span for invoking an agent following the OpenTelemetry Semantic conventions for generative AI systems. See the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions Warning The GenAI Semantic Conventions are still in incubation and subject to changes in future releases. Parameters: agent_name (str) – The name of the agent being invoked. tracer (Optional[trace.Tracer]) – The tracer to use for creating the span. parent (Optional[Span]) – The parent span to link this span to. agent_id (Optional[str]) – The unique identifier for the agent. agent_description (Optional[str]) – A description of the agent. trace_tool_span(tool_name: str, *, tracer: Tracer | None = None, parent: Span | None = None, tool_description: str | None = None, tool_call_id: str | None = None) → Generator[Span, Any, None][source]# Context manager to create a span for tool execution following the OpenTelemetry Semantic conventions for generative AI systems. See the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions Warning The GenAI Semantic Conventions are still in incubation and subject to changes in future releases. Parameters: tool_name (str) – The name of the tool being executed. tracer (Optional[trace.Tracer]) – The tracer to use for creating the span. parent (Optional[Span]) – The parent span to link this span to. tool_description (Optional[str]) – A description of the tool. tool_call_id (Optional[str]) – A unique identifier for the tool call. previous autogen_agentchat.utils next autogen_core.code_executor On this page Agent Agent.metadata Agent.id Agent.bind_id_and_runtime() Agent.on_message() Agent.save_state() Agent.load_state() Agent.close() AgentId AgentId.from_str() AgentId.type AgentId.key AgentProxy AgentProxy.id AgentProxy.metadata AgentProxy.send_message() AgentProxy.save_state() AgentProxy.load_state() AgentMetadata AgentMetadata.type AgentMetadata.key AgentMetadata.description AgentRuntime AgentRuntime.send_message() AgentRuntime.publish_message() AgentRuntime.register_factory() AgentRuntime.register_agent_instance() AgentRuntime.try_get_underlying_agent_instance() AgentRuntime.get() AgentRuntime.save_state() AgentRuntime.load_state() AgentRuntime.agent_metadata() AgentRuntime.agent_save_state() AgentRuntime.agent_load_state() AgentRuntime.add_subscription() AgentRuntime.remove_subscription() AgentRuntime.add_message_serializer() BaseAgent BaseAgent.metadata BaseAgent.bind_id_and_runtime() BaseAgent.type BaseAgent.id BaseAgent.runtime BaseAgent.on_message() BaseAgent.on_message_impl() BaseAgent.send_message() BaseAgent.publish_message() BaseAgent.save_state() BaseAgent.load_state() BaseAgent.close() BaseAgent.register_instance() BaseAgent.register() CacheStore CacheStore.component_type CacheStore.get() CacheStore.set() InMemoryStore InMemoryStore.component_provider_override InMemoryStore.component_config_schema InMemoryStore.get() InMemoryStore.set() InMemoryStore._to_config() InMemoryStore._from_config() CancellationToken CancellationToken.cancel() CancellationToken.is_cancelled() CancellationToken.add_callback() CancellationToken.link_future() AgentInstantiationContext AgentInstantiationContext.current_runtime() AgentInstantiationContext.current_agent_id() AgentInstantiationContext.is_in_factory_call() TopicId TopicId.type TopicId.source TopicId.from_str() Subscription Subscription.id Subscription.is_match() Subscription.map_to_agent() MessageContext MessageContext.sender MessageContext.topic_id MessageContext.is_rpc MessageContext.cancellation_token MessageContext.message_id AgentType AgentType.type SubscriptionInstantiationContext SubscriptionInstantiationContext.agent_type() MessageHandlerContext MessageHandlerContext.agent_id() MessageSerializer MessageSerializer.data_content_type MessageSerializer.type_name MessageSerializer.deserialize() MessageSerializer.serialize() UnknownPayload UnknownPayload.type_name UnknownPayload.data_content_type UnknownPayload.payload Image Image.from_pil() Image.from_uri() Image.from_base64() Image.to_base64() Image.from_file() Image.data_uri Image.to_openai_format() RoutedAgent RoutedAgent.on_message_impl() RoutedAgent.on_unhandled_message() ClosureAgent ClosureAgent.metadata ClosureAgent.id ClosureAgent.runtime ClosureAgent.on_message_impl() ClosureAgent.save_state() ClosureAgent.load_state() ClosureAgent.register_closure() ClosureContext ClosureContext.id ClosureContext.send_message() ClosureContext.publish_message() message_handler() event() rpc() FunctionCall FunctionCall.id FunctionCall.arguments FunctionCall.name TypeSubscription TypeSubscription.id TypeSubscription.topic_type TypeSubscription.agent_type TypeSubscription.is_match() TypeSubscription.map_to_agent() DefaultSubscription DefaultTopicId default_subscription() type_subscription() TypePrefixSubscription TypePrefixSubscription.id TypePrefixSubscription.topic_type_prefix TypePrefixSubscription.agent_type TypePrefixSubscription.is_match() TypePrefixSubscription.map_to_agent() JSON_DATA_CONTENT_TYPE PROTOBUF_DATA_CONTENT_TYPE SingleThreadedAgentRuntime SingleThreadedAgentRuntime.unprocessed_messages_count SingleThreadedAgentRuntime.send_message() SingleThreadedAgentRuntime.publish_message() SingleThreadedAgentRuntime.save_state() SingleThreadedAgentRuntime.load_state() SingleThreadedAgentRuntime.process_next() SingleThreadedAgentRuntime.start() SingleThreadedAgentRuntime.close() SingleThreadedAgentRuntime.stop() SingleThreadedAgentRuntime.stop_when_idle() SingleThreadedAgentRuntime.stop_when() SingleThreadedAgentRuntime.agent_metadata() SingleThreadedAgentRuntime.agent_save_state() SingleThreadedAgentRuntime.agent_load_state() SingleThreadedAgentRuntime.register_factory() SingleThreadedAgentRuntime.register_agent_instance() SingleThreadedAgentRuntime.try_get_underlying_agent_instance() SingleThreadedAgentRuntime.add_subscription() SingleThreadedAgentRuntime.remove_subscription() SingleThreadedAgentRuntime.get() SingleThreadedAgentRuntime.add_message_serializer() ROOT_LOGGER_NAME EVENT_LOGGER_NAME TRACE_LOGGER_NAME Component ComponentBase ComponentFromConfig ComponentFromConfig._from_config() ComponentFromConfig._from_config_past_version() ComponentLoader ComponentLoader.load_component() ComponentModel ComponentModel.provider ComponentModel.component_type ComponentModel.version ComponentModel.component_version ComponentModel.description ComponentModel.label ComponentModel.config ComponentSchemaType ComponentSchemaType.component_config_schema ComponentSchemaType.required_class_vars ComponentToConfig ComponentToConfig.component_type ComponentToConfig.component_version ComponentToConfig.component_provider_override ComponentToConfig.component_description ComponentToConfig.component_label ComponentToConfig._to_config() ComponentToConfig.dump_component() is_component_class() is_component_instance() DropMessage InterventionHandler InterventionHandler.on_send() InterventionHandler.on_publish() InterventionHandler.on_response() DefaultInterventionHandler DefaultInterventionHandler.on_send() DefaultInterventionHandler.on_publish() DefaultInterventionHandler.on_response() trace_create_agent_span() trace_invoke_agent_span() trace_tool_span() Edit on GitHub Show Source",
      "code": "Protocol"
    },
    {
      "description": "API Reference autogen_core autogen_core# class Agent(*args, **kwargs)[source]# Bases: Protocol property metadata: AgentMetadata# Metadata of the agent. property id: AgentId# ID of the agent. async bind_id_and_runtime(id: AgentId, runtime: AgentRuntime) → None[source]# Function used to bind an Agent instance to an AgentRuntime. Parameters: agent_id (AgentId) – ID of the agent. runtime (AgentRuntime) – AgentRuntime instance to bind the agent to. async on_message(message: Any, ctx: MessageContext) → Any[source]# Message handler for the agent. This should only be called by the runtime, not by other agents. Parameters: message (Any) – Received message. Type is one of the types in subscriptions. ctx (MessageContext) – Context of the message. Returns: Any – Response to the message. Can be None. Raises: CancelledError – If the message was cancelled. CantHandleException – If the agent cannot handle the message. async save_state() → Mapping[str, Any][source]# Save the state of the agent. The result must be JSON serializable. async load_state(state: Mapping[str, Any]) → None[source]# Load in the state of the agent obtained from save_state. Parameters: state (Mapping[str, Any]) – State of the agent. Must be JSON serializable. async close() → None[source]# Called when the runtime is closed class AgentId(type: str | AgentType, key: str)[source]# Bases: object Agent ID uniquely identifies an agent instance within an agent runtime - including distributed runtime. It is the ‘address’ of the agent instance for receiving messages. See here for more information: Agent Identity and Lifecycle classmethod from_str(agent_id: str) → Self[source]# Convert a string of the format type/key into an AgentId property type: str# An identifier that associates an agent with a specific factory function. Strings may only be composed of alphanumeric letters (a-z) and (0-9), or underscores (_). property key: str# Agent instance identifier. Strings may only be composed of alphanumeric letters (a-z) and (0-9), or underscores (_). class AgentProxy(agent: AgentId, runtime: AgentRuntime)[source]# Bases: object A helper class that allows you to use an AgentId in place of its associated Agent property id: AgentId# Target agent for this proxy property metadata: Awaitable[AgentMetadata]# Metadata of the agent. async send_message(message: Any, *, sender: AgentId, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# async save_state() → Mapping[str, Any][source]# Save the state of the agent. The result must be JSON serializable. async load_state(state: Mapping[str, Any]) → None[source]# Load in the state of the agent obtained from save_state. Parameters: state (Mapping[str, Any]) – State of the agent. Must be JSON serializable. class AgentMetadata[source]# Bases: TypedDict type: str# key: str# description: str# class AgentRuntime(*args, **kwargs)[source]# Bases: Protocol async send_message(message: Any, recipient: AgentId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# Send a message to an agent and get a response. Parameters: message (Any) – The message to send. recipient (AgentId) – The agent to send the message to. sender (AgentId | None, optional) – Agent which sent the message. Should only be None if this was sent from no agent, such as directly to the runtime externally. Defaults to None. cancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress . Defaults to None. Raises: CantHandleException – If the recipient cannot handle the message. UndeliverableException – If the message cannot be delivered. Other – Any other exception raised by the recipient. Returns: Any – The response from the agent. async publish_message(message: Any, topic_id: TopicId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → None[source]# Publish a message to all agents in the given namespace, or if no namespace is provided, the namespace of the sender. No responses are expected from publishing. Parameters: message (Any) – The message to publish. topic_id (TopicId) – The topic to publish the message to. sender (AgentId | None, optional) – The agent which sent the message. Defaults to None. cancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress. Defaults to None. message_id (str | None, optional) – The message id. If None, a new message id will be generated. Defaults to None. This message id must be unique. and is recommended to be a UUID. Raises: UndeliverableException – If the message cannot be delivered. async register_factory(type: str | AgentType, agent_factory: Callable[[], T | Awaitable[T]], *, expected_class: type[T] | None = None) → AgentType[source]# Register an agent factory with the runtime associated with a specific type. The type must be unique. This API does not add any subscriptions. Note This is a low level API and usually the agent class’s register method should be used instead, as this also handles subscriptions automatically. Example: from dataclasses import dataclass from autogen_core import AgentRuntime, MessageContext, RoutedAgent, event from autogen_core.models import UserMessage @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): def __init__(self) -> None: super().__init__(\"My core agent\") @event async def handler(self, message: UserMessage, context: MessageContext) -> None: print(\"Event received: \", message.content) async def my_agent_factory(): return MyAgent() async def main() -> None: runtime: AgentRuntime = ... # type: ignore await runtime.register_factory(\"my_agent\", lambda: MyAgent()) import asyncio asyncio.run(main()) Parameters: type (str) – The type of agent this factory creates. It is not the same as agent class name. The type parameter is used to differentiate between different factory functions rather than agent classes. agent_factory (Callable[[], T]) – The factory that creates the agent, where T is a concrete Agent type. Inside the factory, use autogen_core.AgentInstantiationContext to access variables like the current runtime and agent ID. expected_class (type[T] | None, optional) – The expected class of the agent, used for runtime validation of the factory. Defaults to None. If None, no validation is performed. async register_agent_instance(agent_instance: Agent, agent_id: AgentId) → AgentId[source]# Register an agent instance with the runtime. The type may be reused, but each agent_id must be unique. All agent instances within a type must be of the same object type. This API does not add any subscriptions. Note This is a low level API and usually the agent class’s register_instance method should be used instead, as this also handles subscriptions automatically. Example: from dataclasses import dataclass from autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event from autogen_core.models import UserMessage @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): def __init__(self) -> None: super().__init__(\"My core agent\") @event async def handler(self, message: UserMessage, context: MessageContext) -> None: print(\"Event received: \", message.content) async def main() -> None: runtime: AgentRuntime = ... # type: ignore agent = MyAgent() await runtime.register_agent_instance( agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\") ) import asyncio asyncio.run(main()) Parameters: agent_instance (Agent) – A concrete instance of the agent. agent_id (AgentId) – The agent’s identifier. The agent’s type is agent_id.type. async try_get_underlying_agent_instance(id: AgentId, type: Type[T] = Agent) → T[source]# Try to get the underlying agent instance by name and namespace. This is generally discouraged (hence the long name), but can be useful in some cases. If the underlying agent is not accessible, this will raise an exception. Parameters: id (AgentId) – The agent id. type (Type[T], optional) – The expected type of the agent. Defaults to Agent. Returns: T – The concrete agent instance. Raises: LookupError – If the agent is not found. NotAccessibleError – If the agent is not accessible, for example if it is located remotely. TypeError – If the agent is not of the expected type. async get(id: AgentId, /, *, lazy: bool = True) → AgentId[source]# async get(type: AgentType | str, /, key: str = 'default', *, lazy: bool = True) → AgentId async save_state() → Mapping[str, Any][source]# Save the state of the entire runtime, including all hosted agents. The only way to restore the state is to pass it to load_state(). The structure of the state is implementation defined and can be any JSON serializable object. Returns: Mapping[str, Any] – The saved state. async load_state(state: Mapping[str, Any]) → None[source]# Load the state of the entire runtime, including all hosted agents. The state should be the same as the one returned by save_state(). Parameters: state (Mapping[str, Any]) – The saved state. async agent_metadata(agent: AgentId) → AgentMetadata[source]# Get the metadata for an agent. Parameters: agent (AgentId) – The agent id. Returns: AgentMetadata – The agent metadata. async agent_save_state(agent: AgentId) → Mapping[str, Any][source]# Save the state of a single agent. The structure of the state is implementation defined and can be any JSON serializable object. Parameters: agent (AgentId) – The agent id. Returns: Mapping[str, Any] – The saved state. async agent_load_state(agent: AgentId, state: Mapping[str, Any]) → None[source]# Load the state of a single agent. Parameters: agent (AgentId) – The agent id. state (Mapping[str, Any]) – The saved state. async add_subscription(subscription: Subscription) → None[source]# Add a new subscription that the runtime should fulfill when processing published messages Parameters: subscription (Subscription) – The subscription to add async remove_subscription(id: str) → None[source]# Remove a subscription from the runtime Parameters: id (str) – id of the subscription to remove Raises: LookupError – If the subscription does not exist add_message_serializer(serializer: MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) → None[source]# Add a new message serialization serializer to the runtime Note: This will deduplicate serializers based on the type_name and data_content_type properties Parameters: serializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – The serializer/s to add class BaseAgent(description: str)[source]# Bases: ABC, Agent property metadata: AgentMetadata# Metadata of the agent. async bind_id_and_runtime(id: AgentId, runtime: AgentRuntime) → None[source]# Function used to bind an Agent instance to an AgentRuntime. Parameters: agent_id (AgentId) – ID of the agent. runtime (AgentRuntime) – AgentRuntime instance to bind the agent to. property type: str# property id: AgentId# ID of the agent. property runtime: AgentRuntime# final async on_message(message: Any, ctx: MessageContext) → Any[source]# Message handler for the agent. This should only be called by the runtime, not by other agents. Parameters: message (Any) – Received message. Type is one of the types in subscriptions. ctx (MessageContext) – Context of the message. Returns: Any – Response to the message. Can be None. Raises: CancelledError – If the message was cancelled. CantHandleException – If the agent cannot handle the message. abstract async on_message_impl(message: Any, ctx: MessageContext) → Any[source]# async send_message(message: Any, recipient: AgentId, *, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# See autogen_core.AgentRuntime.send_message() for more information. async publish_message(message: Any, topic_id: TopicId, *, cancellation_token: CancellationToken | None = None) → None[source]# async save_state() → Mapping[str, Any][source]# Save the state of the agent. The result must be JSON serializable. async load_state(state: Mapping[str, Any]) → None[source]# Load in the state of the agent obtained from save_state. Parameters: state (Mapping[str, Any]) – State of the agent. Must be JSON serializable. async close() → None[source]# Called when the runtime is closed async register_instance(runtime: AgentRuntime, agent_id: AgentId, *, skip_class_subscriptions: bool = True, skip_direct_message_subscription: bool = False) → AgentId[source]# This function is similar to register but is used for registering an instance of an agent. A subscription based on the agent ID is created and added to the runtime. async classmethod register(runtime: AgentRuntime, type: str, factory: Callable[[], Self | Awaitable[Self]], *, skip_class_subscriptions: bool = False, skip_direct_message_subscription: bool = False) → AgentType[source]# Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. class CacheStore[source]# Bases: ABC, Generic[T], ComponentBase[BaseModel] This protocol defines the basic interface for store/cache operations. Sub-classes should handle the lifecycle of underlying storage. component_type: ClassVar[ComponentType] = 'cache_store'# The logical type of the component. abstract get(key: str, default: T | None = None) → T | None[source]# Retrieve an item from the store. Parameters: key – The key identifying the item in the store. default (optional) – The default value to return if the key is not found. Defaults to None. Returns: The value associated with the key if found, else the default value. abstract set(key: str, value: T) → None[source]# Set an item in the store. Parameters: key – The key under which the item is to be stored. value – The value to be stored in the store. class InMemoryStore[source]# Bases: CacheStore[T], Component[InMemoryStoreConfig] component_provider_override: ClassVar[str | None] = 'autogen_core.InMemoryStore'# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. component_config_schema# alias of InMemoryStoreConfig get(key: str, default: T | None = None) → T | None[source]# Retrieve an item from the store. Parameters: key – The key identifying the item in the store. default (optional) – The default value to return if the key is not found. Defaults to None. Returns: The value associated with the key if found, else the default value. set(key: str, value: T) → None[source]# Set an item in the store. Parameters: key – The key under which the item is to be stored. value – The value to be stored in the store. _to_config() → InMemoryStoreConfig[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. classmethod _from_config(config: InMemoryStoreConfig) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. class CancellationToken[source]# Bases: object A token used to cancel pending async calls cancel() → None[source]# Cancel pending async calls linked to this cancellation token. is_cancelled() → bool[source]# Check if the CancellationToken has been used add_callback(callback: Callable[[], None]) → None[source]# Attach a callback that will be called when cancel is invoked link_future(future: Future[Any]) → Future[Any][source]# Link a pending async call to a token to allow its cancellation class AgentInstantiationContext[source]# Bases: object A static class that provides context for agent instantiation. This static class can be used to access the current runtime and agent ID during agent instantiation – inside the factory function or the agent’s class constructor. Example Get the current runtime and agent ID inside the factory function and the agent’s constructor: import asyncio from dataclasses import dataclass from autogen_core import ( AgentId, AgentInstantiationContext, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler, ) @dataclass class TestMessage: content: str class TestAgent(RoutedAgent): def __init__(self, description: str): super().__init__(description) # Get the current runtime -- we don't use it here, but it's available. _ = AgentInstantiationContext.current_runtime() # Get the current agent ID. agent_id = AgentInstantiationContext.current_agent_id() print(f\"Current AgentID from constructor: {agent_id}\") @message_handler async def handle_test_message(self, message: TestMessage, ctx: MessageContext) -> None: print(f\"Received message: {message.content}\") def test_agent_factory() -> TestAgent: # Get the current runtime -- we don't use it here, but it's available. _ = AgentInstantiationContext.current_runtime() # Get the current agent ID. agent_id = AgentInstantiationContext.current_agent_id() print(f\"Current AgentID from factory: {agent_id}\") return TestAgent(description=\"Test agent\") async def main() -> None: # Create a SingleThreadedAgentRuntime instance. runtime = SingleThreadedAgentRuntime() # Start the runtime. runtime.start() # Register the agent type with a factory function. await runtime.register_factory(\"test_agent\", test_agent_factory) # Send a message to the agent. The runtime will instantiate the agent and call the message handler. await runtime.send_message(TestMessage(content=\"Hello, world!\"), AgentId(\"test_agent\", \"default\")) # Stop the runtime. await runtime.stop() asyncio.run(main()) classmethod current_runtime() → AgentRuntime[source]# classmethod current_agent_id() → AgentId[source]# classmethod is_in_factory_call() → bool[source]# class TopicId(type: str, source: str)[source]# Bases: object TopicId defines the scope of a broadcast message. In essence, agent runtime implements a publish-subscribe model through its broadcast API: when publishing a message, the topic must be specified. See here for more information: Topic type: str# Type of the event that this topic_id contains. Adhere’s to the cloud event spec. Must match the pattern: ^[w-.:=]+Z Learn more here: cloudevents/spec source: str# Identifies the context in which an event happened. Adhere’s to the cloud event spec. Learn more here: cloudevents/spec classmethod from_str(topic_id: str) → Self[source]# Convert a string of the format type/source into a TopicId class Subscription(*args, **kwargs)[source]# Bases: Protocol Subscriptions define the topics that an agent is interested in. property id: str# Get the ID of the subscription. Implementations should return a unique ID for the subscription. Usually this is a UUID. Returns: str – ID of the subscription. is_match(topic_id: TopicId) → bool[source]# Check if a given topic_id matches the subscription. Parameters: topic_id (TopicId) – TopicId to check. Returns: bool – True if the topic_id matches the subscription, False otherwise. map_to_agent(topic_id: TopicId) → AgentId[source]# Map a topic_id to an agent. Should only be called if is_match returns True for the given topic_id. Parameters: topic_id (TopicId) – TopicId to map. Returns: AgentId – ID of the agent that should handle the topic_id. Raises: CantHandleException – If the subscription cannot handle the topic_id. class MessageContext(sender: AgentId | None, topic_id: TopicId | None, is_rpc: bool, cancellation_token: CancellationToken, message_id: str)[source]# Bases: object sender: AgentId | None# topic_id: TopicId | None# is_rpc: bool# cancellation_token: CancellationToken# message_id: str# class AgentType(type: str)[source]# Bases: object type: str# String representation of this agent type. class SubscriptionInstantiationContext[source]# Bases: object classmethod agent_type() → AgentType[source]# class MessageHandlerContext[source]# Bases: object classmethod agent_id() → AgentId[source]# class MessageSerializer(*args, **kwargs)[source]# Bases: Protocol[T] property data_content_type: str# property type_name: str# deserialize(payload: bytes) → T[source]# serialize(message: T) → bytes[source]# class UnknownPayload(type_name: str, data_content_type: str, payload: bytes)[source]# Bases: object type_name: str# data_content_type: str# payload: bytes# class Image(image: Image)[source]# Bases: object Represents an image. Example Loading an image from a URL: from autogen_core import Image from PIL import Image as PILImage import aiohttp import asyncio async def from_url(url: str) -> Image: async with aiohttp.ClientSession() as session: async with session.get(url) as response: content = await response.read() return Image.from_pil(PILImage.open(content)) image = asyncio.run(from_url(\"https://example.com/image\")) classmethod from_pil(pil_image: Image) → Image[source]# classmethod from_uri(uri: str) → Image[source]# classmethod from_base64(base64_str: str) → Image[source]# to_base64() → str[source]# classmethod from_file(file_path: Path) → Image[source]# property data_uri: str# to_openai_format(detail: Literal['auto', 'low', 'high'] = 'auto') → Dict[str, Any][source]# class RoutedAgent(description: str)[source]# Bases: BaseAgent A base class for agents that route messages to handlers based on the type of the message and optional matching functions. To create a routed agent, subclass this class and add message handlers as methods decorated with either event() or rpc() decorator. Example: from dataclasses import dataclass from autogen_core import MessageContext from autogen_core import RoutedAgent, event, rpc @dataclass class Message: pass @dataclass class MessageWithContent: content: str @dataclass class Response: pass class MyAgent(RoutedAgent): def __init__(self): super().__init__(\"MyAgent\") @event async def handle_event_message(self, message: Message, ctx: MessageContext) -> None: assert ctx.topic_id is not None await self.publish_message(MessageWithContent(\"event handled\"), ctx.topic_id) @rpc(match=lambda message, ctx: message.content == \"special\") # type: ignore async def handle_special_rpc_message(self, message: MessageWithContent, ctx: MessageContext) -> Response: return Response() async on_message_impl(message: Any, ctx: MessageContext) → Any | None[source]# Handle a message by routing it to the appropriate message handler. Do not override this method in subclasses. Instead, add message handlers as methods decorated with either the event() or rpc() decorator. async on_unhandled_message(message: Any, ctx: MessageContext) → None[source]# Called when a message is received that does not have a matching message handler. The default implementation logs an info message. class ClosureAgent(description: str, closure: Callable[[ClosureContext, T, MessageContext], Awaitable[Any]], *, unknown_type_policy: Literal['error', 'warn', 'ignore'] = 'warn')[source]# Bases: BaseAgent, ClosureContext property metadata: AgentMetadata# Metadata of the agent. property id: AgentId# ID of the agent. property runtime: AgentRuntime# async on_message_impl(message: Any, ctx: MessageContext) → Any[source]# async save_state() → Mapping[str, Any][source]# Closure agents do not have state. So this method always returns an empty dictionary. async load_state(state: Mapping[str, Any]) → None[source]# Closure agents do not have state. So this method does nothing. async classmethod register_closure(runtime: AgentRuntime, type: str, closure: Callable[[ClosureContext, T, MessageContext], Awaitable[Any]], *, unknown_type_policy: Literal['error', 'warn', 'ignore'] = 'warn', skip_direct_message_subscription: bool = False, description: str = '', subscriptions: Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None = None) → AgentType[source]# The closure agent allows you to define an agent using a closure, or function without needing to define a class. It allows values to be extracted out of the runtime. The closure can define the type of message which is expected, or Any can be used to accept any type of message. Example: import asyncio from autogen_core import SingleThreadedAgentRuntime, MessageContext, ClosureAgent, ClosureContext from dataclasses import dataclass from autogen_core._default_subscription import DefaultSubscription from autogen_core._default_topic import DefaultTopicId @dataclass class MyMessage: content: str async def main(): queue = asyncio.Queue[MyMessage]() async def output_result(_ctx: ClosureContext, message: MyMessage, ctx: MessageContext) -> None: await queue.put(message) runtime = SingleThreadedAgentRuntime() await ClosureAgent.register_closure( runtime, \"output_result\", output_result, subscriptions=lambda: [DefaultSubscription()] ) runtime.start() await runtime.publish_message(MyMessage(\"Hello, world!\"), DefaultTopicId()) await runtime.stop_when_idle() result = await queue.get() print(result) asyncio.run(main()) Parameters: runtime (AgentRuntime) – Runtime to register the agent to type (str) – Agent type of registered agent closure (Callable[[ClosureContext, T, MessageContext], Awaitable[Any]]) – Closure to handle messages unknown_type_policy (Literal[\"error\", \"warn\", \"ignore\"], optional) – What to do if a type is encountered that does not match the closure type. Defaults to “warn”. skip_direct_message_subscription (bool, optional) – Do not add direct message subscription for this agent. Defaults to False. description (str, optional) – Description of what agent does. Defaults to “”. subscriptions (Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None, optional) – List of subscriptions for this closure agent. Defaults to None. Returns: AgentType – Type of the agent that was registered class ClosureContext(*args, **kwargs)[source]# Bases: Protocol property id: AgentId# async send_message(message: Any, recipient: AgentId, *, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# async publish_message(message: Any, topic_id: TopicId, *, cancellation_token: CancellationToken | None = None) → None[source]# message_handler(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]]], MessageHandler[AgentT, ReceivesT, ProducesT]] | MessageHandler[AgentT, ReceivesT, ProducesT][source]# Decorator for generic message handlers. Add this decorator to methods in a RoutedAgent class that are intended to handle both event and RPC messages. These methods must have a specific signature that needs to be followed for it to be valid: The method must be an async method. The method must be decorated with the @message_handler decorator. The method must have exactly 3 arguments: self message: The message to be handled, this must be type-hinted with the message type that it is intended to handle. ctx: A autogen_core.MessageContext object. The method must be type hinted with what message types it can return as a response, or it can return None if it does not return anything. Handlers can handle more than one message type by accepting a Union of the message types. It can also return more than one message type by returning a Union of the message types. Parameters: func – The function to be decorated. strict – If True, the handler will raise an exception if the message type or return type is not in the target types. If False, it will log a warning instead. match – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called. event(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, None]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, None]]], MessageHandler[AgentT, ReceivesT, None]] | MessageHandler[AgentT, ReceivesT, None][source]# Decorator for event message handlers. Add this decorator to methods in a RoutedAgent class that are intended to handle event messages. These methods must have a specific signature that needs to be followed for it to be valid: The method must be an async method. The method must be decorated with the @message_handler decorator. The method must have exactly 3 arguments: self message: The event message to be handled, this must be type-hinted with the message type that it is intended to handle. ctx: A autogen_core.MessageContext object. The method must return None. Handlers can handle more than one message type by accepting a Union of the message types. Parameters: func – The function to be decorated. strict – If True, the handler will raise an exception if the message type is not in the target types. If False, it will log a warning instead. match – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called. rpc(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]]], MessageHandler[AgentT, ReceivesT, ProducesT]] | MessageHandler[AgentT, ReceivesT, ProducesT][source]# Decorator for RPC message handlers. Add this decorator to methods in a RoutedAgent class that are intended to handle RPC messages. These methods must have a specific signature that needs to be followed for it to be valid: The method must be an async method. The method must be decorated with the @message_handler decorator. The method must have exactly 3 arguments: self message: The message to be handled, this must be type-hinted with the message type that it is intended to handle. ctx: A autogen_core.MessageContext object. The method must be type hinted with what message types it can return as a response, or it can return None if it does not return anything. Handlers can handle more than one message type by accepting a Union of the message types. It can also return more than one message type by returning a Union of the message types. Parameters: func – The function to be decorated. strict – If True, the handler will raise an exception if the message type or return type is not in the target types. If False, it will log a warning instead. match – A function that takes the message and the context as arguments and returns a boolean. This is used for secondary routing after the message type. For handlers addressing the same message type, the match function is applied in alphabetical order of the handlers and the first matching handler will be called while the rest are skipped. If None, the first handler in alphabetical order matching the same message type will be called. class FunctionCall(id: 'str', arguments: 'str', name: 'str')[source]# Bases: object id: str# arguments: str# name: str# class TypeSubscription(topic_type: str, agent_type: str | AgentType, id: str | None = None)[source]# Bases: Subscription This subscription matches on topics based on the type and maps to agents using the source of the topic as the agent key. This subscription causes each source to have its own agent instance. Example from autogen_core import TypeSubscription subscription = TypeSubscription(topic_type=\"t1\", agent_type=\"a1\") In this case: A topic_id with type t1 and source s1 will be handled by an agent of type a1 with key s1 A topic_id with type t1 and source s2 will be handled by an agent of type a1 with key s2. Parameters: topic_type (str) – Topic type to match against agent_type (str) – Agent type to handle this subscription property id: str# Get the ID of the subscription. Implementations should return a unique ID for the subscription. Usually this is a UUID. Returns: str – ID of the subscription. property topic_type: str# property agent_type: str# is_match(topic_id: TopicId) → bool[source]# Check if a given topic_id matches the subscription. Parameters: topic_id (TopicId) – TopicId to check. Returns: bool – True if the topic_id matches the subscription, False otherwise. map_to_agent(topic_id: TopicId) → AgentId[source]# Map a topic_id to an agent. Should only be called if is_match returns True for the given topic_id. Parameters: topic_id (TopicId) – TopicId to map. Returns: AgentId – ID of the agent that should handle the topic_id. Raises: CantHandleException – If the subscription cannot handle the topic_id. class DefaultSubscription(topic_type: str = 'default', agent_type: str | AgentType | None = None)[source]# Bases: TypeSubscription The default subscription is designed to be a sensible default for applications that only need global scope for agents. This topic by default uses the “default” topic type and attempts to detect the agent type to use based on the instantiation context. Parameters: topic_type (str, optional) – The topic type to subscribe to. Defaults to “default”. agent_type (str, optional) – The agent type to use for the subscription. Defaults to None, in which case it will attempt to detect the agent type based on the instantiation context. class DefaultTopicId(type: str = 'default', source: str | None = None)[source]# Bases: TopicId DefaultTopicId provides a sensible default for the topic_id and source fields of a TopicId. If created in the context of a message handler, the source will be set to the agent_id of the message handler, otherwise it will be set to “default”. Parameters: type (str, optional) – Topic type to publish message to. Defaults to “default”. source (str | None, optional) – Topic source to publish message to. If None, the source will be set to the agent_id of the message handler if in the context of a message handler, otherwise it will be set to “default”. Defaults to None. default_subscription(cls: Type[BaseAgentType] | None = None) → Callable[[Type[BaseAgentType]], Type[BaseAgentType]] | Type[BaseAgentType][source]# type_subscription(topic_type: str) → Callable[[Type[BaseAgentType]], Type[BaseAgentType]][source]# class TypePrefixSubscription(topic_type_prefix: str, agent_type: str | AgentType, id: str | None = None)[source]# Bases: Subscription This subscription matches on topics based on a prefix of the type and maps to agents using the source of the topic as the agent key. This subscription causes each source to have its own agent instance. Example from autogen_core import TypePrefixSubscription subscription = TypePrefixSubscription(topic_type_prefix=\"t1\", agent_type=\"a1\") In this case: A topic_id with type t1 and source s1 will be handled by an agent of type a1 with key s1 A topic_id with type t1 and source s2 will be handled by an agent of type a1 with key s2. A topic_id with type t1SUFFIX and source s2 will be handled by an agent of type a1 with key s2. Parameters: topic_type_prefix (str) – Topic type prefix to match against agent_type (str) – Agent type to handle this subscription property id: str# Get the ID of the subscription. Implementations should return a unique ID for the subscription. Usually this is a UUID. Returns: str – ID of the subscription. property topic_type_prefix: str# property agent_type: str# is_match(topic_id: TopicId) → bool[source]# Check if a given topic_id matches the subscription. Parameters: topic_id (TopicId) – TopicId to check. Returns: bool – True if the topic_id matches the subscription, False otherwise. map_to_agent(topic_id: TopicId) → AgentId[source]# Map a topic_id to an agent. Should only be called if is_match returns True for the given topic_id. Parameters: topic_id (TopicId) – TopicId to map. Returns: AgentId – ID of the agent that should handle the topic_id. Raises: CantHandleException – If the subscription cannot handle the topic_id. JSON_DATA_CONTENT_TYPE = 'application/json'# The content type for JSON data. PROTOBUF_DATA_CONTENT_TYPE = 'application/x-protobuf'# The content type for Protobuf data. class SingleThreadedAgentRuntime(*, intervention_handlers: List[InterventionHandler] | None = None, tracer_provider: TracerProvider | None = None, ignore_unhandled_exceptions: bool = True)[source]# Bases: AgentRuntime A single-threaded agent runtime that processes all messages using a single asyncio queue. Messages are delivered in the order they are received, and the runtime processes each message in a separate asyncio task concurrently. Note This runtime is suitable for development and standalone applications. It is not suitable for high-throughput or high-concurrency scenarios. Parameters: intervention_handlers (List[InterventionHandler], optional) – A list of intervention handlers that can intercept messages before they are sent or published. Defaults to None. tracer_provider (TracerProvider, optional) – The tracer provider to use for tracing. Defaults to None. Additionally, you can set environment variable AUTOGEN_DISABLE_RUNTIME_TRACING to true to disable the agent runtime telemetry if you don’t have access to the runtime constructor. For example, if you are using ComponentConfig. ignore_unhandled_exceptions (bool, optional) – Whether to ignore unhandled exceptions in that occur in agent event handlers. Any background exceptions will be raised on the next call to process_next or from an awaited stop, stop_when_idle or stop_when. Note, this does not apply to RPC handlers. Defaults to True. Examples A simple example of creating a runtime, registering an agent, sending a message and stopping the runtime: import asyncio from dataclasses import dataclass from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): @message_handler async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None: print(f\"Received message: {message.content}\") async def main() -> None: # Create a runtime and register the agent runtime = SingleThreadedAgentRuntime() await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My agent\")) # Start the runtime, send a message and stop the runtime runtime.start() await runtime.send_message(MyMessage(\"Hello, world!\"), recipient=AgentId(\"my_agent\", \"default\")) await runtime.stop() asyncio.run(main()) An example of creating a runtime, registering an agent, publishing a message and stopping the runtime: import asyncio from dataclasses import dataclass from autogen_core import ( DefaultTopicId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, default_subscription, message_handler, ) @dataclass class MyMessage: content: str # The agent is subscribed to the default topic. @default_subscription class MyAgent(RoutedAgent): @message_handler async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None: print(f\"Received message: {message.content}\") async def main() -> None: # Create a runtime and register the agent runtime = SingleThreadedAgentRuntime() await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My agent\")) # Start the runtime. runtime.start() # Publish a message to the default topic that the agent is subscribed to. await runtime.publish_message(MyMessage(\"Hello, world!\"), DefaultTopicId()) # Wait for the message to be processed and then stop the runtime. await runtime.stop_when_idle() asyncio.run(main()) property unprocessed_messages_count: int# async send_message(message: Any, recipient: AgentId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]# Send a message to an agent and get a response. Parameters: message (Any) – The message to send. recipient (AgentId) – The agent to send the message to. sender (AgentId | None, optional) – Agent which sent the message. Should only be None if this was sent from no agent, such as directly to the runtime externally. Defaults to None. cancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress . Defaults to None. Raises: CantHandleException – If the recipient cannot handle the message. UndeliverableException – If the message cannot be delivered. Other – Any other exception raised by the recipient. Returns: Any – The response from the agent. async publish_message(message: Any, topic_id: TopicId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → None[source]# Publish a message to all agents in the given namespace, or if no namespace is provided, the namespace of the sender. No responses are expected from publishing. Parameters: message (Any) – The message to publish. topic_id (TopicId) – The topic to publish the message to. sender (AgentId | None, optional) – The agent which sent the message. Defaults to None. cancellation_token (CancellationToken | None, optional) – Token used to cancel an in progress. Defaults to None. message_id (str | None, optional) – The message id. If None, a new message id will be generated. Defaults to None. This message id must be unique. and is recommended to be a UUID. Raises: UndeliverableException – If the message cannot be delivered. async save_state() → Mapping[str, Any][source]# Save the state of all instantiated agents. This method calls the save_state() method on each agent and returns a dictionary mapping agent IDs to their state. Note This method does not currently save the subscription state. We will add this in the future. Returns: A dictionary mapping agent IDs to their state. async load_state(state: Mapping[str, Any]) → None[source]# Load the state of all instantiated agents. This method calls the load_state() method on each agent with the state provided in the dictionary. The keys of the dictionary are the agent IDs, and the values are the state dictionaries returned by the save_state() method. Note This method does not currently load the subscription state. We will add this in the future. async process_next() → None[source]# Process the next message in the queue. If there is an unhandled exception in the background task, it will be raised here. process_next cannot be called again after an unhandled exception is raised. start() → None[source]# Start the runtime message processing loop. This runs in a background task. Example: import asyncio from autogen_core import SingleThreadedAgentRuntime async def main() -> None: runtime = SingleThreadedAgentRuntime() runtime.start() # ... do other things ... await runtime.stop() asyncio.run(main()) async close() → None[source]# Calls stop() if applicable and the Agent.close() method on all instantiated agents async stop() → None[source]# Immediately stop the runtime message processing loop. The currently processing message will be completed, but all others following it will be discarded. async stop_when_idle() → None[source]# Stop the runtime message processing loop when there is no outstanding message being processed or queued. This is the most common way to stop the runtime. async stop_when(condition: Callable[[], bool]) → None[source]# Stop the runtime message processing loop when the condition is met. Caution This method is not recommended to be used, and is here for legacy reasons. It will spawn a busy loop to continually check the condition. It is much more efficient to call stop_when_idle or stop instead. If you need to stop the runtime based on a condition, consider using a background task and asyncio.Event to signal when the condition is met and the background task should call stop. async agent_metadata(agent: AgentId) → AgentMetadata[source]# Get the metadata for an agent. Parameters: agent (AgentId) – The agent id. Returns: AgentMetadata – The agent metadata. async agent_save_state(agent: AgentId) → Mapping[str, Any][source]# Save the state of a single agent. The structure of the state is implementation defined and can be any JSON serializable object. Parameters: agent (AgentId) – The agent id. Returns: Mapping[str, Any] – The saved state. async agent_load_state(agent: AgentId, state: Mapping[str, Any]) → None[source]# Load the state of a single agent. Parameters: agent (AgentId) – The agent id. state (Mapping[str, Any]) – The saved state. async register_factory(type: str | AgentType, agent_factory: Callable[[], T | Awaitable[T]], *, expected_class: type[T] | None = None) → AgentType[source]# Register an agent factory with the runtime associated with a specific type. The type must be unique. This API does not add any subscriptions. Note This is a low level API and usually the agent class’s register method should be used instead, as this also handles subscriptions automatically. Example: from dataclasses import dataclass from autogen_core import AgentRuntime, MessageContext, RoutedAgent, event from autogen_core.models import UserMessage @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): def __init__(self) -> None: super().__init__(\"My core agent\") @event async def handler(self, message: UserMessage, context: MessageContext) -> None: print(\"Event received: \", message.content) async def my_agent_factory(): return MyAgent() async def main() -> None: runtime: AgentRuntime = ... # type: ignore await runtime.register_factory(\"my_agent\", lambda: MyAgent()) import asyncio asyncio.run(main()) Parameters: type (str) – The type of agent this factory creates. It is not the same as agent class name. The type parameter is used to differentiate between different factory functions rather than agent classes. agent_factory (Callable[[], T]) – The factory that creates the agent, where T is a concrete Agent type. Inside the factory, use autogen_core.AgentInstantiationContext to access variables like the current runtime and agent ID. expected_class (type[T] | None, optional) – The expected class of the agent, used for runtime validation of the factory. Defaults to None. If None, no validation is performed. async register_agent_instance(agent_instance: Agent, agent_id: AgentId) → AgentId[source]# Register an agent instance with the runtime. The type may be reused, but each agent_id must be unique. All agent instances within a type must be of the same object type. This API does not add any subscriptions. Note This is a low level API and usually the agent class’s register_instance method should be used instead, as this also handles subscriptions automatically. Example: from dataclasses import dataclass from autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event from autogen_core.models import UserMessage @dataclass class MyMessage: content: str class MyAgent(RoutedAgent): def __init__(self) -> None: super().__init__(\"My core agent\") @event async def handler(self, message: UserMessage, context: MessageContext) -> None: print(\"Event received: \", message.content) async def main() -> None: runtime: AgentRuntime = ... # type: ignore agent = MyAgent() await runtime.register_agent_instance( agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\") ) import asyncio asyncio.run(main()) Parameters: agent_instance (Agent) – A concrete instance of the agent. agent_id (AgentId) – The agent’s identifier. The agent’s type is agent_id.type. async try_get_underlying_agent_instance(id: AgentId, type: Type[T] = Agent) → T[source]# Try to get the underlying agent instance by name and namespace. This is generally discouraged (hence the long name), but can be useful in some cases. If the underlying agent is not accessible, this will raise an exception. Parameters: id (AgentId) – The agent id. type (Type[T], optional) – The expected type of the agent. Defaults to Agent. Returns: T – The concrete agent instance. Raises: LookupError – If the agent is not found. NotAccessibleError – If the agent is not accessible, for example if it is located remotely. TypeError – If the agent is not of the expected type. async add_subscription(subscription: Subscription) → None[source]# Add a new subscription that the runtime should fulfill when processing published messages Parameters: subscription (Subscription) – The subscription to add async remove_subscription(id: str) → None[source]# Remove a subscription from the runtime Parameters: id (str) – id of the subscription to remove Raises: LookupError – If the subscription does not exist async get(id_or_type: AgentId | AgentType | str, /, key: str = 'default', *, lazy: bool = True) → AgentId[source]# add_message_serializer(serializer: MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) → None[source]# Add a new message serialization serializer to the runtime Note: This will deduplicate serializers based on the type_name and data_content_type properties Parameters: serializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – The serializer/s to add ROOT_LOGGER_NAME = 'autogen_core'# The name of the root logger. EVENT_LOGGER_NAME = 'autogen_core.events'# The name of the logger used for structured events. TRACE_LOGGER_NAME = 'autogen_core.trace'# Logger name used for developer intended trace logging. The content and format of this log should not be depended upon. class Component[source]# Bases: ComponentFromConfig[ConfigT], ComponentSchemaType[ConfigT], Generic[ConfigT] To create a component class, inherit from this class for the concrete class and ComponentBase on the interface. Then implement two class variables: component_config_schema - A Pydantic model class which represents the configuration of the component. This is also the type parameter of Component. component_type - What is the logical type of the component. Example: from __future__ import annotations from pydantic import BaseModel from autogen_core import Component class Config(BaseModel): value: str class MyComponent(Component[Config]): component_type = \"custom\" component_config_schema = Config def __init__(self, value: str): self.value = value def _to_config(self) -> Config: return Config(value=self.value) @classmethod def _from_config(cls, config: Config) -> MyComponent: return cls(value=config.value) class ComponentBase[source]# Bases: ComponentToConfig[ConfigT], ComponentLoader, Generic[ConfigT] class ComponentFromConfig[source]# Bases: Generic[FromConfigT] classmethod _from_config(config: FromConfigT) → Self[source]# Create a new instance of the component from a configuration object. Parameters: config (T) – The configuration object. Returns: Self – The new instance of the component. classmethod _from_config_past_version(config: Dict[str, Any], version: int) → Self[source]# Create a new instance of the component from a previous version of the configuration object. This is only called when the version of the configuration object is less than the current version, since in this case the schema is not known. Parameters: config (Dict[str, Any]) – The configuration object. version (int) – The version of the configuration object. Returns: Self – The new instance of the component. class ComponentLoader[source]# Bases: object classmethod load_component(model: ComponentModel | Dict[str, Any], expected: None = None) → Self[source]# classmethod load_component(model: ComponentModel | Dict[str, Any], expected: Type[ExpectedType]) → ExpectedType Load a component from a model. Intended to be used with the return type of autogen_core.ComponentConfig.dump_component(). Example from autogen_core import ComponentModel from autogen_core.models import ChatCompletionClient component: ComponentModel = ... # type: ignore model_client = ChatCompletionClient.load_component(component) Parameters: model (ComponentModel) – The model to load the component from. model – _description_ expected (Type[ExpectedType] | None, optional) – Explicit type only if used directly on ComponentLoader. Defaults to None. Returns: Self – The loaded component. Raises: ValueError – If the provider string is invalid. TypeError – Provider is not a subclass of ComponentConfigImpl, or the expected type does not match. Returns: Self | ExpectedType – The loaded component. pydantic model ComponentModel[source]# Bases: BaseModel Model class for a component. Contains all information required to instantiate a component. Show JSON schema{ \"title\": \"ComponentModel\", \"description\": \"Model class for a component. Contains all information required to instantiate a component.\", \"type\": \"object\", \"properties\": { \"provider\": { \"title\": \"Provider\", \"type\": \"string\" }, \"component_type\": { \"anyOf\": [ { \"enum\": [ \"model\", \"agent\", \"tool\", \"termination\", \"token_provider\", \"workbench\" ], \"type\": \"string\" }, { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Component Type\" }, \"version\": { \"anyOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Version\" }, \"component_version\": { \"anyOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Component Version\" }, \"description\": { \"anyOf\": [ { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Description\" }, \"label\": { \"anyOf\": [ { \"type\": \"string\" }, { \"type\": \"null\" } ], \"default\": null, \"title\": \"Label\" }, \"config\": { \"title\": \"Config\", \"type\": \"object\" } }, \"required\": [ \"provider\", \"config\" ] } Fields: component_type (Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str | None) component_version (int | None) config (dict[str, Any]) description (str | None) label (str | None) provider (str) version (int | None) field provider: str [Required]# Describes how the component can be instantiated. field component_type: ComponentType | None = None# Logical type of the component. If missing, the component assumes the default type of the provider. field version: int | None = None# Version of the component specification. If missing, the component assumes whatever is the current version of the library used to load it. This is obviously dangerous and should be used for user authored ephmeral config. For all other configs version should be specified. field component_version: int | None = None# Version of the component. If missing, the component assumes the default version of the provider. field description: str | None = None# Description of the component. field label: str | None = None# Human readable label for the component. If missing the component assumes the class name of the provider. field config: dict[str, Any] [Required]# The schema validated config field is passed to a given class’s implmentation of autogen_core.ComponentConfigImpl._from_config() to create a new instance of the component class. class ComponentSchemaType[source]# Bases: Generic[ConfigT] component_config_schema: Type[ConfigT]# The Pydantic model class which represents the configuration of the component. required_class_vars = ['component_config_schema', 'component_type']# class ComponentToConfig[source]# Bases: Generic[ToConfigT] The two methods a class must implement to be a component. Parameters: Protocol (ConfigT) – Type which derives from pydantic.BaseModel. component_type: ClassVar[Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str]# The logical type of the component. component_version: ClassVar[int] = 1# The version of the component, if schema incompatibilities are introduced this should be updated. component_provider_override: ClassVar[str | None] = None# Override the provider string for the component. This should be used to prevent internal module names being a part of the module name. component_description: ClassVar[str | None] = None# A description of the component. If not provided, the docstring of the class will be used. component_label: ClassVar[str | None] = None# A human readable label for the component. If not provided, the component class name will be used. _to_config() → ToConfigT[source]# Dump the configuration that would be requite to create a new instance of a component matching the configuration of this instance. Returns: T – The configuration of the component. dump_component() → ComponentModel[source]# Dump the component to a model that can be loaded back in. Raises: TypeError – If the component is a local class. Returns: ComponentModel – The model representing the component. is_component_class(cls: type) → TypeGuard[Type[_ConcreteComponent[BaseModel]]][source]# is_component_instance(cls: Any) → TypeGuard[_ConcreteComponent[BaseModel]][source]# final class DropMessage[source]# Bases: object Marker type for signalling that a message should be dropped by an intervention handler. The type itself should be returned from the handler. class InterventionHandler(*args, **kwargs)[source]# Bases: Protocol An intervention handler is a class that can be used to modify, log or drop messages that are being processed by the autogen_core.base.AgentRuntime. The handler is called when the message is submitted to the runtime. Currently the only runtime which supports this is the autogen_core.base.SingleThreadedAgentRuntime. Note: Returning None from any of the intervention handler methods will result in a warning being issued and treated as “no change”. If you intend to drop a message, you should return DropMessage explicitly. Example: from autogen_core import DefaultInterventionHandler, MessageContext, AgentId, SingleThreadedAgentRuntime from dataclasses import dataclass from typing import Any @dataclass class MyMessage: content: str class MyInterventionHandler(DefaultInterventionHandler): async def on_send(self, message: Any, *, message_context: MessageContext, recipient: AgentId) -> MyMessage: if isinstance(message, MyMessage): message.content = message.content.upper() return message runtime = SingleThreadedAgentRuntime(intervention_handlers=[MyInterventionHandler()]) async on_send(message: Any, *, message_context: MessageContext, recipient: AgentId) → Any | type[DropMessage][source]# Called when a message is submitted to the AgentRuntime using autogen_core.base.AgentRuntime.send_message(). async on_publish(message: Any, *, message_context: MessageContext) → Any | type[DropMessage][source]# Called when a message is published to the AgentRuntime using autogen_core.base.AgentRuntime.publish_message(). async on_response(message: Any, *, sender: AgentId, recipient: AgentId | None) → Any | type[DropMessage][source]# Called when a response is received by the AgentRuntime from an Agent’s message handler returning a value. class DefaultInterventionHandler(*args, **kwargs)[source]# Bases: InterventionHandler Simple class that provides a default implementation for all intervention handler methods, that simply returns the message unchanged. Allows for easy subclassing to override only the desired methods. async on_send(message: Any, *, message_context: MessageContext, recipient: AgentId) → Any | type[DropMessage][source]# Called when a message is submitted to the AgentRuntime using autogen_core.base.AgentRuntime.send_message(). async on_publish(message: Any, *, message_context: MessageContext) → Any | type[DropMessage][source]# Called when a message is published to the AgentRuntime using autogen_core.base.AgentRuntime.publish_message(). async on_response(message: Any, *, sender: AgentId, recipient: AgentId | None) → Any | type[DropMessage][source]# Called when a response is received by the AgentRuntime from an Agent’s message handler returning a value. trace_create_agent_span(agent_name: str, *, tracer: Tracer | None = None, parent: Span | None = None, agent_id: str | None = None, agent_description: str | None = None) → Generator[Span, Any, None][source]# Context manager to create a span for agent creation following the OpenTelemetry Semantic conventions for generative AI systems. See the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions Warning The GenAI Semantic Conventions are still in incubation and subject to changes in future releases. Parameters: agent_name (str) – The name of the agent being created. tracer (Optional[trace.Tracer]) – The tracer to use for creating the span. parent (Optional[Span]) – The parent span to link this span to. agent_id (Optional[str]) – The unique identifier for the agent. agent_description (Optional[str]) – A description of the agent. trace_invoke_agent_span(agent_name: str, *, tracer: Tracer | None = None, parent: Span | None = None, agent_id: str | None = None, agent_description: str | None = None) → Generator[Span, Any, None][source]# Context manager to create a span for invoking an agent following the OpenTelemetry Semantic conventions for generative AI systems. See the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions Warning The GenAI Semantic Conventions are still in incubation and subject to changes in future releases. Parameters: agent_name (str) – The name of the agent being invoked. tracer (Optional[trace.Tracer]) – The tracer to use for creating the span. parent (Optional[Span]) – The parent span to link this span to. agent_id (Optional[str]) – The unique identifier for the agent. agent_description (Optional[str]) – A description of the agent. trace_tool_span(tool_name: str, *, tracer: Tracer | None = None, parent: Span | None = None, tool_description: str | None = None, tool_call_id: str | None = None) → Generator[Span, Any, None][source]# Context manager to create a span for tool execution following the OpenTelemetry Semantic conventions for generative AI systems. See the GenAI semantic conventions documentation: OpenTelemetry GenAI Semantic Conventions Warning The GenAI Semantic Conventions are still in incubation and subject to changes in future releases. Parameters: tool_name (str) – The name of the tool being executed. tracer (Optional[trace.Tracer]) – The tracer to use for creating the span. parent (Optional[Span]) – The parent span to link this span to. tool_description (Optional[str]) – A description of the tool. tool_call_id (Optional[str]) – A unique identifier for the tool call. previous autogen_agentchat.utils next autogen_core.code_executor",
      "code": "Protocol"
    },
    {
      "description": "Example:",
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def my_agent_factory():\n    return MyAgent()\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    await runtime.register_factory(\"my_agent\", lambda: MyAgent())\n\n\nimport asyncio\n\nasyncio.run(main())"
    },
    {
      "description": "Example:",
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import AgentId, AgentRuntime, MessageContext, RoutedAgent, event\nfrom autogen_core.models import UserMessage\n\n\n@dataclass\nclass MyMessage:\n    content: str\n\n\nclass MyAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"My core agent\")\n\n    @event\n    async def handler(self, message: UserMessage, context: MessageContext) -> None:\n        print(\"Event received: \", message.content)\n\n\nasync def main() -> None:\n    runtime: AgentRuntime = ...  # type: ignore\n    agent = MyAgent()\n    await runtime.register_agent_instance(\n        agent_instance=agent, agent_id=AgentId(type=\"my_agent\", key=\"default\")\n    )\n\n\nimport asyncio\n\nasyncio.run(main())"
    },
    {
      "description": "Must match the pattern: ^[w-.:=]+Z",
      "code": "type/source"
    }
  ],
  "links": [
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html",
    "https://microsoft.github.io/autogen/stable/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/extensions-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/autogenstudio-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/reference/index.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.agents.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.base.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.conditions.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.messages.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.state.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.teams.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.tools.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.ui.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.utils.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.code_executor.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.exceptions.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.logging.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.memory.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.model_context.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.models.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.tool_agent.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.tools.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.utils.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.cache_store.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.experimental.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.teams.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.ui.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.file_surfer.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.magentic_one.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.openai.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.video_surfer.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.web_surfer.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.auth.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.cache_store.diskcache.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.cache_store.redis.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.docker.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.docker_jupyter.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.jupyter.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.code_executors.local.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.experimental.task_centric_memory.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.canvas.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.chromadb.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.mem0.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.memory.redis.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.anthropic.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.cache.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.llama_cpp.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.ollama.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.openai.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.replay.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.semantic_kernel.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.teams.magentic_one.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.azure.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.code_execution.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.graphrag.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.http.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.langchain.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.mcp.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.tools.semantic_kernel.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.video_surfer.tools.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.agents.web_surfer.playwright_controller.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.experimental.task_centric_memory.utils.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.anthropic.config.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.azure.config.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.ollama.config.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.models.openai.config.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.agent_worker_pb2.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.agent_worker_pb2_grpc.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.cloudevent_pb2.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_ext.runtimes.grpc.protos.cloudevent_pb2_grpc.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-identity-and-lifecycle.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/topic-and-subscription.html"
  ]
}