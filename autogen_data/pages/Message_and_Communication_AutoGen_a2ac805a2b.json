{
  "url": "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/message-and-communication.html",
  "title": "Message and Communication — AutoGen",
  "content": "An agent in AutoGen core can react to, send, and publish messages, and messages are the only means through which agents can communicate with each other.\n\nMessages are serializable objects, they can be defined using:\n\nA subclass of Pydantic’s pydantic.BaseModel, or\n\nMessages are purely data, and should not contain any logic.\n\nWhen an agent receives a message the runtime will invoke the agent’s message handler (on_message()) which should implement the agents message handling logic. If this message cannot be handled by the agent, the agent should raise a CantHandleException.\n\nThe base class BaseAgent provides no message handling logic and implementing the on_message() method directly is not recommended unless for the advanced use cases.\n\nDevelopers should start with implementing the RoutedAgent base class which provides built-in message routing capability.\n\nThe RoutedAgent base class provides a mechanism for associating message types with message handlers with the message_handler() decorator, so developers do not need to implement the on_message() method.\n\nFor example, the following type-routed agent responds to TextMessage and ImageMessage using different message handlers:\n\nCreate the agent runtime and register the agent type (see Agent and Agent Runtime):\n\nTest this agent with TextMessage and ImageMessage.\n\nThe runtime automatically creates an instance of MyAgent with the agent ID AgentId(\"my_agent\", \"default\") when delivering the first message.\n\nIn some scenarios, it is useful to route messages of the same type to different handlers. For examples, messages from different sender agents should be handled differently. You can use the match parameter of the message_handler() decorator.\n\nThe match parameter associates handlers for the same message type to a specific message – it is secondary to the message type routing. It accepts a callable that takes the message and MessageContext as arguments, and returns a boolean indicating whether the message should be handled by the decorated handler. The callable is checked in the alphabetical order of the handlers.\n\nHere is an example of an agent that routes messages based on the sender agent using the match parameter:\n\nThe above agent uses the source field of the message to determine the sender agent. You can also use the sender field of MessageContext to determine the sender agent using the agent ID if available.\n\nLet’s test this agent with messages with different source values:\n\nIn the above example, the first ImageMessage is not handled because the source field of the message does not match the handler’s match condition.\n\nThere are two types of communication in AutoGen core:\n\nDirect Messaging: sends a direct message to another agent.\n\nBroadcast: publishes a message to a topic.\n\nLet’s first look at direct messaging. To send a direct message to another agent, within a message handler use the autogen_core.BaseAgent.send_message() method, from the runtime use the autogen_core.AgentRuntime.send_message() method. Awaiting calls to these methods will return the return value of the receiving agent’s message handler. When the receiving agent’s handler returns None, None will be returned.\n\nIf the invoked agent raises an exception while the sender is awaiting, the exception will be propagated back to the sender.\n\nDirect messaging can be used for request/response scenarios, where the sender expects a response from the receiver. The receiver can respond to the message by returning a value from its message handler. You can think of this as a function call between agents.\n\nFor example, consider the following agents:\n\nUpone receving a message, the OuterAgent sends a direct message to the InnerAgent and receives a message in response.\n\nWe can test these agents by sending a Message to the OuterAgent.\n\nBoth outputs are produced by the OuterAgent’s message handler, however the second output is based on the response from the InnerAgent.\n\nGenerally speaking, direct messaging is appropriate for scenarios when the sender and recipient are tightly coupled – they are created together and the sender is linked to a specific instance of the recipient. For example, an agent executes tool calls by sending direct messages to an instance of ToolAgent, and uses the responses to form an action-observation loop.\n\nBroadcast is effectively the publish/subscribe model with topic and subscription. Read Topic and Subscription to learn the core concepts.\n\nThe key difference between direct messaging and broadcast is that broadcast cannot be used for request/response scenarios. When an agent publishes a message it is one way only, it cannot receive a response from any other agent, even if a receiving agent’s handler returns a value.\n\nIf a response is given to a published message, it will be thrown away.\n\nIf an agent publishes a message type for which it is subscribed it will not receive the message it published. This is to prevent infinite loops.\n\nType-based subscription maps messages published to topics of a given topic type to agents of a given agent type. To make an agent that subsclasses RoutedAgent subscribe to a topic of a given topic type, you can use the type_subscription() class decorator.\n\nThe following example shows a ReceiverAgent class that subscribes to topics of \"default\" topic type using the type_subscription() decorator. and prints the received messages.\n\nTo publish a message from an agent’s handler, use the publish_message() method and specify a TopicId. This call must still be awaited to allow the runtime to schedule delivery of the message to all subscribers, but it will always return None. If an agent raises an exception while handling a published message, this will be logged but will not be propagated back to the publishing agent.\n\nThe following example shows a BroadcastingAgent that publishes a message to a topic upon receiving a message.\n\nBroadcastingAgent publishes message to a topic with type \"default\" and source assigned to the agent instance’s agent key.\n\nSubscriptions are registered with the agent runtime, either as part of agent type’s registration or through a separate API method. Here is how we register TypeSubscription for the receiving agent with the type_subscription() decorator, and for the broadcasting agent without the decorator.\n\nAs shown in the above example, you can also publish directly to a topic through the runtime’s publish_message() method without the need to create an agent instance.\n\nFrom the output, you can see two messages were received by the receiving agent: one was published through the runtime, and the other was published by the broadcasting agent.\n\nIn the above example, we used TopicId and TypeSubscription to specify the topic and subscriptions respectively. This is the appropriate way for many scenarios. However, when there is a single scope of publishing, that is, all agents publish and subscribe to all broadcasted messages, we can use the convenience classes DefaultTopicId and default_subscription() to simplify our code.\n\nDefaultTopicId is for creating a topic that uses \"default\" as the default value for the topic type and the publishing agent’s key as the default value for the topic source. default_subscription() is for creating a type subscription that subscribes to the default topic. We can simplify BroadcastingAgent by using DefaultTopicId and default_subscription().\n\nWhen the runtime calls register() to register the agent type, it creates a TypeSubscription whose topic type uses \"default\" as the default value and agent type uses the same agent type that is being registered in the same context.\n\nIf your scenario allows all agents to publish and subscribe to all broadcasted messages, use DefaultTopicId and default_subscription() to decorate your agent classes.\n\nAgent and Agent Runtime",
  "headings": [
    {
      "level": "h1",
      "text": "Message and Communication#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Messages#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Message Handlers#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Routing Messages by Type#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Routing Messages of the Same Type#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Direct Messaging#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Request/Response#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Broadcast#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subscribe and Publish to Topics#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Default Topic and Subscriptions#",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass TextMessage:\n    content: str\n    source: str\n\n\n@dataclass\nclass ImageMessage:\n    url: str\n    source: str",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass TextMessage:\n    content: str\n    source: str\n\n\n@dataclass\nclass ImageMessage:\n    url: str\n    source: str",
      "language": "python"
    },
    {
      "code": "from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler\n\n\nclass MyAgent(RoutedAgent):\n    @message_handler\n    async def on_text_message(self, message: TextMessage, ctx: MessageContext) -> None:\n        print(f\"Hello, {message.source}, you said {message.content}!\")\n\n    @message_handler\n    async def on_image_message(self, message: ImageMessage, ctx: MessageContext) -> None:\n        print(f\"Hello, {message.source}, you sent me {message.url}!\")",
      "language": "python"
    },
    {
      "code": "from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler\n\n\nclass MyAgent(RoutedAgent):\n    @message_handler\n    async def on_text_message(self, message: TextMessage, ctx: MessageContext) -> None:\n        print(f\"Hello, {message.source}, you said {message.content}!\")\n\n    @message_handler\n    async def on_image_message(self, message: ImageMessage, ctx: MessageContext) -> None:\n        print(f\"Hello, {message.source}, you sent me {message.url}!\")",
      "language": "python"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nawait MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My Agent\"))",
      "language": "csharp"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nawait MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My Agent\"))",
      "language": "csharp"
    },
    {
      "code": "AgentType(type='my_agent')",
      "language": "unknown"
    },
    {
      "code": "AgentType(type='my_agent')",
      "language": "unknown"
    },
    {
      "code": "runtime.start()\nagent_id = AgentId(\"my_agent\", \"default\")\nawait runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"User\"), agent_id)\nawait runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"User\"), agent_id)\nawait runtime.stop_when_idle()",
      "language": "csharp"
    },
    {
      "code": "runtime.start()\nagent_id = AgentId(\"my_agent\", \"default\")\nawait runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"User\"), agent_id)\nawait runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"User\"), agent_id)\nawait runtime.stop_when_idle()",
      "language": "csharp"
    },
    {
      "code": "Hello, User, you said Hello, World!!\nHello, User, you sent me https://example.com/image.jpg!",
      "language": "unknown"
    },
    {
      "code": "Hello, User, you said Hello, World!!\nHello, User, you sent me https://example.com/image.jpg!",
      "language": "unknown"
    },
    {
      "code": "class RoutedBySenderAgent(RoutedAgent):\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user1\"))  # type: ignore\n    async def on_user1_message(self, message: TextMessage, ctx: MessageContext) -> None:\n        print(f\"Hello from user 1 handler, {message.source}, you said {message.content}!\")\n\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user2\"))  # type: ignore\n    async def on_user2_message(self, message: TextMessage, ctx: MessageContext) -> None:\n        print(f\"Hello from user 2 handler, {message.source}, you said {message.content}!\")\n\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user2\"))  # type: ignore\n    async def on_image_message(self, message: ImageMessage, ctx: MessageContext) -> None:\n        print(f\"Hello, {message.source}, you sent me {message.url}!\")",
      "language": "python"
    },
    {
      "code": "class RoutedBySenderAgent(RoutedAgent):\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user1\"))  # type: ignore\n    async def on_user1_message(self, message: TextMessage, ctx: MessageContext) -> None:\n        print(f\"Hello from user 1 handler, {message.source}, you said {message.content}!\")\n\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user2\"))  # type: ignore\n    async def on_user2_message(self, message: TextMessage, ctx: MessageContext) -> None:\n        print(f\"Hello from user 2 handler, {message.source}, you said {message.content}!\")\n\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user2\"))  # type: ignore\n    async def on_image_message(self, message: ImageMessage, ctx: MessageContext) -> None:\n        print(f\"Hello, {message.source}, you sent me {message.url}!\")",
      "language": "python"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nawait RoutedBySenderAgent.register(runtime, \"my_agent\", lambda: RoutedBySenderAgent(\"Routed by sender agent\"))\nruntime.start()\nagent_id = AgentId(\"my_agent\", \"default\")\nawait runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"user1-test\"), agent_id)\nawait runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"user2-test\"), agent_id)\nawait runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"user1-test\"), agent_id)\nawait runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"user2-test\"), agent_id)\nawait runtime.stop_when_idle()",
      "language": "csharp"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nawait RoutedBySenderAgent.register(runtime, \"my_agent\", lambda: RoutedBySenderAgent(\"Routed by sender agent\"))\nruntime.start()\nagent_id = AgentId(\"my_agent\", \"default\")\nawait runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"user1-test\"), agent_id)\nawait runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"user2-test\"), agent_id)\nawait runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"user1-test\"), agent_id)\nawait runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"user2-test\"), agent_id)\nawait runtime.stop_when_idle()",
      "language": "csharp"
    },
    {
      "code": "Hello from user 1 handler, user1-test, you said Hello, World!!\nHello from user 2 handler, user2-test, you said Hello, World!!\nHello, user2-test, you sent me https://example.com/image.jpg!",
      "language": "sql"
    },
    {
      "code": "Hello from user 1 handler, user1-test, you said Hello, World!!\nHello from user 2 handler, user2-test, you said Hello, World!!\nHello, user2-test, you sent me https://example.com/image.jpg!",
      "language": "sql"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler\n\n\n@dataclass\nclass Message:\n    content: str\n\n\nclass InnerAgent(RoutedAgent):\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> Message:\n        return Message(content=f\"Hello from inner, {message.content}\")\n\n\nclass OuterAgent(RoutedAgent):\n    def __init__(self, description: str, inner_agent_type: str):\n        super().__init__(description)\n        self.inner_agent_id = AgentId(inner_agent_type, self.id.key)\n\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> None:\n        print(f\"Received message: {message.content}\")\n        # Send a direct message to the inner agent and receives a response.\n        response = await self.send_message(Message(f\"Hello from outer, {message.content}\"), self.inner_agent_id)\n        print(f\"Received inner response: {response.content}\")",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\nfrom autogen_core import MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler\n\n\n@dataclass\nclass Message:\n    content: str\n\n\nclass InnerAgent(RoutedAgent):\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> Message:\n        return Message(content=f\"Hello from inner, {message.content}\")\n\n\nclass OuterAgent(RoutedAgent):\n    def __init__(self, description: str, inner_agent_type: str):\n        super().__init__(description)\n        self.inner_agent_id = AgentId(inner_agent_type, self.id.key)\n\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> None:\n        print(f\"Received message: {message.content}\")\n        # Send a direct message to the inner agent and receives a response.\n        response = await self.send_message(Message(f\"Hello from outer, {message.content}\"), self.inner_agent_id)\n        print(f\"Received inner response: {response.content}\")",
      "language": "python"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nawait InnerAgent.register(runtime, \"inner_agent\", lambda: InnerAgent(\"InnerAgent\"))\nawait OuterAgent.register(runtime, \"outer_agent\", lambda: OuterAgent(\"OuterAgent\", \"inner_agent\"))\nruntime.start()\nouter_agent_id = AgentId(\"outer_agent\", \"default\")\nawait runtime.send_message(Message(content=\"Hello, World!\"), outer_agent_id)\nawait runtime.stop_when_idle()",
      "language": "csharp"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nawait InnerAgent.register(runtime, \"inner_agent\", lambda: InnerAgent(\"InnerAgent\"))\nawait OuterAgent.register(runtime, \"outer_agent\", lambda: OuterAgent(\"OuterAgent\", \"inner_agent\"))\nruntime.start()\nouter_agent_id = AgentId(\"outer_agent\", \"default\")\nawait runtime.send_message(Message(content=\"Hello, World!\"), outer_agent_id)\nawait runtime.stop_when_idle()",
      "language": "csharp"
    },
    {
      "code": "Received message: Hello, World!\nReceived inner response: Hello from inner, Hello from outer, Hello, World!",
      "language": "sql"
    },
    {
      "code": "Received message: Hello, World!\nReceived inner response: Hello from inner, Hello from outer, Hello, World!",
      "language": "sql"
    },
    {
      "code": "from autogen_core import RoutedAgent, message_handler, type_subscription\n\n\n@type_subscription(topic_type=\"default\")\nclass ReceivingAgent(RoutedAgent):\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> None:\n        print(f\"Received a message: {message.content}\")",
      "language": "python"
    },
    {
      "code": "from autogen_core import RoutedAgent, message_handler, type_subscription\n\n\n@type_subscription(topic_type=\"default\")\nclass ReceivingAgent(RoutedAgent):\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> None:\n        print(f\"Received a message: {message.content}\")",
      "language": "python"
    },
    {
      "code": "from autogen_core import TopicId\n\n\nclass BroadcastingAgent(RoutedAgent):\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> None:\n        await self.publish_message(\n            Message(\"Publishing a message from broadcasting agent!\"),\n            topic_id=TopicId(type=\"default\", source=self.id.key),\n        )",
      "language": "python"
    },
    {
      "code": "from autogen_core import TopicId\n\n\nclass BroadcastingAgent(RoutedAgent):\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> None:\n        await self.publish_message(\n            Message(\"Publishing a message from broadcasting agent!\"),\n            topic_id=TopicId(type=\"default\", source=self.id.key),\n        )",
      "language": "python"
    },
    {
      "code": "from autogen_core import TypeSubscription\n\nruntime = SingleThreadedAgentRuntime()\n\n# Option 1: with type_subscription decorator\n# The type_subscription class decorator automatically adds a TypeSubscription to\n# the runtime when the agent is registered.\nawait ReceivingAgent.register(runtime, \"receiving_agent\", lambda: ReceivingAgent(\"Receiving Agent\"))\n\n# Option 2: with TypeSubscription\nawait BroadcastingAgent.register(runtime, \"broadcasting_agent\", lambda: BroadcastingAgent(\"Broadcasting Agent\"))\nawait runtime.add_subscription(TypeSubscription(topic_type=\"default\", agent_type=\"broadcasting_agent\"))\n\n# Start the runtime and publish a message.\nruntime.start()\nawait runtime.publish_message(\n    Message(\"Hello, World! From the runtime!\"), topic_id=TopicId(type=\"default\", source=\"default\")\n)\nawait runtime.stop_when_idle()",
      "language": "python"
    },
    {
      "code": "from autogen_core import TypeSubscription\n\nruntime = SingleThreadedAgentRuntime()\n\n# Option 1: with type_subscription decorator\n# The type_subscription class decorator automatically adds a TypeSubscription to\n# the runtime when the agent is registered.\nawait ReceivingAgent.register(runtime, \"receiving_agent\", lambda: ReceivingAgent(\"Receiving Agent\"))\n\n# Option 2: with TypeSubscription\nawait BroadcastingAgent.register(runtime, \"broadcasting_agent\", lambda: BroadcastingAgent(\"Broadcasting Agent\"))\nawait runtime.add_subscription(TypeSubscription(topic_type=\"default\", agent_type=\"broadcasting_agent\"))\n\n# Start the runtime and publish a message.\nruntime.start()\nawait runtime.publish_message(\n    Message(\"Hello, World! From the runtime!\"), topic_id=TopicId(type=\"default\", source=\"default\")\n)\nawait runtime.stop_when_idle()",
      "language": "python"
    },
    {
      "code": "Received a message: Hello, World! From the runtime!\nReceived a message: Publishing a message from broadcasting agent!",
      "language": "sql"
    },
    {
      "code": "Received a message: Hello, World! From the runtime!\nReceived a message: Publishing a message from broadcasting agent!",
      "language": "sql"
    },
    {
      "code": "from autogen_core import DefaultTopicId, default_subscription\n\n\n@default_subscription\nclass BroadcastingAgentDefaultTopic(RoutedAgent):\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> None:\n        # Publish a message to all agents in the same namespace.\n        await self.publish_message(\n            Message(\"Publishing a message from broadcasting agent!\"),\n            topic_id=DefaultTopicId(),\n        )",
      "language": "python"
    },
    {
      "code": "from autogen_core import DefaultTopicId, default_subscription\n\n\n@default_subscription\nclass BroadcastingAgentDefaultTopic(RoutedAgent):\n    @message_handler\n    async def on_my_message(self, message: Message, ctx: MessageContext) -> None:\n        # Publish a message to all agents in the same namespace.\n        await self.publish_message(\n            Message(\"Publishing a message from broadcasting agent!\"),\n            topic_id=DefaultTopicId(),\n        )",
      "language": "python"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nawait BroadcastingAgentDefaultTopic.register(\n    runtime, \"broadcasting_agent\", lambda: BroadcastingAgentDefaultTopic(\"Broadcasting Agent\")\n)\nawait ReceivingAgent.register(runtime, \"receiving_agent\", lambda: ReceivingAgent(\"Receiving Agent\"))\nruntime.start()\nawait runtime.publish_message(Message(\"Hello, World! From the runtime!\"), topic_id=DefaultTopicId())\nawait runtime.stop_when_idle()",
      "language": "sql"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nawait BroadcastingAgentDefaultTopic.register(\n    runtime, \"broadcasting_agent\", lambda: BroadcastingAgentDefaultTopic(\"Broadcasting Agent\")\n)\nawait ReceivingAgent.register(runtime, \"receiving_agent\", lambda: ReceivingAgent(\"Receiving Agent\"))\nruntime.start()\nawait runtime.publish_message(Message(\"Hello, World! From the runtime!\"), topic_id=DefaultTopicId())\nawait runtime.stop_when_idle()",
      "language": "sql"
    },
    {
      "code": "Received a message: Hello, World! From the runtime!\nReceived a message: Publishing a message from broadcasting agent!",
      "language": "sql"
    },
    {
      "code": "Received a message: Hello, World! From the runtime!\nReceived a message: Publishing a message from broadcasting agent!",
      "language": "sql"
    }
  ],
  "patterns": [
    {
      "description": "Core Message and Communication Message and Communication# An agent in AutoGen core can react to, send, and publish messages, and messages are the only means through which agents can communicate with each other. Messages# Messages are serializable objects, they can be defined using: A subclass of Pydantic’s pydantic.BaseModel, or A dataclass For example: from dataclasses import dataclass @dataclass class TextMessage: content: str source: str @dataclass class ImageMessage: url: str source: str Note Messages are purely data, and should not contain any logic. Message Handlers# When an agent receives a message the runtime will invoke the agent’s message handler (on_message()) which should implement the agents message handling logic. If this message cannot be handled by the agent, the agent should raise a CantHandleException. The base class BaseAgent provides no message handling logic and implementing the on_message() method directly is not recommended unless for the advanced use cases. Developers should start with implementing the RoutedAgent base class which provides built-in message routing capability. Routing Messages by Type# The RoutedAgent base class provides a mechanism for associating message types with message handlers with the message_handler() decorator, so developers do not need to implement the on_message() method. For example, the following type-routed agent responds to TextMessage and ImageMessage using different message handlers: from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler class MyAgent(RoutedAgent): @message_handler async def on_text_message(self, message: TextMessage, ctx: MessageContext) -> None: print(f\"Hello, {message.source}, you said {message.content}!\") @message_handler async def on_image_message(self, message: ImageMessage, ctx: MessageContext) -> None: print(f\"Hello, {message.source}, you sent me {message.url}!\") Create the agent runtime and register the agent type (see Agent and Agent Runtime): runtime = SingleThreadedAgentRuntime() await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My Agent\")) AgentType(type='my_agent') Test this agent with TextMessage and ImageMessage. runtime.start() agent_id = AgentId(\"my_agent\", \"default\") await runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"User\"), agent_id) await runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"User\"), agent_id) await runtime.stop_when_idle() Hello, User, you said Hello, World!! Hello, User, you sent me https://example.com/image.jpg! The runtime automatically creates an instance of MyAgent with the agent ID AgentId(\"my_agent\", \"default\") when delivering the first message. Routing Messages of the Same Type# In some scenarios, it is useful to route messages of the same type to different handlers. For examples, messages from different sender agents should be handled differently. You can use the match parameter of the message_handler() decorator. The match parameter associates handlers for the same message type to a specific message – it is secondary to the message type routing. It accepts a callable that takes the message and MessageContext as arguments, and returns a boolean indicating whether the message should be handled by the decorated handler. The callable is checked in the alphabetical order of the handlers. Here is an example of an agent that routes messages based on the sender agent using the match parameter: class RoutedBySenderAgent(RoutedAgent): @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user1\")) # type: ignore async def on_user1_message(self, message: TextMessage, ctx: MessageContext) -> None: print(f\"Hello from user 1 handler, {message.source}, you said {message.content}!\") @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user2\")) # type: ignore async def on_user2_message(self, message: TextMessage, ctx: MessageContext) -> None: print(f\"Hello from user 2 handler, {message.source}, you said {message.content}!\") @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user2\")) # type: ignore async def on_image_message(self, message: ImageMessage, ctx: MessageContext) -> None: print(f\"Hello, {message.source}, you sent me {message.url}!\") The above agent uses the source field of the message to determine the sender agent. You can also use the sender field of MessageContext to determine the sender agent using the agent ID if available. Let’s test this agent with messages with different source values: runtime = SingleThreadedAgentRuntime() await RoutedBySenderAgent.register(runtime, \"my_agent\", lambda: RoutedBySenderAgent(\"Routed by sender agent\")) runtime.start() agent_id = AgentId(\"my_agent\", \"default\") await runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"user1-test\"), agent_id) await runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"user2-test\"), agent_id) await runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"user1-test\"), agent_id) await runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"user2-test\"), agent_id) await runtime.stop_when_idle() Hello from user 1 handler, user1-test, you said Hello, World!! Hello from user 2 handler, user2-test, you said Hello, World!! Hello, user2-test, you sent me https://example.com/image.jpg! In the above example, the first ImageMessage is not handled because the source field of the message does not match the handler’s match condition. Direct Messaging# There are two types of communication in AutoGen core: Direct Messaging: sends a direct message to another agent. Broadcast: publishes a message to a topic. Let’s first look at direct messaging. To send a direct message to another agent, within a message handler use the autogen_core.BaseAgent.send_message() method, from the runtime use the autogen_core.AgentRuntime.send_message() method. Awaiting calls to these methods will return the return value of the receiving agent’s message handler. When the receiving agent’s handler returns None, None will be returned. Note If the invoked agent raises an exception while the sender is awaiting, the exception will be propagated back to the sender. Request/Response# Direct messaging can be used for request/response scenarios, where the sender expects a response from the receiver. The receiver can respond to the message by returning a value from its message handler. You can think of this as a function call between agents. For example, consider the following agents: from dataclasses import dataclass from autogen_core import MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler @dataclass class Message: content: str class InnerAgent(RoutedAgent): @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> Message: return Message(content=f\"Hello from inner, {message.content}\") class OuterAgent(RoutedAgent): def __init__(self, description: str, inner_agent_type: str): super().__init__(description) self.inner_agent_id = AgentId(inner_agent_type, self.id.key) @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> None: print(f\"Received message: {message.content}\") # Send a direct message to the inner agent and receives a response. response = await self.send_message(Message(f\"Hello from outer, {message.content}\"), self.inner_agent_id) print(f\"Received inner response: {response.content}\") Upone receving a message, the OuterAgent sends a direct message to the InnerAgent and receives a message in response. We can test these agents by sending a Message to the OuterAgent. runtime = SingleThreadedAgentRuntime() await InnerAgent.register(runtime, \"inner_agent\", lambda: InnerAgent(\"InnerAgent\")) await OuterAgent.register(runtime, \"outer_agent\", lambda: OuterAgent(\"OuterAgent\", \"inner_agent\")) runtime.start() outer_agent_id = AgentId(\"outer_agent\", \"default\") await runtime.send_message(Message(content=\"Hello, World!\"), outer_agent_id) await runtime.stop_when_idle() Received message: Hello, World! Received inner response: Hello from inner, Hello from outer, Hello, World! Both outputs are produced by the OuterAgent’s message handler, however the second output is based on the response from the InnerAgent. Generally speaking, direct messaging is appropriate for scenarios when the sender and recipient are tightly coupled – they are created together and the sender is linked to a specific instance of the recipient. For example, an agent executes tool calls by sending direct messages to an instance of ToolAgent, and uses the responses to form an action-observation loop. Broadcast# Broadcast is effectively the publish/subscribe model with topic and subscription. Read Topic and Subscription to learn the core concepts. The key difference between direct messaging and broadcast is that broadcast cannot be used for request/response scenarios. When an agent publishes a message it is one way only, it cannot receive a response from any other agent, even if a receiving agent’s handler returns a value. Note If a response is given to a published message, it will be thrown away. Note If an agent publishes a message type for which it is subscribed it will not receive the message it published. This is to prevent infinite loops. Subscribe and Publish to Topics# Type-based subscription maps messages published to topics of a given topic type to agents of a given agent type. To make an agent that subsclasses RoutedAgent subscribe to a topic of a given topic type, you can use the type_subscription() class decorator. The following example shows a ReceiverAgent class that subscribes to topics of \"default\" topic type using the type_subscription() decorator. and prints the received messages. from autogen_core import RoutedAgent, message_handler, type_subscription @type_subscription(topic_type=\"default\") class ReceivingAgent(RoutedAgent): @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> None: print(f\"Received a message: {message.content}\") To publish a message from an agent’s handler, use the publish_message() method and specify a TopicId. This call must still be awaited to allow the runtime to schedule delivery of the message to all subscribers, but it will always return None. If an agent raises an exception while handling a published message, this will be logged but will not be propagated back to the publishing agent. The following example shows a BroadcastingAgent that publishes a message to a topic upon receiving a message. from autogen_core import TopicId class BroadcastingAgent(RoutedAgent): @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> None: await self.publish_message( Message(\"Publishing a message from broadcasting agent!\"), topic_id=TopicId(type=\"default\", source=self.id.key), ) BroadcastingAgent publishes message to a topic with type \"default\" and source assigned to the agent instance’s agent key. Subscriptions are registered with the agent runtime, either as part of agent type’s registration or through a separate API method. Here is how we register TypeSubscription for the receiving agent with the type_subscription() decorator, and for the broadcasting agent without the decorator. from autogen_core import TypeSubscription runtime = SingleThreadedAgentRuntime() # Option 1: with type_subscription decorator # The type_subscription class decorator automatically adds a TypeSubscription to # the runtime when the agent is registered. await ReceivingAgent.register(runtime, \"receiving_agent\", lambda: ReceivingAgent(\"Receiving Agent\")) # Option 2: with TypeSubscription await BroadcastingAgent.register(runtime, \"broadcasting_agent\", lambda: BroadcastingAgent(\"Broadcasting Agent\")) await runtime.add_subscription(TypeSubscription(topic_type=\"default\", agent_type=\"broadcasting_agent\")) # Start the runtime and publish a message. runtime.start() await runtime.publish_message( Message(\"Hello, World! From the runtime!\"), topic_id=TopicId(type=\"default\", source=\"default\") ) await runtime.stop_when_idle() Received a message: Hello, World! From the runtime! Received a message: Publishing a message from broadcasting agent! As shown in the above example, you can also publish directly to a topic through the runtime’s publish_message() method without the need to create an agent instance. From the output, you can see two messages were received by the receiving agent: one was published through the runtime, and the other was published by the broadcasting agent. Default Topic and Subscriptions# In the above example, we used TopicId and TypeSubscription to specify the topic and subscriptions respectively. This is the appropriate way for many scenarios. However, when there is a single scope of publishing, that is, all agents publish and subscribe to all broadcasted messages, we can use the convenience classes DefaultTopicId and default_subscription() to simplify our code. DefaultTopicId is for creating a topic that uses \"default\" as the default value for the topic type and the publishing agent’s key as the default value for the topic source. default_subscription() is for creating a type subscription that subscribes to the default topic. We can simplify BroadcastingAgent by using DefaultTopicId and default_subscription(). from autogen_core import DefaultTopicId, default_subscription @default_subscription class BroadcastingAgentDefaultTopic(RoutedAgent): @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> None: # Publish a message to all agents in the same namespace. await self.publish_message( Message(\"Publishing a message from broadcasting agent!\"), topic_id=DefaultTopicId(), ) When the runtime calls register() to register the agent type, it creates a TypeSubscription whose topic type uses \"default\" as the default value and agent type uses the same agent type that is being registered in the same context. runtime = SingleThreadedAgentRuntime() await BroadcastingAgentDefaultTopic.register( runtime, \"broadcasting_agent\", lambda: BroadcastingAgentDefaultTopic(\"Broadcasting Agent\") ) await ReceivingAgent.register(runtime, \"receiving_agent\", lambda: ReceivingAgent(\"Receiving Agent\")) runtime.start() await runtime.publish_message(Message(\"Hello, World! From the runtime!\"), topic_id=DefaultTopicId()) await runtime.stop_when_idle() Received a message: Hello, World! From the runtime! Received a message: Publishing a message from broadcasting agent! Note If your scenario allows all agents to publish and subscribe to all broadcasted messages, use DefaultTopicId and default_subscription() to decorate your agent classes. previous Agent and Agent Runtime next Logging On this page Messages Message Handlers Routing Messages by Type Routing Messages of the Same Type Direct Messaging Request/Response Broadcast Subscribe and Publish to Topics Default Topic and Subscriptions Edit on GitHub Show Source",
      "code": "pydantic.BaseModel"
    },
    {
      "description": "Core Message and Communication Message and Communication# An agent in AutoGen core can react to, send, and publish messages, and messages are the only means through which agents can communicate with each other. Messages# Messages are serializable objects, they can be defined using: A subclass of Pydantic’s pydantic.BaseModel, or A dataclass For example: from dataclasses import dataclass @dataclass class TextMessage: content: str source: str @dataclass class ImageMessage: url: str source: str Note Messages are purely data, and should not contain any logic. Message Handlers# When an agent receives a message the runtime will invoke the agent’s message handler (on_message()) which should implement the agents message handling logic. If this message cannot be handled by the agent, the agent should raise a CantHandleException. The base class BaseAgent provides no message handling logic and implementing the on_message() method directly is not recommended unless for the advanced use cases. Developers should start with implementing the RoutedAgent base class which provides built-in message routing capability. Routing Messages by Type# The RoutedAgent base class provides a mechanism for associating message types with message handlers with the message_handler() decorator, so developers do not need to implement the on_message() method. For example, the following type-routed agent responds to TextMessage and ImageMessage using different message handlers: from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler class MyAgent(RoutedAgent): @message_handler async def on_text_message(self, message: TextMessage, ctx: MessageContext) -> None: print(f\"Hello, {message.source}, you said {message.content}!\") @message_handler async def on_image_message(self, message: ImageMessage, ctx: MessageContext) -> None: print(f\"Hello, {message.source}, you sent me {message.url}!\") Create the agent runtime and register the agent type (see Agent and Agent Runtime): runtime = SingleThreadedAgentRuntime() await MyAgent.register(runtime, \"my_agent\", lambda: MyAgent(\"My Agent\")) AgentType(type='my_agent') Test this agent with TextMessage and ImageMessage. runtime.start() agent_id = AgentId(\"my_agent\", \"default\") await runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"User\"), agent_id) await runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"User\"), agent_id) await runtime.stop_when_idle() Hello, User, you said Hello, World!! Hello, User, you sent me https://example.com/image.jpg! The runtime automatically creates an instance of MyAgent with the agent ID AgentId(\"my_agent\", \"default\") when delivering the first message. Routing Messages of the Same Type# In some scenarios, it is useful to route messages of the same type to different handlers. For examples, messages from different sender agents should be handled differently. You can use the match parameter of the message_handler() decorator. The match parameter associates handlers for the same message type to a specific message – it is secondary to the message type routing. It accepts a callable that takes the message and MessageContext as arguments, and returns a boolean indicating whether the message should be handled by the decorated handler. The callable is checked in the alphabetical order of the handlers. Here is an example of an agent that routes messages based on the sender agent using the match parameter: class RoutedBySenderAgent(RoutedAgent): @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user1\")) # type: ignore async def on_user1_message(self, message: TextMessage, ctx: MessageContext) -> None: print(f\"Hello from user 1 handler, {message.source}, you said {message.content}!\") @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user2\")) # type: ignore async def on_user2_message(self, message: TextMessage, ctx: MessageContext) -> None: print(f\"Hello from user 2 handler, {message.source}, you said {message.content}!\") @message_handler(match=lambda msg, ctx: msg.source.startswith(\"user2\")) # type: ignore async def on_image_message(self, message: ImageMessage, ctx: MessageContext) -> None: print(f\"Hello, {message.source}, you sent me {message.url}!\") The above agent uses the source field of the message to determine the sender agent. You can also use the sender field of MessageContext to determine the sender agent using the agent ID if available. Let’s test this agent with messages with different source values: runtime = SingleThreadedAgentRuntime() await RoutedBySenderAgent.register(runtime, \"my_agent\", lambda: RoutedBySenderAgent(\"Routed by sender agent\")) runtime.start() agent_id = AgentId(\"my_agent\", \"default\") await runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"user1-test\"), agent_id) await runtime.send_message(TextMessage(content=\"Hello, World!\", source=\"user2-test\"), agent_id) await runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"user1-test\"), agent_id) await runtime.send_message(ImageMessage(url=\"https://example.com/image.jpg\", source=\"user2-test\"), agent_id) await runtime.stop_when_idle() Hello from user 1 handler, user1-test, you said Hello, World!! Hello from user 2 handler, user2-test, you said Hello, World!! Hello, user2-test, you sent me https://example.com/image.jpg! In the above example, the first ImageMessage is not handled because the source field of the message does not match the handler’s match condition. Direct Messaging# There are two types of communication in AutoGen core: Direct Messaging: sends a direct message to another agent. Broadcast: publishes a message to a topic. Let’s first look at direct messaging. To send a direct message to another agent, within a message handler use the autogen_core.BaseAgent.send_message() method, from the runtime use the autogen_core.AgentRuntime.send_message() method. Awaiting calls to these methods will return the return value of the receiving agent’s message handler. When the receiving agent’s handler returns None, None will be returned. Note If the invoked agent raises an exception while the sender is awaiting, the exception will be propagated back to the sender. Request/Response# Direct messaging can be used for request/response scenarios, where the sender expects a response from the receiver. The receiver can respond to the message by returning a value from its message handler. You can think of this as a function call between agents. For example, consider the following agents: from dataclasses import dataclass from autogen_core import MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler @dataclass class Message: content: str class InnerAgent(RoutedAgent): @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> Message: return Message(content=f\"Hello from inner, {message.content}\") class OuterAgent(RoutedAgent): def __init__(self, description: str, inner_agent_type: str): super().__init__(description) self.inner_agent_id = AgentId(inner_agent_type, self.id.key) @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> None: print(f\"Received message: {message.content}\") # Send a direct message to the inner agent and receives a response. response = await self.send_message(Message(f\"Hello from outer, {message.content}\"), self.inner_agent_id) print(f\"Received inner response: {response.content}\") Upone receving a message, the OuterAgent sends a direct message to the InnerAgent and receives a message in response. We can test these agents by sending a Message to the OuterAgent. runtime = SingleThreadedAgentRuntime() await InnerAgent.register(runtime, \"inner_agent\", lambda: InnerAgent(\"InnerAgent\")) await OuterAgent.register(runtime, \"outer_agent\", lambda: OuterAgent(\"OuterAgent\", \"inner_agent\")) runtime.start() outer_agent_id = AgentId(\"outer_agent\", \"default\") await runtime.send_message(Message(content=\"Hello, World!\"), outer_agent_id) await runtime.stop_when_idle() Received message: Hello, World! Received inner response: Hello from inner, Hello from outer, Hello, World! Both outputs are produced by the OuterAgent’s message handler, however the second output is based on the response from the InnerAgent. Generally speaking, direct messaging is appropriate for scenarios when the sender and recipient are tightly coupled – they are created together and the sender is linked to a specific instance of the recipient. For example, an agent executes tool calls by sending direct messages to an instance of ToolAgent, and uses the responses to form an action-observation loop. Broadcast# Broadcast is effectively the publish/subscribe model with topic and subscription. Read Topic and Subscription to learn the core concepts. The key difference between direct messaging and broadcast is that broadcast cannot be used for request/response scenarios. When an agent publishes a message it is one way only, it cannot receive a response from any other agent, even if a receiving agent’s handler returns a value. Note If a response is given to a published message, it will be thrown away. Note If an agent publishes a message type for which it is subscribed it will not receive the message it published. This is to prevent infinite loops. Subscribe and Publish to Topics# Type-based subscription maps messages published to topics of a given topic type to agents of a given agent type. To make an agent that subsclasses RoutedAgent subscribe to a topic of a given topic type, you can use the type_subscription() class decorator. The following example shows a ReceiverAgent class that subscribes to topics of \"default\" topic type using the type_subscription() decorator. and prints the received messages. from autogen_core import RoutedAgent, message_handler, type_subscription @type_subscription(topic_type=\"default\") class ReceivingAgent(RoutedAgent): @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> None: print(f\"Received a message: {message.content}\") To publish a message from an agent’s handler, use the publish_message() method and specify a TopicId. This call must still be awaited to allow the runtime to schedule delivery of the message to all subscribers, but it will always return None. If an agent raises an exception while handling a published message, this will be logged but will not be propagated back to the publishing agent. The following example shows a BroadcastingAgent that publishes a message to a topic upon receiving a message. from autogen_core import TopicId class BroadcastingAgent(RoutedAgent): @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> None: await self.publish_message( Message(\"Publishing a message from broadcasting agent!\"), topic_id=TopicId(type=\"default\", source=self.id.key), ) BroadcastingAgent publishes message to a topic with type \"default\" and source assigned to the agent instance’s agent key. Subscriptions are registered with the agent runtime, either as part of agent type’s registration or through a separate API method. Here is how we register TypeSubscription for the receiving agent with the type_subscription() decorator, and for the broadcasting agent without the decorator. from autogen_core import TypeSubscription runtime = SingleThreadedAgentRuntime() # Option 1: with type_subscription decorator # The type_subscription class decorator automatically adds a TypeSubscription to # the runtime when the agent is registered. await ReceivingAgent.register(runtime, \"receiving_agent\", lambda: ReceivingAgent(\"Receiving Agent\")) # Option 2: with TypeSubscription await BroadcastingAgent.register(runtime, \"broadcasting_agent\", lambda: BroadcastingAgent(\"Broadcasting Agent\")) await runtime.add_subscription(TypeSubscription(topic_type=\"default\", agent_type=\"broadcasting_agent\")) # Start the runtime and publish a message. runtime.start() await runtime.publish_message( Message(\"Hello, World! From the runtime!\"), topic_id=TopicId(type=\"default\", source=\"default\") ) await runtime.stop_when_idle() Received a message: Hello, World! From the runtime! Received a message: Publishing a message from broadcasting agent! As shown in the above example, you can also publish directly to a topic through the runtime’s publish_message() method without the need to create an agent instance. From the output, you can see two messages were received by the receiving agent: one was published through the runtime, and the other was published by the broadcasting agent. Default Topic and Subscriptions# In the above example, we used TopicId and TypeSubscription to specify the topic and subscriptions respectively. This is the appropriate way for many scenarios. However, when there is a single scope of publishing, that is, all agents publish and subscribe to all broadcasted messages, we can use the convenience classes DefaultTopicId and default_subscription() to simplify our code. DefaultTopicId is for creating a topic that uses \"default\" as the default value for the topic type and the publishing agent’s key as the default value for the topic source. default_subscription() is for creating a type subscription that subscribes to the default topic. We can simplify BroadcastingAgent by using DefaultTopicId and default_subscription(). from autogen_core import DefaultTopicId, default_subscription @default_subscription class BroadcastingAgentDefaultTopic(RoutedAgent): @message_handler async def on_my_message(self, message: Message, ctx: MessageContext) -> None: # Publish a message to all agents in the same namespace. await self.publish_message( Message(\"Publishing a message from broadcasting agent!\"), topic_id=DefaultTopicId(), ) When the runtime calls register() to register the agent type, it creates a TypeSubscription whose topic type uses \"default\" as the default value and agent type uses the same agent type that is being registered in the same context. runtime = SingleThreadedAgentRuntime() await BroadcastingAgentDefaultTopic.register( runtime, \"broadcasting_agent\", lambda: BroadcastingAgentDefaultTopic(\"Broadcasting Agent\") ) await ReceivingAgent.register(runtime, \"receiving_agent\", lambda: ReceivingAgent(\"Receiving Agent\")) runtime.start() await runtime.publish_message(Message(\"Hello, World! From the runtime!\"), topic_id=DefaultTopicId()) await runtime.stop_when_idle() Received a message: Hello, World! From the runtime! Received a message: Publishing a message from broadcasting agent! Note If your scenario allows all agents to publish and subscribe to all broadcasted messages, use DefaultTopicId and default_subscription() to decorate your agent classes. previous Agent and Agent Runtime next Logging",
      "code": "pydantic.BaseModel"
    },
    {
      "description": "For example:",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass TextMessage:\n    content: str\n    source: str\n\n\n@dataclass\nclass ImageMessage:\n    url: str\n    source: str"
    }
  ],
  "links": [
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/message-and-communication.html",
    "https://microsoft.github.io/autogen/stable/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/extensions-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/autogenstudio-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/reference/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/installation.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/quickstart.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-and-multi-agent-application.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/architecture.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/application-stack.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-identity-and-lifecycle.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/topic-and-subscription.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/agent-and-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/logging.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/telemetry.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/distributed-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/component-config.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-clients.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-context.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/tools.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/workbench.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/command-line-code-executors.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/intro.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/concurrent-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/sequential-workflow.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/group-chat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/handoffs.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/mixture-of-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/multi-agent-debate.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/reflection.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/code-execution-groupchat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/azure-openai-with-aad-auth.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/termination-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/tool-use-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/extracting-results-with-an-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/openai-assistant-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/langgraph-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llamaindex-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/local-llms-ollama-litellm.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/instrumenting.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/topic-subscription-scenarios.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/structured-output-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llm-usage-logger.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/faqs.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.exceptions.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.tool_agent.html"
  ]
}