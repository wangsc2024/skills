{
  "url": "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/topic-subscription-scenarios.html",
  "title": "Topic and Subscription Example Scenarios — AutoGen",
  "content": "In this cookbook, we explore how broadcasting works for agent communication in AutoGen using four different broadcasting scenarios. These scenarios illustrate various ways to handle and distribute messages among agents. We’ll use a consistent example of a tax management company processing client requests to demonstrate each scenario.\n\nImagine a tax management company that offers various services to clients, such as tax planning, dispute resolution, compliance, and preparation. The company employs a team of tax specialists, each with expertise in one of these areas, and a tax system manager who oversees the operations.\n\nClients submit requests that need to be processed by the appropriate specialists. The communication between the clients, the tax system manager, and the tax specialists is handled through broadcasting in this system.\n\nWe’ll explore how different broadcasting scenarios affect the way messages are distributed among agents and how they can be used to tailor the communication flow to specific needs.\n\nWe will cover the following broadcasting scenarios:\n\nSingle-Tenant, Single Scope of Publishing\n\nMulti-Tenant, Single Scope of Publishing\n\nSingle-Tenant, Multiple Scopes of Publishing\n\nMulti-Tenant, Multiple Scopes of Publishing\n\nEach scenario represents a different approach to message distribution and agent interaction within the system. By understanding these scenarios, you can design agent communication strategies that best fit your application’s requirements.\n\nIn the single-tenant, single scope of publishing scenario:\n\nAll agents operate within a single tenant (e.g., one client or user session).\n\nMessages are published to a single topic, and all agents subscribe to this topic.\n\nEvery agent receives every message that gets published to the topic.\n\nThis scenario is suitable for situations where all agents need to be aware of all messages, and there’s no need to isolate communication between different groups of agents or sessions.\n\nIn our tax specialist company, this scenario implies:\n\nAll tax specialists receive every client request and internal message.\n\nAll agents collaborate closely, with full visibility of all communications.\n\nUseful for tasks or teams where all agents need to be aware of all messages.\n\nSubscriptions: All agents use the default subscription(e.g., “default”).\n\nPublishing: Messages are published to the default topic.\n\nMessage Handling: Each agent decides whether to act on a message based on its content and available handlers.\n\nSimplicity: Easy to set up and understand.\n\nCollaboration: Promotes transparency and collaboration among agents.\n\nFlexibility: Agents can dynamically decide which messages to process.\n\nScalability: May not scale well with a large number of agents or messages.\n\nEfficiency: Agents may receive many irrelevant messages, leading to unnecessary processing.\n\nIn the multi-tenant, single scope of publishing scenario:\n\nThere are multiple tenants (e.g., multiple clients or user sessions).\n\nEach tenant has its own isolated topic through the topic source.\n\nAll agents within a tenant subscribe to the tenant’s topic. If needed, new agent instances are created for each tenant.\n\nMessages are only visible to agents within the same tenant.\n\nThis scenario is useful when you need to isolate communication between different tenants but want all agents within a tenant to be aware of all messages.\n\nThe company serves multiple clients (tenants) simultaneously.\n\nFor each client, a dedicated set of agent instances is created.\n\nEach client’s communication is isolated from others.\n\nAll agents for a client receive messages published to that client’s topic.\n\nSubscriptions: Agents subscribe to topics based on the tenant’s identity.\n\nPublishing: Messages are published to the tenant-specific topic.\n\nMessage Handling: Agents only receive messages relevant to their tenant.\n\nTenant Isolation: Ensures data privacy and separation between clients.\n\nCollaboration Within Tenant: Agents can collaborate freely within their tenant.\n\nComplexity: Requires managing multiple sets of agents and topics.\n\nResource Usage: More agent instances may consume additional resources.\n\nIn the single-tenant, multiple scopes of publishing scenario:\n\nAll agents operate within a single tenant.\n\nMessages are published to different topics.\n\nAgents subscribe to specific topics relevant to their role or specialty.\n\nMessages are directed to subsets of agents based on the topic.\n\nThis scenario allows for targeted communication within a tenant, enabling more granular control over message distribution.\n\nThe tax system manager communicates with specific specialists based on their specialties.\n\nDifferent topics represent different specialties (e.g., “planning”, “compliance”).\n\nSpecialists subscribe only to the topic that matches their specialty.\n\nThe manager publishes messages to specific topics to reach the intended specialists.\n\nSubscriptions: Agents subscribe to topics corresponding to their specialties.\n\nPublishing: Messages are published to topics based on the intended recipients.\n\nMessage Handling: Only agents subscribed to a topic receive its messages.\n\nTargeted Communication: Messages reach only the relevant agents.\n\nEfficiency: Reduces unnecessary message processing by agents.\n\nSetup Complexity: Requires careful management of topics and subscriptions.\n\nFlexibility: Changes in communication scenarios may require updating subscriptions.\n\nIn the multi-tenant, multiple scopes of publishing scenario:\n\nThere are multiple tenants, each with their own set of agents.\n\nMessages are published to multiple topics within each tenant.\n\nAgents subscribe to tenant-specific topics relevant to their role.\n\nCombines tenant isolation with targeted communication.\n\nThis scenario provides the highest level of control over message distribution, suitable for complex systems with multiple clients and specialized communication needs.\n\nThe company serves multiple clients, each with dedicated agent instances.\n\nWithin each client, agents communicate using multiple topics based on specialties.\n\nFor example, Client A’s planning specialist subscribes to the “planning” topic with source “ClientA”.\n\nThe tax system manager for each client communicates with their specialists using tenant-specific topics.\n\nSubscriptions: Agents subscribe to topics based on both tenant identity and specialty.\n\nPublishing: Messages are published to tenant-specific and specialty-specific topics.\n\nMessage Handling: Only agents matching the tenant and topic receive messages.\n\nComplete Isolation: Ensures both tenant and communication isolation.\n\nGranular Control: Enables precise routing of messages to intended agents.\n\nComplexity: Requires careful management of topics, tenants, and subscriptions.\n\nResource Usage: Increased number of agent instances and topics may impact resources.\n\nInstrumentating your code locally\n\nStructured output using GPT-4o models",
  "headings": [
    {
      "level": "h1",
      "text": "Topic and Subscription Example Scenarios#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Introduction#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Scenario Overview#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Broadcasting Scenarios Overview#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "1. Single-Tenant, Single Scope of Publishing#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Scenarios Explanation#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Application in the Tax Specialist Company#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "How the Scenario Works#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Benefits#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Considerations#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "2. Multi-Tenant, Single Scope of Publishing#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Scenario Explanation#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Application in the Tax Specialist Company#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "How the Scenario Works#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Benefits#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Considerations#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "3. Single-Tenant, Multiple Scopes of Publishing#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Scenario Explanation#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Application in the Tax Management Company#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "How the Scenario Works#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Benefits#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Considerations#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "4. Multi-Tenant, Multiple Scopes of Publishing#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Scenario Explanation#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Application in the Tax Management Company#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "How the Scenario Works#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Benefits#",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Considerations#",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List\n\nfrom autogen_core import (\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    TopicId,\n    TypeSubscription,\n    message_handler,\n)\nfrom autogen_core._default_subscription import DefaultSubscription\nfrom autogen_core._default_topic import DefaultTopicId\nfrom autogen_core.models import (\n    SystemMessage,\n)",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List\n\nfrom autogen_core import (\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    TopicId,\n    TypeSubscription,\n    message_handler,\n)\nfrom autogen_core._default_subscription import DefaultSubscription\nfrom autogen_core._default_topic import DefaultTopicId\nfrom autogen_core.models import (\n    SystemMessage,\n)",
      "language": "python"
    },
    {
      "code": "class TaxSpecialty(str, Enum):\n    PLANNING = \"planning\"\n    DISPUTE_RESOLUTION = \"dispute_resolution\"\n    COMPLIANCE = \"compliance\"\n    PREPARATION = \"preparation\"\n\n\n@dataclass\nclass ClientRequest:\n    content: str\n\n\n@dataclass\nclass RequestAssessment:\n    content: str\n\n\nclass TaxSpecialist(RoutedAgent):\n    def __init__(\n        self,\n        description: str,\n        specialty: TaxSpecialty,\n        system_messages: List[SystemMessage],\n    ) -> None:\n        super().__init__(description)\n        self.specialty = specialty\n        self._system_messages = system_messages\n        self._memory: List[ClientRequest] = []\n\n    @message_handler\n    async def handle_message(self, message: ClientRequest, ctx: MessageContext) -> None:\n        # Process the client request.\n        print(f\"\\n{'='*50}\\nTax specialist {self.id} with specialty {self.specialty}:\\n{message.content}\")\n        # Send a response back to the manager\n        if ctx.topic_id is None:\n            raise ValueError(\"Topic ID is required for broadcasting\")\n        await self.publish_message(\n            message=RequestAssessment(content=f\"I can handle this request in {self.specialty}.\"),\n            topic_id=ctx.topic_id,\n        )",
      "language": "python"
    },
    {
      "code": "class TaxSpecialty(str, Enum):\n    PLANNING = \"planning\"\n    DISPUTE_RESOLUTION = \"dispute_resolution\"\n    COMPLIANCE = \"compliance\"\n    PREPARATION = \"preparation\"\n\n\n@dataclass\nclass ClientRequest:\n    content: str\n\n\n@dataclass\nclass RequestAssessment:\n    content: str\n\n\nclass TaxSpecialist(RoutedAgent):\n    def __init__(\n        self,\n        description: str,\n        specialty: TaxSpecialty,\n        system_messages: List[SystemMessage],\n    ) -> None:\n        super().__init__(description)\n        self.specialty = specialty\n        self._system_messages = system_messages\n        self._memory: List[ClientRequest] = []\n\n    @message_handler\n    async def handle_message(self, message: ClientRequest, ctx: MessageContext) -> None:\n        # Process the client request.\n        print(f\"\\n{'='*50}\\nTax specialist {self.id} with specialty {self.specialty}:\\n{message.content}\")\n        # Send a response back to the manager\n        if ctx.topic_id is None:\n            raise ValueError(\"Topic ID is required for broadcasting\")\n        await self.publish_message(\n            message=RequestAssessment(content=f\"I can handle this request in {self.specialty}.\"),\n            topic_id=ctx.topic_id,\n        )",
      "language": "python"
    },
    {
      "code": "async def run_single_tenant_single_scope() -> None:\n    # Create the runtime.\n    runtime = SingleThreadedAgentRuntime()\n\n    # Register TaxSpecialist agents for each specialty\n    specialist_agent_type_1 = \"TaxSpecialist_1\"\n    specialist_agent_type_2 = \"TaxSpecialist_2\"\n    await TaxSpecialist.register(\n        runtime=runtime,\n        type=specialist_agent_type_1,\n        factory=lambda: TaxSpecialist(\n            description=\"A tax specialist 1\",\n            specialty=TaxSpecialty.PLANNING,\n            system_messages=[SystemMessage(content=\"You are a tax specialist.\")],\n        ),\n    )\n\n    await TaxSpecialist.register(\n        runtime=runtime,\n        type=specialist_agent_type_2,\n        factory=lambda: TaxSpecialist(\n            description=\"A tax specialist 2\",\n            specialty=TaxSpecialty.DISPUTE_RESOLUTION,\n            system_messages=[SystemMessage(content=\"You are a tax specialist.\")],\n        ),\n    )\n\n    # Add default subscriptions for each agent type\n    await runtime.add_subscription(DefaultSubscription(agent_type=specialist_agent_type_1))\n    await runtime.add_subscription(DefaultSubscription(agent_type=specialist_agent_type_2))\n\n    # Start the runtime and send a message to agents on default topic\n    runtime.start()\n    await runtime.publish_message(ClientRequest(\"I need to have my tax for 2024 prepared.\"), topic_id=DefaultTopicId())\n    await runtime.stop_when_idle()\n\n\nawait run_single_tenant_single_scope()",
      "language": "python"
    },
    {
      "code": "async def run_single_tenant_single_scope() -> None:\n    # Create the runtime.\n    runtime = SingleThreadedAgentRuntime()\n\n    # Register TaxSpecialist agents for each specialty\n    specialist_agent_type_1 = \"TaxSpecialist_1\"\n    specialist_agent_type_2 = \"TaxSpecialist_2\"\n    await TaxSpecialist.register(\n        runtime=runtime,\n        type=specialist_agent_type_1,\n        factory=lambda: TaxSpecialist(\n            description=\"A tax specialist 1\",\n            specialty=TaxSpecialty.PLANNING,\n            system_messages=[SystemMessage(content=\"You are a tax specialist.\")],\n        ),\n    )\n\n    await TaxSpecialist.register(\n        runtime=runtime,\n        type=specialist_agent_type_2,\n        factory=lambda: TaxSpecialist(\n            description=\"A tax specialist 2\",\n            specialty=TaxSpecialty.DISPUTE_RESOLUTION,\n            system_messages=[SystemMessage(content=\"You are a tax specialist.\")],\n        ),\n    )\n\n    # Add default subscriptions for each agent type\n    await runtime.add_subscription(DefaultSubscription(agent_type=specialist_agent_type_1))\n    await runtime.add_subscription(DefaultSubscription(agent_type=specialist_agent_type_2))\n\n    # Start the runtime and send a message to agents on default topic\n    runtime.start()\n    await runtime.publish_message(ClientRequest(\"I need to have my tax for 2024 prepared.\"), topic_id=DefaultTopicId())\n    await runtime.stop_when_idle()\n\n\nawait run_single_tenant_single_scope()",
      "language": "python"
    },
    {
      "code": "==================================================\nTax specialist TaxSpecialist_1:default with specialty TaxSpecialty.PLANNING:\nI need to have my tax for 2024 prepared.\n\n==================================================\nTax specialist TaxSpecialist_2:default with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nI need to have my tax for 2024 prepared.",
      "language": "unknown"
    },
    {
      "code": "==================================================\nTax specialist TaxSpecialist_1:default with specialty TaxSpecialty.PLANNING:\nI need to have my tax for 2024 prepared.\n\n==================================================\nTax specialist TaxSpecialist_2:default with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nI need to have my tax for 2024 prepared.",
      "language": "unknown"
    },
    {
      "code": "async def run_multi_tenant_single_scope() -> None:\n    # Create the runtime\n    runtime = SingleThreadedAgentRuntime()\n\n    # List of clients (tenants)\n    tenants = [\"ClientABC\", \"ClientXYZ\"]\n\n    # Initialize sessions and map the topic type to each TaxSpecialist agent type\n    for specialty in TaxSpecialty:\n        specialist_agent_type = f\"TaxSpecialist_{specialty.value}\"\n        await TaxSpecialist.register(\n            runtime=runtime,\n            type=specialist_agent_type,\n            factory=lambda specialty=specialty: TaxSpecialist(  # type: ignore\n                description=f\"A tax specialist in {specialty.value}.\",\n                specialty=specialty,\n                system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")],\n            ),\n        )\n        specialist_subscription = DefaultSubscription(agent_type=specialist_agent_type)\n        await runtime.add_subscription(specialist_subscription)\n\n    # Start the runtime\n    runtime.start()\n\n    # Publish client requests to their respective topics\n    for tenant in tenants:\n        topic_source = tenant  # The topic source is the client name\n        topic_id = DefaultTopicId(source=topic_source)\n        await runtime.publish_message(\n            ClientRequest(f\"{tenant} requires tax services.\"),\n            topic_id=topic_id,\n        )\n\n    # Allow time for message processing\n    await asyncio.sleep(1)\n\n    # Stop the runtime when idle\n    await runtime.stop_when_idle()\n\n\nawait run_multi_tenant_single_scope()",
      "language": "python"
    },
    {
      "code": "async def run_multi_tenant_single_scope() -> None:\n    # Create the runtime\n    runtime = SingleThreadedAgentRuntime()\n\n    # List of clients (tenants)\n    tenants = [\"ClientABC\", \"ClientXYZ\"]\n\n    # Initialize sessions and map the topic type to each TaxSpecialist agent type\n    for specialty in TaxSpecialty:\n        specialist_agent_type = f\"TaxSpecialist_{specialty.value}\"\n        await TaxSpecialist.register(\n            runtime=runtime,\n            type=specialist_agent_type,\n            factory=lambda specialty=specialty: TaxSpecialist(  # type: ignore\n                description=f\"A tax specialist in {specialty.value}.\",\n                specialty=specialty,\n                system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")],\n            ),\n        )\n        specialist_subscription = DefaultSubscription(agent_type=specialist_agent_type)\n        await runtime.add_subscription(specialist_subscription)\n\n    # Start the runtime\n    runtime.start()\n\n    # Publish client requests to their respective topics\n    for tenant in tenants:\n        topic_source = tenant  # The topic source is the client name\n        topic_id = DefaultTopicId(source=topic_source)\n        await runtime.publish_message(\n            ClientRequest(f\"{tenant} requires tax services.\"),\n            topic_id=topic_id,\n        )\n\n    # Allow time for message processing\n    await asyncio.sleep(1)\n\n    # Stop the runtime when idle\n    await runtime.stop_when_idle()\n\n\nawait run_multi_tenant_single_scope()",
      "language": "python"
    },
    {
      "code": "==================================================\nTax specialist TaxSpecialist_planning:ClientABC with specialty TaxSpecialty.PLANNING:\nClientABC requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:ClientABC with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nClientABC requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_compliance:ClientABC with specialty TaxSpecialty.COMPLIANCE:\nClientABC requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_preparation:ClientABC with specialty TaxSpecialty.PREPARATION:\nClientABC requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_planning:ClientXYZ with specialty TaxSpecialty.PLANNING:\nClientXYZ requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:ClientXYZ with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nClientXYZ requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_compliance:ClientXYZ with specialty TaxSpecialty.COMPLIANCE:\nClientXYZ requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_preparation:ClientXYZ with specialty TaxSpecialty.PREPARATION:\nClientXYZ requires tax services.",
      "language": "unknown"
    },
    {
      "code": "==================================================\nTax specialist TaxSpecialist_planning:ClientABC with specialty TaxSpecialty.PLANNING:\nClientABC requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:ClientABC with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nClientABC requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_compliance:ClientABC with specialty TaxSpecialty.COMPLIANCE:\nClientABC requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_preparation:ClientABC with specialty TaxSpecialty.PREPARATION:\nClientABC requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_planning:ClientXYZ with specialty TaxSpecialty.PLANNING:\nClientXYZ requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:ClientXYZ with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nClientXYZ requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_compliance:ClientXYZ with specialty TaxSpecialty.COMPLIANCE:\nClientXYZ requires tax services.\n\n==================================================\nTax specialist TaxSpecialist_preparation:ClientXYZ with specialty TaxSpecialty.PREPARATION:\nClientXYZ requires tax services.",
      "language": "unknown"
    },
    {
      "code": "async def run_single_tenant_multiple_scope() -> None:\n    # Create the runtime\n    runtime = SingleThreadedAgentRuntime()\n    # Register TaxSpecialist agents for each specialty and add subscriptions\n    for specialty in TaxSpecialty:\n        specialist_agent_type = f\"TaxSpecialist_{specialty.value}\"\n        await TaxSpecialist.register(\n            runtime=runtime,\n            type=specialist_agent_type,\n            factory=lambda specialty=specialty: TaxSpecialist(  # type: ignore\n                description=f\"A tax specialist in {specialty.value}.\",\n                specialty=specialty,\n                system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")],\n            ),\n        )\n        specialist_subscription = TypeSubscription(topic_type=specialty.value, agent_type=specialist_agent_type)\n        await runtime.add_subscription(specialist_subscription)\n\n    # Start the runtime\n    runtime.start()\n\n    # Publish a ClientRequest to each specialist's topic\n    for specialty in TaxSpecialty:\n        topic_id = TopicId(type=specialty.value, source=\"default\")\n        await runtime.publish_message(\n            ClientRequest(f\"I need assistance with {specialty.value} taxes.\"),\n            topic_id=topic_id,\n        )\n\n    # Allow time for message processing\n    await asyncio.sleep(1)\n\n    # Stop the runtime when idle\n    await runtime.stop_when_idle()\n\n\nawait run_single_tenant_multiple_scope()",
      "language": "python"
    },
    {
      "code": "async def run_single_tenant_multiple_scope() -> None:\n    # Create the runtime\n    runtime = SingleThreadedAgentRuntime()\n    # Register TaxSpecialist agents for each specialty and add subscriptions\n    for specialty in TaxSpecialty:\n        specialist_agent_type = f\"TaxSpecialist_{specialty.value}\"\n        await TaxSpecialist.register(\n            runtime=runtime,\n            type=specialist_agent_type,\n            factory=lambda specialty=specialty: TaxSpecialist(  # type: ignore\n                description=f\"A tax specialist in {specialty.value}.\",\n                specialty=specialty,\n                system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")],\n            ),\n        )\n        specialist_subscription = TypeSubscription(topic_type=specialty.value, agent_type=specialist_agent_type)\n        await runtime.add_subscription(specialist_subscription)\n\n    # Start the runtime\n    runtime.start()\n\n    # Publish a ClientRequest to each specialist's topic\n    for specialty in TaxSpecialty:\n        topic_id = TopicId(type=specialty.value, source=\"default\")\n        await runtime.publish_message(\n            ClientRequest(f\"I need assistance with {specialty.value} taxes.\"),\n            topic_id=topic_id,\n        )\n\n    # Allow time for message processing\n    await asyncio.sleep(1)\n\n    # Stop the runtime when idle\n    await runtime.stop_when_idle()\n\n\nawait run_single_tenant_multiple_scope()",
      "language": "python"
    },
    {
      "code": "==================================================\nTax specialist TaxSpecialist_planning:default with specialty TaxSpecialty.PLANNING:\nI need assistance with planning taxes.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:default with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nI need assistance with dispute_resolution taxes.\n\n==================================================\nTax specialist TaxSpecialist_compliance:default with specialty TaxSpecialty.COMPLIANCE:\nI need assistance with compliance taxes.\n\n==================================================\nTax specialist TaxSpecialist_preparation:default with specialty TaxSpecialty.PREPARATION:\nI need assistance with preparation taxes.",
      "language": "unknown"
    },
    {
      "code": "==================================================\nTax specialist TaxSpecialist_planning:default with specialty TaxSpecialty.PLANNING:\nI need assistance with planning taxes.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:default with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nI need assistance with dispute_resolution taxes.\n\n==================================================\nTax specialist TaxSpecialist_compliance:default with specialty TaxSpecialty.COMPLIANCE:\nI need assistance with compliance taxes.\n\n==================================================\nTax specialist TaxSpecialist_preparation:default with specialty TaxSpecialty.PREPARATION:\nI need assistance with preparation taxes.",
      "language": "unknown"
    },
    {
      "code": "async def run_multi_tenant_multiple_scope() -> None:\n    # Create the runtime\n    runtime = SingleThreadedAgentRuntime()\n\n    # Define TypeSubscriptions for each specialty and tenant\n    tenants = [\"ClientABC\", \"ClientXYZ\"]\n\n    # Initialize agents for all specialties and add type subscriptions\n    for specialty in TaxSpecialty:\n        specialist_agent_type = f\"TaxSpecialist_{specialty.value}\"\n        await TaxSpecialist.register(\n            runtime=runtime,\n            type=specialist_agent_type,\n            factory=lambda specialty=specialty: TaxSpecialist(  # type: ignore\n                description=f\"A tax specialist in {specialty.value}.\",\n                specialty=specialty,\n                system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")],\n            ),\n        )\n        for tenant in tenants:\n            specialist_subscription = TypeSubscription(\n                topic_type=f\"{tenant}_{specialty.value}\", agent_type=specialist_agent_type\n            )\n            await runtime.add_subscription(specialist_subscription)\n\n    # Start the runtime\n    runtime.start()\n\n    # Send messages for each tenant to each specialty\n    for tenant in tenants:\n        for specialty in TaxSpecialty:\n            topic_id = TopicId(type=f\"{tenant}_{specialty.value}\", source=tenant)\n            await runtime.publish_message(\n                ClientRequest(f\"{tenant} needs assistance with {specialty.value} taxes.\"),\n                topic_id=topic_id,\n            )\n\n    # Allow time for message processing\n    await asyncio.sleep(1)\n\n    # Stop the runtime when idle\n    await runtime.stop_when_idle()\n\n\nawait run_multi_tenant_multiple_scope()",
      "language": "python"
    },
    {
      "code": "async def run_multi_tenant_multiple_scope() -> None:\n    # Create the runtime\n    runtime = SingleThreadedAgentRuntime()\n\n    # Define TypeSubscriptions for each specialty and tenant\n    tenants = [\"ClientABC\", \"ClientXYZ\"]\n\n    # Initialize agents for all specialties and add type subscriptions\n    for specialty in TaxSpecialty:\n        specialist_agent_type = f\"TaxSpecialist_{specialty.value}\"\n        await TaxSpecialist.register(\n            runtime=runtime,\n            type=specialist_agent_type,\n            factory=lambda specialty=specialty: TaxSpecialist(  # type: ignore\n                description=f\"A tax specialist in {specialty.value}.\",\n                specialty=specialty,\n                system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")],\n            ),\n        )\n        for tenant in tenants:\n            specialist_subscription = TypeSubscription(\n                topic_type=f\"{tenant}_{specialty.value}\", agent_type=specialist_agent_type\n            )\n            await runtime.add_subscription(specialist_subscription)\n\n    # Start the runtime\n    runtime.start()\n\n    # Send messages for each tenant to each specialty\n    for tenant in tenants:\n        for specialty in TaxSpecialty:\n            topic_id = TopicId(type=f\"{tenant}_{specialty.value}\", source=tenant)\n            await runtime.publish_message(\n                ClientRequest(f\"{tenant} needs assistance with {specialty.value} taxes.\"),\n                topic_id=topic_id,\n            )\n\n    # Allow time for message processing\n    await asyncio.sleep(1)\n\n    # Stop the runtime when idle\n    await runtime.stop_when_idle()\n\n\nawait run_multi_tenant_multiple_scope()",
      "language": "python"
    },
    {
      "code": "==================================================\nTax specialist TaxSpecialist_planning:ClientABC with specialty TaxSpecialty.PLANNING:\nClientABC needs assistance with planning taxes.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:ClientABC with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nClientABC needs assistance with dispute_resolution taxes.\n\n==================================================\nTax specialist TaxSpecialist_compliance:ClientABC with specialty TaxSpecialty.COMPLIANCE:\nClientABC needs assistance with compliance taxes.\n\n==================================================\nTax specialist TaxSpecialist_preparation:ClientABC with specialty TaxSpecialty.PREPARATION:\nClientABC needs assistance with preparation taxes.\n\n==================================================\nTax specialist TaxSpecialist_planning:ClientXYZ with specialty TaxSpecialty.PLANNING:\nClientXYZ needs assistance with planning taxes.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:ClientXYZ with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nClientXYZ needs assistance with dispute_resolution taxes.\n\n==================================================\nTax specialist TaxSpecialist_compliance:ClientXYZ with specialty TaxSpecialty.COMPLIANCE:\nClientXYZ needs assistance with compliance taxes.\n\n==================================================\nTax specialist TaxSpecialist_preparation:ClientXYZ with specialty TaxSpecialty.PREPARATION:\nClientXYZ needs assistance with preparation taxes.",
      "language": "unknown"
    },
    {
      "code": "==================================================\nTax specialist TaxSpecialist_planning:ClientABC with specialty TaxSpecialty.PLANNING:\nClientABC needs assistance with planning taxes.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:ClientABC with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nClientABC needs assistance with dispute_resolution taxes.\n\n==================================================\nTax specialist TaxSpecialist_compliance:ClientABC with specialty TaxSpecialty.COMPLIANCE:\nClientABC needs assistance with compliance taxes.\n\n==================================================\nTax specialist TaxSpecialist_preparation:ClientABC with specialty TaxSpecialty.PREPARATION:\nClientABC needs assistance with preparation taxes.\n\n==================================================\nTax specialist TaxSpecialist_planning:ClientXYZ with specialty TaxSpecialty.PLANNING:\nClientXYZ needs assistance with planning taxes.\n\n==================================================\nTax specialist TaxSpecialist_dispute_resolution:ClientXYZ with specialty TaxSpecialty.DISPUTE_RESOLUTION:\nClientXYZ needs assistance with dispute_resolution taxes.\n\n==================================================\nTax specialist TaxSpecialist_compliance:ClientXYZ with specialty TaxSpecialty.COMPLIANCE:\nClientXYZ needs assistance with compliance taxes.\n\n==================================================\nTax specialist TaxSpecialist_preparation:ClientXYZ with specialty TaxSpecialty.PREPARATION:\nClientXYZ needs assistance with preparation taxes.",
      "language": "unknown"
    }
  ],
  "patterns": [
    {
      "description": "Core Cookbook Topic and Subscription Example Scenarios Topic and Subscription Example Scenarios# Introduction# In this cookbook, we explore how broadcasting works for agent communication in AutoGen using four different broadcasting scenarios. These scenarios illustrate various ways to handle and distribute messages among agents. We’ll use a consistent example of a tax management company processing client requests to demonstrate each scenario. Scenario Overview# Imagine a tax management company that offers various services to clients, such as tax planning, dispute resolution, compliance, and preparation. The company employs a team of tax specialists, each with expertise in one of these areas, and a tax system manager who oversees the operations. Clients submit requests that need to be processed by the appropriate specialists. The communication between the clients, the tax system manager, and the tax specialists is handled through broadcasting in this system. We’ll explore how different broadcasting scenarios affect the way messages are distributed among agents and how they can be used to tailor the communication flow to specific needs. Broadcasting Scenarios Overview# We will cover the following broadcasting scenarios: Single-Tenant, Single Scope of Publishing Multi-Tenant, Single Scope of Publishing Single-Tenant, Multiple Scopes of Publishing Multi-Tenant, Multiple Scopes of Publishing Each scenario represents a different approach to message distribution and agent interaction within the system. By understanding these scenarios, you can design agent communication strategies that best fit your application’s requirements. import asyncio from dataclasses import dataclass from enum import Enum from typing import List from autogen_core import ( MessageContext, RoutedAgent, SingleThreadedAgentRuntime, TopicId, TypeSubscription, message_handler, ) from autogen_core._default_subscription import DefaultSubscription from autogen_core._default_topic import DefaultTopicId from autogen_core.models import ( SystemMessage, ) class TaxSpecialty(str, Enum): PLANNING = \"planning\" DISPUTE_RESOLUTION = \"dispute_resolution\" COMPLIANCE = \"compliance\" PREPARATION = \"preparation\" @dataclass class ClientRequest: content: str @dataclass class RequestAssessment: content: str class TaxSpecialist(RoutedAgent): def __init__( self, description: str, specialty: TaxSpecialty, system_messages: List[SystemMessage], ) -> None: super().__init__(description) self.specialty = specialty self._system_messages = system_messages self._memory: List[ClientRequest] = [] @message_handler async def handle_message(self, message: ClientRequest, ctx: MessageContext) -> None: # Process the client request. print(f\"\\n{'='*50}\\nTax specialist {self.id} with specialty {self.specialty}:\\n{message.content}\") # Send a response back to the manager if ctx.topic_id is None: raise ValueError(\"Topic ID is required for broadcasting\") await self.publish_message( message=RequestAssessment(content=f\"I can handle this request in {self.specialty}.\"), topic_id=ctx.topic_id, ) 1. Single-Tenant, Single Scope of Publishing# Scenarios Explanation# In the single-tenant, single scope of publishing scenario: All agents operate within a single tenant (e.g., one client or user session). Messages are published to a single topic, and all agents subscribe to this topic. Every agent receives every message that gets published to the topic. This scenario is suitable for situations where all agents need to be aware of all messages, and there’s no need to isolate communication between different groups of agents or sessions. Application in the Tax Specialist Company# In our tax specialist company, this scenario implies: All tax specialists receive every client request and internal message. All agents collaborate closely, with full visibility of all communications. Useful for tasks or teams where all agents need to be aware of all messages. How the Scenario Works# Subscriptions: All agents use the default subscription(e.g., “default”). Publishing: Messages are published to the default topic. Message Handling: Each agent decides whether to act on a message based on its content and available handlers. Benefits# Simplicity: Easy to set up and understand. Collaboration: Promotes transparency and collaboration among agents. Flexibility: Agents can dynamically decide which messages to process. Considerations# Scalability: May not scale well with a large number of agents or messages. Efficiency: Agents may receive many irrelevant messages, leading to unnecessary processing. async def run_single_tenant_single_scope() -> None: # Create the runtime. runtime = SingleThreadedAgentRuntime() # Register TaxSpecialist agents for each specialty specialist_agent_type_1 = \"TaxSpecialist_1\" specialist_agent_type_2 = \"TaxSpecialist_2\" await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type_1, factory=lambda: TaxSpecialist( description=\"A tax specialist 1\", specialty=TaxSpecialty.PLANNING, system_messages=[SystemMessage(content=\"You are a tax specialist.\")], ), ) await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type_2, factory=lambda: TaxSpecialist( description=\"A tax specialist 2\", specialty=TaxSpecialty.DISPUTE_RESOLUTION, system_messages=[SystemMessage(content=\"You are a tax specialist.\")], ), ) # Add default subscriptions for each agent type await runtime.add_subscription(DefaultSubscription(agent_type=specialist_agent_type_1)) await runtime.add_subscription(DefaultSubscription(agent_type=specialist_agent_type_2)) # Start the runtime and send a message to agents on default topic runtime.start() await runtime.publish_message(ClientRequest(\"I need to have my tax for 2024 prepared.\"), topic_id=DefaultTopicId()) await runtime.stop_when_idle() await run_single_tenant_single_scope() ================================================== Tax specialist TaxSpecialist_1:default with specialty TaxSpecialty.PLANNING: I need to have my tax for 2024 prepared. ================================================== Tax specialist TaxSpecialist_2:default with specialty TaxSpecialty.DISPUTE_RESOLUTION: I need to have my tax for 2024 prepared. 2. Multi-Tenant, Single Scope of Publishing# Scenario Explanation# In the multi-tenant, single scope of publishing scenario: There are multiple tenants (e.g., multiple clients or user sessions). Each tenant has its own isolated topic through the topic source. All agents within a tenant subscribe to the tenant’s topic. If needed, new agent instances are created for each tenant. Messages are only visible to agents within the same tenant. This scenario is useful when you need to isolate communication between different tenants but want all agents within a tenant to be aware of all messages. Application in the Tax Specialist Company# In this scenario: The company serves multiple clients (tenants) simultaneously. For each client, a dedicated set of agent instances is created. Each client’s communication is isolated from others. All agents for a client receive messages published to that client’s topic. How the Scenario Works# Subscriptions: Agents subscribe to topics based on the tenant’s identity. Publishing: Messages are published to the tenant-specific topic. Message Handling: Agents only receive messages relevant to their tenant. Benefits# Tenant Isolation: Ensures data privacy and separation between clients. Collaboration Within Tenant: Agents can collaborate freely within their tenant. Considerations# Complexity: Requires managing multiple sets of agents and topics. Resource Usage: More agent instances may consume additional resources. async def run_multi_tenant_single_scope() -> None: # Create the runtime runtime = SingleThreadedAgentRuntime() # List of clients (tenants) tenants = [\"ClientABC\", \"ClientXYZ\"] # Initialize sessions and map the topic type to each TaxSpecialist agent type for specialty in TaxSpecialty: specialist_agent_type = f\"TaxSpecialist_{specialty.value}\" await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type, factory=lambda specialty=specialty: TaxSpecialist( # type: ignore description=f\"A tax specialist in {specialty.value}.\", specialty=specialty, system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")], ), ) specialist_subscription = DefaultSubscription(agent_type=specialist_agent_type) await runtime.add_subscription(specialist_subscription) # Start the runtime runtime.start() # Publish client requests to their respective topics for tenant in tenants: topic_source = tenant # The topic source is the client name topic_id = DefaultTopicId(source=topic_source) await runtime.publish_message( ClientRequest(f\"{tenant} requires tax services.\"), topic_id=topic_id, ) # Allow time for message processing await asyncio.sleep(1) # Stop the runtime when idle await runtime.stop_when_idle() await run_multi_tenant_single_scope() ================================================== Tax specialist TaxSpecialist_planning:ClientABC with specialty TaxSpecialty.PLANNING: ClientABC requires tax services. ================================================== Tax specialist TaxSpecialist_dispute_resolution:ClientABC with specialty TaxSpecialty.DISPUTE_RESOLUTION: ClientABC requires tax services. ================================================== Tax specialist TaxSpecialist_compliance:ClientABC with specialty TaxSpecialty.COMPLIANCE: ClientABC requires tax services. ================================================== Tax specialist TaxSpecialist_preparation:ClientABC with specialty TaxSpecialty.PREPARATION: ClientABC requires tax services. ================================================== Tax specialist TaxSpecialist_planning:ClientXYZ with specialty TaxSpecialty.PLANNING: ClientXYZ requires tax services. ================================================== Tax specialist TaxSpecialist_dispute_resolution:ClientXYZ with specialty TaxSpecialty.DISPUTE_RESOLUTION: ClientXYZ requires tax services. ================================================== Tax specialist TaxSpecialist_compliance:ClientXYZ with specialty TaxSpecialty.COMPLIANCE: ClientXYZ requires tax services. ================================================== Tax specialist TaxSpecialist_preparation:ClientXYZ with specialty TaxSpecialty.PREPARATION: ClientXYZ requires tax services. 3. Single-Tenant, Multiple Scopes of Publishing# Scenario Explanation# In the single-tenant, multiple scopes of publishing scenario: All agents operate within a single tenant. Messages are published to different topics. Agents subscribe to specific topics relevant to their role or specialty. Messages are directed to subsets of agents based on the topic. This scenario allows for targeted communication within a tenant, enabling more granular control over message distribution. Application in the Tax Management Company# In this scenario: The tax system manager communicates with specific specialists based on their specialties. Different topics represent different specialties (e.g., “planning”, “compliance”). Specialists subscribe only to the topic that matches their specialty. The manager publishes messages to specific topics to reach the intended specialists. How the Scenario Works# Subscriptions: Agents subscribe to topics corresponding to their specialties. Publishing: Messages are published to topics based on the intended recipients. Message Handling: Only agents subscribed to a topic receive its messages. Benefits# Targeted Communication: Messages reach only the relevant agents. Efficiency: Reduces unnecessary message processing by agents. Considerations# Setup Complexity: Requires careful management of topics and subscriptions. Flexibility: Changes in communication scenarios may require updating subscriptions. async def run_single_tenant_multiple_scope() -> None: # Create the runtime runtime = SingleThreadedAgentRuntime() # Register TaxSpecialist agents for each specialty and add subscriptions for specialty in TaxSpecialty: specialist_agent_type = f\"TaxSpecialist_{specialty.value}\" await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type, factory=lambda specialty=specialty: TaxSpecialist( # type: ignore description=f\"A tax specialist in {specialty.value}.\", specialty=specialty, system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")], ), ) specialist_subscription = TypeSubscription(topic_type=specialty.value, agent_type=specialist_agent_type) await runtime.add_subscription(specialist_subscription) # Start the runtime runtime.start() # Publish a ClientRequest to each specialist's topic for specialty in TaxSpecialty: topic_id = TopicId(type=specialty.value, source=\"default\") await runtime.publish_message( ClientRequest(f\"I need assistance with {specialty.value} taxes.\"), topic_id=topic_id, ) # Allow time for message processing await asyncio.sleep(1) # Stop the runtime when idle await runtime.stop_when_idle() await run_single_tenant_multiple_scope() ================================================== Tax specialist TaxSpecialist_planning:default with specialty TaxSpecialty.PLANNING: I need assistance with planning taxes. ================================================== Tax specialist TaxSpecialist_dispute_resolution:default with specialty TaxSpecialty.DISPUTE_RESOLUTION: I need assistance with dispute_resolution taxes. ================================================== Tax specialist TaxSpecialist_compliance:default with specialty TaxSpecialty.COMPLIANCE: I need assistance with compliance taxes. ================================================== Tax specialist TaxSpecialist_preparation:default with specialty TaxSpecialty.PREPARATION: I need assistance with preparation taxes. 4. Multi-Tenant, Multiple Scopes of Publishing# Scenario Explanation# In the multi-tenant, multiple scopes of publishing scenario: There are multiple tenants, each with their own set of agents. Messages are published to multiple topics within each tenant. Agents subscribe to tenant-specific topics relevant to their role. Combines tenant isolation with targeted communication. This scenario provides the highest level of control over message distribution, suitable for complex systems with multiple clients and specialized communication needs. Application in the Tax Management Company# In this scenario: The company serves multiple clients, each with dedicated agent instances. Within each client, agents communicate using multiple topics based on specialties. For example, Client A’s planning specialist subscribes to the “planning” topic with source “ClientA”. The tax system manager for each client communicates with their specialists using tenant-specific topics. How the Scenario Works# Subscriptions: Agents subscribe to topics based on both tenant identity and specialty. Publishing: Messages are published to tenant-specific and specialty-specific topics. Message Handling: Only agents matching the tenant and topic receive messages. Benefits# Complete Isolation: Ensures both tenant and communication isolation. Granular Control: Enables precise routing of messages to intended agents. Considerations# Complexity: Requires careful management of topics, tenants, and subscriptions. Resource Usage: Increased number of agent instances and topics may impact resources. async def run_multi_tenant_multiple_scope() -> None: # Create the runtime runtime = SingleThreadedAgentRuntime() # Define TypeSubscriptions for each specialty and tenant tenants = [\"ClientABC\", \"ClientXYZ\"] # Initialize agents for all specialties and add type subscriptions for specialty in TaxSpecialty: specialist_agent_type = f\"TaxSpecialist_{specialty.value}\" await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type, factory=lambda specialty=specialty: TaxSpecialist( # type: ignore description=f\"A tax specialist in {specialty.value}.\", specialty=specialty, system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")], ), ) for tenant in tenants: specialist_subscription = TypeSubscription( topic_type=f\"{tenant}_{specialty.value}\", agent_type=specialist_agent_type ) await runtime.add_subscription(specialist_subscription) # Start the runtime runtime.start() # Send messages for each tenant to each specialty for tenant in tenants: for specialty in TaxSpecialty: topic_id = TopicId(type=f\"{tenant}_{specialty.value}\", source=tenant) await runtime.publish_message( ClientRequest(f\"{tenant} needs assistance with {specialty.value} taxes.\"), topic_id=topic_id, ) # Allow time for message processing await asyncio.sleep(1) # Stop the runtime when idle await runtime.stop_when_idle() await run_multi_tenant_multiple_scope() ================================================== Tax specialist TaxSpecialist_planning:ClientABC with specialty TaxSpecialty.PLANNING: ClientABC needs assistance with planning taxes. ================================================== Tax specialist TaxSpecialist_dispute_resolution:ClientABC with specialty TaxSpecialty.DISPUTE_RESOLUTION: ClientABC needs assistance with dispute_resolution taxes. ================================================== Tax specialist TaxSpecialist_compliance:ClientABC with specialty TaxSpecialty.COMPLIANCE: ClientABC needs assistance with compliance taxes. ================================================== Tax specialist TaxSpecialist_preparation:ClientABC with specialty TaxSpecialty.PREPARATION: ClientABC needs assistance with preparation taxes. ================================================== Tax specialist TaxSpecialist_planning:ClientXYZ with specialty TaxSpecialty.PLANNING: ClientXYZ needs assistance with planning taxes. ================================================== Tax specialist TaxSpecialist_dispute_resolution:ClientXYZ with specialty TaxSpecialty.DISPUTE_RESOLUTION: ClientXYZ needs assistance with dispute_resolution taxes. ================================================== Tax specialist TaxSpecialist_compliance:ClientXYZ with specialty TaxSpecialty.COMPLIANCE: ClientXYZ needs assistance with compliance taxes. ================================================== Tax specialist TaxSpecialist_preparation:ClientXYZ with specialty TaxSpecialty.PREPARATION: ClientXYZ needs assistance with preparation taxes. previous Instrumentating your code locally next Structured output using GPT-4o models On this page Introduction Scenario Overview Broadcasting Scenarios Overview 1. Single-Tenant, Single Scope of Publishing Scenarios Explanation Application in the Tax Specialist Company How the Scenario Works Benefits Considerations 2. Multi-Tenant, Single Scope of Publishing Scenario Explanation Application in the Tax Specialist Company How the Scenario Works Benefits Considerations 3. Single-Tenant, Multiple Scopes of Publishing Scenario Explanation Application in the Tax Management Company How the Scenario Works Benefits Considerations 4. Multi-Tenant, Multiple Scopes of Publishing Scenario Explanation Application in the Tax Management Company How the Scenario Works Benefits Considerations Edit on GitHub Show Source",
      "code": "import asyncio\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List\n\nfrom autogen_core import (\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    TopicId,\n    TypeSubscription,\n    message_handler,\n)\nfrom autogen_core._default_subscription import DefaultSubscription\nfrom autogen_core._default_topic import DefaultTopicId\nfrom autogen_core.models import (\n    SystemMessage,\n)"
    },
    {
      "description": "Core Cookbook Topic and Subscription Example Scenarios Topic and Subscription Example Scenarios# Introduction# In this cookbook, we explore how broadcasting works for agent communication in AutoGen using four different broadcasting scenarios. These scenarios illustrate various ways to handle and distribute messages among agents. We’ll use a consistent example of a tax management company processing client requests to demonstrate each scenario. Scenario Overview# Imagine a tax management company that offers various services to clients, such as tax planning, dispute resolution, compliance, and preparation. The company employs a team of tax specialists, each with expertise in one of these areas, and a tax system manager who oversees the operations. Clients submit requests that need to be processed by the appropriate specialists. The communication between the clients, the tax system manager, and the tax specialists is handled through broadcasting in this system. We’ll explore how different broadcasting scenarios affect the way messages are distributed among agents and how they can be used to tailor the communication flow to specific needs. Broadcasting Scenarios Overview# We will cover the following broadcasting scenarios: Single-Tenant, Single Scope of Publishing Multi-Tenant, Single Scope of Publishing Single-Tenant, Multiple Scopes of Publishing Multi-Tenant, Multiple Scopes of Publishing Each scenario represents a different approach to message distribution and agent interaction within the system. By understanding these scenarios, you can design agent communication strategies that best fit your application’s requirements. import asyncio from dataclasses import dataclass from enum import Enum from typing import List from autogen_core import ( MessageContext, RoutedAgent, SingleThreadedAgentRuntime, TopicId, TypeSubscription, message_handler, ) from autogen_core._default_subscription import DefaultSubscription from autogen_core._default_topic import DefaultTopicId from autogen_core.models import ( SystemMessage, ) class TaxSpecialty(str, Enum): PLANNING = \"planning\" DISPUTE_RESOLUTION = \"dispute_resolution\" COMPLIANCE = \"compliance\" PREPARATION = \"preparation\" @dataclass class ClientRequest: content: str @dataclass class RequestAssessment: content: str class TaxSpecialist(RoutedAgent): def __init__( self, description: str, specialty: TaxSpecialty, system_messages: List[SystemMessage], ) -> None: super().__init__(description) self.specialty = specialty self._system_messages = system_messages self._memory: List[ClientRequest] = [] @message_handler async def handle_message(self, message: ClientRequest, ctx: MessageContext) -> None: # Process the client request. print(f\"\\n{'='*50}\\nTax specialist {self.id} with specialty {self.specialty}:\\n{message.content}\") # Send a response back to the manager if ctx.topic_id is None: raise ValueError(\"Topic ID is required for broadcasting\") await self.publish_message( message=RequestAssessment(content=f\"I can handle this request in {self.specialty}.\"), topic_id=ctx.topic_id, ) 1. Single-Tenant, Single Scope of Publishing# Scenarios Explanation# In the single-tenant, single scope of publishing scenario: All agents operate within a single tenant (e.g., one client or user session). Messages are published to a single topic, and all agents subscribe to this topic. Every agent receives every message that gets published to the topic. This scenario is suitable for situations where all agents need to be aware of all messages, and there’s no need to isolate communication between different groups of agents or sessions. Application in the Tax Specialist Company# In our tax specialist company, this scenario implies: All tax specialists receive every client request and internal message. All agents collaborate closely, with full visibility of all communications. Useful for tasks or teams where all agents need to be aware of all messages. How the Scenario Works# Subscriptions: All agents use the default subscription(e.g., “default”). Publishing: Messages are published to the default topic. Message Handling: Each agent decides whether to act on a message based on its content and available handlers. Benefits# Simplicity: Easy to set up and understand. Collaboration: Promotes transparency and collaboration among agents. Flexibility: Agents can dynamically decide which messages to process. Considerations# Scalability: May not scale well with a large number of agents or messages. Efficiency: Agents may receive many irrelevant messages, leading to unnecessary processing. async def run_single_tenant_single_scope() -> None: # Create the runtime. runtime = SingleThreadedAgentRuntime() # Register TaxSpecialist agents for each specialty specialist_agent_type_1 = \"TaxSpecialist_1\" specialist_agent_type_2 = \"TaxSpecialist_2\" await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type_1, factory=lambda: TaxSpecialist( description=\"A tax specialist 1\", specialty=TaxSpecialty.PLANNING, system_messages=[SystemMessage(content=\"You are a tax specialist.\")], ), ) await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type_2, factory=lambda: TaxSpecialist( description=\"A tax specialist 2\", specialty=TaxSpecialty.DISPUTE_RESOLUTION, system_messages=[SystemMessage(content=\"You are a tax specialist.\")], ), ) # Add default subscriptions for each agent type await runtime.add_subscription(DefaultSubscription(agent_type=specialist_agent_type_1)) await runtime.add_subscription(DefaultSubscription(agent_type=specialist_agent_type_2)) # Start the runtime and send a message to agents on default topic runtime.start() await runtime.publish_message(ClientRequest(\"I need to have my tax for 2024 prepared.\"), topic_id=DefaultTopicId()) await runtime.stop_when_idle() await run_single_tenant_single_scope() ================================================== Tax specialist TaxSpecialist_1:default with specialty TaxSpecialty.PLANNING: I need to have my tax for 2024 prepared. ================================================== Tax specialist TaxSpecialist_2:default with specialty TaxSpecialty.DISPUTE_RESOLUTION: I need to have my tax for 2024 prepared. 2. Multi-Tenant, Single Scope of Publishing# Scenario Explanation# In the multi-tenant, single scope of publishing scenario: There are multiple tenants (e.g., multiple clients or user sessions). Each tenant has its own isolated topic through the topic source. All agents within a tenant subscribe to the tenant’s topic. If needed, new agent instances are created for each tenant. Messages are only visible to agents within the same tenant. This scenario is useful when you need to isolate communication between different tenants but want all agents within a tenant to be aware of all messages. Application in the Tax Specialist Company# In this scenario: The company serves multiple clients (tenants) simultaneously. For each client, a dedicated set of agent instances is created. Each client’s communication is isolated from others. All agents for a client receive messages published to that client’s topic. How the Scenario Works# Subscriptions: Agents subscribe to topics based on the tenant’s identity. Publishing: Messages are published to the tenant-specific topic. Message Handling: Agents only receive messages relevant to their tenant. Benefits# Tenant Isolation: Ensures data privacy and separation between clients. Collaboration Within Tenant: Agents can collaborate freely within their tenant. Considerations# Complexity: Requires managing multiple sets of agents and topics. Resource Usage: More agent instances may consume additional resources. async def run_multi_tenant_single_scope() -> None: # Create the runtime runtime = SingleThreadedAgentRuntime() # List of clients (tenants) tenants = [\"ClientABC\", \"ClientXYZ\"] # Initialize sessions and map the topic type to each TaxSpecialist agent type for specialty in TaxSpecialty: specialist_agent_type = f\"TaxSpecialist_{specialty.value}\" await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type, factory=lambda specialty=specialty: TaxSpecialist( # type: ignore description=f\"A tax specialist in {specialty.value}.\", specialty=specialty, system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")], ), ) specialist_subscription = DefaultSubscription(agent_type=specialist_agent_type) await runtime.add_subscription(specialist_subscription) # Start the runtime runtime.start() # Publish client requests to their respective topics for tenant in tenants: topic_source = tenant # The topic source is the client name topic_id = DefaultTopicId(source=topic_source) await runtime.publish_message( ClientRequest(f\"{tenant} requires tax services.\"), topic_id=topic_id, ) # Allow time for message processing await asyncio.sleep(1) # Stop the runtime when idle await runtime.stop_when_idle() await run_multi_tenant_single_scope() ================================================== Tax specialist TaxSpecialist_planning:ClientABC with specialty TaxSpecialty.PLANNING: ClientABC requires tax services. ================================================== Tax specialist TaxSpecialist_dispute_resolution:ClientABC with specialty TaxSpecialty.DISPUTE_RESOLUTION: ClientABC requires tax services. ================================================== Tax specialist TaxSpecialist_compliance:ClientABC with specialty TaxSpecialty.COMPLIANCE: ClientABC requires tax services. ================================================== Tax specialist TaxSpecialist_preparation:ClientABC with specialty TaxSpecialty.PREPARATION: ClientABC requires tax services. ================================================== Tax specialist TaxSpecialist_planning:ClientXYZ with specialty TaxSpecialty.PLANNING: ClientXYZ requires tax services. ================================================== Tax specialist TaxSpecialist_dispute_resolution:ClientXYZ with specialty TaxSpecialty.DISPUTE_RESOLUTION: ClientXYZ requires tax services. ================================================== Tax specialist TaxSpecialist_compliance:ClientXYZ with specialty TaxSpecialty.COMPLIANCE: ClientXYZ requires tax services. ================================================== Tax specialist TaxSpecialist_preparation:ClientXYZ with specialty TaxSpecialty.PREPARATION: ClientXYZ requires tax services. 3. Single-Tenant, Multiple Scopes of Publishing# Scenario Explanation# In the single-tenant, multiple scopes of publishing scenario: All agents operate within a single tenant. Messages are published to different topics. Agents subscribe to specific topics relevant to their role or specialty. Messages are directed to subsets of agents based on the topic. This scenario allows for targeted communication within a tenant, enabling more granular control over message distribution. Application in the Tax Management Company# In this scenario: The tax system manager communicates with specific specialists based on their specialties. Different topics represent different specialties (e.g., “planning”, “compliance”). Specialists subscribe only to the topic that matches their specialty. The manager publishes messages to specific topics to reach the intended specialists. How the Scenario Works# Subscriptions: Agents subscribe to topics corresponding to their specialties. Publishing: Messages are published to topics based on the intended recipients. Message Handling: Only agents subscribed to a topic receive its messages. Benefits# Targeted Communication: Messages reach only the relevant agents. Efficiency: Reduces unnecessary message processing by agents. Considerations# Setup Complexity: Requires careful management of topics and subscriptions. Flexibility: Changes in communication scenarios may require updating subscriptions. async def run_single_tenant_multiple_scope() -> None: # Create the runtime runtime = SingleThreadedAgentRuntime() # Register TaxSpecialist agents for each specialty and add subscriptions for specialty in TaxSpecialty: specialist_agent_type = f\"TaxSpecialist_{specialty.value}\" await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type, factory=lambda specialty=specialty: TaxSpecialist( # type: ignore description=f\"A tax specialist in {specialty.value}.\", specialty=specialty, system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")], ), ) specialist_subscription = TypeSubscription(topic_type=specialty.value, agent_type=specialist_agent_type) await runtime.add_subscription(specialist_subscription) # Start the runtime runtime.start() # Publish a ClientRequest to each specialist's topic for specialty in TaxSpecialty: topic_id = TopicId(type=specialty.value, source=\"default\") await runtime.publish_message( ClientRequest(f\"I need assistance with {specialty.value} taxes.\"), topic_id=topic_id, ) # Allow time for message processing await asyncio.sleep(1) # Stop the runtime when idle await runtime.stop_when_idle() await run_single_tenant_multiple_scope() ================================================== Tax specialist TaxSpecialist_planning:default with specialty TaxSpecialty.PLANNING: I need assistance with planning taxes. ================================================== Tax specialist TaxSpecialist_dispute_resolution:default with specialty TaxSpecialty.DISPUTE_RESOLUTION: I need assistance with dispute_resolution taxes. ================================================== Tax specialist TaxSpecialist_compliance:default with specialty TaxSpecialty.COMPLIANCE: I need assistance with compliance taxes. ================================================== Tax specialist TaxSpecialist_preparation:default with specialty TaxSpecialty.PREPARATION: I need assistance with preparation taxes. 4. Multi-Tenant, Multiple Scopes of Publishing# Scenario Explanation# In the multi-tenant, multiple scopes of publishing scenario: There are multiple tenants, each with their own set of agents. Messages are published to multiple topics within each tenant. Agents subscribe to tenant-specific topics relevant to their role. Combines tenant isolation with targeted communication. This scenario provides the highest level of control over message distribution, suitable for complex systems with multiple clients and specialized communication needs. Application in the Tax Management Company# In this scenario: The company serves multiple clients, each with dedicated agent instances. Within each client, agents communicate using multiple topics based on specialties. For example, Client A’s planning specialist subscribes to the “planning” topic with source “ClientA”. The tax system manager for each client communicates with their specialists using tenant-specific topics. How the Scenario Works# Subscriptions: Agents subscribe to topics based on both tenant identity and specialty. Publishing: Messages are published to tenant-specific and specialty-specific topics. Message Handling: Only agents matching the tenant and topic receive messages. Benefits# Complete Isolation: Ensures both tenant and communication isolation. Granular Control: Enables precise routing of messages to intended agents. Considerations# Complexity: Requires careful management of topics, tenants, and subscriptions. Resource Usage: Increased number of agent instances and topics may impact resources. async def run_multi_tenant_multiple_scope() -> None: # Create the runtime runtime = SingleThreadedAgentRuntime() # Define TypeSubscriptions for each specialty and tenant tenants = [\"ClientABC\", \"ClientXYZ\"] # Initialize agents for all specialties and add type subscriptions for specialty in TaxSpecialty: specialist_agent_type = f\"TaxSpecialist_{specialty.value}\" await TaxSpecialist.register( runtime=runtime, type=specialist_agent_type, factory=lambda specialty=specialty: TaxSpecialist( # type: ignore description=f\"A tax specialist in {specialty.value}.\", specialty=specialty, system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")], ), ) for tenant in tenants: specialist_subscription = TypeSubscription( topic_type=f\"{tenant}_{specialty.value}\", agent_type=specialist_agent_type ) await runtime.add_subscription(specialist_subscription) # Start the runtime runtime.start() # Send messages for each tenant to each specialty for tenant in tenants: for specialty in TaxSpecialty: topic_id = TopicId(type=f\"{tenant}_{specialty.value}\", source=tenant) await runtime.publish_message( ClientRequest(f\"{tenant} needs assistance with {specialty.value} taxes.\"), topic_id=topic_id, ) # Allow time for message processing await asyncio.sleep(1) # Stop the runtime when idle await runtime.stop_when_idle() await run_multi_tenant_multiple_scope() ================================================== Tax specialist TaxSpecialist_planning:ClientABC with specialty TaxSpecialty.PLANNING: ClientABC needs assistance with planning taxes. ================================================== Tax specialist TaxSpecialist_dispute_resolution:ClientABC with specialty TaxSpecialty.DISPUTE_RESOLUTION: ClientABC needs assistance with dispute_resolution taxes. ================================================== Tax specialist TaxSpecialist_compliance:ClientABC with specialty TaxSpecialty.COMPLIANCE: ClientABC needs assistance with compliance taxes. ================================================== Tax specialist TaxSpecialist_preparation:ClientABC with specialty TaxSpecialty.PREPARATION: ClientABC needs assistance with preparation taxes. ================================================== Tax specialist TaxSpecialist_planning:ClientXYZ with specialty TaxSpecialty.PLANNING: ClientXYZ needs assistance with planning taxes. ================================================== Tax specialist TaxSpecialist_dispute_resolution:ClientXYZ with specialty TaxSpecialty.DISPUTE_RESOLUTION: ClientXYZ needs assistance with dispute_resolution taxes. ================================================== Tax specialist TaxSpecialist_compliance:ClientXYZ with specialty TaxSpecialty.COMPLIANCE: ClientXYZ needs assistance with compliance taxes. ================================================== Tax specialist TaxSpecialist_preparation:ClientXYZ with specialty TaxSpecialty.PREPARATION: ClientXYZ needs assistance with preparation taxes. previous Instrumentating your code locally next Structured output using GPT-4o models",
      "code": "import asyncio\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List\n\nfrom autogen_core import (\n    MessageContext,\n    RoutedAgent,\n    SingleThreadedAgentRuntime,\n    TopicId,\n    TypeSubscription,\n    message_handler,\n)\nfrom autogen_core._default_subscription import DefaultSubscription\nfrom autogen_core._default_topic import DefaultTopicId\nfrom autogen_core.models import (\n    SystemMessage,\n)"
    },
    {
      "description": "Resource Usage: More agent instances may consume additional resources.",
      "code": "async def run_multi_tenant_single_scope() -> None:\n    # Create the runtime\n    runtime = SingleThreadedAgentRuntime()\n\n    # List of clients (tenants)\n    tenants = [\"ClientABC\", \"ClientXYZ\"]\n\n    # Initialize sessions and map the topic type to each TaxSpecialist agent type\n    for specialty in TaxSpecialty:\n        specialist_agent_type = f\"TaxSpecialist_{specialty.value}\"\n        await TaxSpecialist.register(\n            runtime=runtime,\n            type=specialist_agent_type,\n            factory=lambda specialty=specialty: TaxSpecialist(  # type: ignore\n                description=f\"A tax specialist in {specialty.value}.\",\n                specialty=specialty,\n                system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")],\n            ),\n        )\n        specialist_subscription = DefaultSubscription(agent_type=specialist_agent_type)\n        await runtime.add_subscription(specialist_subscription)\n\n    # Start the runtime\n    runtime.start()\n\n    # Publish client requests to their respective topics\n    for tenant in tenants:\n        topic_source = tenant  # The topic source is the client name\n        topic_id = DefaultTopicId(source=topic_source)\n        await runtime.publish_message(\n            ClientRequest(f\"{tenant} requires tax services.\"),\n            topic_id=topic_id,\n        )\n\n    # Allow time for message processing\n    await asyncio.sleep(1)\n\n    # Stop the runtime when idle\n    await runtime.stop_when_idle()\n\n\nawait run_multi_tenant_single_scope()"
    },
    {
      "description": "Resource Usage: Increased number of agent instances and topics may impact resources.",
      "code": "async def run_multi_tenant_multiple_scope() -> None:\n    # Create the runtime\n    runtime = SingleThreadedAgentRuntime()\n\n    # Define TypeSubscriptions for each specialty and tenant\n    tenants = [\"ClientABC\", \"ClientXYZ\"]\n\n    # Initialize agents for all specialties and add type subscriptions\n    for specialty in TaxSpecialty:\n        specialist_agent_type = f\"TaxSpecialist_{specialty.value}\"\n        await TaxSpecialist.register(\n            runtime=runtime,\n            type=specialist_agent_type,\n            factory=lambda specialty=specialty: TaxSpecialist(  # type: ignore\n                description=f\"A tax specialist in {specialty.value}.\",\n                specialty=specialty,\n                system_messages=[SystemMessage(content=f\"You are a tax specialist in {specialty.value}.\")],\n            ),\n        )\n        for tenant in tenants:\n            specialist_subscription = TypeSubscription(\n                topic_type=f\"{tenant}_{specialty.value}\", agent_type=specialist_agent_type\n            )\n            await runtime.add_subscription(specialist_subscription)\n\n    # Start the runtime\n    runtime.start()\n\n    # Send messages for each tenant to each specialty\n    for tenant in tenants:\n        for specialty in TaxSpecialty:\n            topic_id = TopicId(type=f\"{tenant}_{specialty.value}\", source=tenant)\n            await runtime.publish_message(\n                ClientRequest(f\"{tenant} needs assistance with {specialty.value} taxes.\"),\n                topic_id=topic_id,\n            )\n\n    # Allow time for message processing\n    await asyncio.sleep(1)\n\n    # Stop the runtime when idle\n    await runtime.stop_when_idle()\n\n\nawait run_multi_tenant_multiple_scope()"
    }
  ],
  "links": [
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/topic-subscription-scenarios.html",
    "https://microsoft.github.io/autogen/stable/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/extensions-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/autogenstudio-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/reference/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/installation.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/quickstart.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-and-multi-agent-application.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/architecture.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/application-stack.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-identity-and-lifecycle.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/topic-and-subscription.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/agent-and-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/message-and-communication.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/logging.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/telemetry.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/distributed-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/component-config.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-clients.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-context.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/tools.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/workbench.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/command-line-code-executors.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/intro.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/concurrent-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/sequential-workflow.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/group-chat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/handoffs.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/mixture-of-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/multi-agent-debate.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/reflection.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/code-execution-groupchat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/azure-openai-with-aad-auth.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/termination-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/tool-use-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/extracting-results-with-an-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/openai-assistant-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/langgraph-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llamaindex-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/local-llms-ollama-litellm.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/instrumenting.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/structured-output-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llm-usage-logger.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/faqs.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html"
  ]
}