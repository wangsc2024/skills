{
  "url": "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/reflection.html",
  "title": "Reflection — AutoGen",
  "content": "Reflection is a design pattern where an LLM generation is followed by a reflection, which in itself is another LLM generation conditioned on the output of the first one. For example, given a task to write code, the first LLM can generate a code snippet, and the second LLM can generate a critique of the code snippet.\n\nIn the context of AutoGen and agents, reflection can be implemented as a pair of agents, where the first agent generates a message and the second agent generates a response to the message. The two agents continue to interact until they reach a stopping condition, such as a maximum number of iterations or an approval from the second agent.\n\nLet’s implement a simple reflection design pattern using AutoGen agents. There will be two agents: a coder agent and a reviewer agent, the coder agent will generate a code snippet, and the reviewer agent will generate a critique of the code snippet.\n\nBefore we define the agents, we need to first define the message protocol for the agents.\n\nThe above set of messages defines the protocol for our example reflection design pattern:\n\nThe application sends a CodeWritingTask message to the coder agent\n\nThe coder agent generates a CodeReviewTask message, which is sent to the reviewer agent\n\nThe reviewer agent generates a CodeReviewResult message, which is sent back to the coder agent\n\nDepending on the CodeReviewResult message, if the code is approved, the coder agent sends a CodeWritingResult message back to the application, otherwise, the coder agent sends another CodeReviewTask message to the reviewer agent, and the process continues.\n\nWe can visualize the message protocol using a data flow diagram:\n\nNow, let’s define the agents for the reflection design pattern.\n\nWe use the Broadcast API to implement the design pattern. The agents implements the pub/sub model. The coder agent subscribes to the CodeWritingTask and CodeReviewResult messages, and publishes the CodeReviewTask and CodeWritingResult messages.\n\nA few things to note about CoderAgent:\n\nIt uses chain-of-thought prompting in its system message.\n\nIt stores message histories for different CodeWritingTask in a dictionary, so each task has its own history.\n\nWhen making an LLM inference request using its model client, it transforms the message history into a list of autogen_core.models.LLMMessage objects to pass to the model client.\n\nThe reviewer agent subscribes to the CodeReviewTask message and publishes the CodeReviewResult message.\n\nThe ReviewerAgent uses JSON-mode when making an LLM inference request, and also uses chain-of-thought prompting in its system message.\n\nTurn on logging to see the messages exchanged between the agents.\n\nLet’s test the design pattern with a coding task. Since all the agents are decorated with the default_subscription() class decorator, the agents when created will automatically subscribe to the default topic. We publish a CodeWritingTask message to the default topic to start the reflection process.\n\nThe log messages show the interaction between the coder and reviewer agents. The final output shows the code snippet generated by the coder agent and the critique generated by the reviewer agent.",
  "headings": [
    {
      "level": "h1",
      "text": "Reflection#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Message Protocol#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Agents#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Logging#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Running the Design Pattern#",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass CodeWritingTask:\n    task: str\n\n\n@dataclass\nclass CodeWritingResult:\n    task: str\n    code: str\n    review: str\n\n\n@dataclass\nclass CodeReviewTask:\n    session_id: str\n    code_writing_task: str\n    code_writing_scratchpad: str\n    code: str\n\n\n@dataclass\nclass CodeReviewResult:\n    review: str\n    session_id: str\n    approved: bool",
      "language": "python"
    },
    {
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass CodeWritingTask:\n    task: str\n\n\n@dataclass\nclass CodeWritingResult:\n    task: str\n    code: str\n    review: str\n\n\n@dataclass\nclass CodeReviewTask:\n    session_id: str\n    code_writing_task: str\n    code_writing_scratchpad: str\n    code: str\n\n\n@dataclass\nclass CodeReviewResult:\n    review: str\n    session_id: str\n    approved: bool",
      "language": "python"
    },
    {
      "code": "import json\nimport re\nimport uuid\nfrom typing import Dict, List, Union\n\nfrom autogen_core import MessageContext, RoutedAgent, TopicId, default_subscription, message_handler\nfrom autogen_core.models import (\n    AssistantMessage,\n    ChatCompletionClient,\n    LLMMessage,\n    SystemMessage,\n    UserMessage,\n)",
      "language": "python"
    },
    {
      "code": "import json\nimport re\nimport uuid\nfrom typing import Dict, List, Union\n\nfrom autogen_core import MessageContext, RoutedAgent, TopicId, default_subscription, message_handler\nfrom autogen_core.models import (\n    AssistantMessage,\n    ChatCompletionClient,\n    LLMMessage,\n    SystemMessage,\n    UserMessage,\n)",
      "language": "python"
    },
    {
      "code": "@default_subscription\nclass CoderAgent(RoutedAgent):\n    \"\"\"An agent that performs code writing tasks.\"\"\"\n\n    def __init__(self, model_client: ChatCompletionClient) -> None:\n        super().__init__(\"A code writing agent.\")\n        self._system_messages: List[LLMMessage] = [\n            SystemMessage(\n                content=\"\"\"You are a proficient coder. You write code to solve problems.\nWork with the reviewer to improve your code.\nAlways put all finished code in a single Markdown code block.\nFor example:\n```python\ndef hello_world():\n    print(\"Hello, World!\")\n```\n\nRespond using the following format:\n\nThoughts: <Your comments>\nCode: <Your code>\n\"\"\",\n            )\n        ]\n        self._model_client = model_client\n        self._session_memory: Dict[str, List[CodeWritingTask | CodeReviewTask | CodeReviewResult]] = {}\n\n    @message_handler\n    async def handle_code_writing_task(self, message: CodeWritingTask, ctx: MessageContext) -> None:\n        # Store the messages in a temporary memory for this request only.\n        session_id = str(uuid.uuid4())\n        self._session_memory.setdefault(session_id, []).append(message)\n        # Generate a response using the chat completion API.\n        response = await self._model_client.create(\n            self._system_messages + [UserMessage(content=message.task, source=self.metadata[\"type\"])],\n            cancellation_token=ctx.cancellation_token,\n        )\n        assert isinstance(response.content, str)\n        # Extract the code block from the response.\n        code_block = self._extract_code_block(response.content)\n        if code_block is None:\n            raise ValueError(\"Code block not found.\")\n        # Create a code review task.\n        code_review_task = CodeReviewTask(\n            session_id=session_id,\n            code_writing_task=message.task,\n            code_writing_scratchpad=response.content,\n            code=code_block,\n        )\n        # Store the code review task in the session memory.\n        self._session_memory[session_id].append(code_review_task)\n        # Publish a code review task.\n        await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key))\n\n    @message_handler\n    async def handle_code_review_result(self, message: CodeReviewResult, ctx: MessageContext) -> None:\n        # Store the review result in the session memory.\n        self._session_memory[message.session_id].append(message)\n        # Obtain the request from previous messages.\n        review_request = next(\n            m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewTask)\n        )\n        assert review_request is not None\n        # Check if the code is approved.\n        if message.approved:\n            # Publish the code writing result.\n            await self.publish_message(\n                CodeWritingResult(\n                    code=review_request.code,\n                    task=review_request.code_writing_task,\n                    review=message.review,\n                ),\n                topic_id=TopicId(\"default\", self.id.key),\n            )\n            print(\"Code Writing Result:\")\n            print(\"-\" * 80)\n            print(f\"Task:\\n{review_request.code_writing_task}\")\n            print(\"-\" * 80)\n            print(f\"Code:\\n{review_request.code}\")\n            print(\"-\" * 80)\n            print(f\"Review:\\n{message.review}\")\n            print(\"-\" * 80)\n        else:\n            # Create a list of LLM messages to send to the model.\n            messages: List[LLMMessage] = [*self._system_messages]\n            for m in self._session_memory[message.session_id]:\n                if isinstance(m, CodeReviewResult):\n                    messages.append(UserMessage(content=m.review, source=\"Reviewer\"))\n                elif isinstance(m, CodeReviewTask):\n                    messages.append(AssistantMessage(content=m.code_writing_scratchpad, source=\"Coder\"))\n                elif isinstance(m, CodeWritingTask):\n                    messages.append(UserMessage(content=m.task, source=\"User\"))\n                else:\n                    raise ValueError(f\"Unexpected message type: {m}\")\n            # Generate a revision using the chat completion API.\n            response = await self._model_client.create(messages, cancellation_token=ctx.cancellation_token)\n            assert isinstance(response.content, str)\n            # Extract the code block from the response.\n            code_block = self._extract_code_block(response.content)\n            if code_block is None:\n                raise ValueError(\"Code block not found.\")\n            # Create a new code review task.\n            code_review_task = CodeReviewTask(\n                session_id=message.session_id,\n                code_writing_task=review_request.code_writing_task,\n                code_writing_scratchpad=response.content,\n                code=code_block,\n            )\n            # Store the code review task in the session memory.\n            self._session_memory[message.session_id].append(code_review_task)\n            # Publish a new code review task.\n            await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key))\n\n    def _extract_code_block(self, markdown_text: str) -> Union[str, None]:\n        pattern = r\"```(\\w+)\\n(.*?)\\n```\"\n        # Search for the pattern in the markdown text\n        match = re.search(pattern, markdown_text, re.DOTALL)\n        # Extract the language and code block if a match is found\n        if match:\n            return match.group(2)\n        return None",
      "language": "python"
    },
    {
      "code": "@default_subscription\nclass CoderAgent(RoutedAgent):\n    \"\"\"An agent that performs code writing tasks.\"\"\"\n\n    def __init__(self, model_client: ChatCompletionClient) -> None:\n        super().__init__(\"A code writing agent.\")\n        self._system_messages: List[LLMMessage] = [\n            SystemMessage(\n                content=\"\"\"You are a proficient coder. You write code to solve problems.\nWork with the reviewer to improve your code.\nAlways put all finished code in a single Markdown code block.\nFor example:\n```python\ndef hello_world():\n    print(\"Hello, World!\")\n```\n\nRespond using the following format:\n\nThoughts: <Your comments>\nCode: <Your code>\n\"\"\",\n            )\n        ]\n        self._model_client = model_client\n        self._session_memory: Dict[str, List[CodeWritingTask | CodeReviewTask | CodeReviewResult]] = {}\n\n    @message_handler\n    async def handle_code_writing_task(self, message: CodeWritingTask, ctx: MessageContext) -> None:\n        # Store the messages in a temporary memory for this request only.\n        session_id = str(uuid.uuid4())\n        self._session_memory.setdefault(session_id, []).append(message)\n        # Generate a response using the chat completion API.\n        response = await self._model_client.create(\n            self._system_messages + [UserMessage(content=message.task, source=self.metadata[\"type\"])],\n            cancellation_token=ctx.cancellation_token,\n        )\n        assert isinstance(response.content, str)\n        # Extract the code block from the response.\n        code_block = self._extract_code_block(response.content)\n        if code_block is None:\n            raise ValueError(\"Code block not found.\")\n        # Create a code review task.\n        code_review_task = CodeReviewTask(\n            session_id=session_id,\n            code_writing_task=message.task,\n            code_writing_scratchpad=response.content,\n            code=code_block,\n        )\n        # Store the code review task in the session memory.\n        self._session_memory[session_id].append(code_review_task)\n        # Publish a code review task.\n        await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key))\n\n    @message_handler\n    async def handle_code_review_result(self, message: CodeReviewResult, ctx: MessageContext) -> None:\n        # Store the review result in the session memory.\n        self._session_memory[message.session_id].append(message)\n        # Obtain the request from previous messages.\n        review_request = next(\n            m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewTask)\n        )\n        assert review_request is not None\n        # Check if the code is approved.\n        if message.approved:\n            # Publish the code writing result.\n            await self.publish_message(\n                CodeWritingResult(\n                    code=review_request.code,\n                    task=review_request.code_writing_task,\n                    review=message.review,\n                ),\n                topic_id=TopicId(\"default\", self.id.key),\n            )\n            print(\"Code Writing Result:\")\n            print(\"-\" * 80)\n            print(f\"Task:\\n{review_request.code_writing_task}\")\n            print(\"-\" * 80)\n            print(f\"Code:\\n{review_request.code}\")\n            print(\"-\" * 80)\n            print(f\"Review:\\n{message.review}\")\n            print(\"-\" * 80)\n        else:\n            # Create a list of LLM messages to send to the model.\n            messages: List[LLMMessage] = [*self._system_messages]\n            for m in self._session_memory[message.session_id]:\n                if isinstance(m, CodeReviewResult):\n                    messages.append(UserMessage(content=m.review, source=\"Reviewer\"))\n                elif isinstance(m, CodeReviewTask):\n                    messages.append(AssistantMessage(content=m.code_writing_scratchpad, source=\"Coder\"))\n                elif isinstance(m, CodeWritingTask):\n                    messages.append(UserMessage(content=m.task, source=\"User\"))\n                else:\n                    raise ValueError(f\"Unexpected message type: {m}\")\n            # Generate a revision using the chat completion API.\n            response = await self._model_client.create(messages, cancellation_token=ctx.cancellation_token)\n            assert isinstance(response.content, str)\n            # Extract the code block from the response.\n            code_block = self._extract_code_block(response.content)\n            if code_block is None:\n                raise ValueError(\"Code block not found.\")\n            # Create a new code review task.\n            code_review_task = CodeReviewTask(\n                session_id=message.session_id,\n                code_writing_task=review_request.code_writing_task,\n                code_writing_scratchpad=response.content,\n                code=code_block,\n            )\n            # Store the code review task in the session memory.\n            self._session_memory[message.session_id].append(code_review_task)\n            # Publish a new code review task.\n            await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key))\n\n    def _extract_code_block(self, markdown_text: str) -> Union[str, None]:\n        pattern = r\"```(\\w+)\\n(.*?)\\n```\"\n        # Search for the pattern in the markdown text\n        match = re.search(pattern, markdown_text, re.DOTALL)\n        # Extract the language and code block if a match is found\n        if match:\n            return match.group(2)\n        return None",
      "language": "python"
    },
    {
      "code": "@default_subscription\nclass ReviewerAgent(RoutedAgent):\n    \"\"\"An agent that performs code review tasks.\"\"\"\n\n    def __init__(self, model_client: ChatCompletionClient) -> None:\n        super().__init__(\"A code reviewer agent.\")\n        self._system_messages: List[LLMMessage] = [\n            SystemMessage(\n                content=\"\"\"You are a code reviewer. You focus on correctness, efficiency and safety of the code.\nRespond using the following JSON format:\n{\n    \"correctness\": \"<Your comments>\",\n    \"efficiency\": \"<Your comments>\",\n    \"safety\": \"<Your comments>\",\n    \"approval\": \"<APPROVE or REVISE>\",\n    \"suggested_changes\": \"<Your comments>\"\n}\n\"\"\",\n            )\n        ]\n        self._session_memory: Dict[str, List[CodeReviewTask | CodeReviewResult]] = {}\n        self._model_client = model_client\n\n    @message_handler\n    async def handle_code_review_task(self, message: CodeReviewTask, ctx: MessageContext) -> None:\n        # Format the prompt for the code review.\n        # Gather the previous feedback if available.\n        previous_feedback = \"\"\n        if message.session_id in self._session_memory:\n            previous_review = next(\n                (m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewResult)),\n                None,\n            )\n            if previous_review is not None:\n                previous_feedback = previous_review.review\n        # Store the messages in a temporary memory for this request only.\n        self._session_memory.setdefault(message.session_id, []).append(message)\n        prompt = f\"\"\"The problem statement is: {message.code_writing_task}\nThe code is:\n```\n{message.code}\n```\n\nPrevious feedback:\n{previous_feedback}\n\nPlease review the code. If previous feedback was provided, see if it was addressed.\n\"\"\"\n        # Generate a response using the chat completion API.\n        response = await self._model_client.create(\n            self._system_messages + [UserMessage(content=prompt, source=self.metadata[\"type\"])],\n            cancellation_token=ctx.cancellation_token,\n            json_output=True,\n        )\n        assert isinstance(response.content, str)\n        # TODO: use structured generation library e.g. guidance to ensure the response is in the expected format.\n        # Parse the response JSON.\n        review = json.loads(response.content)\n        # Construct the review text.\n        review_text = \"Code review:\\n\" + \"\\n\".join([f\"{k}: {v}\" for k, v in review.items()])\n        approved = review[\"approval\"].lower().strip() == \"approve\"\n        result = CodeReviewResult(\n            review=review_text,\n            session_id=message.session_id,\n            approved=approved,\n        )\n        # Store the review result in the session memory.\n        self._session_memory[message.session_id].append(result)\n        # Publish the review result.\n        await self.publish_message(result, topic_id=TopicId(\"default\", self.id.key))",
      "language": "python"
    },
    {
      "code": "@default_subscription\nclass ReviewerAgent(RoutedAgent):\n    \"\"\"An agent that performs code review tasks.\"\"\"\n\n    def __init__(self, model_client: ChatCompletionClient) -> None:\n        super().__init__(\"A code reviewer agent.\")\n        self._system_messages: List[LLMMessage] = [\n            SystemMessage(\n                content=\"\"\"You are a code reviewer. You focus on correctness, efficiency and safety of the code.\nRespond using the following JSON format:\n{\n    \"correctness\": \"<Your comments>\",\n    \"efficiency\": \"<Your comments>\",\n    \"safety\": \"<Your comments>\",\n    \"approval\": \"<APPROVE or REVISE>\",\n    \"suggested_changes\": \"<Your comments>\"\n}\n\"\"\",\n            )\n        ]\n        self._session_memory: Dict[str, List[CodeReviewTask | CodeReviewResult]] = {}\n        self._model_client = model_client\n\n    @message_handler\n    async def handle_code_review_task(self, message: CodeReviewTask, ctx: MessageContext) -> None:\n        # Format the prompt for the code review.\n        # Gather the previous feedback if available.\n        previous_feedback = \"\"\n        if message.session_id in self._session_memory:\n            previous_review = next(\n                (m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewResult)),\n                None,\n            )\n            if previous_review is not None:\n                previous_feedback = previous_review.review\n        # Store the messages in a temporary memory for this request only.\n        self._session_memory.setdefault(message.session_id, []).append(message)\n        prompt = f\"\"\"The problem statement is: {message.code_writing_task}\nThe code is:\n```\n{message.code}\n```\n\nPrevious feedback:\n{previous_feedback}\n\nPlease review the code. If previous feedback was provided, see if it was addressed.\n\"\"\"\n        # Generate a response using the chat completion API.\n        response = await self._model_client.create(\n            self._system_messages + [UserMessage(content=prompt, source=self.metadata[\"type\"])],\n            cancellation_token=ctx.cancellation_token,\n            json_output=True,\n        )\n        assert isinstance(response.content, str)\n        # TODO: use structured generation library e.g. guidance to ensure the response is in the expected format.\n        # Parse the response JSON.\n        review = json.loads(response.content)\n        # Construct the review text.\n        review_text = \"Code review:\\n\" + \"\\n\".join([f\"{k}: {v}\" for k, v in review.items()])\n        approved = review[\"approval\"].lower().strip() == \"approve\"\n        result = CodeReviewResult(\n            review=review_text,\n            session_id=message.session_id,\n            approved=approved,\n        )\n        # Store the review result in the session memory.\n        self._session_memory[message.session_id].append(result)\n        # Publish the review result.\n        await self.publish_message(result, topic_id=TopicId(\"default\", self.id.key))",
      "language": "python"
    },
    {
      "code": "import logging\n\nlogging.basicConfig(level=logging.WARNING)\nlogging.getLogger(\"autogen_core\").setLevel(logging.DEBUG)",
      "language": "python"
    },
    {
      "code": "import logging\n\nlogging.basicConfig(level=logging.WARNING)\nlogging.getLogger(\"autogen_core\").setLevel(logging.DEBUG)",
      "language": "python"
    },
    {
      "code": "from autogen_core import DefaultTopicId, SingleThreadedAgentRuntime\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\n\nruntime = SingleThreadedAgentRuntime()\nmodel_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\")\nawait ReviewerAgent.register(runtime, \"ReviewerAgent\", lambda: ReviewerAgent(model_client=model_client))\nawait CoderAgent.register(runtime, \"CoderAgent\", lambda: CoderAgent(model_client=model_client))\nruntime.start()\nawait runtime.publish_message(\n    message=CodeWritingTask(task=\"Write a function to find the sum of all even numbers in a list.\"),\n    topic_id=DefaultTopicId(),\n)\n\n# Keep processing messages until idle.\nawait runtime.stop_when_idle()\n# Close the model client.\nawait model_client.close()",
      "language": "python"
    },
    {
      "code": "from autogen_core import DefaultTopicId, SingleThreadedAgentRuntime\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\n\nruntime = SingleThreadedAgentRuntime()\nmodel_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\")\nawait ReviewerAgent.register(runtime, \"ReviewerAgent\", lambda: ReviewerAgent(model_client=model_client))\nawait CoderAgent.register(runtime, \"CoderAgent\", lambda: CoderAgent(model_client=model_client))\nruntime.start()\nawait runtime.publish_message(\n    message=CodeWritingTask(task=\"Write a function to find the sum of all even numbers in a list.\"),\n    topic_id=DefaultTopicId(),\n)\n\n# Keep processing messages until idle.\nawait runtime.stop_when_idle()\n# Close the model client.\nawait model_client.close()",
      "language": "python"
    },
    {
      "code": "INFO:autogen_core:Publishing message of type CodeWritingTask to all subscribers: {'task': 'Write a function to find the sum of all even numbers in a list.'}\nINFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeWritingTask published by Unknown\nINFO:autogen_core:Calling message handler for CoderAgent with message type CodeWritingTask published by Unknown\nINFO:autogen_core:Unhandled message: CodeWritingTask(task='Write a function to find the sum of all even numbers in a list.')\nINFO:autogen_core.events:{\"prompt_tokens\": 101, \"completion_tokens\": 88, \"type\": \"LLMCall\"}\nINFO:autogen_core:Publishing message of type CodeReviewTask to all subscribers: {'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'code_writing_task': 'Write a function to find the sum of all even numbers in a list.', 'code_writing_scratchpad': 'Thoughts: To find the sum of all even numbers in a list, we can use a list comprehension to filter out the even numbers and then use the `sum()` function to calculate their total. The implementation should handle edge cases like an empty list or a list with no even numbers.\\n\\nCode:\\n```python\\ndef sum_of_even_numbers(numbers):\\n    return sum(num for num in numbers if num % 2 == 0)\\n```', 'code': 'def sum_of_even_numbers(numbers):\\n    return sum(num for num in numbers if num % 2 == 0)'}\nINFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeReviewTask published by CoderAgent:default\nINFO:autogen_core.events:{\"prompt_tokens\": 163, \"completion_tokens\": 235, \"type\": \"LLMCall\"}\nINFO:autogen_core:Publishing message of type CodeReviewResult to all subscribers: {'review': \"Code review:\\ncorrectness: The function correctly identifies and sums all even numbers in the provided list. The use of a generator expression ensures that only even numbers are processed, which is correct.\\nefficiency: The function is efficient as it utilizes a generator expression that avoids creating an intermediate list, therefore using less memory. The time complexity is O(n) where n is the number of elements in the input list, which is optimal for this task.\\nsafety: The function does not include checks for input types. If a non-iterable or a list containing non-integer types is passed, it could lead to unexpected behavior or errors. It’s advisable to handle such cases.\\napproval: REVISE\\nsuggested_changes: Consider adding input validation to ensure that 'numbers' is a list and contains only integers. You could raise a ValueError if the input is invalid. Example: 'if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): raise ValueError('Input must be a list of integers')'. This will make the function more robust.\", 'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'approved': False}\nINFO:autogen_core:Calling message handler for CoderAgent with message type CodeReviewResult published by ReviewerAgent:default\nINFO:autogen_core.events:{\"prompt_tokens\": 421, \"completion_tokens\": 119, \"type\": \"LLMCall\"}\nINFO:autogen_core:Publishing message of type CodeReviewTask to all subscribers: {'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'code_writing_task': 'Write a function to find the sum of all even numbers in a list.', 'code_writing_scratchpad': \"Thoughts: I appreciate the reviewer's feedback on input validation. Adding type checks ensures that the function can handle unexpected inputs gracefully. I will implement the suggested changes and include checks for both the input type and the elements within the list to confirm that they are integers.\\n\\nCode:\\n```python\\ndef sum_of_even_numbers(numbers):\\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n        raise ValueError('Input must be a list of integers')\\n    \\n    return sum(num for num in numbers if num % 2 == 0)\\n```\", 'code': \"def sum_of_even_numbers(numbers):\\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n        raise ValueError('Input must be a list of integers')\\n    \\n    return sum(num for num in numbers if num % 2 == 0)\"}\nINFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeReviewTask published by CoderAgent:default\nINFO:autogen_core.events:{\"prompt_tokens\": 420, \"completion_tokens\": 153, \"type\": \"LLMCall\"}\nINFO:autogen_core:Publishing message of type CodeReviewResult to all subscribers: {'review': 'Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.', 'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'approved': True}\nINFO:autogen_core:Calling message handler for CoderAgent with message type CodeReviewResult published by ReviewerAgent:default\nINFO:autogen_core:Publishing message of type CodeWritingResult to all subscribers: {'task': 'Write a function to find the sum of all even numbers in a list.', 'code': \"def sum_of_even_numbers(numbers):\\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n        raise ValueError('Input must be a list of integers')\\n    \\n    return sum(num for num in numbers if num % 2 == 0)\", 'review': 'Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.'}\nINFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeWritingResult published by CoderAgent:default\nINFO:autogen_core:Unhandled message: CodeWritingResult(task='Write a function to find the sum of all even numbers in a list.', code=\"def sum_of_even_numbers(numbers):\\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n        raise ValueError('Input must be a list of integers')\\n    \\n    return sum(num for num in numbers if num % 2 == 0)\", review='Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.')",
      "language": "json"
    },
    {
      "code": "INFO:autogen_core:Publishing message of type CodeWritingTask to all subscribers: {'task': 'Write a function to find the sum of all even numbers in a list.'}\nINFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeWritingTask published by Unknown\nINFO:autogen_core:Calling message handler for CoderAgent with message type CodeWritingTask published by Unknown\nINFO:autogen_core:Unhandled message: CodeWritingTask(task='Write a function to find the sum of all even numbers in a list.')\nINFO:autogen_core.events:{\"prompt_tokens\": 101, \"completion_tokens\": 88, \"type\": \"LLMCall\"}\nINFO:autogen_core:Publishing message of type CodeReviewTask to all subscribers: {'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'code_writing_task': 'Write a function to find the sum of all even numbers in a list.', 'code_writing_scratchpad': 'Thoughts: To find the sum of all even numbers in a list, we can use a list comprehension to filter out the even numbers and then use the `sum()` function to calculate their total. The implementation should handle edge cases like an empty list or a list with no even numbers.\\n\\nCode:\\n```python\\ndef sum_of_even_numbers(numbers):\\n    return sum(num for num in numbers if num % 2 == 0)\\n```', 'code': 'def sum_of_even_numbers(numbers):\\n    return sum(num for num in numbers if num % 2 == 0)'}\nINFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeReviewTask published by CoderAgent:default\nINFO:autogen_core.events:{\"prompt_tokens\": 163, \"completion_tokens\": 235, \"type\": \"LLMCall\"}\nINFO:autogen_core:Publishing message of type CodeReviewResult to all subscribers: {'review': \"Code review:\\ncorrectness: The function correctly identifies and sums all even numbers in the provided list. The use of a generator expression ensures that only even numbers are processed, which is correct.\\nefficiency: The function is efficient as it utilizes a generator expression that avoids creating an intermediate list, therefore using less memory. The time complexity is O(n) where n is the number of elements in the input list, which is optimal for this task.\\nsafety: The function does not include checks for input types. If a non-iterable or a list containing non-integer types is passed, it could lead to unexpected behavior or errors. It’s advisable to handle such cases.\\napproval: REVISE\\nsuggested_changes: Consider adding input validation to ensure that 'numbers' is a list and contains only integers. You could raise a ValueError if the input is invalid. Example: 'if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): raise ValueError('Input must be a list of integers')'. This will make the function more robust.\", 'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'approved': False}\nINFO:autogen_core:Calling message handler for CoderAgent with message type CodeReviewResult published by ReviewerAgent:default\nINFO:autogen_core.events:{\"prompt_tokens\": 421, \"completion_tokens\": 119, \"type\": \"LLMCall\"}\nINFO:autogen_core:Publishing message of type CodeReviewTask to all subscribers: {'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'code_writing_task': 'Write a function to find the sum of all even numbers in a list.', 'code_writing_scratchpad': \"Thoughts: I appreciate the reviewer's feedback on input validation. Adding type checks ensures that the function can handle unexpected inputs gracefully. I will implement the suggested changes and include checks for both the input type and the elements within the list to confirm that they are integers.\\n\\nCode:\\n```python\\ndef sum_of_even_numbers(numbers):\\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n        raise ValueError('Input must be a list of integers')\\n    \\n    return sum(num for num in numbers if num % 2 == 0)\\n```\", 'code': \"def sum_of_even_numbers(numbers):\\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n        raise ValueError('Input must be a list of integers')\\n    \\n    return sum(num for num in numbers if num % 2 == 0)\"}\nINFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeReviewTask published by CoderAgent:default\nINFO:autogen_core.events:{\"prompt_tokens\": 420, \"completion_tokens\": 153, \"type\": \"LLMCall\"}\nINFO:autogen_core:Publishing message of type CodeReviewResult to all subscribers: {'review': 'Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.', 'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'approved': True}\nINFO:autogen_core:Calling message handler for CoderAgent with message type CodeReviewResult published by ReviewerAgent:default\nINFO:autogen_core:Publishing message of type CodeWritingResult to all subscribers: {'task': 'Write a function to find the sum of all even numbers in a list.', 'code': \"def sum_of_even_numbers(numbers):\\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n        raise ValueError('Input must be a list of integers')\\n    \\n    return sum(num for num in numbers if num % 2 == 0)\", 'review': 'Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.'}\nINFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeWritingResult published by CoderAgent:default\nINFO:autogen_core:Unhandled message: CodeWritingResult(task='Write a function to find the sum of all even numbers in a list.', code=\"def sum_of_even_numbers(numbers):\\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n        raise ValueError('Input must be a list of integers')\\n    \\n    return sum(num for num in numbers if num % 2 == 0)\", review='Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.')",
      "language": "json"
    },
    {
      "code": "Code Writing Result:\n--------------------------------------------------------------------------------\nTask:\nWrite a function to find the sum of all even numbers in a list.\n--------------------------------------------------------------------------------\nCode:\ndef sum_of_even_numbers(numbers):\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise ValueError('Input must be a list of integers')\n    \n    return sum(num for num in numbers if num % 2 == 0)\n--------------------------------------------------------------------------------\nReview:\nCode review:\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\napproval: APPROVE\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.\n--------------------------------------------------------------------------------",
      "language": "yaml"
    },
    {
      "code": "Code Writing Result:\n--------------------------------------------------------------------------------\nTask:\nWrite a function to find the sum of all even numbers in a list.\n--------------------------------------------------------------------------------\nCode:\ndef sum_of_even_numbers(numbers):\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise ValueError('Input must be a list of integers')\n    \n    return sum(num for num in numbers if num % 2 == 0)\n--------------------------------------------------------------------------------\nReview:\nCode review:\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\napproval: APPROVE\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.\n--------------------------------------------------------------------------------",
      "language": "yaml"
    }
  ],
  "patterns": [
    {
      "description": "Core Reflection Reflection# Reflection is a design pattern where an LLM generation is followed by a reflection, which in itself is another LLM generation conditioned on the output of the first one. For example, given a task to write code, the first LLM can generate a code snippet, and the second LLM can generate a critique of the code snippet. In the context of AutoGen and agents, reflection can be implemented as a pair of agents, where the first agent generates a message and the second agent generates a response to the message. The two agents continue to interact until they reach a stopping condition, such as a maximum number of iterations or an approval from the second agent. Let’s implement a simple reflection design pattern using AutoGen agents. There will be two agents: a coder agent and a reviewer agent, the coder agent will generate a code snippet, and the reviewer agent will generate a critique of the code snippet. Message Protocol# Before we define the agents, we need to first define the message protocol for the agents. from dataclasses import dataclass @dataclass class CodeWritingTask: task: str @dataclass class CodeWritingResult: task: str code: str review: str @dataclass class CodeReviewTask: session_id: str code_writing_task: str code_writing_scratchpad: str code: str @dataclass class CodeReviewResult: review: str session_id: str approved: bool The above set of messages defines the protocol for our example reflection design pattern: The application sends a CodeWritingTask message to the coder agent The coder agent generates a CodeReviewTask message, which is sent to the reviewer agent The reviewer agent generates a CodeReviewResult message, which is sent back to the coder agent Depending on the CodeReviewResult message, if the code is approved, the coder agent sends a CodeWritingResult message back to the application, otherwise, the coder agent sends another CodeReviewTask message to the reviewer agent, and the process continues. We can visualize the message protocol using a data flow diagram: Agents# Now, let’s define the agents for the reflection design pattern. import json import re import uuid from typing import Dict, List, Union from autogen_core import MessageContext, RoutedAgent, TopicId, default_subscription, message_handler from autogen_core.models import ( AssistantMessage, ChatCompletionClient, LLMMessage, SystemMessage, UserMessage, ) We use the Broadcast API to implement the design pattern. The agents implements the pub/sub model. The coder agent subscribes to the CodeWritingTask and CodeReviewResult messages, and publishes the CodeReviewTask and CodeWritingResult messages. @default_subscription class CoderAgent(RoutedAgent): \"\"\"An agent that performs code writing tasks.\"\"\" def __init__(self, model_client: ChatCompletionClient) -> None: super().__init__(\"A code writing agent.\") self._system_messages: List[LLMMessage] = [ SystemMessage( content=\"\"\"You are a proficient coder. You write code to solve problems. Work with the reviewer to improve your code. Always put all finished code in a single Markdown code block. For example: ```python def hello_world(): print(\"Hello, World!\") ``` Respond using the following format: Thoughts: <Your comments> Code: <Your code> \"\"\", ) ] self._model_client = model_client self._session_memory: Dict[str, List[CodeWritingTask | CodeReviewTask | CodeReviewResult]] = {} @message_handler async def handle_code_writing_task(self, message: CodeWritingTask, ctx: MessageContext) -> None: # Store the messages in a temporary memory for this request only. session_id = str(uuid.uuid4()) self._session_memory.setdefault(session_id, []).append(message) # Generate a response using the chat completion API. response = await self._model_client.create( self._system_messages + [UserMessage(content=message.task, source=self.metadata[\"type\"])], cancellation_token=ctx.cancellation_token, ) assert isinstance(response.content, str) # Extract the code block from the response. code_block = self._extract_code_block(response.content) if code_block is None: raise ValueError(\"Code block not found.\") # Create a code review task. code_review_task = CodeReviewTask( session_id=session_id, code_writing_task=message.task, code_writing_scratchpad=response.content, code=code_block, ) # Store the code review task in the session memory. self._session_memory[session_id].append(code_review_task) # Publish a code review task. await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key)) @message_handler async def handle_code_review_result(self, message: CodeReviewResult, ctx: MessageContext) -> None: # Store the review result in the session memory. self._session_memory[message.session_id].append(message) # Obtain the request from previous messages. review_request = next( m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewTask) ) assert review_request is not None # Check if the code is approved. if message.approved: # Publish the code writing result. await self.publish_message( CodeWritingResult( code=review_request.code, task=review_request.code_writing_task, review=message.review, ), topic_id=TopicId(\"default\", self.id.key), ) print(\"Code Writing Result:\") print(\"-\" * 80) print(f\"Task:\\n{review_request.code_writing_task}\") print(\"-\" * 80) print(f\"Code:\\n{review_request.code}\") print(\"-\" * 80) print(f\"Review:\\n{message.review}\") print(\"-\" * 80) else: # Create a list of LLM messages to send to the model. messages: List[LLMMessage] = [*self._system_messages] for m in self._session_memory[message.session_id]: if isinstance(m, CodeReviewResult): messages.append(UserMessage(content=m.review, source=\"Reviewer\")) elif isinstance(m, CodeReviewTask): messages.append(AssistantMessage(content=m.code_writing_scratchpad, source=\"Coder\")) elif isinstance(m, CodeWritingTask): messages.append(UserMessage(content=m.task, source=\"User\")) else: raise ValueError(f\"Unexpected message type: {m}\") # Generate a revision using the chat completion API. response = await self._model_client.create(messages, cancellation_token=ctx.cancellation_token) assert isinstance(response.content, str) # Extract the code block from the response. code_block = self._extract_code_block(response.content) if code_block is None: raise ValueError(\"Code block not found.\") # Create a new code review task. code_review_task = CodeReviewTask( session_id=message.session_id, code_writing_task=review_request.code_writing_task, code_writing_scratchpad=response.content, code=code_block, ) # Store the code review task in the session memory. self._session_memory[message.session_id].append(code_review_task) # Publish a new code review task. await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key)) def _extract_code_block(self, markdown_text: str) -> Union[str, None]: pattern = r\"```(\\w+)\\n(.*?)\\n```\" # Search for the pattern in the markdown text match = re.search(pattern, markdown_text, re.DOTALL) # Extract the language and code block if a match is found if match: return match.group(2) return None A few things to note about CoderAgent: It uses chain-of-thought prompting in its system message. It stores message histories for different CodeWritingTask in a dictionary, so each task has its own history. When making an LLM inference request using its model client, it transforms the message history into a list of autogen_core.models.LLMMessage objects to pass to the model client. The reviewer agent subscribes to the CodeReviewTask message and publishes the CodeReviewResult message. @default_subscription class ReviewerAgent(RoutedAgent): \"\"\"An agent that performs code review tasks.\"\"\" def __init__(self, model_client: ChatCompletionClient) -> None: super().__init__(\"A code reviewer agent.\") self._system_messages: List[LLMMessage] = [ SystemMessage( content=\"\"\"You are a code reviewer. You focus on correctness, efficiency and safety of the code. Respond using the following JSON format: { \"correctness\": \"<Your comments>\", \"efficiency\": \"<Your comments>\", \"safety\": \"<Your comments>\", \"approval\": \"<APPROVE or REVISE>\", \"suggested_changes\": \"<Your comments>\" } \"\"\", ) ] self._session_memory: Dict[str, List[CodeReviewTask | CodeReviewResult]] = {} self._model_client = model_client @message_handler async def handle_code_review_task(self, message: CodeReviewTask, ctx: MessageContext) -> None: # Format the prompt for the code review. # Gather the previous feedback if available. previous_feedback = \"\" if message.session_id in self._session_memory: previous_review = next( (m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewResult)), None, ) if previous_review is not None: previous_feedback = previous_review.review # Store the messages in a temporary memory for this request only. self._session_memory.setdefault(message.session_id, []).append(message) prompt = f\"\"\"The problem statement is: {message.code_writing_task} The code is: ``` {message.code} ``` Previous feedback: {previous_feedback} Please review the code. If previous feedback was provided, see if it was addressed. \"\"\" # Generate a response using the chat completion API. response = await self._model_client.create( self._system_messages + [UserMessage(content=prompt, source=self.metadata[\"type\"])], cancellation_token=ctx.cancellation_token, json_output=True, ) assert isinstance(response.content, str) # TODO: use structured generation library e.g. guidance to ensure the response is in the expected format. # Parse the response JSON. review = json.loads(response.content) # Construct the review text. review_text = \"Code review:\\n\" + \"\\n\".join([f\"{k}: {v}\" for k, v in review.items()]) approved = review[\"approval\"].lower().strip() == \"approve\" result = CodeReviewResult( review=review_text, session_id=message.session_id, approved=approved, ) # Store the review result in the session memory. self._session_memory[message.session_id].append(result) # Publish the review result. await self.publish_message(result, topic_id=TopicId(\"default\", self.id.key)) The ReviewerAgent uses JSON-mode when making an LLM inference request, and also uses chain-of-thought prompting in its system message. Logging# Turn on logging to see the messages exchanged between the agents. import logging logging.basicConfig(level=logging.WARNING) logging.getLogger(\"autogen_core\").setLevel(logging.DEBUG) Running the Design Pattern# Let’s test the design pattern with a coding task. Since all the agents are decorated with the default_subscription() class decorator, the agents when created will automatically subscribe to the default topic. We publish a CodeWritingTask message to the default topic to start the reflection process. from autogen_core import DefaultTopicId, SingleThreadedAgentRuntime from autogen_ext.models.openai import OpenAIChatCompletionClient runtime = SingleThreadedAgentRuntime() model_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\") await ReviewerAgent.register(runtime, \"ReviewerAgent\", lambda: ReviewerAgent(model_client=model_client)) await CoderAgent.register(runtime, \"CoderAgent\", lambda: CoderAgent(model_client=model_client)) runtime.start() await runtime.publish_message( message=CodeWritingTask(task=\"Write a function to find the sum of all even numbers in a list.\"), topic_id=DefaultTopicId(), ) # Keep processing messages until idle. await runtime.stop_when_idle() # Close the model client. await model_client.close() INFO:autogen_core:Publishing message of type CodeWritingTask to all subscribers: {'task': 'Write a function to find the sum of all even numbers in a list.'} INFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeWritingTask published by Unknown INFO:autogen_core:Calling message handler for CoderAgent with message type CodeWritingTask published by Unknown INFO:autogen_core:Unhandled message: CodeWritingTask(task='Write a function to find the sum of all even numbers in a list.') INFO:autogen_core.events:{\"prompt_tokens\": 101, \"completion_tokens\": 88, \"type\": \"LLMCall\"} INFO:autogen_core:Publishing message of type CodeReviewTask to all subscribers: {'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'code_writing_task': 'Write a function to find the sum of all even numbers in a list.', 'code_writing_scratchpad': 'Thoughts: To find the sum of all even numbers in a list, we can use a list comprehension to filter out the even numbers and then use the `sum()` function to calculate their total. The implementation should handle edge cases like an empty list or a list with no even numbers.\\n\\nCode:\\n```python\\ndef sum_of_even_numbers(numbers):\\n return sum(num for num in numbers if num % 2 == 0)\\n```', 'code': 'def sum_of_even_numbers(numbers):\\n return sum(num for num in numbers if num % 2 == 0)'} INFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeReviewTask published by CoderAgent:default INFO:autogen_core.events:{\"prompt_tokens\": 163, \"completion_tokens\": 235, \"type\": \"LLMCall\"} INFO:autogen_core:Publishing message of type CodeReviewResult to all subscribers: {'review': \"Code review:\\ncorrectness: The function correctly identifies and sums all even numbers in the provided list. The use of a generator expression ensures that only even numbers are processed, which is correct.\\nefficiency: The function is efficient as it utilizes a generator expression that avoids creating an intermediate list, therefore using less memory. The time complexity is O(n) where n is the number of elements in the input list, which is optimal for this task.\\nsafety: The function does not include checks for input types. If a non-iterable or a list containing non-integer types is passed, it could lead to unexpected behavior or errors. It’s advisable to handle such cases.\\napproval: REVISE\\nsuggested_changes: Consider adding input validation to ensure that 'numbers' is a list and contains only integers. You could raise a ValueError if the input is invalid. Example: 'if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): raise ValueError('Input must be a list of integers')'. This will make the function more robust.\", 'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'approved': False} INFO:autogen_core:Calling message handler for CoderAgent with message type CodeReviewResult published by ReviewerAgent:default INFO:autogen_core.events:{\"prompt_tokens\": 421, \"completion_tokens\": 119, \"type\": \"LLMCall\"} INFO:autogen_core:Publishing message of type CodeReviewTask to all subscribers: {'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'code_writing_task': 'Write a function to find the sum of all even numbers in a list.', 'code_writing_scratchpad': \"Thoughts: I appreciate the reviewer's feedback on input validation. Adding type checks ensures that the function can handle unexpected inputs gracefully. I will implement the suggested changes and include checks for both the input type and the elements within the list to confirm that they are integers.\\n\\nCode:\\n```python\\ndef sum_of_even_numbers(numbers):\\n if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n raise ValueError('Input must be a list of integers')\\n \\n return sum(num for num in numbers if num % 2 == 0)\\n```\", 'code': \"def sum_of_even_numbers(numbers):\\n if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n raise ValueError('Input must be a list of integers')\\n \\n return sum(num for num in numbers if num % 2 == 0)\"} INFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeReviewTask published by CoderAgent:default INFO:autogen_core.events:{\"prompt_tokens\": 420, \"completion_tokens\": 153, \"type\": \"LLMCall\"} INFO:autogen_core:Publishing message of type CodeReviewResult to all subscribers: {'review': 'Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.', 'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'approved': True} INFO:autogen_core:Calling message handler for CoderAgent with message type CodeReviewResult published by ReviewerAgent:default INFO:autogen_core:Publishing message of type CodeWritingResult to all subscribers: {'task': 'Write a function to find the sum of all even numbers in a list.', 'code': \"def sum_of_even_numbers(numbers):\\n if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n raise ValueError('Input must be a list of integers')\\n \\n return sum(num for num in numbers if num % 2 == 0)\", 'review': 'Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.'} INFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeWritingResult published by CoderAgent:default INFO:autogen_core:Unhandled message: CodeWritingResult(task='Write a function to find the sum of all even numbers in a list.', code=\"def sum_of_even_numbers(numbers):\\n if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n raise ValueError('Input must be a list of integers')\\n \\n return sum(num for num in numbers if num % 2 == 0)\", review='Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.') Code Writing Result: -------------------------------------------------------------------------------- Task: Write a function to find the sum of all even numbers in a list. -------------------------------------------------------------------------------- Code: def sum_of_even_numbers(numbers): if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): raise ValueError('Input must be a list of integers') return sum(num for num in numbers if num % 2 == 0) -------------------------------------------------------------------------------- Review: Code review: correctness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness. efficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal. safety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data. approval: APPROVE suggested_changes: No further changes are necessary as the previous feedback has been adequately addressed. -------------------------------------------------------------------------------- The log messages show the interaction between the coder and reviewer agents. The final output shows the code snippet generated by the coder agent and the critique generated by the reviewer agent. previous Multi-Agent Debate next Code Execution On this page Message Protocol Agents Logging Running the Design Pattern Edit on GitHub Show Source",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass CodeWritingTask:\n    task: str\n\n\n@dataclass\nclass CodeWritingResult:\n    task: str\n    code: str\n    review: str\n\n\n@dataclass\nclass CodeReviewTask:\n    session_id: str\n    code_writing_task: str\n    code_writing_scratchpad: str\n    code: str\n\n\n@dataclass\nclass CodeReviewResult:\n    review: str\n    session_id: str\n    approved: bool"
    },
    {
      "description": "Core Reflection Reflection# Reflection is a design pattern where an LLM generation is followed by a reflection, which in itself is another LLM generation conditioned on the output of the first one. For example, given a task to write code, the first LLM can generate a code snippet, and the second LLM can generate a critique of the code snippet. In the context of AutoGen and agents, reflection can be implemented as a pair of agents, where the first agent generates a message and the second agent generates a response to the message. The two agents continue to interact until they reach a stopping condition, such as a maximum number of iterations or an approval from the second agent. Let’s implement a simple reflection design pattern using AutoGen agents. There will be two agents: a coder agent and a reviewer agent, the coder agent will generate a code snippet, and the reviewer agent will generate a critique of the code snippet. Message Protocol# Before we define the agents, we need to first define the message protocol for the agents. from dataclasses import dataclass @dataclass class CodeWritingTask: task: str @dataclass class CodeWritingResult: task: str code: str review: str @dataclass class CodeReviewTask: session_id: str code_writing_task: str code_writing_scratchpad: str code: str @dataclass class CodeReviewResult: review: str session_id: str approved: bool The above set of messages defines the protocol for our example reflection design pattern: The application sends a CodeWritingTask message to the coder agent The coder agent generates a CodeReviewTask message, which is sent to the reviewer agent The reviewer agent generates a CodeReviewResult message, which is sent back to the coder agent Depending on the CodeReviewResult message, if the code is approved, the coder agent sends a CodeWritingResult message back to the application, otherwise, the coder agent sends another CodeReviewTask message to the reviewer agent, and the process continues. We can visualize the message protocol using a data flow diagram: Agents# Now, let’s define the agents for the reflection design pattern. import json import re import uuid from typing import Dict, List, Union from autogen_core import MessageContext, RoutedAgent, TopicId, default_subscription, message_handler from autogen_core.models import ( AssistantMessage, ChatCompletionClient, LLMMessage, SystemMessage, UserMessage, ) We use the Broadcast API to implement the design pattern. The agents implements the pub/sub model. The coder agent subscribes to the CodeWritingTask and CodeReviewResult messages, and publishes the CodeReviewTask and CodeWritingResult messages. @default_subscription class CoderAgent(RoutedAgent): \"\"\"An agent that performs code writing tasks.\"\"\" def __init__(self, model_client: ChatCompletionClient) -> None: super().__init__(\"A code writing agent.\") self._system_messages: List[LLMMessage] = [ SystemMessage( content=\"\"\"You are a proficient coder. You write code to solve problems. Work with the reviewer to improve your code. Always put all finished code in a single Markdown code block. For example: ```python def hello_world(): print(\"Hello, World!\") ``` Respond using the following format: Thoughts: <Your comments> Code: <Your code> \"\"\", ) ] self._model_client = model_client self._session_memory: Dict[str, List[CodeWritingTask | CodeReviewTask | CodeReviewResult]] = {} @message_handler async def handle_code_writing_task(self, message: CodeWritingTask, ctx: MessageContext) -> None: # Store the messages in a temporary memory for this request only. session_id = str(uuid.uuid4()) self._session_memory.setdefault(session_id, []).append(message) # Generate a response using the chat completion API. response = await self._model_client.create( self._system_messages + [UserMessage(content=message.task, source=self.metadata[\"type\"])], cancellation_token=ctx.cancellation_token, ) assert isinstance(response.content, str) # Extract the code block from the response. code_block = self._extract_code_block(response.content) if code_block is None: raise ValueError(\"Code block not found.\") # Create a code review task. code_review_task = CodeReviewTask( session_id=session_id, code_writing_task=message.task, code_writing_scratchpad=response.content, code=code_block, ) # Store the code review task in the session memory. self._session_memory[session_id].append(code_review_task) # Publish a code review task. await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key)) @message_handler async def handle_code_review_result(self, message: CodeReviewResult, ctx: MessageContext) -> None: # Store the review result in the session memory. self._session_memory[message.session_id].append(message) # Obtain the request from previous messages. review_request = next( m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewTask) ) assert review_request is not None # Check if the code is approved. if message.approved: # Publish the code writing result. await self.publish_message( CodeWritingResult( code=review_request.code, task=review_request.code_writing_task, review=message.review, ), topic_id=TopicId(\"default\", self.id.key), ) print(\"Code Writing Result:\") print(\"-\" * 80) print(f\"Task:\\n{review_request.code_writing_task}\") print(\"-\" * 80) print(f\"Code:\\n{review_request.code}\") print(\"-\" * 80) print(f\"Review:\\n{message.review}\") print(\"-\" * 80) else: # Create a list of LLM messages to send to the model. messages: List[LLMMessage] = [*self._system_messages] for m in self._session_memory[message.session_id]: if isinstance(m, CodeReviewResult): messages.append(UserMessage(content=m.review, source=\"Reviewer\")) elif isinstance(m, CodeReviewTask): messages.append(AssistantMessage(content=m.code_writing_scratchpad, source=\"Coder\")) elif isinstance(m, CodeWritingTask): messages.append(UserMessage(content=m.task, source=\"User\")) else: raise ValueError(f\"Unexpected message type: {m}\") # Generate a revision using the chat completion API. response = await self._model_client.create(messages, cancellation_token=ctx.cancellation_token) assert isinstance(response.content, str) # Extract the code block from the response. code_block = self._extract_code_block(response.content) if code_block is None: raise ValueError(\"Code block not found.\") # Create a new code review task. code_review_task = CodeReviewTask( session_id=message.session_id, code_writing_task=review_request.code_writing_task, code_writing_scratchpad=response.content, code=code_block, ) # Store the code review task in the session memory. self._session_memory[message.session_id].append(code_review_task) # Publish a new code review task. await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key)) def _extract_code_block(self, markdown_text: str) -> Union[str, None]: pattern = r\"```(\\w+)\\n(.*?)\\n```\" # Search for the pattern in the markdown text match = re.search(pattern, markdown_text, re.DOTALL) # Extract the language and code block if a match is found if match: return match.group(2) return None A few things to note about CoderAgent: It uses chain-of-thought prompting in its system message. It stores message histories for different CodeWritingTask in a dictionary, so each task has its own history. When making an LLM inference request using its model client, it transforms the message history into a list of autogen_core.models.LLMMessage objects to pass to the model client. The reviewer agent subscribes to the CodeReviewTask message and publishes the CodeReviewResult message. @default_subscription class ReviewerAgent(RoutedAgent): \"\"\"An agent that performs code review tasks.\"\"\" def __init__(self, model_client: ChatCompletionClient) -> None: super().__init__(\"A code reviewer agent.\") self._system_messages: List[LLMMessage] = [ SystemMessage( content=\"\"\"You are a code reviewer. You focus on correctness, efficiency and safety of the code. Respond using the following JSON format: { \"correctness\": \"<Your comments>\", \"efficiency\": \"<Your comments>\", \"safety\": \"<Your comments>\", \"approval\": \"<APPROVE or REVISE>\", \"suggested_changes\": \"<Your comments>\" } \"\"\", ) ] self._session_memory: Dict[str, List[CodeReviewTask | CodeReviewResult]] = {} self._model_client = model_client @message_handler async def handle_code_review_task(self, message: CodeReviewTask, ctx: MessageContext) -> None: # Format the prompt for the code review. # Gather the previous feedback if available. previous_feedback = \"\" if message.session_id in self._session_memory: previous_review = next( (m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewResult)), None, ) if previous_review is not None: previous_feedback = previous_review.review # Store the messages in a temporary memory for this request only. self._session_memory.setdefault(message.session_id, []).append(message) prompt = f\"\"\"The problem statement is: {message.code_writing_task} The code is: ``` {message.code} ``` Previous feedback: {previous_feedback} Please review the code. If previous feedback was provided, see if it was addressed. \"\"\" # Generate a response using the chat completion API. response = await self._model_client.create( self._system_messages + [UserMessage(content=prompt, source=self.metadata[\"type\"])], cancellation_token=ctx.cancellation_token, json_output=True, ) assert isinstance(response.content, str) # TODO: use structured generation library e.g. guidance to ensure the response is in the expected format. # Parse the response JSON. review = json.loads(response.content) # Construct the review text. review_text = \"Code review:\\n\" + \"\\n\".join([f\"{k}: {v}\" for k, v in review.items()]) approved = review[\"approval\"].lower().strip() == \"approve\" result = CodeReviewResult( review=review_text, session_id=message.session_id, approved=approved, ) # Store the review result in the session memory. self._session_memory[message.session_id].append(result) # Publish the review result. await self.publish_message(result, topic_id=TopicId(\"default\", self.id.key)) The ReviewerAgent uses JSON-mode when making an LLM inference request, and also uses chain-of-thought prompting in its system message. Logging# Turn on logging to see the messages exchanged between the agents. import logging logging.basicConfig(level=logging.WARNING) logging.getLogger(\"autogen_core\").setLevel(logging.DEBUG) Running the Design Pattern# Let’s test the design pattern with a coding task. Since all the agents are decorated with the default_subscription() class decorator, the agents when created will automatically subscribe to the default topic. We publish a CodeWritingTask message to the default topic to start the reflection process. from autogen_core import DefaultTopicId, SingleThreadedAgentRuntime from autogen_ext.models.openai import OpenAIChatCompletionClient runtime = SingleThreadedAgentRuntime() model_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\") await ReviewerAgent.register(runtime, \"ReviewerAgent\", lambda: ReviewerAgent(model_client=model_client)) await CoderAgent.register(runtime, \"CoderAgent\", lambda: CoderAgent(model_client=model_client)) runtime.start() await runtime.publish_message( message=CodeWritingTask(task=\"Write a function to find the sum of all even numbers in a list.\"), topic_id=DefaultTopicId(), ) # Keep processing messages until idle. await runtime.stop_when_idle() # Close the model client. await model_client.close() INFO:autogen_core:Publishing message of type CodeWritingTask to all subscribers: {'task': 'Write a function to find the sum of all even numbers in a list.'} INFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeWritingTask published by Unknown INFO:autogen_core:Calling message handler for CoderAgent with message type CodeWritingTask published by Unknown INFO:autogen_core:Unhandled message: CodeWritingTask(task='Write a function to find the sum of all even numbers in a list.') INFO:autogen_core.events:{\"prompt_tokens\": 101, \"completion_tokens\": 88, \"type\": \"LLMCall\"} INFO:autogen_core:Publishing message of type CodeReviewTask to all subscribers: {'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'code_writing_task': 'Write a function to find the sum of all even numbers in a list.', 'code_writing_scratchpad': 'Thoughts: To find the sum of all even numbers in a list, we can use a list comprehension to filter out the even numbers and then use the `sum()` function to calculate their total. The implementation should handle edge cases like an empty list or a list with no even numbers.\\n\\nCode:\\n```python\\ndef sum_of_even_numbers(numbers):\\n return sum(num for num in numbers if num % 2 == 0)\\n```', 'code': 'def sum_of_even_numbers(numbers):\\n return sum(num for num in numbers if num % 2 == 0)'} INFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeReviewTask published by CoderAgent:default INFO:autogen_core.events:{\"prompt_tokens\": 163, \"completion_tokens\": 235, \"type\": \"LLMCall\"} INFO:autogen_core:Publishing message of type CodeReviewResult to all subscribers: {'review': \"Code review:\\ncorrectness: The function correctly identifies and sums all even numbers in the provided list. The use of a generator expression ensures that only even numbers are processed, which is correct.\\nefficiency: The function is efficient as it utilizes a generator expression that avoids creating an intermediate list, therefore using less memory. The time complexity is O(n) where n is the number of elements in the input list, which is optimal for this task.\\nsafety: The function does not include checks for input types. If a non-iterable or a list containing non-integer types is passed, it could lead to unexpected behavior or errors. It’s advisable to handle such cases.\\napproval: REVISE\\nsuggested_changes: Consider adding input validation to ensure that 'numbers' is a list and contains only integers. You could raise a ValueError if the input is invalid. Example: 'if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): raise ValueError('Input must be a list of integers')'. This will make the function more robust.\", 'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'approved': False} INFO:autogen_core:Calling message handler for CoderAgent with message type CodeReviewResult published by ReviewerAgent:default INFO:autogen_core.events:{\"prompt_tokens\": 421, \"completion_tokens\": 119, \"type\": \"LLMCall\"} INFO:autogen_core:Publishing message of type CodeReviewTask to all subscribers: {'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'code_writing_task': 'Write a function to find the sum of all even numbers in a list.', 'code_writing_scratchpad': \"Thoughts: I appreciate the reviewer's feedback on input validation. Adding type checks ensures that the function can handle unexpected inputs gracefully. I will implement the suggested changes and include checks for both the input type and the elements within the list to confirm that they are integers.\\n\\nCode:\\n```python\\ndef sum_of_even_numbers(numbers):\\n if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n raise ValueError('Input must be a list of integers')\\n \\n return sum(num for num in numbers if num % 2 == 0)\\n```\", 'code': \"def sum_of_even_numbers(numbers):\\n if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n raise ValueError('Input must be a list of integers')\\n \\n return sum(num for num in numbers if num % 2 == 0)\"} INFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeReviewTask published by CoderAgent:default INFO:autogen_core.events:{\"prompt_tokens\": 420, \"completion_tokens\": 153, \"type\": \"LLMCall\"} INFO:autogen_core:Publishing message of type CodeReviewResult to all subscribers: {'review': 'Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.', 'session_id': '51db93d5-3e29-4b7f-9f96-77be7bb02a5e', 'approved': True} INFO:autogen_core:Calling message handler for CoderAgent with message type CodeReviewResult published by ReviewerAgent:default INFO:autogen_core:Publishing message of type CodeWritingResult to all subscribers: {'task': 'Write a function to find the sum of all even numbers in a list.', 'code': \"def sum_of_even_numbers(numbers):\\n if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n raise ValueError('Input must be a list of integers')\\n \\n return sum(num for num in numbers if num % 2 == 0)\", 'review': 'Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.'} INFO:autogen_core:Calling message handler for ReviewerAgent with message type CodeWritingResult published by CoderAgent:default INFO:autogen_core:Unhandled message: CodeWritingResult(task='Write a function to find the sum of all even numbers in a list.', code=\"def sum_of_even_numbers(numbers):\\n if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\\n raise ValueError('Input must be a list of integers')\\n \\n return sum(num for num in numbers if num % 2 == 0)\", review='Code review:\\ncorrectness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness.\\nefficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal.\\nsafety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data.\\napproval: APPROVE\\nsuggested_changes: No further changes are necessary as the previous feedback has been adequately addressed.') Code Writing Result: -------------------------------------------------------------------------------- Task: Write a function to find the sum of all even numbers in a list. -------------------------------------------------------------------------------- Code: def sum_of_even_numbers(numbers): if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): raise ValueError('Input must be a list of integers') return sum(num for num in numbers if num % 2 == 0) -------------------------------------------------------------------------------- Review: Code review: correctness: The function correctly sums all even numbers in the provided list. It raises a ValueError if the input is not a list of integers, which is a necessary check for correctness. efficiency: The function remains efficient with a time complexity of O(n) due to the use of a generator expression. There are no unnecessary intermediate lists created, so memory usage is optimal. safety: The function includes input validation, which enhances safety by preventing incorrect input types. It raises a ValueError for invalid inputs, making the function more robust against unexpected data. approval: APPROVE suggested_changes: No further changes are necessary as the previous feedback has been adequately addressed. -------------------------------------------------------------------------------- The log messages show the interaction between the coder and reviewer agents. The final output shows the code snippet generated by the coder agent and the critique generated by the reviewer agent. previous Multi-Agent Debate next Code Execution",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass CodeWritingTask:\n    task: str\n\n\n@dataclass\nclass CodeWritingResult:\n    task: str\n    code: str\n    review: str\n\n\n@dataclass\nclass CodeReviewTask:\n    session_id: str\n    code_writing_task: str\n    code_writing_scratchpad: str\n    code: str\n\n\n@dataclass\nclass CodeReviewResult:\n    review: str\n    session_id: str\n    approved: bool"
    },
    {
      "description": "The above set of messages defines the protocol for our example reflection design pattern:",
      "code": "CodeWritingTask"
    },
    {
      "description": "@default_subscription class CoderAgent(RoutedAgent): \"\"\"An agent that performs code writing tasks.\"\"\" def __init__(self, model_client: ChatCompletionClient) -> None: super().__init__(\"A code writing agent.\") self._system_messages: List[LLMMessage] = [ SystemMessage( content=\"\"\"You are a proficient coder. You write code to solve problems. Work with the reviewer to improve your code. Always put all finished code in a single Markdown code block. For example: ```python def hello_world(): print(\"Hello, World!\") ``` Respond using the following format: Thoughts: <Your comments> Code: <Your code> \"\"\", ) ] self._model_client = model_client self._session_memory: Dict[str, List[CodeWritingTask | CodeReviewTask | CodeReviewResult]] = {} @message_handler async def handle_code_writing_task(self, message: CodeWritingTask, ctx: MessageContext) -> None: # Store the messages in a temporary memory for this request only. session_id = str(uuid.uuid4()) self._session_memory.setdefault(session_id, []).append(message) # Generate a response using the chat completion API. response = await self._model_client.create( self._system_messages + [UserMessage(content=message.task, source=self.metadata[\"type\"])], cancellation_token=ctx.cancellation_token, ) assert isinstance(response.content, str) # Extract the code block from the response. code_block = self._extract_code_block(response.content) if code_block is None: raise ValueError(\"Code block not found.\") # Create a code review task. code_review_task = CodeReviewTask( session_id=session_id, code_writing_task=message.task, code_writing_scratchpad=response.content, code=code_block, ) # Store the code review task in the session memory. self._session_memory[session_id].append(code_review_task) # Publish a code review task. await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key)) @message_handler async def handle_code_review_result(self, message: CodeReviewResult, ctx: MessageContext) -> None: # Store the review result in the session memory. self._session_memory[message.session_id].append(message) # Obtain the request from previous messages. review_request = next( m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewTask) ) assert review_request is not None # Check if the code is approved. if message.approved: # Publish the code writing result. await self.publish_message( CodeWritingResult( code=review_request.code, task=review_request.code_writing_task, review=message.review, ), topic_id=TopicId(\"default\", self.id.key), ) print(\"Code Writing Result:\") print(\"-\" * 80) print(f\"Task:\\n{review_request.code_writing_task}\") print(\"-\" * 80) print(f\"Code:\\n{review_request.code}\") print(\"-\" * 80) print(f\"Review:\\n{message.review}\") print(\"-\" * 80) else: # Create a list of LLM messages to send to the model. messages: List[LLMMessage] = [*self._system_messages] for m in self._session_memory[message.session_id]: if isinstance(m, CodeReviewResult): messages.append(UserMessage(content=m.review, source=\"Reviewer\")) elif isinstance(m, CodeReviewTask): messages.append(AssistantMessage(content=m.code_writing_scratchpad, source=\"Coder\")) elif isinstance(m, CodeWritingTask): messages.append(UserMessage(content=m.task, source=\"User\")) else: raise ValueError(f\"Unexpected message type: {m}\") # Generate a revision using the chat completion API. response = await self._model_client.create(messages, cancellation_token=ctx.cancellation_token) assert isinstance(response.content, str) # Extract the code block from the response. code_block = self._extract_code_block(response.content) if code_block is None: raise ValueError(\"Code block not found.\") # Create a new code review task. code_review_task = CodeReviewTask( session_id=message.session_id, code_writing_task=review_request.code_writing_task, code_writing_scratchpad=response.content, code=code_block, ) # Store the code review task in the session memory. self._session_memory[message.session_id].append(code_review_task) # Publish a new code review task. await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key)) def _extract_code_block(self, markdown_text: str) -> Union[str, None]: pattern = r\"```(\\w+)\\n(.*?)\\n```\" # Search for the pattern in the markdown text match = re.search(pattern, markdown_text, re.DOTALL) # Extract the language and code block if a match is found if match: return match.group(2) return None",
      "code": "@default_subscription\nclass CoderAgent(RoutedAgent):\n    \"\"\"An agent that performs code writing tasks.\"\"\"\n\n    def __init__(self, model_client: ChatCompletionClient) -> None:\n        super().__init__(\"A code writing agent.\")\n        self._system_messages: List[LLMMessage] = [\n            SystemMessage(\n                content=\"\"\"You are a proficient coder. You write code to solve problems.\nWork with the reviewer to improve your code.\nAlways put all finished code in a single Markdown code block.\nFor example:\n```python\ndef hello_world():\n    print(\"Hello, World!\")\n```\n\nRespond using the following format:\n\nThoughts: <Your comments>\nCode: <Your code>\n\"\"\",\n            )\n        ]\n        self._model_client = model_client\n        self._session_memory: Dict[str, List[CodeWritingTask | CodeReviewTask | CodeReviewResult]] = {}\n\n    @message_handler\n    async def handle_code_writing_task(self, message: CodeWritingTask, ctx: MessageContext) -> None:\n        # Store the messages in a temporary memory for this request only.\n        session_id = str(uuid.uuid4())\n        self._session_memory.setdefault(session_id, []).append(message)\n        # Generate a response using the chat completion API.\n        response = await self._model_client.create(\n            self._system_messages + [UserMessage(content=message.task, source=self.metadata[\"type\"])],\n            cancellation_token=ctx.cancellation_token,\n        )\n        assert isinstance(response.content, str)\n        # Extract the code block from the response.\n        code_block = self._extract_code_block(response.content)\n        if code_block is None:\n            raise ValueError(\"Code block not found.\")\n        # Create a code review task.\n        code_review_task = CodeReviewTask(\n            session_id=session_id,\n            code_writing_task=message.task,\n            code_writing_scratchpad=response.content,\n            code=code_block,\n        )\n        # Store the code review task in the session memory.\n        self._session_memory[session_id].append(code_review_task)\n        # Publish a code review task.\n        await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key))\n\n    @message_handler\n    async def handle_code_review_result(self, message: CodeReviewResult, ctx: MessageContext) -> None:\n        # Store the review result in the session memory.\n        self._session_memory[message.session_id].append(message)\n        # Obtain the request from previous messages.\n        review_request = next(\n            m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewTask)\n        )\n        assert review_request is not None\n        # Check if the code is approved.\n        if message.approved:\n            # Publish the code writing result.\n            await self.publish_message(\n                CodeWritingResult(\n                    code=review_request.code,\n                    task=review_request.code_writing_task,\n                    review=message.review,\n                ),\n                topic_id=TopicId(\"default\", self.id.key),\n            )\n            print(\"Code Writing Result:\")\n            print(\"-\" * 80)\n            print(f\"Task:\\n{review_request.code_writing_task}\")\n            print(\"-\" * 80)\n            print(f\"Code:\\n{review_request.code}\")\n            print(\"-\" * 80)\n            print(f\"Review:\\n{message.review}\")\n            print(\"-\" * 80)\n        else:\n            # Create a list of LLM messages to send to the model.\n            messages: List[LLMMessage] = [*self._system_messages]\n            for m in self._session_memory[message.session_id]:\n                if isinstance(m, CodeReviewResult):\n                    messages.append(UserMessage(content=m.review, source=\"Reviewer\"))\n                elif isinstance(m, CodeReviewTask):\n                    messages.append(AssistantMessage(content=m.code_writing_scratchpad, source=\"Coder\"))\n                elif isinstance(m, CodeWritingTask):\n                    messages.append(UserMessage(content=m.task, source=\"User\"))\n                else:\n                    raise ValueError(f\"Unexpected message type: {m}\")\n            # Generate a revision using the chat completion API.\n            response = await self._model_client.create(messages, cancellation_token=ctx.cancellation_token)\n            assert isinstance(response.content, str)\n            # Extract the code block from the response.\n            code_block = self._extract_code_block(response.content)\n            if code_block is None:\n                raise ValueError(\"Code block not found.\")\n            # Create a new code review task.\n            code_review_task = CodeReviewTask(\n                session_id=message.session_id,\n                code_writing_task=review_request.code_writing_task,\n                code_writing_scratchpad=response.content,\n                code=code_block,\n            )\n            # Store the code review task in the session memory.\n            self._session_memory[message.session_id].append(code_review_task)\n            # Publish a new code review task.\n            await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key))\n\n    def _extract_code_block(self, markdown_text: str) -> Union[str, None]:\n        pattern = r\"```(\\w+)\\n(.*?)\\n```\"\n        # Search for the pattern in the markdown text\n        match = re.search(pattern, markdown_text, re.DOTALL)\n        # Extract the language and code block if a match is found\n        if match:\n            return match.group(2)\n        return None"
    },
    {
      "description": "@default_subscription class CoderAgent(RoutedAgent): \"\"\"An agent that performs code writing tasks.\"\"\" def __init__(self, model_client: ChatCompletionClient) -> None: super().__init__(\"A code writing agent.\") self._system_messages: List[LLMMessage] = [ SystemMessage( content=\"\"\"You are a proficient coder. You write code to solve problems. Work with the reviewer to improve your code. Always put all finished code in a single Markdown code block. For example: ```python def hello_world(): print(\"Hello, World!\") ``` Respond using the following format: Thoughts: <Your comments> Code: <Your code> \"\"\", ) ] self._model_client = model_client self._session_memory: Dict[str, List[CodeWritingTask | CodeReviewTask | CodeReviewResult]] = {} @message_handler async def handle_code_writing_task(self, message: CodeWritingTask, ctx: MessageContext) -> None: # Store the messages in a temporary memory for this request only. session_id = str(uuid.uuid4()) self._session_memory.setdefault(session_id, []).append(message) # Generate a response using the chat completion API. response = await self._model_client.create( self._system_messages + [UserMessage(content=message.task, source=self.metadata[\"type\"])], cancellation_token=ctx.cancellation_token, ) assert isinstance(response.content, str) # Extract the code block from the response. code_block = self._extract_code_block(response.content) if code_block is None: raise ValueError(\"Code block not found.\") # Create a code review task. code_review_task = CodeReviewTask( session_id=session_id, code_writing_task=message.task, code_writing_scratchpad=response.content, code=code_block, ) # Store the code review task in the session memory. self._session_memory[session_id].append(code_review_task) # Publish a code review task. await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key)) @message_handler async def handle_code_review_result(self, message: CodeReviewResult, ctx: MessageContext) -> None: # Store the review result in the session memory. self._session_memory[message.session_id].append(message) # Obtain the request from previous messages. review_request = next( m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewTask) ) assert review_request is not None # Check if the code is approved. if message.approved: # Publish the code writing result. await self.publish_message( CodeWritingResult( code=review_request.code, task=review_request.code_writing_task, review=message.review, ), topic_id=TopicId(\"default\", self.id.key), ) print(\"Code Writing Result:\") print(\"-\" * 80) print(f\"Task:\\n{review_request.code_writing_task}\") print(\"-\" * 80) print(f\"Code:\\n{review_request.code}\") print(\"-\" * 80) print(f\"Review:\\n{message.review}\") print(\"-\" * 80) else: # Create a list of LLM messages to send to the model. messages: List[LLMMessage] = [*self._system_messages] for m in self._session_memory[message.session_id]: if isinstance(m, CodeReviewResult): messages.append(UserMessage(content=m.review, source=\"Reviewer\")) elif isinstance(m, CodeReviewTask): messages.append(AssistantMessage(content=m.code_writing_scratchpad, source=\"Coder\")) elif isinstance(m, CodeWritingTask): messages.append(UserMessage(content=m.task, source=\"User\")) else: raise ValueError(f\"Unexpected message type: {m}\") # Generate a revision using the chat completion API. response = await self._model_client.create(messages, cancellation_token=ctx.cancellation_token) assert isinstance(response.content, str) # Extract the code block from the response. code_block = self._extract_code_block(response.content) if code_block is None: raise ValueError(\"Code block not found.\") # Create a new code review task. code_review_task = CodeReviewTask( session_id=message.session_id, code_writing_task=review_request.code_writing_task, code_writing_scratchpad=response.content, code=code_block, ) # Store the code review task in the session memory. self._session_memory[message.session_id].append(code_review_task) # Publish a new code review task. await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key)) def _extract_code_block(self, markdown_text: str) -> Union[str, None]: pattern = r\"```(\\w+)\\n(.*?)\\n```\" # Search for the pattern in the markdown text match = re.search(pattern, markdown_text, re.DOTALL) # Extract the language and code block if a match is found if match: return match.group(2) return None",
      "code": "@default_subscription\nclass CoderAgent(RoutedAgent):\n    \"\"\"An agent that performs code writing tasks.\"\"\"\n\n    def __init__(self, model_client: ChatCompletionClient) -> None:\n        super().__init__(\"A code writing agent.\")\n        self._system_messages: List[LLMMessage] = [\n            SystemMessage(\n                content=\"\"\"You are a proficient coder. You write code to solve problems.\nWork with the reviewer to improve your code.\nAlways put all finished code in a single Markdown code block.\nFor example:\n```python\ndef hello_world():\n    print(\"Hello, World!\")\n```\n\nRespond using the following format:\n\nThoughts: <Your comments>\nCode: <Your code>\n\"\"\",\n            )\n        ]\n        self._model_client = model_client\n        self._session_memory: Dict[str, List[CodeWritingTask | CodeReviewTask | CodeReviewResult]] = {}\n\n    @message_handler\n    async def handle_code_writing_task(self, message: CodeWritingTask, ctx: MessageContext) -> None:\n        # Store the messages in a temporary memory for this request only.\n        session_id = str(uuid.uuid4())\n        self._session_memory.setdefault(session_id, []).append(message)\n        # Generate a response using the chat completion API.\n        response = await self._model_client.create(\n            self._system_messages + [UserMessage(content=message.task, source=self.metadata[\"type\"])],\n            cancellation_token=ctx.cancellation_token,\n        )\n        assert isinstance(response.content, str)\n        # Extract the code block from the response.\n        code_block = self._extract_code_block(response.content)\n        if code_block is None:\n            raise ValueError(\"Code block not found.\")\n        # Create a code review task.\n        code_review_task = CodeReviewTask(\n            session_id=session_id,\n            code_writing_task=message.task,\n            code_writing_scratchpad=response.content,\n            code=code_block,\n        )\n        # Store the code review task in the session memory.\n        self._session_memory[session_id].append(code_review_task)\n        # Publish a code review task.\n        await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key))\n\n    @message_handler\n    async def handle_code_review_result(self, message: CodeReviewResult, ctx: MessageContext) -> None:\n        # Store the review result in the session memory.\n        self._session_memory[message.session_id].append(message)\n        # Obtain the request from previous messages.\n        review_request = next(\n            m for m in reversed(self._session_memory[message.session_id]) if isinstance(m, CodeReviewTask)\n        )\n        assert review_request is not None\n        # Check if the code is approved.\n        if message.approved:\n            # Publish the code writing result.\n            await self.publish_message(\n                CodeWritingResult(\n                    code=review_request.code,\n                    task=review_request.code_writing_task,\n                    review=message.review,\n                ),\n                topic_id=TopicId(\"default\", self.id.key),\n            )\n            print(\"Code Writing Result:\")\n            print(\"-\" * 80)\n            print(f\"Task:\\n{review_request.code_writing_task}\")\n            print(\"-\" * 80)\n            print(f\"Code:\\n{review_request.code}\")\n            print(\"-\" * 80)\n            print(f\"Review:\\n{message.review}\")\n            print(\"-\" * 80)\n        else:\n            # Create a list of LLM messages to send to the model.\n            messages: List[LLMMessage] = [*self._system_messages]\n            for m in self._session_memory[message.session_id]:\n                if isinstance(m, CodeReviewResult):\n                    messages.append(UserMessage(content=m.review, source=\"Reviewer\"))\n                elif isinstance(m, CodeReviewTask):\n                    messages.append(AssistantMessage(content=m.code_writing_scratchpad, source=\"Coder\"))\n                elif isinstance(m, CodeWritingTask):\n                    messages.append(UserMessage(content=m.task, source=\"User\"))\n                else:\n                    raise ValueError(f\"Unexpected message type: {m}\")\n            # Generate a revision using the chat completion API.\n            response = await self._model_client.create(messages, cancellation_token=ctx.cancellation_token)\n            assert isinstance(response.content, str)\n            # Extract the code block from the response.\n            code_block = self._extract_code_block(response.content)\n            if code_block is None:\n                raise ValueError(\"Code block not found.\")\n            # Create a new code review task.\n            code_review_task = CodeReviewTask(\n                session_id=message.session_id,\n                code_writing_task=review_request.code_writing_task,\n                code_writing_scratchpad=response.content,\n                code=code_block,\n            )\n            # Store the code review task in the session memory.\n            self._session_memory[message.session_id].append(code_review_task)\n            # Publish a new code review task.\n            await self.publish_message(code_review_task, topic_id=TopicId(\"default\", self.id.key))\n\n    def _extract_code_block(self, markdown_text: str) -> Union[str, None]:\n        pattern = r\"```(\\w+)\\n(.*?)\\n```\"\n        # Search for the pattern in the markdown text\n        match = re.search(pattern, markdown_text, re.DOTALL)\n        # Extract the language and code block if a match is found\n        if match:\n            return match.group(2)\n        return None"
    }
  ],
  "links": [
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/reflection.html",
    "https://microsoft.github.io/autogen/stable/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/extensions-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/autogenstudio-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/reference/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/installation.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/quickstart.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-and-multi-agent-application.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/architecture.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/application-stack.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-identity-and-lifecycle.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/topic-and-subscription.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/agent-and-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/message-and-communication.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/logging.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/telemetry.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/distributed-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/component-config.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-clients.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-context.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/tools.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/workbench.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/command-line-code-executors.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/intro.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/concurrent-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/sequential-workflow.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/group-chat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/handoffs.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/mixture-of-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/multi-agent-debate.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/code-execution-groupchat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/azure-openai-with-aad-auth.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/termination-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/tool-use-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/extracting-results-with-an-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/openai-assistant-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/langgraph-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llamaindex-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/local-llms-ollama-litellm.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/instrumenting.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/topic-subscription-scenarios.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/structured-output-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llm-usage-logger.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/faqs.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html"
  ]
}