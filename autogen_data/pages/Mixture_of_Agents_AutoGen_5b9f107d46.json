{
  "url": "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/mixture-of-agents.html",
  "title": "Mixture of Agents — AutoGen",
  "content": "Mixture of Agents is a multi-agent design pattern that models after the feed-forward neural network architecture.\n\nThe pattern consists of two types of agents: worker agents and a single orchestrator agent. Worker agents are organized into multiple layers, with each layer consisting of a fixed number of worker agents. Messages from the worker agents in a previous layer are concatenated and sent to all the worker agents in the next layer.\n\nThis example implements the Mixture of Agents pattern using the core library following the original implementation of multi-layer mixture of agents.\n\nHere is a high-level procedure overview of the pattern:\n\nThe orchestrator agent takes input a user task and first dispatches it to the worker agents in the first layer.\n\nThe worker agents in the first layer process the task and return the results to the orchestrator agent.\n\nThe orchestrator agent then synthesizes the results from the first layer and dispatches an updated task with the previous results to the worker agents in the second layer.\n\nThe process continues until the final layer is reached.\n\nIn the final layer, the orchestrator agent aggregates the results from previous layer and returns a single final result to the user.\n\nWe use the direct messaging API send_message() to implement this pattern. This makes it easier to add more features like worker task cancellation and error handling in the future.\n\nThe agents communicate using the following messages:\n\nEach worker agent receives a task from the orchestrator agent and processes them indepedently. Once the task is completed, the worker agent returns the result.\n\nThe orchestrator agent receives tasks from the user and distributes them to the worker agents, iterating over multiple layers of worker agents. Once all worker agents have processed the task, the orchestrator agent aggregates the results and publishes the final result.\n\nLet’s run the mixture of agents on a math task. You can change the task to make it more challenging, for example, by trying tasks from the International Mathematical Olympiad.\n\nLet’s set up the runtime with 3 layers of worker agents, each layer consisting of 3 worker agents. We only need to register a single worker agent types, “worker”, because we are using the same model client configuration (i.e., gpt-4o-mini) for all worker agents. If you want to use different models, you will need to register multiple worker agent types, one for each model, and update the worker_agent_types list in the orchestrator agent’s factory function.\n\nThe instances of worker agents are automatically created when the orchestrator agent dispatches tasks to them. See Agent Identity and Lifecycle for more information on agent lifecycle.",
  "headings": [
    {
      "level": "h1",
      "text": "Mixture of Agents#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Message Protocol#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Worker Agent#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Orchestrator Agent#",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Running Mixture of Agents#",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler\nfrom autogen_core.models import ChatCompletionClient, SystemMessage, UserMessage\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient",
      "language": "python"
    },
    {
      "code": "import asyncio\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler\nfrom autogen_core.models import ChatCompletionClient, SystemMessage, UserMessage\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass WorkerTask:\n    task: str\n    previous_results: List[str]\n\n\n@dataclass\nclass WorkerTaskResult:\n    result: str\n\n\n@dataclass\nclass UserTask:\n    task: str\n\n\n@dataclass\nclass FinalResult:\n    result: str",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass WorkerTask:\n    task: str\n    previous_results: List[str]\n\n\n@dataclass\nclass WorkerTaskResult:\n    result: str\n\n\n@dataclass\nclass UserTask:\n    task: str\n\n\n@dataclass\nclass FinalResult:\n    result: str",
      "language": "python"
    },
    {
      "code": "class WorkerAgent(RoutedAgent):\n    def __init__(\n        self,\n        model_client: ChatCompletionClient,\n    ) -> None:\n        super().__init__(description=\"Worker Agent\")\n        self._model_client = model_client\n\n    @message_handler\n    async def handle_task(self, message: WorkerTask, ctx: MessageContext) -> WorkerTaskResult:\n        if message.previous_results:\n            # If previous results are provided, we need to synthesize them to create a single prompt.\n            system_prompt = \"You have been provided with a set of responses from various open-source models to the latest user query. Your task is to synthesize these responses into a single, high-quality response. It is crucial to critically evaluate the information provided in these responses, recognizing that some of it may be biased or incorrect. Your response should not simply replicate the given answers but should offer a refined, accurate, and comprehensive reply to the instruction. Ensure your response is well-structured, coherent, and adheres to the highest standards of accuracy and reliability.\\n\\nResponses from models:\"\n            system_prompt += \"\\n\" + \"\\n\\n\".join([f\"{i+1}. {r}\" for i, r in enumerate(message.previous_results)])\n            model_result = await self._model_client.create(\n                [SystemMessage(content=system_prompt), UserMessage(content=message.task, source=\"user\")]\n            )\n        else:\n            # If no previous results are provided, we can simply pass the user query to the model.\n            model_result = await self._model_client.create([UserMessage(content=message.task, source=\"user\")])\n        assert isinstance(model_result.content, str)\n        print(f\"{'-'*80}\\nWorker-{self.id}:\\n{model_result.content}\")\n        return WorkerTaskResult(result=model_result.content)",
      "language": "python"
    },
    {
      "code": "class WorkerAgent(RoutedAgent):\n    def __init__(\n        self,\n        model_client: ChatCompletionClient,\n    ) -> None:\n        super().__init__(description=\"Worker Agent\")\n        self._model_client = model_client\n\n    @message_handler\n    async def handle_task(self, message: WorkerTask, ctx: MessageContext) -> WorkerTaskResult:\n        if message.previous_results:\n            # If previous results are provided, we need to synthesize them to create a single prompt.\n            system_prompt = \"You have been provided with a set of responses from various open-source models to the latest user query. Your task is to synthesize these responses into a single, high-quality response. It is crucial to critically evaluate the information provided in these responses, recognizing that some of it may be biased or incorrect. Your response should not simply replicate the given answers but should offer a refined, accurate, and comprehensive reply to the instruction. Ensure your response is well-structured, coherent, and adheres to the highest standards of accuracy and reliability.\\n\\nResponses from models:\"\n            system_prompt += \"\\n\" + \"\\n\\n\".join([f\"{i+1}. {r}\" for i, r in enumerate(message.previous_results)])\n            model_result = await self._model_client.create(\n                [SystemMessage(content=system_prompt), UserMessage(content=message.task, source=\"user\")]\n            )\n        else:\n            # If no previous results are provided, we can simply pass the user query to the model.\n            model_result = await self._model_client.create([UserMessage(content=message.task, source=\"user\")])\n        assert isinstance(model_result.content, str)\n        print(f\"{'-'*80}\\nWorker-{self.id}:\\n{model_result.content}\")\n        return WorkerTaskResult(result=model_result.content)",
      "language": "python"
    },
    {
      "code": "class OrchestratorAgent(RoutedAgent):\n    def __init__(\n        self,\n        model_client: ChatCompletionClient,\n        worker_agent_types: List[str],\n        num_layers: int,\n    ) -> None:\n        super().__init__(description=\"Aggregator Agent\")\n        self._model_client = model_client\n        self._worker_agent_types = worker_agent_types\n        self._num_layers = num_layers\n\n    @message_handler\n    async def handle_task(self, message: UserTask, ctx: MessageContext) -> FinalResult:\n        print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nReceived task: {message.task}\")\n        # Create task for the first layer.\n        worker_task = WorkerTask(task=message.task, previous_results=[])\n        # Iterate over layers.\n        for i in range(self._num_layers - 1):\n            # Assign workers for this layer.\n            worker_ids = [\n                AgentId(worker_type, f\"{self.id.key}/layer_{i}/worker_{j}\")\n                for j, worker_type in enumerate(self._worker_agent_types)\n            ]\n            # Dispatch tasks to workers.\n            print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nDispatch to workers at layer {i}\")\n            results = await asyncio.gather(*[self.send_message(worker_task, worker_id) for worker_id in worker_ids])\n            print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nReceived results from workers at layer {i}\")\n            # Prepare task for the next layer.\n            worker_task = WorkerTask(task=message.task, previous_results=[r.result for r in results])\n        # Perform final aggregation.\n        print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nPerforming final aggregation\")\n        system_prompt = \"You have been provided with a set of responses from various open-source models to the latest user query. Your task is to synthesize these responses into a single, high-quality response. It is crucial to critically evaluate the information provided in these responses, recognizing that some of it may be biased or incorrect. Your response should not simply replicate the given answers but should offer a refined, accurate, and comprehensive reply to the instruction. Ensure your response is well-structured, coherent, and adheres to the highest standards of accuracy and reliability.\\n\\nResponses from models:\"\n        system_prompt += \"\\n\" + \"\\n\\n\".join([f\"{i+1}. {r}\" for i, r in enumerate(worker_task.previous_results)])\n        model_result = await self._model_client.create(\n            [SystemMessage(content=system_prompt), UserMessage(content=message.task, source=\"user\")]\n        )\n        assert isinstance(model_result.content, str)\n        return FinalResult(result=model_result.content)",
      "language": "python"
    },
    {
      "code": "class OrchestratorAgent(RoutedAgent):\n    def __init__(\n        self,\n        model_client: ChatCompletionClient,\n        worker_agent_types: List[str],\n        num_layers: int,\n    ) -> None:\n        super().__init__(description=\"Aggregator Agent\")\n        self._model_client = model_client\n        self._worker_agent_types = worker_agent_types\n        self._num_layers = num_layers\n\n    @message_handler\n    async def handle_task(self, message: UserTask, ctx: MessageContext) -> FinalResult:\n        print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nReceived task: {message.task}\")\n        # Create task for the first layer.\n        worker_task = WorkerTask(task=message.task, previous_results=[])\n        # Iterate over layers.\n        for i in range(self._num_layers - 1):\n            # Assign workers for this layer.\n            worker_ids = [\n                AgentId(worker_type, f\"{self.id.key}/layer_{i}/worker_{j}\")\n                for j, worker_type in enumerate(self._worker_agent_types)\n            ]\n            # Dispatch tasks to workers.\n            print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nDispatch to workers at layer {i}\")\n            results = await asyncio.gather(*[self.send_message(worker_task, worker_id) for worker_id in worker_ids])\n            print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nReceived results from workers at layer {i}\")\n            # Prepare task for the next layer.\n            worker_task = WorkerTask(task=message.task, previous_results=[r.result for r in results])\n        # Perform final aggregation.\n        print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nPerforming final aggregation\")\n        system_prompt = \"You have been provided with a set of responses from various open-source models to the latest user query. Your task is to synthesize these responses into a single, high-quality response. It is crucial to critically evaluate the information provided in these responses, recognizing that some of it may be biased or incorrect. Your response should not simply replicate the given answers but should offer a refined, accurate, and comprehensive reply to the instruction. Ensure your response is well-structured, coherent, and adheres to the highest standards of accuracy and reliability.\\n\\nResponses from models:\"\n        system_prompt += \"\\n\" + \"\\n\\n\".join([f\"{i+1}. {r}\" for i, r in enumerate(worker_task.previous_results)])\n        model_result = await self._model_client.create(\n            [SystemMessage(content=system_prompt), UserMessage(content=message.task, source=\"user\")]\n        )\n        assert isinstance(model_result.content, str)\n        return FinalResult(result=model_result.content)",
      "language": "python"
    },
    {
      "code": "task = (\n    \"I have 432 cookies, and divide them 3:4:2 between Alice, Bob, and Charlie. How many cookies does each person get?\"\n)",
      "language": "json"
    },
    {
      "code": "task = (\n    \"I have 432 cookies, and divide them 3:4:2 between Alice, Bob, and Charlie. How many cookies does each person get?\"\n)",
      "language": "json"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nmodel_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\")\nawait WorkerAgent.register(runtime, \"worker\", lambda: WorkerAgent(model_client=model_client))\nawait OrchestratorAgent.register(\n    runtime,\n    \"orchestrator\",\n    lambda: OrchestratorAgent(model_client=model_client, worker_agent_types=[\"worker\"] * 3, num_layers=3),\n)\n\nruntime.start()\nresult = await runtime.send_message(UserTask(task=task), AgentId(\"orchestrator\", \"default\"))\n\nawait runtime.stop_when_idle()\nawait model_client.close()\n\nprint(f\"{'-'*80}\\nFinal result:\\n{result.result}\")",
      "language": "python"
    },
    {
      "code": "runtime = SingleThreadedAgentRuntime()\nmodel_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\")\nawait WorkerAgent.register(runtime, \"worker\", lambda: WorkerAgent(model_client=model_client))\nawait OrchestratorAgent.register(\n    runtime,\n    \"orchestrator\",\n    lambda: OrchestratorAgent(model_client=model_client, worker_agent_types=[\"worker\"] * 3, num_layers=3),\n)\n\nruntime.start()\nresult = await runtime.send_message(UserTask(task=task), AgentId(\"orchestrator\", \"default\"))\n\nawait runtime.stop_when_idle()\nawait model_client.close()\n\nprint(f\"{'-'*80}\\nFinal result:\\n{result.result}\")",
      "language": "python"
    },
    {
      "code": "--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nReceived task: I have 432 cookies, and divide them 3:4:2 between Alice, Bob, and Charlie. How many cookies does each person get?\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nDispatch to workers at layer 0\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_0/worker_1:\nTo divide 432 cookies in the ratio of 3:4:2 between Alice, Bob, and Charlie, you first need to determine the total number of parts in the ratio.\n\nAdd the parts together:\n\\[ 3 + 4 + 2 = 9 \\]\n\nNow, you can find the value of one part by dividing the total number of cookies by the total number of parts:\n\\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\]\n\nNow, multiply the value of one part by the number of parts for each person:\n\n- For Alice (3 parts):\n\\[ 3 \\times 48 = 144 \\]\n\n- For Bob (4 parts):\n\\[ 4 \\times 48 = 192 \\]\n\n- For Charlie (2 parts):\n\\[ 2 \\times 48 = 96 \\]\n\nThus, the number of cookies each person gets is:\n- Alice: 144 cookies\n- Bob: 192 cookies\n- Charlie: 96 cookies\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_0/worker_0:\nTo divide 432 cookies in the ratio of 3:4:2 between Alice, Bob, and Charlie, we will first determine the total number of parts in the ratio:\n\n\\[\n3 + 4 + 2 = 9 \\text{ parts}\n\\]\n\nNext, we calculate the value of one part by dividing the total number of cookies by the total number of parts:\n\n\\[\n\\text{Value of one part} = \\frac{432}{9} = 48\n\\]\n\nNow, we can find out how many cookies each person receives by multiplying the value of one part by the number of parts each person receives:\n\n- For Alice (3 parts):\n\\[\n3 \\times 48 = 144 \\text{ cookies}\n\\]\n\n- For Bob (4 parts):\n\\[\n4 \\times 48 = 192 \\text{ cookies}\n\\]\n\n- For Charlie (2 parts):\n\\[\n2 \\times 48 = 96 \\text{ cookies}\n\\]\n\nThus, the number of cookies each person gets is:\n- **Alice**: 144 cookies\n- **Bob**: 192 cookies\n- **Charlie**: 96 cookies\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_0/worker_2:\nTo divide the cookies in the ratio of 3:4:2, we first need to find the total parts in the ratio. \n\nThe total parts are:\n- Alice: 3 parts\n- Bob: 4 parts\n- Charlie: 2 parts\n\nAdding these parts together gives:\n\\[ 3 + 4 + 2 = 9 \\text{ parts} \\]\n\nNext, we can determine how many cookies each part represents by dividing the total number of cookies by the total parts:\n\\[ \\text{Cookies per part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part} \\]\n\nNow we can calculate the number of cookies for each person:\n- Alice's share: \n\\[ 3 \\text{ parts} \\times 48 \\text{ cookies/part} = 144 \\text{ cookies} \\]\n- Bob's share: \n\\[ 4 \\text{ parts} \\times 48 \\text{ cookies/part} = 192 \\text{ cookies} \\]\n- Charlie's share: \n\\[ 2 \\text{ parts} \\times 48 \\text{ cookies/part} = 96 \\text{ cookies} \\]\n\nSo, the final distribution of cookies is:\n- Alice: 144 cookies\n- Bob: 192 cookies\n- Charlie: 96 cookies\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nReceived results from workers at layer 0\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nDispatch to workers at layer 1\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_1/worker_2:\nTo divide 432 cookies in the ratio of 3:4:2 among Alice, Bob, and Charlie, follow these steps:\n\n1. **Determine the total number of parts in the ratio**:\n   \\[\n   3 + 4 + 2 = 9 \\text{ parts}\n   \\]\n\n2. **Calculate the value of one part** by dividing the total number of cookies by the total number of parts:\n   \\[\n   \\text{Value of one part} = \\frac{432}{9} = 48\n   \\]\n\n3. **Calculate the number of cookies each person receives** by multiplying the value of one part by the number of parts each individual gets:\n   - **For Alice (3 parts)**:\n     \\[\n     3 \\times 48 = 144 \\text{ cookies}\n     \\]\n   - **For Bob (4 parts)**:\n     \\[\n     4 \\times 48 = 192 \\text{ cookies}\n     \\]\n   - **For Charlie (2 parts)**:\n     \\[\n     2 \\times 48 = 96 \\text{ cookies}\n     \\]\n\nThus, the final distribution of cookies is:\n- **Alice**: 144 cookies\n- **Bob**: 192 cookies\n- **Charlie**: 96 cookies\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_1/worker_0:\nTo divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, we can follow these steps:\n\n1. **Calculate the Total Parts**: \n   Add the parts of the ratio together:\n   \\[\n   3 + 4 + 2 = 9 \\text{ parts}\n   \\]\n\n2. **Determine the Value of One Part**: \n   Divide the total number of cookies by the total number of parts:\n   \\[\n   \\text{Value of one part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part}\n   \\]\n\n3. **Calculate Each Person's Share**:\n   - **Alice's Share** (3 parts):\n     \\[\n     3 \\times 48 = 144 \\text{ cookies}\n     \\]\n   - **Bob's Share** (4 parts):\n     \\[\n     4 \\times 48 = 192 \\text{ cookies}\n     \\]\n   - **Charlie's Share** (2 parts):\n     \\[\n     2 \\times 48 = 96 \\text{ cookies}\n     \\]\n\n4. **Final Distribution**:\n   - Alice: 144 cookies\n   - Bob: 192 cookies\n   - Charlie: 96 cookies\n\nThus, the distribution of cookies is:\n- **Alice**: 144 cookies\n- **Bob**: 192 cookies\n- **Charlie**: 96 cookies\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_1/worker_1:\nTo divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, we first need to determine the total number of parts in this ratio.\n\n1. **Calculate Total Parts:**\n   \\[\n   3 \\text{ (Alice)} + 4 \\text{ (Bob)} + 2 \\text{ (Charlie)} = 9 \\text{ parts}\n   \\]\n\n2. **Determine the Value of One Part:**\n   Next, we'll find out how many cookies correspond to one part by dividing the total number of cookies by the total number of parts:\n   \\[\n   \\text{Value of one part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part}\n   \\]\n\n3. **Calculate the Share for Each Person:**\n   - **Alice's Share (3 parts):**\n     \\[\n     3 \\times 48 = 144 \\text{ cookies}\n     \\]\n   - **Bob's Share (4 parts):**\n     \\[\n     4 \\times 48 = 192 \\text{ cookies}\n     \\]\n   - **Charlie’s Share (2 parts):**\n     \\[\n     2 \\times 48 = 96 \\text{ cookies}\n     \\]\n\n4. **Summary of the Distribution:**\n   - **Alice:** 144 cookies\n   - **Bob:** 192 cookies\n   - **Charlie:** 96 cookies\n\nIn conclusion, Alice receives 144 cookies, Bob receives 192 cookies, and Charlie receives 96 cookies.\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nReceived results from workers at layer 1\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nPerforming final aggregation\n--------------------------------------------------------------------------------\nFinal result:\nTo divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, follow these steps:\n\n1. **Calculate the Total Parts in the Ratio:**\n   Add the parts of the ratio together:\n   \\[\n   3 + 4 + 2 = 9\n   \\]\n\n2. **Determine the Value of One Part:**\n   Divide the total number of cookies by the total number of parts:\n   \\[\n   \\text{Value of one part} = \\frac{432}{9} = 48 \\text{ cookies/part}\n   \\]\n\n3. **Calculate Each Person's Share:**\n   - **Alice's Share (3 parts):**\n     \\[\n     3 \\times 48 = 144 \\text{ cookies}\n     \\]\n   - **Bob's Share (4 parts):**\n     \\[\n     4 \\times 48 = 192 \\text{ cookies}\n     \\]\n   - **Charlie's Share (2 parts):**\n     \\[\n     2 \\times 48 = 96 \\text{ cookies}\n     \\]\n\nTherefore, the distribution of cookies is as follows:\n- **Alice:** 144 cookies\n- **Bob:** 192 cookies\n- **Charlie:** 96 cookies\n\nIn summary, Alice gets 144 cookies, Bob gets 192 cookies, and Charlie gets 96 cookies.",
      "language": "yaml"
    },
    {
      "code": "--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nReceived task: I have 432 cookies, and divide them 3:4:2 between Alice, Bob, and Charlie. How many cookies does each person get?\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nDispatch to workers at layer 0\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_0/worker_1:\nTo divide 432 cookies in the ratio of 3:4:2 between Alice, Bob, and Charlie, you first need to determine the total number of parts in the ratio.\n\nAdd the parts together:\n\\[ 3 + 4 + 2 = 9 \\]\n\nNow, you can find the value of one part by dividing the total number of cookies by the total number of parts:\n\\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\]\n\nNow, multiply the value of one part by the number of parts for each person:\n\n- For Alice (3 parts):\n\\[ 3 \\times 48 = 144 \\]\n\n- For Bob (4 parts):\n\\[ 4 \\times 48 = 192 \\]\n\n- For Charlie (2 parts):\n\\[ 2 \\times 48 = 96 \\]\n\nThus, the number of cookies each person gets is:\n- Alice: 144 cookies\n- Bob: 192 cookies\n- Charlie: 96 cookies\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_0/worker_0:\nTo divide 432 cookies in the ratio of 3:4:2 between Alice, Bob, and Charlie, we will first determine the total number of parts in the ratio:\n\n\\[\n3 + 4 + 2 = 9 \\text{ parts}\n\\]\n\nNext, we calculate the value of one part by dividing the total number of cookies by the total number of parts:\n\n\\[\n\\text{Value of one part} = \\frac{432}{9} = 48\n\\]\n\nNow, we can find out how many cookies each person receives by multiplying the value of one part by the number of parts each person receives:\n\n- For Alice (3 parts):\n\\[\n3 \\times 48 = 144 \\text{ cookies}\n\\]\n\n- For Bob (4 parts):\n\\[\n4 \\times 48 = 192 \\text{ cookies}\n\\]\n\n- For Charlie (2 parts):\n\\[\n2 \\times 48 = 96 \\text{ cookies}\n\\]\n\nThus, the number of cookies each person gets is:\n- **Alice**: 144 cookies\n- **Bob**: 192 cookies\n- **Charlie**: 96 cookies\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_0/worker_2:\nTo divide the cookies in the ratio of 3:4:2, we first need to find the total parts in the ratio. \n\nThe total parts are:\n- Alice: 3 parts\n- Bob: 4 parts\n- Charlie: 2 parts\n\nAdding these parts together gives:\n\\[ 3 + 4 + 2 = 9 \\text{ parts} \\]\n\nNext, we can determine how many cookies each part represents by dividing the total number of cookies by the total parts:\n\\[ \\text{Cookies per part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part} \\]\n\nNow we can calculate the number of cookies for each person:\n- Alice's share: \n\\[ 3 \\text{ parts} \\times 48 \\text{ cookies/part} = 144 \\text{ cookies} \\]\n- Bob's share: \n\\[ 4 \\text{ parts} \\times 48 \\text{ cookies/part} = 192 \\text{ cookies} \\]\n- Charlie's share: \n\\[ 2 \\text{ parts} \\times 48 \\text{ cookies/part} = 96 \\text{ cookies} \\]\n\nSo, the final distribution of cookies is:\n- Alice: 144 cookies\n- Bob: 192 cookies\n- Charlie: 96 cookies\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nReceived results from workers at layer 0\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nDispatch to workers at layer 1\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_1/worker_2:\nTo divide 432 cookies in the ratio of 3:4:2 among Alice, Bob, and Charlie, follow these steps:\n\n1. **Determine the total number of parts in the ratio**:\n   \\[\n   3 + 4 + 2 = 9 \\text{ parts}\n   \\]\n\n2. **Calculate the value of one part** by dividing the total number of cookies by the total number of parts:\n   \\[\n   \\text{Value of one part} = \\frac{432}{9} = 48\n   \\]\n\n3. **Calculate the number of cookies each person receives** by multiplying the value of one part by the number of parts each individual gets:\n   - **For Alice (3 parts)**:\n     \\[\n     3 \\times 48 = 144 \\text{ cookies}\n     \\]\n   - **For Bob (4 parts)**:\n     \\[\n     4 \\times 48 = 192 \\text{ cookies}\n     \\]\n   - **For Charlie (2 parts)**:\n     \\[\n     2 \\times 48 = 96 \\text{ cookies}\n     \\]\n\nThus, the final distribution of cookies is:\n- **Alice**: 144 cookies\n- **Bob**: 192 cookies\n- **Charlie**: 96 cookies\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_1/worker_0:\nTo divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, we can follow these steps:\n\n1. **Calculate the Total Parts**: \n   Add the parts of the ratio together:\n   \\[\n   3 + 4 + 2 = 9 \\text{ parts}\n   \\]\n\n2. **Determine the Value of One Part**: \n   Divide the total number of cookies by the total number of parts:\n   \\[\n   \\text{Value of one part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part}\n   \\]\n\n3. **Calculate Each Person's Share**:\n   - **Alice's Share** (3 parts):\n     \\[\n     3 \\times 48 = 144 \\text{ cookies}\n     \\]\n   - **Bob's Share** (4 parts):\n     \\[\n     4 \\times 48 = 192 \\text{ cookies}\n     \\]\n   - **Charlie's Share** (2 parts):\n     \\[\n     2 \\times 48 = 96 \\text{ cookies}\n     \\]\n\n4. **Final Distribution**:\n   - Alice: 144 cookies\n   - Bob: 192 cookies\n   - Charlie: 96 cookies\n\nThus, the distribution of cookies is:\n- **Alice**: 144 cookies\n- **Bob**: 192 cookies\n- **Charlie**: 96 cookies\n--------------------------------------------------------------------------------\nWorker-worker:default/layer_1/worker_1:\nTo divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, we first need to determine the total number of parts in this ratio.\n\n1. **Calculate Total Parts:**\n   \\[\n   3 \\text{ (Alice)} + 4 \\text{ (Bob)} + 2 \\text{ (Charlie)} = 9 \\text{ parts}\n   \\]\n\n2. **Determine the Value of One Part:**\n   Next, we'll find out how many cookies correspond to one part by dividing the total number of cookies by the total number of parts:\n   \\[\n   \\text{Value of one part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part}\n   \\]\n\n3. **Calculate the Share for Each Person:**\n   - **Alice's Share (3 parts):**\n     \\[\n     3 \\times 48 = 144 \\text{ cookies}\n     \\]\n   - **Bob's Share (4 parts):**\n     \\[\n     4 \\times 48 = 192 \\text{ cookies}\n     \\]\n   - **Charlie’s Share (2 parts):**\n     \\[\n     2 \\times 48 = 96 \\text{ cookies}\n     \\]\n\n4. **Summary of the Distribution:**\n   - **Alice:** 144 cookies\n   - **Bob:** 192 cookies\n   - **Charlie:** 96 cookies\n\nIn conclusion, Alice receives 144 cookies, Bob receives 192 cookies, and Charlie receives 96 cookies.\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nReceived results from workers at layer 1\n--------------------------------------------------------------------------------\nOrchestrator-orchestrator:default:\nPerforming final aggregation\n--------------------------------------------------------------------------------\nFinal result:\nTo divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, follow these steps:\n\n1. **Calculate the Total Parts in the Ratio:**\n   Add the parts of the ratio together:\n   \\[\n   3 + 4 + 2 = 9\n   \\]\n\n2. **Determine the Value of One Part:**\n   Divide the total number of cookies by the total number of parts:\n   \\[\n   \\text{Value of one part} = \\frac{432}{9} = 48 \\text{ cookies/part}\n   \\]\n\n3. **Calculate Each Person's Share:**\n   - **Alice's Share (3 parts):**\n     \\[\n     3 \\times 48 = 144 \\text{ cookies}\n     \\]\n   - **Bob's Share (4 parts):**\n     \\[\n     4 \\times 48 = 192 \\text{ cookies}\n     \\]\n   - **Charlie's Share (2 parts):**\n     \\[\n     2 \\times 48 = 96 \\text{ cookies}\n     \\]\n\nTherefore, the distribution of cookies is as follows:\n- **Alice:** 144 cookies\n- **Bob:** 192 cookies\n- **Charlie:** 96 cookies\n\nIn summary, Alice gets 144 cookies, Bob gets 192 cookies, and Charlie gets 96 cookies.",
      "language": "yaml"
    }
  ],
  "patterns": [
    {
      "description": "Core Mixture of Agents Mixture of Agents# Mixture of Agents is a multi-agent design pattern that models after the feed-forward neural network architecture. The pattern consists of two types of agents: worker agents and a single orchestrator agent. Worker agents are organized into multiple layers, with each layer consisting of a fixed number of worker agents. Messages from the worker agents in a previous layer are concatenated and sent to all the worker agents in the next layer. This example implements the Mixture of Agents pattern using the core library following the original implementation of multi-layer mixture of agents. Here is a high-level procedure overview of the pattern: The orchestrator agent takes input a user task and first dispatches it to the worker agents in the first layer. The worker agents in the first layer process the task and return the results to the orchestrator agent. The orchestrator agent then synthesizes the results from the first layer and dispatches an updated task with the previous results to the worker agents in the second layer. The process continues until the final layer is reached. In the final layer, the orchestrator agent aggregates the results from previous layer and returns a single final result to the user. We use the direct messaging API send_message() to implement this pattern. This makes it easier to add more features like worker task cancellation and error handling in the future. import asyncio from dataclasses import dataclass from typing import List from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler from autogen_core.models import ChatCompletionClient, SystemMessage, UserMessage from autogen_ext.models.openai import OpenAIChatCompletionClient Message Protocol# The agents communicate using the following messages: @dataclass class WorkerTask: task: str previous_results: List[str] @dataclass class WorkerTaskResult: result: str @dataclass class UserTask: task: str @dataclass class FinalResult: result: str Worker Agent# Each worker agent receives a task from the orchestrator agent and processes them indepedently. Once the task is completed, the worker agent returns the result. class WorkerAgent(RoutedAgent): def __init__( self, model_client: ChatCompletionClient, ) -> None: super().__init__(description=\"Worker Agent\") self._model_client = model_client @message_handler async def handle_task(self, message: WorkerTask, ctx: MessageContext) -> WorkerTaskResult: if message.previous_results: # If previous results are provided, we need to synthesize them to create a single prompt. system_prompt = \"You have been provided with a set of responses from various open-source models to the latest user query. Your task is to synthesize these responses into a single, high-quality response. It is crucial to critically evaluate the information provided in these responses, recognizing that some of it may be biased or incorrect. Your response should not simply replicate the given answers but should offer a refined, accurate, and comprehensive reply to the instruction. Ensure your response is well-structured, coherent, and adheres to the highest standards of accuracy and reliability.\\n\\nResponses from models:\" system_prompt += \"\\n\" + \"\\n\\n\".join([f\"{i+1}. {r}\" for i, r in enumerate(message.previous_results)]) model_result = await self._model_client.create( [SystemMessage(content=system_prompt), UserMessage(content=message.task, source=\"user\")] ) else: # If no previous results are provided, we can simply pass the user query to the model. model_result = await self._model_client.create([UserMessage(content=message.task, source=\"user\")]) assert isinstance(model_result.content, str) print(f\"{'-'*80}\\nWorker-{self.id}:\\n{model_result.content}\") return WorkerTaskResult(result=model_result.content) Orchestrator Agent# The orchestrator agent receives tasks from the user and distributes them to the worker agents, iterating over multiple layers of worker agents. Once all worker agents have processed the task, the orchestrator agent aggregates the results and publishes the final result. class OrchestratorAgent(RoutedAgent): def __init__( self, model_client: ChatCompletionClient, worker_agent_types: List[str], num_layers: int, ) -> None: super().__init__(description=\"Aggregator Agent\") self._model_client = model_client self._worker_agent_types = worker_agent_types self._num_layers = num_layers @message_handler async def handle_task(self, message: UserTask, ctx: MessageContext) -> FinalResult: print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nReceived task: {message.task}\") # Create task for the first layer. worker_task = WorkerTask(task=message.task, previous_results=[]) # Iterate over layers. for i in range(self._num_layers - 1): # Assign workers for this layer. worker_ids = [ AgentId(worker_type, f\"{self.id.key}/layer_{i}/worker_{j}\") for j, worker_type in enumerate(self._worker_agent_types) ] # Dispatch tasks to workers. print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nDispatch to workers at layer {i}\") results = await asyncio.gather(*[self.send_message(worker_task, worker_id) for worker_id in worker_ids]) print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nReceived results from workers at layer {i}\") # Prepare task for the next layer. worker_task = WorkerTask(task=message.task, previous_results=[r.result for r in results]) # Perform final aggregation. print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nPerforming final aggregation\") system_prompt = \"You have been provided with a set of responses from various open-source models to the latest user query. Your task is to synthesize these responses into a single, high-quality response. It is crucial to critically evaluate the information provided in these responses, recognizing that some of it may be biased or incorrect. Your response should not simply replicate the given answers but should offer a refined, accurate, and comprehensive reply to the instruction. Ensure your response is well-structured, coherent, and adheres to the highest standards of accuracy and reliability.\\n\\nResponses from models:\" system_prompt += \"\\n\" + \"\\n\\n\".join([f\"{i+1}. {r}\" for i, r in enumerate(worker_task.previous_results)]) model_result = await self._model_client.create( [SystemMessage(content=system_prompt), UserMessage(content=message.task, source=\"user\")] ) assert isinstance(model_result.content, str) return FinalResult(result=model_result.content) Running Mixture of Agents# Let’s run the mixture of agents on a math task. You can change the task to make it more challenging, for example, by trying tasks from the International Mathematical Olympiad. task = ( \"I have 432 cookies, and divide them 3:4:2 between Alice, Bob, and Charlie. How many cookies does each person get?\" ) Let’s set up the runtime with 3 layers of worker agents, each layer consisting of 3 worker agents. We only need to register a single worker agent types, “worker”, because we are using the same model client configuration (i.e., gpt-4o-mini) for all worker agents. If you want to use different models, you will need to register multiple worker agent types, one for each model, and update the worker_agent_types list in the orchestrator agent’s factory function. The instances of worker agents are automatically created when the orchestrator agent dispatches tasks to them. See Agent Identity and Lifecycle for more information on agent lifecycle. runtime = SingleThreadedAgentRuntime() model_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\") await WorkerAgent.register(runtime, \"worker\", lambda: WorkerAgent(model_client=model_client)) await OrchestratorAgent.register( runtime, \"orchestrator\", lambda: OrchestratorAgent(model_client=model_client, worker_agent_types=[\"worker\"] * 3, num_layers=3), ) runtime.start() result = await runtime.send_message(UserTask(task=task), AgentId(\"orchestrator\", \"default\")) await runtime.stop_when_idle() await model_client.close() print(f\"{'-'*80}\\nFinal result:\\n{result.result}\") -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Received task: I have 432 cookies, and divide them 3:4:2 between Alice, Bob, and Charlie. How many cookies does each person get? -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Dispatch to workers at layer 0 -------------------------------------------------------------------------------- Worker-worker:default/layer_0/worker_1: To divide 432 cookies in the ratio of 3:4:2 between Alice, Bob, and Charlie, you first need to determine the total number of parts in the ratio. Add the parts together: \\[ 3 + 4 + 2 = 9 \\] Now, you can find the value of one part by dividing the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\] Now, multiply the value of one part by the number of parts for each person: - For Alice (3 parts): \\[ 3 \\times 48 = 144 \\] - For Bob (4 parts): \\[ 4 \\times 48 = 192 \\] - For Charlie (2 parts): \\[ 2 \\times 48 = 96 \\] Thus, the number of cookies each person gets is: - Alice: 144 cookies - Bob: 192 cookies - Charlie: 96 cookies -------------------------------------------------------------------------------- Worker-worker:default/layer_0/worker_0: To divide 432 cookies in the ratio of 3:4:2 between Alice, Bob, and Charlie, we will first determine the total number of parts in the ratio: \\[ 3 + 4 + 2 = 9 \\text{ parts} \\] Next, we calculate the value of one part by dividing the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\] Now, we can find out how many cookies each person receives by multiplying the value of one part by the number of parts each person receives: - For Alice (3 parts): \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - For Bob (4 parts): \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - For Charlie (2 parts): \\[ 2 \\times 48 = 96 \\text{ cookies} \\] Thus, the number of cookies each person gets is: - **Alice**: 144 cookies - **Bob**: 192 cookies - **Charlie**: 96 cookies -------------------------------------------------------------------------------- Worker-worker:default/layer_0/worker_2: To divide the cookies in the ratio of 3:4:2, we first need to find the total parts in the ratio. The total parts are: - Alice: 3 parts - Bob: 4 parts - Charlie: 2 parts Adding these parts together gives: \\[ 3 + 4 + 2 = 9 \\text{ parts} \\] Next, we can determine how many cookies each part represents by dividing the total number of cookies by the total parts: \\[ \\text{Cookies per part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part} \\] Now we can calculate the number of cookies for each person: - Alice's share: \\[ 3 \\text{ parts} \\times 48 \\text{ cookies/part} = 144 \\text{ cookies} \\] - Bob's share: \\[ 4 \\text{ parts} \\times 48 \\text{ cookies/part} = 192 \\text{ cookies} \\] - Charlie's share: \\[ 2 \\text{ parts} \\times 48 \\text{ cookies/part} = 96 \\text{ cookies} \\] So, the final distribution of cookies is: - Alice: 144 cookies - Bob: 192 cookies - Charlie: 96 cookies -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Received results from workers at layer 0 -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Dispatch to workers at layer 1 -------------------------------------------------------------------------------- Worker-worker:default/layer_1/worker_2: To divide 432 cookies in the ratio of 3:4:2 among Alice, Bob, and Charlie, follow these steps: 1. **Determine the total number of parts in the ratio**: \\[ 3 + 4 + 2 = 9 \\text{ parts} \\] 2. **Calculate the value of one part** by dividing the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\] 3. **Calculate the number of cookies each person receives** by multiplying the value of one part by the number of parts each individual gets: - **For Alice (3 parts)**: \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - **For Bob (4 parts)**: \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - **For Charlie (2 parts)**: \\[ 2 \\times 48 = 96 \\text{ cookies} \\] Thus, the final distribution of cookies is: - **Alice**: 144 cookies - **Bob**: 192 cookies - **Charlie**: 96 cookies -------------------------------------------------------------------------------- Worker-worker:default/layer_1/worker_0: To divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, we can follow these steps: 1. **Calculate the Total Parts**: Add the parts of the ratio together: \\[ 3 + 4 + 2 = 9 \\text{ parts} \\] 2. **Determine the Value of One Part**: Divide the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part} \\] 3. **Calculate Each Person's Share**: - **Alice's Share** (3 parts): \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - **Bob's Share** (4 parts): \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - **Charlie's Share** (2 parts): \\[ 2 \\times 48 = 96 \\text{ cookies} \\] 4. **Final Distribution**: - Alice: 144 cookies - Bob: 192 cookies - Charlie: 96 cookies Thus, the distribution of cookies is: - **Alice**: 144 cookies - **Bob**: 192 cookies - **Charlie**: 96 cookies -------------------------------------------------------------------------------- Worker-worker:default/layer_1/worker_1: To divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, we first need to determine the total number of parts in this ratio. 1. **Calculate Total Parts:** \\[ 3 \\text{ (Alice)} + 4 \\text{ (Bob)} + 2 \\text{ (Charlie)} = 9 \\text{ parts} \\] 2. **Determine the Value of One Part:** Next, we'll find out how many cookies correspond to one part by dividing the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part} \\] 3. **Calculate the Share for Each Person:** - **Alice's Share (3 parts):** \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - **Bob's Share (4 parts):** \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - **Charlie’s Share (2 parts):** \\[ 2 \\times 48 = 96 \\text{ cookies} \\] 4. **Summary of the Distribution:** - **Alice:** 144 cookies - **Bob:** 192 cookies - **Charlie:** 96 cookies In conclusion, Alice receives 144 cookies, Bob receives 192 cookies, and Charlie receives 96 cookies. -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Received results from workers at layer 1 -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Performing final aggregation -------------------------------------------------------------------------------- Final result: To divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, follow these steps: 1. **Calculate the Total Parts in the Ratio:** Add the parts of the ratio together: \\[ 3 + 4 + 2 = 9 \\] 2. **Determine the Value of One Part:** Divide the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\text{ cookies/part} \\] 3. **Calculate Each Person's Share:** - **Alice's Share (3 parts):** \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - **Bob's Share (4 parts):** \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - **Charlie's Share (2 parts):** \\[ 2 \\times 48 = 96 \\text{ cookies} \\] Therefore, the distribution of cookies is as follows: - **Alice:** 144 cookies - **Bob:** 192 cookies - **Charlie:** 96 cookies In summary, Alice gets 144 cookies, Bob gets 192 cookies, and Charlie gets 96 cookies. previous Handoffs next Multi-Agent Debate On this page Message Protocol Worker Agent Orchestrator Agent Running Mixture of Agents Edit on GitHub Show Source",
      "code": "send_message()"
    },
    {
      "description": "Core Mixture of Agents Mixture of Agents# Mixture of Agents is a multi-agent design pattern that models after the feed-forward neural network architecture. The pattern consists of two types of agents: worker agents and a single orchestrator agent. Worker agents are organized into multiple layers, with each layer consisting of a fixed number of worker agents. Messages from the worker agents in a previous layer are concatenated and sent to all the worker agents in the next layer. This example implements the Mixture of Agents pattern using the core library following the original implementation of multi-layer mixture of agents. Here is a high-level procedure overview of the pattern: The orchestrator agent takes input a user task and first dispatches it to the worker agents in the first layer. The worker agents in the first layer process the task and return the results to the orchestrator agent. The orchestrator agent then synthesizes the results from the first layer and dispatches an updated task with the previous results to the worker agents in the second layer. The process continues until the final layer is reached. In the final layer, the orchestrator agent aggregates the results from previous layer and returns a single final result to the user. We use the direct messaging API send_message() to implement this pattern. This makes it easier to add more features like worker task cancellation and error handling in the future. import asyncio from dataclasses import dataclass from typing import List from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler from autogen_core.models import ChatCompletionClient, SystemMessage, UserMessage from autogen_ext.models.openai import OpenAIChatCompletionClient Message Protocol# The agents communicate using the following messages: @dataclass class WorkerTask: task: str previous_results: List[str] @dataclass class WorkerTaskResult: result: str @dataclass class UserTask: task: str @dataclass class FinalResult: result: str Worker Agent# Each worker agent receives a task from the orchestrator agent and processes them indepedently. Once the task is completed, the worker agent returns the result. class WorkerAgent(RoutedAgent): def __init__( self, model_client: ChatCompletionClient, ) -> None: super().__init__(description=\"Worker Agent\") self._model_client = model_client @message_handler async def handle_task(self, message: WorkerTask, ctx: MessageContext) -> WorkerTaskResult: if message.previous_results: # If previous results are provided, we need to synthesize them to create a single prompt. system_prompt = \"You have been provided with a set of responses from various open-source models to the latest user query. Your task is to synthesize these responses into a single, high-quality response. It is crucial to critically evaluate the information provided in these responses, recognizing that some of it may be biased or incorrect. Your response should not simply replicate the given answers but should offer a refined, accurate, and comprehensive reply to the instruction. Ensure your response is well-structured, coherent, and adheres to the highest standards of accuracy and reliability.\\n\\nResponses from models:\" system_prompt += \"\\n\" + \"\\n\\n\".join([f\"{i+1}. {r}\" for i, r in enumerate(message.previous_results)]) model_result = await self._model_client.create( [SystemMessage(content=system_prompt), UserMessage(content=message.task, source=\"user\")] ) else: # If no previous results are provided, we can simply pass the user query to the model. model_result = await self._model_client.create([UserMessage(content=message.task, source=\"user\")]) assert isinstance(model_result.content, str) print(f\"{'-'*80}\\nWorker-{self.id}:\\n{model_result.content}\") return WorkerTaskResult(result=model_result.content) Orchestrator Agent# The orchestrator agent receives tasks from the user and distributes them to the worker agents, iterating over multiple layers of worker agents. Once all worker agents have processed the task, the orchestrator agent aggregates the results and publishes the final result. class OrchestratorAgent(RoutedAgent): def __init__( self, model_client: ChatCompletionClient, worker_agent_types: List[str], num_layers: int, ) -> None: super().__init__(description=\"Aggregator Agent\") self._model_client = model_client self._worker_agent_types = worker_agent_types self._num_layers = num_layers @message_handler async def handle_task(self, message: UserTask, ctx: MessageContext) -> FinalResult: print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nReceived task: {message.task}\") # Create task for the first layer. worker_task = WorkerTask(task=message.task, previous_results=[]) # Iterate over layers. for i in range(self._num_layers - 1): # Assign workers for this layer. worker_ids = [ AgentId(worker_type, f\"{self.id.key}/layer_{i}/worker_{j}\") for j, worker_type in enumerate(self._worker_agent_types) ] # Dispatch tasks to workers. print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nDispatch to workers at layer {i}\") results = await asyncio.gather(*[self.send_message(worker_task, worker_id) for worker_id in worker_ids]) print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nReceived results from workers at layer {i}\") # Prepare task for the next layer. worker_task = WorkerTask(task=message.task, previous_results=[r.result for r in results]) # Perform final aggregation. print(f\"{'-'*80}\\nOrchestrator-{self.id}:\\nPerforming final aggregation\") system_prompt = \"You have been provided with a set of responses from various open-source models to the latest user query. Your task is to synthesize these responses into a single, high-quality response. It is crucial to critically evaluate the information provided in these responses, recognizing that some of it may be biased or incorrect. Your response should not simply replicate the given answers but should offer a refined, accurate, and comprehensive reply to the instruction. Ensure your response is well-structured, coherent, and adheres to the highest standards of accuracy and reliability.\\n\\nResponses from models:\" system_prompt += \"\\n\" + \"\\n\\n\".join([f\"{i+1}. {r}\" for i, r in enumerate(worker_task.previous_results)]) model_result = await self._model_client.create( [SystemMessage(content=system_prompt), UserMessage(content=message.task, source=\"user\")] ) assert isinstance(model_result.content, str) return FinalResult(result=model_result.content) Running Mixture of Agents# Let’s run the mixture of agents on a math task. You can change the task to make it more challenging, for example, by trying tasks from the International Mathematical Olympiad. task = ( \"I have 432 cookies, and divide them 3:4:2 between Alice, Bob, and Charlie. How many cookies does each person get?\" ) Let’s set up the runtime with 3 layers of worker agents, each layer consisting of 3 worker agents. We only need to register a single worker agent types, “worker”, because we are using the same model client configuration (i.e., gpt-4o-mini) for all worker agents. If you want to use different models, you will need to register multiple worker agent types, one for each model, and update the worker_agent_types list in the orchestrator agent’s factory function. The instances of worker agents are automatically created when the orchestrator agent dispatches tasks to them. See Agent Identity and Lifecycle for more information on agent lifecycle. runtime = SingleThreadedAgentRuntime() model_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\") await WorkerAgent.register(runtime, \"worker\", lambda: WorkerAgent(model_client=model_client)) await OrchestratorAgent.register( runtime, \"orchestrator\", lambda: OrchestratorAgent(model_client=model_client, worker_agent_types=[\"worker\"] * 3, num_layers=3), ) runtime.start() result = await runtime.send_message(UserTask(task=task), AgentId(\"orchestrator\", \"default\")) await runtime.stop_when_idle() await model_client.close() print(f\"{'-'*80}\\nFinal result:\\n{result.result}\") -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Received task: I have 432 cookies, and divide them 3:4:2 between Alice, Bob, and Charlie. How many cookies does each person get? -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Dispatch to workers at layer 0 -------------------------------------------------------------------------------- Worker-worker:default/layer_0/worker_1: To divide 432 cookies in the ratio of 3:4:2 between Alice, Bob, and Charlie, you first need to determine the total number of parts in the ratio. Add the parts together: \\[ 3 + 4 + 2 = 9 \\] Now, you can find the value of one part by dividing the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\] Now, multiply the value of one part by the number of parts for each person: - For Alice (3 parts): \\[ 3 \\times 48 = 144 \\] - For Bob (4 parts): \\[ 4 \\times 48 = 192 \\] - For Charlie (2 parts): \\[ 2 \\times 48 = 96 \\] Thus, the number of cookies each person gets is: - Alice: 144 cookies - Bob: 192 cookies - Charlie: 96 cookies -------------------------------------------------------------------------------- Worker-worker:default/layer_0/worker_0: To divide 432 cookies in the ratio of 3:4:2 between Alice, Bob, and Charlie, we will first determine the total number of parts in the ratio: \\[ 3 + 4 + 2 = 9 \\text{ parts} \\] Next, we calculate the value of one part by dividing the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\] Now, we can find out how many cookies each person receives by multiplying the value of one part by the number of parts each person receives: - For Alice (3 parts): \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - For Bob (4 parts): \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - For Charlie (2 parts): \\[ 2 \\times 48 = 96 \\text{ cookies} \\] Thus, the number of cookies each person gets is: - **Alice**: 144 cookies - **Bob**: 192 cookies - **Charlie**: 96 cookies -------------------------------------------------------------------------------- Worker-worker:default/layer_0/worker_2: To divide the cookies in the ratio of 3:4:2, we first need to find the total parts in the ratio. The total parts are: - Alice: 3 parts - Bob: 4 parts - Charlie: 2 parts Adding these parts together gives: \\[ 3 + 4 + 2 = 9 \\text{ parts} \\] Next, we can determine how many cookies each part represents by dividing the total number of cookies by the total parts: \\[ \\text{Cookies per part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part} \\] Now we can calculate the number of cookies for each person: - Alice's share: \\[ 3 \\text{ parts} \\times 48 \\text{ cookies/part} = 144 \\text{ cookies} \\] - Bob's share: \\[ 4 \\text{ parts} \\times 48 \\text{ cookies/part} = 192 \\text{ cookies} \\] - Charlie's share: \\[ 2 \\text{ parts} \\times 48 \\text{ cookies/part} = 96 \\text{ cookies} \\] So, the final distribution of cookies is: - Alice: 144 cookies - Bob: 192 cookies - Charlie: 96 cookies -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Received results from workers at layer 0 -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Dispatch to workers at layer 1 -------------------------------------------------------------------------------- Worker-worker:default/layer_1/worker_2: To divide 432 cookies in the ratio of 3:4:2 among Alice, Bob, and Charlie, follow these steps: 1. **Determine the total number of parts in the ratio**: \\[ 3 + 4 + 2 = 9 \\text{ parts} \\] 2. **Calculate the value of one part** by dividing the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\] 3. **Calculate the number of cookies each person receives** by multiplying the value of one part by the number of parts each individual gets: - **For Alice (3 parts)**: \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - **For Bob (4 parts)**: \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - **For Charlie (2 parts)**: \\[ 2 \\times 48 = 96 \\text{ cookies} \\] Thus, the final distribution of cookies is: - **Alice**: 144 cookies - **Bob**: 192 cookies - **Charlie**: 96 cookies -------------------------------------------------------------------------------- Worker-worker:default/layer_1/worker_0: To divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, we can follow these steps: 1. **Calculate the Total Parts**: Add the parts of the ratio together: \\[ 3 + 4 + 2 = 9 \\text{ parts} \\] 2. **Determine the Value of One Part**: Divide the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part} \\] 3. **Calculate Each Person's Share**: - **Alice's Share** (3 parts): \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - **Bob's Share** (4 parts): \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - **Charlie's Share** (2 parts): \\[ 2 \\times 48 = 96 \\text{ cookies} \\] 4. **Final Distribution**: - Alice: 144 cookies - Bob: 192 cookies - Charlie: 96 cookies Thus, the distribution of cookies is: - **Alice**: 144 cookies - **Bob**: 192 cookies - **Charlie**: 96 cookies -------------------------------------------------------------------------------- Worker-worker:default/layer_1/worker_1: To divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, we first need to determine the total number of parts in this ratio. 1. **Calculate Total Parts:** \\[ 3 \\text{ (Alice)} + 4 \\text{ (Bob)} + 2 \\text{ (Charlie)} = 9 \\text{ parts} \\] 2. **Determine the Value of One Part:** Next, we'll find out how many cookies correspond to one part by dividing the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432 \\text{ cookies}}{9 \\text{ parts}} = 48 \\text{ cookies/part} \\] 3. **Calculate the Share for Each Person:** - **Alice's Share (3 parts):** \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - **Bob's Share (4 parts):** \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - **Charlie’s Share (2 parts):** \\[ 2 \\times 48 = 96 \\text{ cookies} \\] 4. **Summary of the Distribution:** - **Alice:** 144 cookies - **Bob:** 192 cookies - **Charlie:** 96 cookies In conclusion, Alice receives 144 cookies, Bob receives 192 cookies, and Charlie receives 96 cookies. -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Received results from workers at layer 1 -------------------------------------------------------------------------------- Orchestrator-orchestrator:default: Performing final aggregation -------------------------------------------------------------------------------- Final result: To divide 432 cookies among Alice, Bob, and Charlie in the ratio of 3:4:2, follow these steps: 1. **Calculate the Total Parts in the Ratio:** Add the parts of the ratio together: \\[ 3 + 4 + 2 = 9 \\] 2. **Determine the Value of One Part:** Divide the total number of cookies by the total number of parts: \\[ \\text{Value of one part} = \\frac{432}{9} = 48 \\text{ cookies/part} \\] 3. **Calculate Each Person's Share:** - **Alice's Share (3 parts):** \\[ 3 \\times 48 = 144 \\text{ cookies} \\] - **Bob's Share (4 parts):** \\[ 4 \\times 48 = 192 \\text{ cookies} \\] - **Charlie's Share (2 parts):** \\[ 2 \\times 48 = 96 \\text{ cookies} \\] Therefore, the distribution of cookies is as follows: - **Alice:** 144 cookies - **Bob:** 192 cookies - **Charlie:** 96 cookies In summary, Alice gets 144 cookies, Bob gets 192 cookies, and Charlie gets 96 cookies. previous Handoffs next Multi-Agent Debate",
      "code": "send_message()"
    },
    {
      "description": "Here is a high-level procedure overview of the pattern:",
      "code": "send_message()"
    }
  ],
  "links": [
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/mixture-of-agents.html",
    "https://microsoft.github.io/autogen/stable/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/extensions-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/autogenstudio-user-guide/index.html",
    "https://microsoft.github.io/autogen/stable/reference/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/installation.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/quickstart.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-and-multi-agent-application.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/architecture.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/application-stack.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/agent-identity-and-lifecycle.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/core-concepts/topic-and-subscription.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/agent-and-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/message-and-communication.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/logging.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/telemetry.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/distributed-agent-runtime.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/framework/component-config.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-clients.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/model-context.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/tools.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/workbench.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/components/command-line-code-executors.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/intro.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/concurrent-agents.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/sequential-workflow.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/group-chat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/handoffs.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/multi-agent-debate.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/reflection.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/design-patterns/code-execution-groupchat.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/index.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/azure-openai-with-aad-auth.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/termination-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/tool-use-with-intervention.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/extracting-results-with-an-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/openai-assistant-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/langgraph-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llamaindex-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/local-llms-ollama-litellm.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/instrumenting.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/topic-subscription-scenarios.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/structured-output-agent.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/cookbook/llm-usage-logger.html",
    "https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/faqs.html",
    "https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html"
  ]
}