{
  "url": "https://react.dev/reference/react/useSyncExternalStore",
  "title": "useSyncExternalStore",
  "content": "useSyncExternalStore is a React Hook that lets you subscribe to an external store.\n\nCall useSyncExternalStore at the top level of your component to read a value from an external data store.\n\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n\nSee more examples below.\n\nsubscribe: A function that takes a single callback argument and subscribes it to the store. When the store changes, it should invoke the provided callback, which will cause React to re-call getSnapshot and (if needed) re-render the component. The subscribe function should return a function that cleans up the subscription.\n\ngetSnapshot: A function that returns a snapshot of the data in the store that‚Äôs needed by the component. While the store has not changed, repeated calls to getSnapshot must return the same value. If the store changes and the returned value is different (as compared by Object.is), React re-renders the component.\n\noptional getServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.\n\nThe current snapshot of the store which you can use in your rendering logic.\n\nThe store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.\n\nIf a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component.\n\nIf the store is mutated during a non-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call getSnapshot a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.\n\nIt‚Äôs not recommended to suspend a render based on a store value returned by useSyncExternalStore. The reason is that mutations to the external store cannot be marked as non-blocking Transition updates, so they will trigger the nearest Suspense fallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.\n\nFor example, the following are discouraged:\n\nMost of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:\n\nCall useSyncExternalStore at the top level of your component to read a value from an external data store.\n\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n\nReact will use these functions to keep your component subscribed to the store and re-render it on changes.\n\nFor example, in the sandbox below, todosStore is implemented as an external store that stores data outside of React. The TodosApp component connects to that external store with the useSyncExternalStore Hook.\n\nWhen possible, we recommend using built-in React state with useState and useReducer instead. The useSyncExternalStore API is mostly useful if you need to integrate with existing non-React code.\n\nAnother reason to add useSyncExternalStore is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called navigator.onLine.\n\nThis value can change without React‚Äôs knowledge, so you should read it with useSyncExternalStore.\n\nTo implement the getSnapshot function, read the current value from the browser API:\n\nNext, you need to implement the subscribe function. For example, when navigator.onLine changes, the browser fires the online and offline events on the window object. You need to subscribe the callback argument to the corresponding events, and then return a function that cleans up the subscriptions:\n\nNow React knows how to read the value from the external navigator.onLine API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:\n\nUsually you won‚Äôt write useSyncExternalStore directly in your components. Instead, you‚Äôll typically call it from your own custom Hook. This lets you use the same external store from different components.\n\nFor example, this custom useOnlineStatus Hook tracks whether the network is online:\n\nNow different components can call useOnlineStatus without repeating the underlying implementation:\n\nIf your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:\n\nTo solve these issues, pass a getServerSnapshot function as the third argument to useSyncExternalStore:\n\nThe getServerSnapshot function is similar to getSnapshot, but it runs only in two situations:\n\nThis lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client.\n\nMake sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a <script> tag during server rendering that sets a global like window.MY_STORE_DATA, and read from that global on the client in getServerSnapshot. Your external store should provide instructions on how to do that.\n\nThis error means your getSnapshot function returns a new object every time it‚Äôs called, for example:\n\nReact will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.\n\nYour getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:\n\nIf your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn‚Äôt do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store.\n\nThis subscribe function is defined inside a component so it is different on every re-render:\n\nReact will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you‚Äôd like to avoid resubscribing, move the subscribe function outside:\n\nAlternatively, wrap subscribe into useCallback to only resubscribe when some argument changes:",
  "headings": [
    {
      "level": "h1",
      "text": "useSyncExternalStore",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Reference",
      "id": "reference"
    },
    {
      "level": "h3",
      "text": "useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
      "id": "usesyncexternalstore"
    },
    {
      "level": "h4",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h4",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h4",
      "text": "Caveats",
      "id": "caveats"
    },
    {
      "level": "h2",
      "text": "Usage",
      "id": "usage"
    },
    {
      "level": "h3",
      "text": "Subscribing to an external store",
      "id": "subscribing-to-an-external-store"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subscribing to a browser API",
      "id": "subscribing-to-a-browser-api"
    },
    {
      "level": "h3",
      "text": "Extracting the logic to a custom Hook",
      "id": "extracting-the-logic-to-a-custom-hook"
    },
    {
      "level": "h3",
      "text": "Adding support for server rendering",
      "id": "adding-support-for-server-rendering"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h3",
      "text": "I‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù",
      "id": "im-getting-an-error-the-result-of-getsnapshot-should-be-cached"
    },
    {
      "level": "h3",
      "text": "My subscribe function gets called after every re-render",
      "id": "my-subscribe-function-gets-called-after-every-re-render"
    }
  ],
  "code_samples": [
    {
      "code": "const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
      "language": "javascript"
    },
    {
      "code": "import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() {  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);  // ...}",
      "language": "javascript"
    },
    {
      "code": "const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() {  const selectedProductId = useSyncExternalStore(...);  // ‚ùå Calling `use` with a Promise dependent on `selectedProductId`  const data = use(fetchItem(selectedProductId))  // ‚ùå Conditionally rendering a lazy component based on `selectedProductId`  return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;}",
      "language": "jsx"
    },
    {
      "code": "import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() {  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);  // ...}",
      "language": "javascript"
    },
    {
      "code": "import { useSyncExternalStore } from 'react';function ChatIndicator() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}",
      "language": "javascript"
    },
    {
      "code": "function getSnapshot() {  return navigator.onLine;}",
      "language": "javascript"
    },
    {
      "code": "function subscribe(callback) {  window.addEventListener('online', callback);  window.addEventListener('offline', callback);  return () => {    window.removeEventListener('online', callback);    window.removeEventListener('offline', callback);  };}",
      "language": "javascript"
    },
    {
      "code": "import { useSyncExternalStore } from 'react';export function useOnlineStatus() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);  return isOnline;}function getSnapshot() {  // ...}function subscribe(callback) {  // ...}",
      "language": "javascript"
    },
    {
      "code": "import { useSyncExternalStore } from 'react';export function useOnlineStatus() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);  return isOnline;}function getSnapshot() {  return navigator.onLine;}function getServerSnapshot() {  return true; // Always show \"Online\" for server-generated HTML}function subscribe(callback) {  // ...}",
      "language": "javascript"
    },
    {
      "code": "function getSnapshot() {  // üî¥ Do not return always different objects from getSnapshot  return {    todos: myStore.todos  };}",
      "language": "javascript"
    },
    {
      "code": "function getSnapshot() {  // ‚úÖ You can return immutable data  return myStore.todos;}",
      "language": "javascript"
    },
    {
      "code": "function ChatIndicator() {  // üö© Always a different function, so React will resubscribe on every re-render  function subscribe() {    // ...  }    const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}",
      "language": "javascript"
    },
    {
      "code": "// ‚úÖ Always the same function, so React won't need to resubscribefunction subscribe() {  // ...}function ChatIndicator() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}",
      "language": "javascript"
    },
    {
      "code": "function ChatIndicator({ userId }) {  // ‚úÖ Same function as long as userId doesn't change  const subscribe = useCallback(() => {    // ...  }, [userId]);    const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}",
      "language": "javascript"
    }
  ],
  "patterns": [
    {
      "description": "API ReferenceHooksuseSyncExternalStoreuseSyncExternalStore is a React Hook that lets you subscribe to an external store.const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Reference useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Usage Subscribing to an external store Subscribing to a browser API Extracting the logic to a custom Hook Adding support for server rendering Troubleshooting I‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù My subscribe function gets called after every re-render Reference useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Call useSyncExternalStore at the top level of your component to read a value from an external data store. import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); // ...} It returns the snapshot of the data in the store. You need to pass two functions as arguments: The subscribe function should subscribe to the store and return a function that unsubscribes. The getSnapshot function should read a snapshot of the data from the store. See more examples below. Parameters subscribe: A function that takes a single callback argument and subscribes it to the store. When the store changes, it should invoke the provided callback, which will cause React to re-call getSnapshot and (if needed) re-render the component. The subscribe function should return a function that cleans up the subscription. getSnapshot: A function that returns a snapshot of the data in the store that‚Äôs needed by the component. While the store has not changed, repeated calls to getSnapshot must return the same value. If the store changes and the returned value is different (as compared by Object.is), React re-renders the component. optional getServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error. Returns The current snapshot of the store which you can use in your rendering logic. Caveats The store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot. If a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component. If the store is mutated during a non-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call getSnapshot a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store. It‚Äôs not recommended to suspend a render based on a store value returned by useSyncExternalStore. The reason is that mutations to the external store cannot be marked as non-blocking Transition updates, so they will trigger the nearest Suspense fallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX. For example, the following are discouraged: const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() { const selectedProductId = useSyncExternalStore(...); // ‚ùå Calling `use` with a Promise dependent on `selectedProductId` const data = use(fetchItem(selectedProductId)) // ‚ùå Conditionally rendering a lazy component based on `selectedProductId` return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;} Usage Subscribing to an external store Most of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes: Third-party state management libraries that hold state outside of React. Browser APIs that expose a mutable value and events to subscribe to its changes. Call useSyncExternalStore at the top level of your component to read a value from an external data store. import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); // ...} It returns the snapshot of the data in the store. You need to pass two functions as arguments: The subscribe function should subscribe to the store and return a function that unsubscribes. The getSnapshot function should read a snapshot of the data from the store. React will use these functions to keep your component subscribed to the store and re-render it on changes. For example, in the sandbox below, todosStore is implemented as an external store that stores data outside of React. The TodosApp component connects to that external store with the useSyncExternalStore Hook. App.jstodoStore.jsApp.jsReloadClearForkimport { useSyncExternalStore } from 'react'; import { todosStore } from './todoStore.js'; export default function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); return ( <> <button onClick={() => todosStore.addTodo()}>Add todo</button> <hr /> <ul> {todos.map(todo => ( <li key={todo.id}>{todo.text}</li> ))} </ul> </> ); } Show more NoteWhen possible, we recommend using built-in React state with useState and useReducer instead. The useSyncExternalStore API is mostly useful if you need to integrate with existing non-React code. Subscribing to a browser API Another reason to add useSyncExternalStore is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called navigator.onLine. This value can change without React‚Äôs knowledge, so you should read it with useSyncExternalStore. import { useSyncExternalStore } from 'react';function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} To implement the getSnapshot function, read the current value from the browser API: function getSnapshot() { return navigator.onLine;} Next, you need to implement the subscribe function. For example, when navigator.onLine changes, the browser fires the online and offline events on the window object. You need to subscribe the callback argument to the corresponding events, and then return a function that cleans up the subscriptions: function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); };} Now React knows how to read the value from the external navigator.onLine API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response: App.jsApp.jsReloadClearForkimport { useSyncExternalStore } from 'react'; export default function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>; } function getSnapshot() { return navigator.onLine; } function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; } Show more Extracting the logic to a custom Hook Usually you won‚Äôt write useSyncExternalStore directly in your components. Instead, you‚Äôll typically call it from your own custom Hook. This lets you use the same external store from different components. For example, this custom useOnlineStatus Hook tracks whether the network is online: import { useSyncExternalStore } from 'react';export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return isOnline;}function getSnapshot() { // ...}function subscribe(callback) { // ...} Now different components can call useOnlineStatus without repeating the underlying implementation: App.jsuseOnlineStatus.jsApp.jsReloadClearForkimport { useOnlineStatus } from './useOnlineStatus.js'; function StatusBar() { const isOnline = useOnlineStatus(); return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>; } function SaveButton() { const isOnline = useOnlineStatus(); function handleSaveClick() { console.log('‚úÖ Progress saved'); } return ( <button disabled={!isOnline} onClick={handleSaveClick}> {isOnline ? 'Save progress' : 'Reconnecting...'} </button> ); } export default function App() { return ( <> <SaveButton /> <StatusBar /> </> ); } Show more Adding support for server rendering If your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store: If you‚Äôre connecting to a browser-only API, it won‚Äôt work because it does not exist on the server. If you‚Äôre connecting to a third-party data store, you‚Äôll need its data to match between the server and client. To solve these issues, pass a getServerSnapshot function as the third argument to useSyncExternalStore: import { useSyncExternalStore } from 'react';export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot); return isOnline;}function getSnapshot() { return navigator.onLine;}function getServerSnapshot() { return true; // Always show \"Online\" for server-generated HTML}function subscribe(callback) { // ...} The getServerSnapshot function is similar to getSnapshot, but it runs only in two situations: It runs on the server when generating the HTML. It runs on the client during hydration, i.e. when React takes the server HTML and makes it interactive. This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client. NoteMake sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a <script> tag during server rendering that sets a global like window.MY_STORE_DATA, and read from that global on the client in getServerSnapshot. Your external store should provide instructions on how to do that. Troubleshooting I‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù This error means your getSnapshot function returns a new object every time it‚Äôs called, for example: function getSnapshot() { // üî¥ Do not return always different objects from getSnapshot return { todos: myStore.todos };} React will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error. Your getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly: function getSnapshot() { // ‚úÖ You can return immutable data return myStore.todos;} If your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn‚Äôt do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store. My subscribe function gets called after every re-render This subscribe function is defined inside a component so it is different on every re-render: function ChatIndicator() { // üö© Always a different function, so React will resubscribe on every re-render function subscribe() { // ... } const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} React will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you‚Äôd like to avoid resubscribing, move the subscribe function outside: // ‚úÖ Always the same function, so React won't need to resubscribefunction subscribe() { // ...}function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} Alternatively, wrap subscribe into useCallback to only resubscribe when some argument changes: function ChatIndicator({ userId }) { // ‚úÖ Same function as long as userId doesn't change const subscribe = useCallback(() => { // ... }, [userId]); const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...}PrevioususeStateNextuseTransition",
      "code": "useSyncExternalStore"
    },
    {
      "description": "useSyncExternalStore is a React Hook that lets you subscribe to an external store.const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Reference useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Usage Subscribing to an external store Subscribing to a browser API Extracting the logic to a custom Hook Adding support for server rendering Troubleshooting I‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù My subscribe function gets called after every re-render Reference useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Call useSyncExternalStore at the top level of your component to read a value from an external data store. import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); // ...} It returns the snapshot of the data in the store. You need to pass two functions as arguments: The subscribe function should subscribe to the store and return a function that unsubscribes. The getSnapshot function should read a snapshot of the data from the store. See more examples below. Parameters subscribe: A function that takes a single callback argument and subscribes it to the store. When the store changes, it should invoke the provided callback, which will cause React to re-call getSnapshot and (if needed) re-render the component. The subscribe function should return a function that cleans up the subscription. getSnapshot: A function that returns a snapshot of the data in the store that‚Äôs needed by the component. While the store has not changed, repeated calls to getSnapshot must return the same value. If the store changes and the returned value is different (as compared by Object.is), React re-renders the component. optional getServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error. Returns The current snapshot of the store which you can use in your rendering logic. Caveats The store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot. If a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component. If the store is mutated during a non-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call getSnapshot a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store. It‚Äôs not recommended to suspend a render based on a store value returned by useSyncExternalStore. The reason is that mutations to the external store cannot be marked as non-blocking Transition updates, so they will trigger the nearest Suspense fallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX. For example, the following are discouraged: const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() { const selectedProductId = useSyncExternalStore(...); // ‚ùå Calling `use` with a Promise dependent on `selectedProductId` const data = use(fetchItem(selectedProductId)) // ‚ùå Conditionally rendering a lazy component based on `selectedProductId` return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;} Usage Subscribing to an external store Most of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes: Third-party state management libraries that hold state outside of React. Browser APIs that expose a mutable value and events to subscribe to its changes. Call useSyncExternalStore at the top level of your component to read a value from an external data store. import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); // ...} It returns the snapshot of the data in the store. You need to pass two functions as arguments: The subscribe function should subscribe to the store and return a function that unsubscribes. The getSnapshot function should read a snapshot of the data from the store. React will use these functions to keep your component subscribed to the store and re-render it on changes. For example, in the sandbox below, todosStore is implemented as an external store that stores data outside of React. The TodosApp component connects to that external store with the useSyncExternalStore Hook. App.jstodoStore.jsApp.jsReloadClearForkimport { useSyncExternalStore } from 'react'; import { todosStore } from './todoStore.js'; export default function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); return ( <> <button onClick={() => todosStore.addTodo()}>Add todo</button> <hr /> <ul> {todos.map(todo => ( <li key={todo.id}>{todo.text}</li> ))} </ul> </> ); } Show more NoteWhen possible, we recommend using built-in React state with useState and useReducer instead. The useSyncExternalStore API is mostly useful if you need to integrate with existing non-React code. Subscribing to a browser API Another reason to add useSyncExternalStore is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called navigator.onLine. This value can change without React‚Äôs knowledge, so you should read it with useSyncExternalStore. import { useSyncExternalStore } from 'react';function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} To implement the getSnapshot function, read the current value from the browser API: function getSnapshot() { return navigator.onLine;} Next, you need to implement the subscribe function. For example, when navigator.onLine changes, the browser fires the online and offline events on the window object. You need to subscribe the callback argument to the corresponding events, and then return a function that cleans up the subscriptions: function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); };} Now React knows how to read the value from the external navigator.onLine API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response: App.jsApp.jsReloadClearForkimport { useSyncExternalStore } from 'react'; export default function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>; } function getSnapshot() { return navigator.onLine; } function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; } Show more Extracting the logic to a custom Hook Usually you won‚Äôt write useSyncExternalStore directly in your components. Instead, you‚Äôll typically call it from your own custom Hook. This lets you use the same external store from different components. For example, this custom useOnlineStatus Hook tracks whether the network is online: import { useSyncExternalStore } from 'react';export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return isOnline;}function getSnapshot() { // ...}function subscribe(callback) { // ...} Now different components can call useOnlineStatus without repeating the underlying implementation: App.jsuseOnlineStatus.jsApp.jsReloadClearForkimport { useOnlineStatus } from './useOnlineStatus.js'; function StatusBar() { const isOnline = useOnlineStatus(); return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>; } function SaveButton() { const isOnline = useOnlineStatus(); function handleSaveClick() { console.log('‚úÖ Progress saved'); } return ( <button disabled={!isOnline} onClick={handleSaveClick}> {isOnline ? 'Save progress' : 'Reconnecting...'} </button> ); } export default function App() { return ( <> <SaveButton /> <StatusBar /> </> ); } Show more Adding support for server rendering If your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store: If you‚Äôre connecting to a browser-only API, it won‚Äôt work because it does not exist on the server. If you‚Äôre connecting to a third-party data store, you‚Äôll need its data to match between the server and client. To solve these issues, pass a getServerSnapshot function as the third argument to useSyncExternalStore: import { useSyncExternalStore } from 'react';export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot); return isOnline;}function getSnapshot() { return navigator.onLine;}function getServerSnapshot() { return true; // Always show \"Online\" for server-generated HTML}function subscribe(callback) { // ...} The getServerSnapshot function is similar to getSnapshot, but it runs only in two situations: It runs on the server when generating the HTML. It runs on the client during hydration, i.e. when React takes the server HTML and makes it interactive. This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client. NoteMake sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a <script> tag during server rendering that sets a global like window.MY_STORE_DATA, and read from that global on the client in getServerSnapshot. Your external store should provide instructions on how to do that. Troubleshooting I‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù This error means your getSnapshot function returns a new object every time it‚Äôs called, for example: function getSnapshot() { // üî¥ Do not return always different objects from getSnapshot return { todos: myStore.todos };} React will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error. Your getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly: function getSnapshot() { // ‚úÖ You can return immutable data return myStore.todos;} If your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn‚Äôt do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store. My subscribe function gets called after every re-render This subscribe function is defined inside a component so it is different on every re-render: function ChatIndicator() { // üö© Always a different function, so React will resubscribe on every re-render function subscribe() { // ... } const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} React will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you‚Äôd like to avoid resubscribing, move the subscribe function outside: // ‚úÖ Always the same function, so React won't need to resubscribefunction subscribe() { // ...}function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} Alternatively, wrap subscribe into useCallback to only resubscribe when some argument changes: function ChatIndicator({ userId }) { // ‚úÖ Same function as long as userId doesn't change const subscribe = useCallback(() => { // ... }, [userId]); const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...}PrevioususeStateNextuseTransition",
      "code": "useSyncExternalStore"
    },
    {
      "description": "useSyncExternalStore is a React Hook that lets you subscribe to an external store.const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Reference useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Usage Subscribing to an external store Subscribing to a browser API Extracting the logic to a custom Hook Adding support for server rendering Troubleshooting I‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù My subscribe function gets called after every re-render Reference useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Call useSyncExternalStore at the top level of your component to read a value from an external data store. import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); // ...} It returns the snapshot of the data in the store. You need to pass two functions as arguments: The subscribe function should subscribe to the store and return a function that unsubscribes. The getSnapshot function should read a snapshot of the data from the store. See more examples below. Parameters subscribe: A function that takes a single callback argument and subscribes it to the store. When the store changes, it should invoke the provided callback, which will cause React to re-call getSnapshot and (if needed) re-render the component. The subscribe function should return a function that cleans up the subscription. getSnapshot: A function that returns a snapshot of the data in the store that‚Äôs needed by the component. While the store has not changed, repeated calls to getSnapshot must return the same value. If the store changes and the returned value is different (as compared by Object.is), React re-renders the component. optional getServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error. Returns The current snapshot of the store which you can use in your rendering logic. Caveats The store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot. If a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component. If the store is mutated during a non-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call getSnapshot a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store. It‚Äôs not recommended to suspend a render based on a store value returned by useSyncExternalStore. The reason is that mutations to the external store cannot be marked as non-blocking Transition updates, so they will trigger the nearest Suspense fallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX. For example, the following are discouraged: const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() { const selectedProductId = useSyncExternalStore(...); // ‚ùå Calling `use` with a Promise dependent on `selectedProductId` const data = use(fetchItem(selectedProductId)) // ‚ùå Conditionally rendering a lazy component based on `selectedProductId` return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;} Usage Subscribing to an external store Most of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes: Third-party state management libraries that hold state outside of React. Browser APIs that expose a mutable value and events to subscribe to its changes. Call useSyncExternalStore at the top level of your component to read a value from an external data store. import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); // ...} It returns the snapshot of the data in the store. You need to pass two functions as arguments: The subscribe function should subscribe to the store and return a function that unsubscribes. The getSnapshot function should read a snapshot of the data from the store. React will use these functions to keep your component subscribed to the store and re-render it on changes. For example, in the sandbox below, todosStore is implemented as an external store that stores data outside of React. The TodosApp component connects to that external store with the useSyncExternalStore Hook. App.jstodoStore.jsApp.jsReloadClearForkimport { useSyncExternalStore } from 'react'; import { todosStore } from './todoStore.js'; export default function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); return ( <> <button onClick={() => todosStore.addTodo()}>Add todo</button> <hr /> <ul> {todos.map(todo => ( <li key={todo.id}>{todo.text}</li> ))} </ul> </> ); } Show more NoteWhen possible, we recommend using built-in React state with useState and useReducer instead. The useSyncExternalStore API is mostly useful if you need to integrate with existing non-React code. Subscribing to a browser API Another reason to add useSyncExternalStore is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called navigator.onLine. This value can change without React‚Äôs knowledge, so you should read it with useSyncExternalStore. import { useSyncExternalStore } from 'react';function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} To implement the getSnapshot function, read the current value from the browser API: function getSnapshot() { return navigator.onLine;} Next, you need to implement the subscribe function. For example, when navigator.onLine changes, the browser fires the online and offline events on the window object. You need to subscribe the callback argument to the corresponding events, and then return a function that cleans up the subscriptions: function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); };} Now React knows how to read the value from the external navigator.onLine API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response: App.jsApp.jsReloadClearForkimport { useSyncExternalStore } from 'react'; export default function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>; } function getSnapshot() { return navigator.onLine; } function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; } Show more Extracting the logic to a custom Hook Usually you won‚Äôt write useSyncExternalStore directly in your components. Instead, you‚Äôll typically call it from your own custom Hook. This lets you use the same external store from different components. For example, this custom useOnlineStatus Hook tracks whether the network is online: import { useSyncExternalStore } from 'react';export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return isOnline;}function getSnapshot() { // ...}function subscribe(callback) { // ...} Now different components can call useOnlineStatus without repeating the underlying implementation: App.jsuseOnlineStatus.jsApp.jsReloadClearForkimport { useOnlineStatus } from './useOnlineStatus.js'; function StatusBar() { const isOnline = useOnlineStatus(); return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>; } function SaveButton() { const isOnline = useOnlineStatus(); function handleSaveClick() { console.log('‚úÖ Progress saved'); } return ( <button disabled={!isOnline} onClick={handleSaveClick}> {isOnline ? 'Save progress' : 'Reconnecting...'} </button> ); } export default function App() { return ( <> <SaveButton /> <StatusBar /> </> ); } Show more Adding support for server rendering If your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store: If you‚Äôre connecting to a browser-only API, it won‚Äôt work because it does not exist on the server. If you‚Äôre connecting to a third-party data store, you‚Äôll need its data to match between the server and client. To solve these issues, pass a getServerSnapshot function as the third argument to useSyncExternalStore: import { useSyncExternalStore } from 'react';export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot); return isOnline;}function getSnapshot() { return navigator.onLine;}function getServerSnapshot() { return true; // Always show \"Online\" for server-generated HTML}function subscribe(callback) { // ...} The getServerSnapshot function is similar to getSnapshot, but it runs only in two situations: It runs on the server when generating the HTML. It runs on the client during hydration, i.e. when React takes the server HTML and makes it interactive. This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client. NoteMake sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a <script> tag during server rendering that sets a global like window.MY_STORE_DATA, and read from that global on the client in getServerSnapshot. Your external store should provide instructions on how to do that. Troubleshooting I‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù This error means your getSnapshot function returns a new object every time it‚Äôs called, for example: function getSnapshot() { // üî¥ Do not return always different objects from getSnapshot return { todos: myStore.todos };} React will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error. Your getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly: function getSnapshot() { // ‚úÖ You can return immutable data return myStore.todos;} If your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn‚Äôt do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store. My subscribe function gets called after every re-render This subscribe function is defined inside a component so it is different on every re-render: function ChatIndicator() { // üö© Always a different function, so React will resubscribe on every re-render function subscribe() { // ... } const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} React will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you‚Äôd like to avoid resubscribing, move the subscribe function outside: // ‚úÖ Always the same function, so React won't need to resubscribefunction subscribe() { // ...}function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} Alternatively, wrap subscribe into useCallback to only resubscribe when some argument changes: function ChatIndicator({ userId }) { // ‚úÖ Same function as long as userId doesn't change const subscribe = useCallback(() => { // ... }, [userId]); const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...}",
      "code": "useSyncExternalStore"
    },
    {
      "description": "Adding support for server rendering If your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store: If you‚Äôre connecting to a browser-only API, it won‚Äôt work because it does not exist on the server. If you‚Äôre connecting to a third-party data store, you‚Äôll need its data to match between the server and client. To solve these issues, pass a getServerSnapshot function as the third argument to useSyncExternalStore: import { useSyncExternalStore } from 'react';export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot); return isOnline;}function getSnapshot() { return navigator.onLine;}function getServerSnapshot() { return true; // Always show \"Online\" for server-generated HTML}function subscribe(callback) { // ...} The getServerSnapshot function is similar to getSnapshot, but it runs only in two situations: It runs on the server when generating the HTML. It runs on the client during hydration, i.e. when React takes the server HTML and makes it interactive. This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client. NoteMake sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a <script> tag during server rendering that sets a global like window.MY_STORE_DATA, and read from that global on the client in getServerSnapshot. Your external store should provide instructions on how to do that. Troubleshooting I‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù This error means your getSnapshot function returns a new object every time it‚Äôs called, for example: function getSnapshot() { // üî¥ Do not return always different objects from getSnapshot return { todos: myStore.todos };} React will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error. Your getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly: function getSnapshot() { // ‚úÖ You can return immutable data return myStore.todos;} If your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn‚Äôt do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store. My subscribe function gets called after every re-render This subscribe function is defined inside a component so it is different on every re-render: function ChatIndicator() { // üö© Always a different function, so React will resubscribe on every re-render function subscribe() { // ... } const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} React will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you‚Äôd like to avoid resubscribing, move the subscribe function outside: // ‚úÖ Always the same function, so React won't need to resubscribefunction subscribe() { // ...}function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...} Alternatively, wrap subscribe into useCallback to only resubscribe when some argument changes: function ChatIndicator({ userId }) { // ‚úÖ Same function as long as userId doesn't change const subscribe = useCallback(() => { // ... }, [userId]); const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ...}",
      "code": "getServerSnapshot"
    },
    {
      "description": "This error means your getSnapshot function returns a new object every time it‚Äôs called, for example:",
      "code": "getSnapshot"
    }
  ],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/reference/react/hooks",
    "https://react.dev/reference/react/useActionState",
    "https://react.dev/reference/react/useCallback",
    "https://react.dev/reference/react/useContext",
    "https://react.dev/reference/react/useDebugValue",
    "https://react.dev/reference/react/useDeferredValue",
    "https://react.dev/reference/react/useEffect",
    "https://react.dev/reference/react/useEffectEvent",
    "https://react.dev/reference/react/useId",
    "https://react.dev/reference/react/useImperativeHandle",
    "https://react.dev/reference/react/useInsertionEffect",
    "https://react.dev/reference/react/useLayoutEffect",
    "https://react.dev/reference/react/useMemo",
    "https://react.dev/reference/react/useOptimistic",
    "https://react.dev/reference/react/useReducer",
    "https://react.dev/reference/react/useRef",
    "https://react.dev/reference/react/useState",
    "https://react.dev/reference/react/useSyncExternalStore",
    "https://react.dev/reference/react/useTransition",
    "https://react.dev/reference/react/components",
    "https://react.dev/reference/react/Fragment",
    "https://react.dev/reference/react/Profiler",
    "https://react.dev/reference/react/StrictMode",
    "https://react.dev/reference/react/Suspense",
    "https://react.dev/reference/react/Activity",
    "https://react.dev/reference/react/ViewTransition",
    "https://react.dev/reference/react/apis",
    "https://react.dev/reference/react/act",
    "https://react.dev/reference/react/addTransitionType",
    "https://react.dev/reference/react/cache",
    "https://react.dev/reference/react/cacheSignal",
    "https://react.dev/reference/react/captureOwnerStack",
    "https://react.dev/reference/react/createContext",
    "https://react.dev/reference/react/lazy",
    "https://react.dev/reference/react/memo",
    "https://react.dev/reference/react/startTransition",
    "https://react.dev/reference/react/use",
    "https://react.dev/reference/react/experimental_taintObjectReference",
    "https://react.dev/reference/react/experimental_taintUniqueValue",
    "https://react.dev/reference/react-dom/hooks",
    "https://react.dev/reference/react-dom/hooks/useFormStatus",
    "https://react.dev/reference/react-dom/components",
    "https://react.dev/reference/react-dom/components/common",
    "https://react.dev/reference/react-dom/components/form",
    "https://react.dev/reference/react-dom/components/input",
    "https://react.dev/reference/react-dom/components/option",
    "https://react.dev/reference/react-dom/components/progress",
    "https://react.dev/reference/react-dom/components/select",
    "https://react.dev/reference/react-dom/components/textarea",
    "https://react.dev/reference/react-dom/components/link",
    "https://react.dev/reference/react-dom/components/meta",
    "https://react.dev/reference/react-dom/components/script",
    "https://react.dev/reference/react-dom/components/style",
    "https://react.dev/reference/react-dom/components/title",
    "https://react.dev/reference/react-dom",
    "https://react.dev/reference/react-dom/createPortal",
    "https://react.dev/reference/react-dom/flushSync",
    "https://react.dev/reference/react-dom/preconnect",
    "https://react.dev/reference/react-dom/prefetchDNS",
    "https://react.dev/reference/react-dom/preinit",
    "https://react.dev/reference/react-dom/preinitModule",
    "https://react.dev/reference/react-dom/preload",
    "https://react.dev/reference/react-dom/preloadModule",
    "https://react.dev/reference/react-dom/client",
    "https://react.dev/reference/react-dom/client/createRoot",
    "https://react.dev/reference/react-dom/client/hydrateRoot",
    "https://react.dev/reference/react-dom/server",
    "https://react.dev/reference/react-dom/server/renderToPipeableStream",
    "https://react.dev/reference/react-dom/server/renderToReadableStream",
    "https://react.dev/reference/react-dom/server/renderToStaticMarkup",
    "https://react.dev/reference/react-dom/server/renderToString",
    "https://react.dev/reference/react-dom/server/resume",
    "https://react.dev/reference/react-dom/server/resumeToPipeableStream",
    "https://react.dev/reference/react-dom/static",
    "https://react.dev/reference/react-dom/static/prerender",
    "https://react.dev/reference/react-dom/static/prerenderToNodeStream",
    "https://react.dev/reference/react-dom/static/resumeAndPrerender",
    "https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream",
    "https://react.dev/reference/react-compiler/configuration",
    "https://react.dev/reference/react-compiler/compilationMode",
    "https://react.dev/reference/react-compiler/gating",
    "https://react.dev/reference/react-compiler/logger",
    "https://react.dev/reference/react-compiler/panicThreshold",
    "https://react.dev/reference/react-compiler/target",
    "https://react.dev/reference/react-compiler/directives",
    "https://react.dev/reference/react-compiler/directives/use-memo",
    "https://react.dev/reference/react-compiler/directives/use-no-memo",
    "https://react.dev/reference/react-compiler/compiling-libraries",
    "https://react.dev/reference/dev-tools/react-performance-tracks",
    "https://react.dev/reference/eslint-plugin-react-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/config",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/gating",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/globals",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/purity",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/refs",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/use-memo",
    "https://react.dev/reference/rules",
    "https://react.dev/reference/rules/components-and-hooks-must-be-pure",
    "https://react.dev/reference/rules/react-calls-components-and-hooks",
    "https://react.dev/reference/rules/rules-of-hooks",
    "https://react.dev/reference/rsc/server-components",
    "https://react.dev/reference/rsc/server-functions",
    "https://react.dev/reference/rsc/directives",
    "https://react.dev/reference/rsc/use-client",
    "https://react.dev/reference/rsc/use-server",
    "https://react.dev/reference/react/legacy",
    "https://react.dev/reference/react/Children",
    "https://react.dev/reference/react/cloneElement",
    "https://react.dev/reference/react/Component",
    "https://react.dev/reference/react/createElement",
    "https://react.dev/reference/react/createRef",
    "https://react.dev/reference/react/forwardRef",
    "https://react.dev/reference/react/isValidElement",
    "https://react.dev/reference/react/PureComponent",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/escape-hatches"
  ]
}