{
  "url": "https://react.dev/reference/react/useContext",
  "title": "useContext",
  "content": "useContext is a React Hook that lets you read and subscribe to context from your component.\n\nCall useContext at the top level of your component to read and subscribe to context.\n\nSee more examples below.\n\nuseContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.\n\nCall useContext at the top level of your component to read and subscribe to context.\n\nuseContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.\n\nTo pass context to a Button, wrap it or one of its parent components into the corresponding context provider:\n\nIt doesn‚Äôt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value.\n\nuseContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which you‚Äôre calling useContext().\n\nOften, you‚Äôll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider.\n\nNow any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value.\n\nIn this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the ‚ÄúDark mode‚Äù checkbox updates the state. Changing the provided value re-renders all the components using that context.\n\nNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that aren‚Äôt strings.\n\nIf React can‚Äôt find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context:\n\nThe default value never changes. If you want to update context, use it with state as described above.\n\nOften, instead of null, there is some more meaningful value you can use as a default, for example:\n\nThis way, if you accidentally render some component without a corresponding provider, it won‚Äôt break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.\n\nIn the example below, the ‚ÄúToggle theme‚Äù button is always light because it‚Äôs outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'.\n\nYou can override the context for a part of the tree by wrapping that part in a provider with a different value.\n\nYou can nest and override providers as many times as you need.\n\nHere, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\").\n\nYou can pass any values via context, including objects and functions.\n\nHere, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext).\n\nIn smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization:\n\nAs a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) won‚Äôt need to re-render unless currentUser has changed.\n\nRead more about useMemo and useCallback.\n\nThere are a few common ways that this can happen:\n\nYou might have a provider without a value in the tree:\n\nIf you forget to specify value, it‚Äôs like passing value={undefined}.\n\nYou may have also mistakingly used a different prop name by mistake:\n\nIn both of these cases you should see a warning from React in the console. To fix them, call the prop value:\n\nNote that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a <SomeContext value={undefined}> component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.",
  "headings": [
    {
      "level": "h1",
      "text": "useContext",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Reference",
      "id": "reference"
    },
    {
      "level": "h3",
      "text": "useContext(SomeContext)",
      "id": "usecontext"
    },
    {
      "level": "h4",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h4",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h4",
      "text": "Caveats",
      "id": "caveats"
    },
    {
      "level": "h2",
      "text": "Usage",
      "id": "usage"
    },
    {
      "level": "h3",
      "text": "Passing data deeply into the tree",
      "id": "passing-data-deeply-into-the-tree"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Updating data passed via context",
      "id": "updating-data-passed-via-context"
    },
    {
      "level": "h4",
      "text": "Examples of updating context",
      "id": "examples-basic"
    },
    {
      "level": "h4",
      "text": "Example 1 of 5: Updating a value via context",
      "id": "updating-a-value-via-context"
    },
    {
      "level": "h3",
      "text": "Specifying a fallback default value",
      "id": "specifying-a-fallback-default-value"
    },
    {
      "level": "h3",
      "text": "Overriding context for a part of the tree",
      "id": "overriding-context-for-a-part-of-the-tree"
    },
    {
      "level": "h4",
      "text": "Examples of overriding context",
      "id": "examples"
    },
    {
      "level": "h4",
      "text": "Example 1 of 2: Overriding a theme",
      "id": "overriding-a-theme"
    },
    {
      "level": "h3",
      "text": "Optimizing re-renders when passing objects and functions",
      "id": "optimizing-re-renders-when-passing-objects-and-functions"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h3",
      "text": "My component doesn‚Äôt see the value from my provider",
      "id": "my-component-doesnt-see-the-value-from-my-provider"
    },
    {
      "level": "h3",
      "text": "I am always getting undefined from my context although the default value is different",
      "id": "i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different"
    }
  ],
  "code_samples": [
    {
      "code": "const value = useContext(SomeContext)",
      "language": "javascript"
    },
    {
      "code": "import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ...",
      "language": "javascript"
    },
    {
      "code": "import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ...",
      "language": "javascript"
    },
    {
      "code": "function MyPage() {  return (    <ThemeContext value=\"dark\">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}",
      "language": "jsx"
    },
    {
      "code": "function MyPage() {  const [theme, setTheme] = useState('dark');  return (    <ThemeContext value={theme}>      <Form />      <Button onClick={() => {        setTheme('light');      }}>        Switch to light theme      </Button>    </ThemeContext>  );}",
      "language": "jsx"
    },
    {
      "code": "const ThemeContext = createContext(null);",
      "language": "javascript"
    },
    {
      "code": "const ThemeContext = createContext('light');",
      "language": "javascript"
    },
    {
      "code": "<ThemeContext value=\"dark\">  ...  <ThemeContext value=\"light\">    <Footer />  </ThemeContext>  ...</ThemeContext>",
      "language": "jsx"
    },
    {
      "code": "function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  function login(response) {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }  return (    <AuthContext value={{ currentUser, login }}>      <Page />    </AuthContext>  );}",
      "language": "jsx"
    },
    {
      "code": "import { useCallback, useMemo } from 'react';function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  const login = useCallback((response) => {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }, []);  const contextValue = useMemo(() => ({    currentUser,    login  }), [currentUser, login]);  return (    <AuthContext value={contextValue}>      <Page />    </AuthContext>  );}",
      "language": "jsx"
    },
    {
      "code": "// üö© Doesn't work: no value prop<ThemeContext>   <Button /></ThemeContext>",
      "language": "jsx"
    },
    {
      "code": "// üö© Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}>   <Button /></ThemeContext>",
      "language": "jsx"
    },
    {
      "code": "// ‚úÖ Passing the value prop<ThemeContext value={theme}>   <Button /></ThemeContext>",
      "language": "jsx"
    }
  ],
  "patterns": [
    {
      "description": "API ReferenceHooksuseContextuseContext is a React Hook that lets you read and subscribe to context from your component.const value = useContext(SomeContext) Reference useContext(SomeContext) Usage Passing data deeply into the tree Updating data passed via context Specifying a fallback default value Overriding context for a part of the tree Optimizing re-renders when passing objects and functions Troubleshooting My component doesn‚Äôt see the value from my provider I am always getting undefined from my context although the default value is different Reference useContext(SomeContext) Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function MyComponent() { const theme = useContext(ThemeContext); // ... See more examples below. Parameters SomeContext: The context that you‚Äôve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components. Returns useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes. Caveats useContext() call in a component is not affected by providers returned from the same component. The corresponding <Context> needs to be above the component doing the useContext() call. React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values. If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison. Usage Passing data deeply into the tree Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function Button() { const theme = useContext(ThemeContext); // ... useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context. To pass context to a Button, wrap it or one of its parent components into the corresponding context provider: function MyPage() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> );}function Form() { // ... renders buttons inside ...} It doesn‚Äôt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value. PitfalluseContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which you‚Äôre calling useContext(). App.jsApp.jsReloadClearForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show more Updating data passed via context Often, you‚Äôll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider. function MyPage() { const [theme, setTheme] = useState('dark'); return ( <ThemeContext value={theme}> <Form /> <Button onClick={() => { setTheme('light'); }}> Switch to light theme </Button> </ThemeContext> );} Now any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value. Examples of updating context1. Updating a value via context 2. Updating an object via context 3. Multiple contexts 4. Extracting providers to a component 5. Scaling up with context and a reducer Example 1 of 5: Updating a value via context In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the ‚ÄúDark mode‚Äù checkbox updates the state. Changing the provided value re-renders all the components using that context.App.jsApp.jsReloadClearForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <ThemeContext value={theme}> <Form /> <label> <input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) => { setTheme(e.target.checked ? 'dark' : 'light') }} /> Use dark mode </label> </ThemeContext> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show moreNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that aren‚Äôt strings.Next Example Specifying a fallback default value If React can‚Äôt find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context: const ThemeContext = createContext(null); The default value never changes. If you want to update context, use it with state as described above. Often, instead of null, there is some more meaningful value you can use as a default, for example: const ThemeContext = createContext('light'); This way, if you accidentally render some component without a corresponding provider, it won‚Äôt break. This also helps your components work well in a test environment without setting up a lot of providers in the tests. In the example below, the ‚ÄúToggle theme‚Äù button is always light because it‚Äôs outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'. App.jsApp.jsReloadClearForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <> <ThemeContext value={theme}> <Form /> </ThemeContext> <Button onClick={() => { setTheme(theme === 'dark' ? 'light' : 'dark'); }}> Toggle theme </Button> </> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className} onClick={onClick}> {children} </button> ); } Show more Overriding context for a part of the tree You can override the context for a part of the tree by wrapping that part in a provider with a different value. <ThemeContext value=\"dark\"> ... <ThemeContext value=\"light\"> <Footer /> </ThemeContext> ...</ThemeContext> You can nest and override providers as many times as you need. Examples of overriding context1. Overriding a theme 2. Automatically nested headings Example 1 of 2: Overriding a theme Here, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\").App.jsApp.jsReloadClearForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> <ThemeContext value=\"light\"> <Footer /> </ThemeContext> </Panel> ); } function Footer() { return ( <footer> <Button>Settings</Button> </footer> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> {title && <h1>{title}</h1>} {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show moreNext Example Optimizing re-renders when passing objects and functions You can pass any values via context, including objects and functions. function MyApp() { const [currentUser, setCurrentUser] = useState(null); function login(response) { storeCredentials(response.credentials); setCurrentUser(response.user); } return ( <AuthContext value={{ currentUser, login }}> <Page /> </AuthContext> );} Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext). In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization: import { useCallback, useMemo } from 'react';function MyApp() { const [currentUser, setCurrentUser] = useState(null); const login = useCallback((response) => { storeCredentials(response.credentials); setCurrentUser(response.user); }, []); const contextValue = useMemo(() => ({ currentUser, login }), [currentUser, login]); return ( <AuthContext value={contextValue}> <Page /> </AuthContext> );} As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) won‚Äôt need to re-render unless currentUser has changed. Read more about useMemo and useCallback. Troubleshooting My component doesn‚Äôt see the value from my provider There are a few common ways that this can happen: You‚Äôre rendering <SomeContext> in the same component (or below) as where you‚Äôre calling useContext(). Move <SomeContext> above and outside the component calling useContext(). You may have forgotten to wrap your component with <SomeContext>, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools. You might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like window.SomeContext1 and window.SomeContext2 and then checking whether window.SomeContext1 === window.SomeContext2 in the console. If they‚Äôre not the same, fix that issue on the build tool level. I am always getting undefined from my context although the default value is different You might have a provider without a value in the tree: // üö© Doesn't work: no value prop<ThemeContext> <Button /></ThemeContext> If you forget to specify value, it‚Äôs like passing value={undefined}. You may have also mistakingly used a different prop name by mistake: // üö© Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}> <Button /></ThemeContext> In both of these cases you should see a warning from React in the console. To fix them, call the prop value: // ‚úÖ Passing the value prop<ThemeContext value={theme}> <Button /></ThemeContext> Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a <SomeContext value={undefined}> component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.PrevioususeCallbackNextuseDebugValue",
      "code": "useContext"
    },
    {
      "description": "useContext is a React Hook that lets you read and subscribe to context from your component.const value = useContext(SomeContext) Reference useContext(SomeContext) Usage Passing data deeply into the tree Updating data passed via context Specifying a fallback default value Overriding context for a part of the tree Optimizing re-renders when passing objects and functions Troubleshooting My component doesn‚Äôt see the value from my provider I am always getting undefined from my context although the default value is different Reference useContext(SomeContext) Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function MyComponent() { const theme = useContext(ThemeContext); // ... See more examples below. Parameters SomeContext: The context that you‚Äôve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components. Returns useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes. Caveats useContext() call in a component is not affected by providers returned from the same component. The corresponding <Context> needs to be above the component doing the useContext() call. React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values. If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison. Usage Passing data deeply into the tree Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function Button() { const theme = useContext(ThemeContext); // ... useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context. To pass context to a Button, wrap it or one of its parent components into the corresponding context provider: function MyPage() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> );}function Form() { // ... renders buttons inside ...} It doesn‚Äôt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value. PitfalluseContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which you‚Äôre calling useContext(). App.jsApp.jsReloadClearForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show more Updating data passed via context Often, you‚Äôll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider. function MyPage() { const [theme, setTheme] = useState('dark'); return ( <ThemeContext value={theme}> <Form /> <Button onClick={() => { setTheme('light'); }}> Switch to light theme </Button> </ThemeContext> );} Now any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value. Examples of updating context1. Updating a value via context 2. Updating an object via context 3. Multiple contexts 4. Extracting providers to a component 5. Scaling up with context and a reducer Example 1 of 5: Updating a value via context In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the ‚ÄúDark mode‚Äù checkbox updates the state. Changing the provided value re-renders all the components using that context.App.jsApp.jsReloadClearForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <ThemeContext value={theme}> <Form /> <label> <input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) => { setTheme(e.target.checked ? 'dark' : 'light') }} /> Use dark mode </label> </ThemeContext> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show moreNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that aren‚Äôt strings.Next Example Specifying a fallback default value If React can‚Äôt find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context: const ThemeContext = createContext(null); The default value never changes. If you want to update context, use it with state as described above. Often, instead of null, there is some more meaningful value you can use as a default, for example: const ThemeContext = createContext('light'); This way, if you accidentally render some component without a corresponding provider, it won‚Äôt break. This also helps your components work well in a test environment without setting up a lot of providers in the tests. In the example below, the ‚ÄúToggle theme‚Äù button is always light because it‚Äôs outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'. App.jsApp.jsReloadClearForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <> <ThemeContext value={theme}> <Form /> </ThemeContext> <Button onClick={() => { setTheme(theme === 'dark' ? 'light' : 'dark'); }}> Toggle theme </Button> </> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className} onClick={onClick}> {children} </button> ); } Show more Overriding context for a part of the tree You can override the context for a part of the tree by wrapping that part in a provider with a different value. <ThemeContext value=\"dark\"> ... <ThemeContext value=\"light\"> <Footer /> </ThemeContext> ...</ThemeContext> You can nest and override providers as many times as you need. Examples of overriding context1. Overriding a theme 2. Automatically nested headings Example 1 of 2: Overriding a theme Here, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\").App.jsApp.jsReloadClearForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> <ThemeContext value=\"light\"> <Footer /> </ThemeContext> </Panel> ); } function Footer() { return ( <footer> <Button>Settings</Button> </footer> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> {title && <h1>{title}</h1>} {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show moreNext Example Optimizing re-renders when passing objects and functions You can pass any values via context, including objects and functions. function MyApp() { const [currentUser, setCurrentUser] = useState(null); function login(response) { storeCredentials(response.credentials); setCurrentUser(response.user); } return ( <AuthContext value={{ currentUser, login }}> <Page /> </AuthContext> );} Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext). In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization: import { useCallback, useMemo } from 'react';function MyApp() { const [currentUser, setCurrentUser] = useState(null); const login = useCallback((response) => { storeCredentials(response.credentials); setCurrentUser(response.user); }, []); const contextValue = useMemo(() => ({ currentUser, login }), [currentUser, login]); return ( <AuthContext value={contextValue}> <Page /> </AuthContext> );} As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) won‚Äôt need to re-render unless currentUser has changed. Read more about useMemo and useCallback. Troubleshooting My component doesn‚Äôt see the value from my provider There are a few common ways that this can happen: You‚Äôre rendering <SomeContext> in the same component (or below) as where you‚Äôre calling useContext(). Move <SomeContext> above and outside the component calling useContext(). You may have forgotten to wrap your component with <SomeContext>, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools. You might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like window.SomeContext1 and window.SomeContext2 and then checking whether window.SomeContext1 === window.SomeContext2 in the console. If they‚Äôre not the same, fix that issue on the build tool level. I am always getting undefined from my context although the default value is different You might have a provider without a value in the tree: // üö© Doesn't work: no value prop<ThemeContext> <Button /></ThemeContext> If you forget to specify value, it‚Äôs like passing value={undefined}. You may have also mistakingly used a different prop name by mistake: // üö© Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}> <Button /></ThemeContext> In both of these cases you should see a warning from React in the console. To fix them, call the prop value: // ‚úÖ Passing the value prop<ThemeContext value={theme}> <Button /></ThemeContext> Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a <SomeContext value={undefined}> component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.PrevioususeCallbackNextuseDebugValue",
      "code": "useContext"
    },
    {
      "description": "useContext is a React Hook that lets you read and subscribe to context from your component.const value = useContext(SomeContext) Reference useContext(SomeContext) Usage Passing data deeply into the tree Updating data passed via context Specifying a fallback default value Overriding context for a part of the tree Optimizing re-renders when passing objects and functions Troubleshooting My component doesn‚Äôt see the value from my provider I am always getting undefined from my context although the default value is different Reference useContext(SomeContext) Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function MyComponent() { const theme = useContext(ThemeContext); // ... See more examples below. Parameters SomeContext: The context that you‚Äôve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components. Returns useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes. Caveats useContext() call in a component is not affected by providers returned from the same component. The corresponding <Context> needs to be above the component doing the useContext() call. React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values. If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison. Usage Passing data deeply into the tree Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function Button() { const theme = useContext(ThemeContext); // ... useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context. To pass context to a Button, wrap it or one of its parent components into the corresponding context provider: function MyPage() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> );}function Form() { // ... renders buttons inside ...} It doesn‚Äôt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value. PitfalluseContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which you‚Äôre calling useContext(). App.jsApp.jsReloadClearForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show more Updating data passed via context Often, you‚Äôll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider. function MyPage() { const [theme, setTheme] = useState('dark'); return ( <ThemeContext value={theme}> <Form /> <Button onClick={() => { setTheme('light'); }}> Switch to light theme </Button> </ThemeContext> );} Now any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value. Examples of updating context1. Updating a value via context 2. Updating an object via context 3. Multiple contexts 4. Extracting providers to a component 5. Scaling up with context and a reducer Example 1 of 5: Updating a value via context In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the ‚ÄúDark mode‚Äù checkbox updates the state. Changing the provided value re-renders all the components using that context.App.jsApp.jsReloadClearForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <ThemeContext value={theme}> <Form /> <label> <input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) => { setTheme(e.target.checked ? 'dark' : 'light') }} /> Use dark mode </label> </ThemeContext> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show moreNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that aren‚Äôt strings.Next Example Specifying a fallback default value If React can‚Äôt find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context: const ThemeContext = createContext(null); The default value never changes. If you want to update context, use it with state as described above. Often, instead of null, there is some more meaningful value you can use as a default, for example: const ThemeContext = createContext('light'); This way, if you accidentally render some component without a corresponding provider, it won‚Äôt break. This also helps your components work well in a test environment without setting up a lot of providers in the tests. In the example below, the ‚ÄúToggle theme‚Äù button is always light because it‚Äôs outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'. App.jsApp.jsReloadClearForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <> <ThemeContext value={theme}> <Form /> </ThemeContext> <Button onClick={() => { setTheme(theme === 'dark' ? 'light' : 'dark'); }}> Toggle theme </Button> </> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className} onClick={onClick}> {children} </button> ); } Show more Overriding context for a part of the tree You can override the context for a part of the tree by wrapping that part in a provider with a different value. <ThemeContext value=\"dark\"> ... <ThemeContext value=\"light\"> <Footer /> </ThemeContext> ...</ThemeContext> You can nest and override providers as many times as you need. Examples of overriding context1. Overriding a theme 2. Automatically nested headings Example 1 of 2: Overriding a theme Here, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\").App.jsApp.jsReloadClearForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext value=\"dark\"> <Form /> </ThemeContext> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> <ThemeContext value=\"light\"> <Footer /> </ThemeContext> </Panel> ); } function Footer() { return ( <footer> <Button>Settings</Button> </footer> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> {title && <h1>{title}</h1>} {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Show moreNext Example Optimizing re-renders when passing objects and functions You can pass any values via context, including objects and functions. function MyApp() { const [currentUser, setCurrentUser] = useState(null); function login(response) { storeCredentials(response.credentials); setCurrentUser(response.user); } return ( <AuthContext value={{ currentUser, login }}> <Page /> </AuthContext> );} Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext). In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization: import { useCallback, useMemo } from 'react';function MyApp() { const [currentUser, setCurrentUser] = useState(null); const login = useCallback((response) => { storeCredentials(response.credentials); setCurrentUser(response.user); }, []); const contextValue = useMemo(() => ({ currentUser, login }), [currentUser, login]); return ( <AuthContext value={contextValue}> <Page /> </AuthContext> );} As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) won‚Äôt need to re-render unless currentUser has changed. Read more about useMemo and useCallback. Troubleshooting My component doesn‚Äôt see the value from my provider There are a few common ways that this can happen: You‚Äôre rendering <SomeContext> in the same component (or below) as where you‚Äôre calling useContext(). Move <SomeContext> above and outside the component calling useContext(). You may have forgotten to wrap your component with <SomeContext>, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools. You might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like window.SomeContext1 and window.SomeContext2 and then checking whether window.SomeContext1 === window.SomeContext2 in the console. If they‚Äôre not the same, fix that issue on the build tool level. I am always getting undefined from my context although the default value is different You might have a provider without a value in the tree: // üö© Doesn't work: no value prop<ThemeContext> <Button /></ThemeContext> If you forget to specify value, it‚Äôs like passing value={undefined}. You may have also mistakingly used a different prop name by mistake: // üö© Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}> <Button /></ThemeContext> In both of these cases you should see a warning from React in the console. To fix them, call the prop value: // ‚úÖ Passing the value prop<ThemeContext value={theme}> <Button /></ThemeContext> Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a <SomeContext value={undefined}> component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.",
      "code": "useContext"
    },
    {
      "description": "Specifying a fallback default value If React can‚Äôt find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context: const ThemeContext = createContext(null); The default value never changes. If you want to update context, use it with state as described above. Often, instead of null, there is some more meaningful value you can use as a default, for example: const ThemeContext = createContext('light'); This way, if you accidentally render some component without a corresponding provider, it won‚Äôt break. This also helps your components work well in a test environment without setting up a lot of providers in the tests. In the example below, the ‚ÄúToggle theme‚Äù button is always light because it‚Äôs outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'.",
      "code": "useContext()"
    },
    {
      "description": "Often, instead of null, there is some more meaningful value you can use as a default, for example:",
      "code": "null"
    }
  ],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/reference/react/hooks",
    "https://react.dev/reference/react/useActionState",
    "https://react.dev/reference/react/useCallback",
    "https://react.dev/reference/react/useContext",
    "https://react.dev/reference/react/useDebugValue",
    "https://react.dev/reference/react/useDeferredValue",
    "https://react.dev/reference/react/useEffect",
    "https://react.dev/reference/react/useEffectEvent",
    "https://react.dev/reference/react/useId",
    "https://react.dev/reference/react/useImperativeHandle",
    "https://react.dev/reference/react/useInsertionEffect",
    "https://react.dev/reference/react/useLayoutEffect",
    "https://react.dev/reference/react/useMemo",
    "https://react.dev/reference/react/useOptimistic",
    "https://react.dev/reference/react/useReducer",
    "https://react.dev/reference/react/useRef",
    "https://react.dev/reference/react/useState",
    "https://react.dev/reference/react/useSyncExternalStore",
    "https://react.dev/reference/react/useTransition",
    "https://react.dev/reference/react/components",
    "https://react.dev/reference/react/Fragment",
    "https://react.dev/reference/react/Profiler",
    "https://react.dev/reference/react/StrictMode",
    "https://react.dev/reference/react/Suspense",
    "https://react.dev/reference/react/Activity",
    "https://react.dev/reference/react/ViewTransition",
    "https://react.dev/reference/react/apis",
    "https://react.dev/reference/react/act",
    "https://react.dev/reference/react/addTransitionType",
    "https://react.dev/reference/react/cache",
    "https://react.dev/reference/react/cacheSignal",
    "https://react.dev/reference/react/captureOwnerStack",
    "https://react.dev/reference/react/createContext",
    "https://react.dev/reference/react/lazy",
    "https://react.dev/reference/react/memo",
    "https://react.dev/reference/react/startTransition",
    "https://react.dev/reference/react/use",
    "https://react.dev/reference/react/experimental_taintObjectReference",
    "https://react.dev/reference/react/experimental_taintUniqueValue",
    "https://react.dev/reference/react-dom/hooks",
    "https://react.dev/reference/react-dom/hooks/useFormStatus",
    "https://react.dev/reference/react-dom/components",
    "https://react.dev/reference/react-dom/components/common",
    "https://react.dev/reference/react-dom/components/form",
    "https://react.dev/reference/react-dom/components/input",
    "https://react.dev/reference/react-dom/components/option",
    "https://react.dev/reference/react-dom/components/progress",
    "https://react.dev/reference/react-dom/components/select",
    "https://react.dev/reference/react-dom/components/textarea",
    "https://react.dev/reference/react-dom/components/link",
    "https://react.dev/reference/react-dom/components/meta",
    "https://react.dev/reference/react-dom/components/script",
    "https://react.dev/reference/react-dom/components/style",
    "https://react.dev/reference/react-dom/components/title",
    "https://react.dev/reference/react-dom",
    "https://react.dev/reference/react-dom/createPortal",
    "https://react.dev/reference/react-dom/flushSync",
    "https://react.dev/reference/react-dom/preconnect",
    "https://react.dev/reference/react-dom/prefetchDNS",
    "https://react.dev/reference/react-dom/preinit",
    "https://react.dev/reference/react-dom/preinitModule",
    "https://react.dev/reference/react-dom/preload",
    "https://react.dev/reference/react-dom/preloadModule",
    "https://react.dev/reference/react-dom/client",
    "https://react.dev/reference/react-dom/client/createRoot",
    "https://react.dev/reference/react-dom/client/hydrateRoot",
    "https://react.dev/reference/react-dom/server",
    "https://react.dev/reference/react-dom/server/renderToPipeableStream",
    "https://react.dev/reference/react-dom/server/renderToReadableStream",
    "https://react.dev/reference/react-dom/server/renderToStaticMarkup",
    "https://react.dev/reference/react-dom/server/renderToString",
    "https://react.dev/reference/react-dom/server/resume",
    "https://react.dev/reference/react-dom/server/resumeToPipeableStream",
    "https://react.dev/reference/react-dom/static",
    "https://react.dev/reference/react-dom/static/prerender",
    "https://react.dev/reference/react-dom/static/prerenderToNodeStream",
    "https://react.dev/reference/react-dom/static/resumeAndPrerender",
    "https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream",
    "https://react.dev/reference/react-compiler/configuration",
    "https://react.dev/reference/react-compiler/compilationMode",
    "https://react.dev/reference/react-compiler/gating",
    "https://react.dev/reference/react-compiler/logger",
    "https://react.dev/reference/react-compiler/panicThreshold",
    "https://react.dev/reference/react-compiler/target",
    "https://react.dev/reference/react-compiler/directives",
    "https://react.dev/reference/react-compiler/directives/use-memo",
    "https://react.dev/reference/react-compiler/directives/use-no-memo",
    "https://react.dev/reference/react-compiler/compiling-libraries",
    "https://react.dev/reference/dev-tools/react-performance-tracks",
    "https://react.dev/reference/eslint-plugin-react-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/config",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/gating",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/globals",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/purity",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/refs",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/use-memo",
    "https://react.dev/reference/rules",
    "https://react.dev/reference/rules/components-and-hooks-must-be-pure",
    "https://react.dev/reference/rules/react-calls-components-and-hooks",
    "https://react.dev/reference/rules/rules-of-hooks",
    "https://react.dev/reference/rsc/server-components",
    "https://react.dev/reference/rsc/server-functions",
    "https://react.dev/reference/rsc/directives",
    "https://react.dev/reference/rsc/use-client",
    "https://react.dev/reference/rsc/use-server",
    "https://react.dev/reference/react/legacy",
    "https://react.dev/reference/react/Children",
    "https://react.dev/reference/react/cloneElement",
    "https://react.dev/reference/react/Component",
    "https://react.dev/reference/react/createElement",
    "https://react.dev/reference/react/createRef",
    "https://react.dev/reference/react/forwardRef",
    "https://react.dev/reference/react/isValidElement",
    "https://react.dev/reference/react/PureComponent",
    "https://react.dev/learn/passing-data-deeply-with-context",
    "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
    "https://react.dev/learn/react-developer-tools",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/escape-hatches"
  ]
}