{
  "url": "https://react.dev/learn/lifecycle-of-reactive-effects",
  "title": "Lifecycle of Reactive Effects",
  "content": "Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that youâ€™ve specified your Effectâ€™s dependencies correctly. This keeps your Effect synchronized to the latest props and state.\n\nEvery React component goes through the same lifecycle:\n\nItâ€™s a good way to think about components, but not about Effects. Instead, try to think about each Effect independently from your componentâ€™s lifecycle. An Effect describes how to synchronize an external system to the current props and state. As your code changes, synchronization will need to happen more or less often.\n\nTo illustrate this point, consider this Effect connecting your component to a chat server:\n\nYour Effectâ€™s body specifies how to start synchronizing:\n\nThe cleanup function returned by your Effect specifies how to stop synchronizing:\n\nIntuitively, you might think that React would start synchronizing when your component mounts and stop synchronizing when your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary to start and stop synchronizing multiple times while the component remains mounted.\n\nLetâ€™s look at why this is necessary, when it happens, and how you can control this behavior.\n\nSome Effects donâ€™t return a cleanup function at all. More often than not, youâ€™ll want to return oneâ€”but if you donâ€™t, React will behave as if you returned an empty cleanup function.\n\nImagine this ChatRoom component receives a roomId prop that the user picks in a dropdown. Letâ€™s say that initially the user picks the \"general\" room as the roomId. Your app displays the \"general\" chat room:\n\nAfter the UI is displayed, React will run your Effect to start synchronizing. It connects to the \"general\" room:\n\nLater, the user picks a different room in the dropdown (for example, \"travel\"). First, React will update the UI:\n\nThink about what should happen next. The user sees that \"travel\" is the selected chat room in the UI. However, the Effect that ran the last time is still connected to the \"general\" room. The roomId prop has changed, so what your Effect did back then (connecting to the \"general\" room) no longer matches the UI.\n\nAt this point, you want React to do two things:\n\nLuckily, youâ€™ve already taught React how to do both of these things! Your Effectâ€™s body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Letâ€™s see how exactly that happens.\n\nRecall that your ChatRoom component has received a new value for its roomId prop. It used to be \"general\", and now it is \"travel\". React needs to re-synchronize your Effect to re-connect you to a different room.\n\nTo stop synchronizing, React will call the cleanup function that your Effect returned after connecting to the \"general\" room. Since roomId was \"general\", the cleanup function disconnects from the \"general\" room:\n\nThen React will run the Effect that youâ€™ve provided during this render. This time, roomId is \"travel\" so it will start synchronizing to the \"travel\" chat room (until its cleanup function is eventually called too):\n\nThanks to this, youâ€™re now connected to the same room that the user chose in the UI. Disaster averted!\n\nEvery time after your component re-renders with a different roomId, your Effect will re-synchronize. For example, letâ€™s say the user changes roomId from \"travel\" to \"music\". React will again stop synchronizing your Effect by calling its cleanup function (disconnecting you from the \"travel\" room). Then it will start synchronizing again by running its body with the new roomId prop (connecting you to the \"music\" room).\n\nFinally, when the user goes to a different screen, ChatRoom unmounts. Now there is no need to stay connected at all. React will stop synchronizing your Effect one last time and disconnect you from the \"music\" chat room.\n\nLetâ€™s recap everything thatâ€™s happened from the ChatRoom componentâ€™s perspective:\n\nDuring each of these points in the componentâ€™s lifecycle, your Effect did different things:\n\nNow letâ€™s think about what happened from the perspective of the Effect itself:\n\nThis codeâ€™s structure might inspire you to see what happened as a sequence of non-overlapping time periods:\n\nPreviously, you were thinking from the componentâ€™s perspective. When you looked from the componentâ€™s perspective, it was tempting to think of Effects as â€œcallbacksâ€ or â€œlifecycle eventsâ€ that fire at a specific time like â€œafter a renderâ€ or â€œbefore unmountâ€. This way of thinking gets complicated very fast, so itâ€™s best to avoid.\n\nInstead, always focus on a single start/stop cycle at a time. It shouldnâ€™t matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as itâ€™s needed.\n\nThis might remind you how you donâ€™t think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and React figures out the rest.\n\nHere is a live example that you can play with. Press â€œOpen chatâ€ to mount the ChatRoom component:\n\nNotice that when the component mounts for the first time, you see three logs:\n\nThe first two logs are development-only. In development, React always remounts each component once.\n\nReact verifies that your Effect can re-synchronize by forcing it to do that immediately in development. This might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to check youâ€™ve implemented its cleanup well.\n\nThe main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when the roomId changes, your Effect re-synchronizes.\n\nHowever, there are also more unusual cases in which re-synchronization is necessary. For example, try editing the serverUrl in the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization.\n\nYou might be wondering how React knew that your Effect needed to re-synchronize after roomId changes. Itâ€™s because you told React that its code depends on roomId by including it in the list of dependencies:\n\nHereâ€™s how this works:\n\nEvery time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect.\n\nFor example, if you passed [\"general\"] during the initial render, and later you passed [\"travel\"] during the next render, React will compare \"general\" and \"travel\". These are different values (compared with Object.is), so React will re-synchronize your Effect. On the other hand, if your component re-renders but roomId has not changed, your Effect will remain connected to the same room.\n\nResist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, letâ€™s say you want to send an analytics event when the user visits the room. You already have an Effect that depends on roomId, so you might feel tempted to add the analytics call there:\n\nBut imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also call logVisit(roomId) for the same room, which you did not intend. Logging the visit is a separate process from connecting. Write them as two separate Effects:\n\nEach Effect in your code should represent a separate and independent synchronization process.\n\nIn the above example, deleting one Effect wouldnâ€™t break the other Effectâ€™s logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look â€œcleanerâ€ but will be more difficult to maintain. This is why you should think whether the processes are same or separate, not whether the code looks cleaner.\n\nYour Effect reads two variables (serverUrl and roomId), but you only specified roomId as a dependency:\n\nWhy doesnâ€™t serverUrl need to be a dependency?\n\nThis is because the serverUrl never changes due to a re-render. Itâ€™s always the same no matter how many times the component re-renders and why. Since serverUrl never changes, it wouldnâ€™t make sense to specify it as a dependency. After all, dependencies only do something when they change over time!\n\nOn the other hand, roomId may be different on a re-render. Props, state, and other values declared inside the component are reactive because theyâ€™re calculated during rendering and participate in the React data flow.\n\nIf serverUrl was a state variable, it would be reactive. Reactive values must be included in dependencies:\n\nBy including serverUrl as a dependency, you ensure that the Effect re-synchronizes after it changes.\n\nTry changing the selected chat room or edit the server URL in this sandbox:\n\nWhenever you change a reactive value like roomId or serverUrl, the Effect re-connects to the chat server.\n\nWhat happens if you move both serverUrl and roomId outside the component?\n\nNow your Effectâ€™s code does not use any reactive values, so its dependencies can be empty ([]).\n\nThinking from the componentâ€™s perspective, the empty [] dependency array means this Effect connects to the chat room only when the component mounts, and disconnects only when the component unmounts. (Keep in mind that React would still re-synchronize it an extra time in development to stress-test your logic.)\n\nHowever, if you think from the Effectâ€™s perspective, you donâ€™t need to think about mounting and unmounting at all. Whatâ€™s important is youâ€™ve specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to change roomId or serverUrl over time (and they would become reactive), your Effectâ€™s code wonâ€™t change. You will only need to add them to the dependencies.\n\nProps and state arenâ€™t the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list.\n\nLetâ€™s say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose youâ€™ve already put the settings state in a context so you read the settings from that context. Now you calculate the serverUrl based on the selected server from props and the default server:\n\nIn this example, serverUrl is not a prop or a state variable. Itâ€™s a regular variable that you calculate during rendering. But itâ€™s calculated during rendering, so it can change due to a re-render. This is why itâ€™s reactive.\n\nAll values inside the component (including props, state, and variables in your componentâ€™s body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effectâ€™s dependencies.\n\nIn other words, Effects â€œreactâ€ to all values from the component body.\n\nMutable values (including global variables) arenâ€™t reactive.\n\nA mutable value like location.pathname canâ€™t be a dependency. Itâ€™s mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldnâ€™t trigger a re-render of your component. Therefore, even if you specified it in the dependencies, React wouldnâ€™t know to re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breaks purity of rendering. Instead, you should read and subscribe to an external mutable value with useSyncExternalStore.\n\nA mutable value like ref.current or things you read from it also canâ€™t be a dependency. The ref object returned by useRef itself can be a dependency, but its current property is intentionally mutable. It lets you keep track of something without triggering a re-render. But since changing it doesnâ€™t trigger a re-render, itâ€™s not a reactive value, and React wonâ€™t know to re-run your Effect when it changes.\n\nAs youâ€™ll learn below on this page, a linter will check for these issues automatically.\n\nIf your linter is configured for React, it will check that every reactive value used by your Effectâ€™s code is declared as its dependency. For example, this is a lint error because both roomId and serverUrl are reactive:\n\nThis may look like a React error, but really React is pointing out a bug in your code. Both roomId and serverUrl may change over time, but youâ€™re forgetting to re-synchronize your Effect when they change. You will remain connected to the initial roomId and serverUrl even after the user picks different values in the UI.\n\nTo fix the bug, follow the linterâ€™s suggestion to specify roomId and serverUrl as dependencies of your Effect:\n\nTry this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed.\n\nIn some cases, React knows that a value never changes even though itâ€™s declared inside the component. For example, the set function returned from useState and the ref object returned by useRef are stableâ€”they are guaranteed to not change on a re-render. Stable values arenâ€™t reactive, so you may omit them from the list. Including them is allowed: they wonâ€™t change, so it doesnâ€™t matter.\n\nIn the previous example, youâ€™ve fixed the lint error by listing roomId and serverUrl as dependencies.\n\nHowever, you could instead â€œproveâ€ to the linter that these values arenâ€™t reactive values, i.e. that they canâ€™t change as a result of a re-render. For example, if serverUrl and roomId donâ€™t depend on rendering and always have the same values, you can move them outside the component. Now they donâ€™t need to be dependencies:\n\nYou can also move them inside the Effect. They arenâ€™t calculated during rendering, so theyâ€™re not reactive:\n\nEffects are reactive blocks of code. They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary.\n\nYou canâ€™t â€œchooseâ€ your dependencies. Your dependencies must include every reactive value you read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Donâ€™t fix these problems by suppressing the linter! Hereâ€™s what to try instead:\n\nCheck that your Effect represents an independent synchronization process. If your Effect doesnâ€™t synchronize anything, it might be unnecessary. If it synchronizes several independent things, split it up.\n\nIf you want to read the latest value of props or state without â€œreactingâ€ to it and re-synchronizing the Effect, you can split your Effect into a reactive part (which youâ€™ll keep in the Effect) and a non-reactive part (which youâ€™ll extract into something called an Effect Event). Read about separating Events from Effects.\n\nAvoid relying on objects and functions as dependencies. If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time. Read more about removing unnecessary dependencies from Effects.\n\nThe linter is your friend, but its powers are limited. The linter only knows when the dependencies are wrong. It doesnâ€™t know the best way to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesnâ€™t mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isnâ€™t reactive and doesnâ€™t need to be a dependency.\n\nIf you have an existing codebase, you might have some Effects that suppress the linter like this:\n\nOn the next pages, youâ€™ll learn how to fix this code without breaking the rules. Itâ€™s always worth fixing!\n\nIn this example, the ChatRoom component connects to the chat room when the component mounts, disconnects when it unmounts, and reconnects when you select a different chat room. This behavior is correct, so you need to keep it working.\n\nHowever, there is a problem. Whenever you type into the message box input at the bottom, ChatRoom also reconnects to the chat. (You can notice this by clearing the console and typing into the input.) Fix the issue so that this doesnâ€™t happen.",
  "headings": [
    {
      "level": "h1",
      "text": "Lifecycle of Reactive Effects",
      "id": ""
    },
    {
      "level": "h3",
      "text": "You will learn",
      "id": ""
    },
    {
      "level": "h2",
      "text": "The lifecycle of an Effect",
      "id": "the-lifecycle-of-an-effect"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Why synchronization may need to happen more than once",
      "id": "why-synchronization-may-need-to-happen-more-than-once"
    },
    {
      "level": "h3",
      "text": "How React re-synchronizes your Effect",
      "id": "how-react-re-synchronizes-your-effect"
    },
    {
      "level": "h3",
      "text": "Thinking from the Effectâ€™s perspective",
      "id": "thinking-from-the-effects-perspective"
    },
    {
      "level": "h3",
      "text": "How React verifies that your Effect can re-synchronize",
      "id": "how-react-verifies-that-your-effect-can-re-synchronize"
    },
    {
      "level": "h3",
      "text": "How React knows that it needs to re-synchronize the Effect",
      "id": "how-react-knows-that-it-needs-to-re-synchronize-the-effect"
    },
    {
      "level": "h3",
      "text": "Each Effect represents a separate synchronization process",
      "id": "each-effect-represents-a-separate-synchronization-process"
    },
    {
      "level": "h2",
      "text": "Effects â€œreactâ€ to reactive values",
      "id": "effects-react-to-reactive-values"
    },
    {
      "level": "h3",
      "text": "What an Effect with empty dependencies means",
      "id": "what-an-effect-with-empty-dependencies-means"
    },
    {
      "level": "h3",
      "text": "All variables declared in the component body are reactive",
      "id": "all-variables-declared-in-the-component-body-are-reactive"
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Can global or mutable values be dependencies?",
      "id": "can-global-or-mutable-values-be-dependencies"
    },
    {
      "level": "h3",
      "text": "React verifies that you specified every reactive value as a dependency",
      "id": "react-verifies-that-you-specified-every-reactive-value-as-a-dependency"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h3",
      "text": "What to do when you donâ€™t want to re-synchronize",
      "id": "what-to-do-when-you-dont-want-to-re-synchronize"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Recap",
      "id": "recap"
    },
    {
      "level": "h2",
      "text": "Try out some challenges",
      "id": "challenges"
    },
    {
      "level": "h4",
      "text": "Challenge 1 of 5: Fix reconnecting on every keystroke",
      "id": "fix-reconnecting-on-every-keystroke"
    }
  ],
  "code_samples": [
    {
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]);  // ...}",
      "language": "javascript"
    },
    {
      "code": "// ...    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };    // ...",
      "language": "javascript"
    },
    {
      "code": "// ...    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };    // ...",
      "language": "javascript"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId /* \"general\" */ }) {  // ...  return <h1>Welcome to the {roomId} room!</h1>;}",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId /* \"general\" */ }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Connects to the \"general\" room    connection.connect();    return () => {      connection.disconnect(); // Disconnects from the \"general\" room    };  }, [roomId]);  // ...",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId /* \"travel\" */ }) {  // ...  return <h1>Welcome to the {roomId} room!</h1>;}",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId /* \"general\" */ }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Connects to the \"general\" room    connection.connect();    return () => {      connection.disconnect(); // Disconnects from the \"general\" room    };    // ...",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId /* \"travel\" */ }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Connects to the \"travel\" room    connection.connect();    // ...",
      "language": "javascript"
    },
    {
      "code": "useEffect(() => {    // Your Effect connected to the room specified with roomId...    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      // ...until it disconnected      connection.disconnect();    };  }, [roomId]);",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId }) { // The roomId prop may change over time  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads roomId     connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]); // So you tell React that this Effect \"depends on\" roomId  // ...",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId }) {  useEffect(() => {    logVisit(roomId);    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]);  // ...}",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId }) {  useEffect(() => {    logVisit(roomId);  }, [roomId]);  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    // ...  }, [roomId]);  // ...}",
      "language": "javascript"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]);  // ...}",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId }) { // Props change over time  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // State may change over time  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Your Effect reads props and state    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId, serverUrl]); // So you tell React that this Effect \"depends on\" on props and state  // ...}",
      "language": "jsx"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234';const roomId = 'general';function ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, []); // âœ… All dependencies declared  // ...}",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId, selectedServerUrl }) { // roomId is reactive  const settings = useContext(SettingsContext); // settings is reactive  const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!  // ...}",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId }) { // roomId is reactive  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]); // âœ… All dependencies declared  // ...}",
      "language": "jsx"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234'; // serverUrl is not reactiveconst roomId = 'general'; // roomId is not reactivefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, []); // âœ… All dependencies declared  // ...}",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom() {  useEffect(() => {    const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive    const roomId = 'general'; // roomId is not reactive    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, []); // âœ… All dependencies declared  // ...}",
      "language": "javascript"
    },
    {
      "code": "useEffect(() => {  // ...  // ðŸ”´ Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);",
      "language": "jsx"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/learn/tutorial-tic-tac-toe",
    "https://react.dev/learn/thinking-in-react",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/creating-a-react-app",
    "https://react.dev/learn/build-a-react-app-from-scratch",
    "https://react.dev/learn/add-react-to-an-existing-project",
    "https://react.dev/learn/setup",
    "https://react.dev/learn/editor-setup",
    "https://react.dev/learn/typescript",
    "https://react.dev/learn/react-developer-tools",
    "https://react.dev/learn/react-compiler",
    "https://react.dev/learn/react-compiler/introduction",
    "https://react.dev/learn/react-compiler/installation",
    "https://react.dev/learn/react-compiler/incremental-adoption",
    "https://react.dev/learn/react-compiler/debugging",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/your-first-component",
    "https://react.dev/learn/importing-and-exporting-components",
    "https://react.dev/learn/writing-markup-with-jsx",
    "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/conditional-rendering",
    "https://react.dev/learn/rendering-lists",
    "https://react.dev/learn/keeping-components-pure",
    "https://react.dev/learn/understanding-your-ui-as-a-tree",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/responding-to-events",
    "https://react.dev/learn/state-a-components-memory",
    "https://react.dev/learn/render-and-commit",
    "https://react.dev/learn/state-as-a-snapshot",
    "https://react.dev/learn/queueing-a-series-of-state-updates",
    "https://react.dev/learn/updating-objects-in-state",
    "https://react.dev/learn/updating-arrays-in-state",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/reacting-to-input-with-state",
    "https://react.dev/learn/choosing-the-state-structure",
    "https://react.dev/learn/sharing-state-between-components",
    "https://react.dev/learn/preserving-and-resetting-state",
    "https://react.dev/learn/extracting-state-logic-into-a-reducer",
    "https://react.dev/learn/passing-data-deeply-with-context",
    "https://react.dev/learn/scaling-up-with-reducer-and-context",
    "https://react.dev/learn/escape-hatches",
    "https://react.dev/learn/referencing-values-with-refs",
    "https://react.dev/learn/manipulating-the-dom-with-refs",
    "https://react.dev/learn/synchronizing-with-effects",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/learn/lifecycle-of-reactive-effects",
    "https://react.dev/learn/separating-events-from-effects",
    "https://react.dev/learn/removing-effect-dependencies",
    "https://react.dev/learn/reusing-logic-with-custom-hooks",
    "https://react.dev/reference/react/useRef",
    "https://react.dev/reference/react/useState",
    "https://react.dev/reference/react-dom"
  ]
}