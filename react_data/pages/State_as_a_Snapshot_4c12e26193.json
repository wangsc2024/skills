{
  "url": "https://react.dev/learn/state-as-a-snapshot",
  "title": "State as a Snapshot",
  "content": "State variables might look like regular JavaScript variables that you can read and write to. However, state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render.\n\nYou might think of your user interface as changing directly in response to the user event like a click. In React, it works a little differently from this mental model. On the previous page, you saw that setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.\n\nIn this example, when you press “send”, setIsSent(true) tells React to re-render the UI:\n\nHere’s what happens when you click the button:\n\nLet’s take a closer look at the relationship between state and rendering.\n\n“Rendering” means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated using its state at the time of the render.\n\nUnlike a photograph or a movie frame, the UI “snapshot” you return is interactive. It includes logic like event handlers that specify what happens in response to inputs. React updates the screen to match this snapshot and connects the event handlers. As a result, pressing a button will trigger the click handler from your JSX.\n\nWhen React re-renders a component:\n\nIllustrated by Rachel Lee Nabors\n\nAs a component’s memory, state is not like a regular variable that disappears after your function returns. State actually “lives” in React itself—as if on a shelf!—outside of your function. When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!\n\nIllustrated by Rachel Lee Nabors\n\nHere’s a little experiment to show you how this works. In this example, you might expect that clicking the “+3” button would increment the counter three times because it calls setNumber(number + 1) three times.\n\nSee what happens when you click the “+3” button:\n\nNotice that number only increments once per click!\n\nSetting state only changes it for the next render. During the first render, number was 0. This is why, in that render’s onClick handler, the value of number is still 0 even after setNumber(number + 1) was called:\n\nHere is what this button’s click handler tells React to do:\n\nEven though you called setNumber(number + 1) three times, in this render’s event handler number is always 0, so you set the state to 1 three times. This is why, after your event handler finishes, React re-renders the component with number equal to 1 rather than 3.\n\nYou can also visualize this by mentally substituting state variables with their values in your code. Since the number state variable is 0 for this render, its event handler looks like this:\n\nFor the next render, number is 1, so that render’s click handler looks like this:\n\nThis is why clicking the button again will set the counter to 2, then to 3 on the next click, and so on.\n\nWell, that was fun. Try to guess what clicking this button will alert:\n\nIf you use the substitution method from before, you can guess that the alert shows “0”:\n\nBut what if you put a timer on the alert, so it only fires after the component re-rendered? Would it say “0” or “5”? Have a guess!\n\nSurprised? If you use the substitution method, you can see the “snapshot” of the state passed to the alert.\n\nThe state stored in React may have changed by the time the alert runs, but it was scheduled using a snapshot of the state at the time the user interacted with it!\n\nA state variable’s value never changes within a render, even if its event handler’s code is asynchronous. Inside that render’s onClick, the value of number continues to be 0 even after setNumber(number + 5) was called. Its value was “fixed” when React “took the snapshot” of the UI by calling your component.\n\nHere is an example of how that makes your event handlers less prone to timing mistakes. Below is a form that sends a message with a five-second delay. Imagine this scenario:\n\nWhat do you expect the alert to display? Would it display, “You said Hello to Alice”? Or would it display, “You said Hello to Bob”? Make a guess based on what you know, and then try it:\n\nReact keeps the state values “fixed” within one render’s event handlers. You don’t need to worry whether the state has changed while the code is running.\n\nBut what if you wanted to read the latest state before a re-render? You’ll want to use a state updater function, covered on the next page!\n\nHere is a crosswalk light component that toggles when the button is pressed:\n\nAdd an alert to the click handler. When the light is green and says “Walk”, clicking the button should say “Stop is next”. When the light is red and says “Stop”, clicking the button should say “Walk is next”.\n\nDoes it make a difference whether you put the alert before or after the setWalk call?",
  "headings": [
    {
      "level": "h1",
      "text": "State as a Snapshot",
      "id": ""
    },
    {
      "level": "h3",
      "text": "You will learn",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Setting state triggers renders",
      "id": "setting-state-triggers-renders"
    },
    {
      "level": "h2",
      "text": "Rendering takes a snapshot in time",
      "id": "rendering-takes-a-snapshot-in-time"
    },
    {
      "level": "h2",
      "text": "State over time",
      "id": "state-over-time"
    },
    {
      "level": "h2",
      "text": "Recap",
      "id": "recap"
    },
    {
      "level": "h2",
      "text": "Try out some challenges",
      "id": "challenges"
    },
    {
      "level": "h4",
      "text": "Challenge 1 of 1: Implement a traffic light",
      "id": "implement-a-traffic-light"
    }
  ],
  "code_samples": [
    {
      "code": "<button onClick={() => {  setNumber(number + 1);  setNumber(number + 1);  setNumber(number + 1);}}>+3</button>",
      "language": "jsx"
    },
    {
      "code": "<button onClick={() => {  setNumber(0 + 1);  setNumber(0 + 1);  setNumber(0 + 1);}}>+3</button>",
      "language": "jsx"
    },
    {
      "code": "<button onClick={() => {  setNumber(1 + 1);  setNumber(1 + 1);  setNumber(1 + 1);}}>+3</button>",
      "language": "jsx"
    },
    {
      "code": "setNumber(0 + 5);alert(0);",
      "language": "unknown"
    },
    {
      "code": "setNumber(0 + 5);setTimeout(() => {  alert(0);}, 3000);",
      "language": "javascript"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/learn/tutorial-tic-tac-toe",
    "https://react.dev/learn/thinking-in-react",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/creating-a-react-app",
    "https://react.dev/learn/build-a-react-app-from-scratch",
    "https://react.dev/learn/add-react-to-an-existing-project",
    "https://react.dev/learn/setup",
    "https://react.dev/learn/editor-setup",
    "https://react.dev/learn/typescript",
    "https://react.dev/learn/react-developer-tools",
    "https://react.dev/learn/react-compiler",
    "https://react.dev/learn/react-compiler/introduction",
    "https://react.dev/learn/react-compiler/installation",
    "https://react.dev/learn/react-compiler/incremental-adoption",
    "https://react.dev/learn/react-compiler/debugging",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/your-first-component",
    "https://react.dev/learn/importing-and-exporting-components",
    "https://react.dev/learn/writing-markup-with-jsx",
    "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/conditional-rendering",
    "https://react.dev/learn/rendering-lists",
    "https://react.dev/learn/keeping-components-pure",
    "https://react.dev/learn/understanding-your-ui-as-a-tree",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/responding-to-events",
    "https://react.dev/learn/state-a-components-memory",
    "https://react.dev/learn/render-and-commit",
    "https://react.dev/learn/state-as-a-snapshot",
    "https://react.dev/learn/queueing-a-series-of-state-updates",
    "https://react.dev/learn/updating-objects-in-state",
    "https://react.dev/learn/updating-arrays-in-state",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/reacting-to-input-with-state",
    "https://react.dev/learn/choosing-the-state-structure",
    "https://react.dev/learn/sharing-state-between-components",
    "https://react.dev/learn/preserving-and-resetting-state",
    "https://react.dev/learn/extracting-state-logic-into-a-reducer",
    "https://react.dev/learn/passing-data-deeply-with-context",
    "https://react.dev/learn/scaling-up-with-reducer-and-context",
    "https://react.dev/learn/escape-hatches",
    "https://react.dev/learn/referencing-values-with-refs",
    "https://react.dev/learn/manipulating-the-dom-with-refs",
    "https://react.dev/learn/synchronizing-with-effects",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/learn/lifecycle-of-reactive-effects",
    "https://react.dev/learn/separating-events-from-effects",
    "https://react.dev/learn/removing-effect-dependencies",
    "https://react.dev/learn/reusing-logic-with-custom-hooks",
    "https://react.dev/reference/react-dom"
  ]
}