{
  "url": "https://react.dev/reference/react-dom/components/input",
  "title": "<input>",
  "content": "The built-in browser <input> component lets you render different kinds of form inputs.\n\nTo display an input, render the built-in browser <input> component.\n\nSee more examples below.\n\n<input> supports all common element props.\n\nYou can make an input controlled by passing one of these props:\n\nWhen you pass either of them, you must also pass an onChange handler that updates the passed value.\n\nThese <input> props are only relevant for uncontrolled inputs:\n\nThese <input> props are relevant both for uncontrolled and controlled inputs:\n\nTo display an input, render an <input> component. By default, it will be a text input. You can pass type=\"checkbox\" for a checkbox, type=\"radio\" for a radio button, or one of the other input types.\n\nTypically, you will place every <input> inside a <label> tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input.\n\nIf you can‚Äôt nest <input> into a <label>, associate them by passing the same ID to <input id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.\n\nYou can optionally specify the initial value for any input. Pass it as the defaultValue string for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked boolean instead.\n\nAdd a <form> around your inputs with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).\n\nGive a name to every <input>, for example <input name=\"firstName\" defaultValue=\"Taylor\" />. The name you specified will be used as a key in the form data, for example { firstName: \"Taylor\" }.\n\nBy default, a <button> inside a <form> without a type attribute will submit it. This can be surprising! If you have your own custom Button React component, consider using <button type=\"button\"> instead of <button> (with no type). Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form.\n\nAn input like <input /> is uncontrolled. Even if you pass an initial value like <input defaultValue=\"Initial text\" />, your JSX only specifies the initial value. It does not control what the value should be right now.\n\nTo render a controlled input, pass the value prop to it (or checked for checkboxes and radios). React will force the input to always have the value you passed. Usually, you would do this by declaring a state variable:\n\nA controlled input makes sense if you needed state anyway‚Äîfor example, to re-render your UI on every edit:\n\nIt‚Äôs also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):\n\nThe value you pass to controlled components should not be undefined or null. If you need the initial value to be empty (such as with the firstName field below), initialize your state variable to an empty string ('').\n\nIf you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified.\n\nWhen you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There‚Äôs a few ways you can optimize re-rendering performance.\n\nFor example, suppose you start with a form that re-renders all page content on every keystroke:\n\nSince <PageContent /> doesn‚Äôt rely on the input state, you can move the input state into its own component:\n\nThis significantly improves performance because now only SignupForm re-renders on every keystroke.\n\nIf there is no way to avoid re-rendering (for example, if PageContent depends on the search input‚Äôs value), useDeferredValue lets you keep the controlled input responsive even in the middle of a large re-render.\n\nIf you render an input with value but no onChange, you will see an error in the console:\n\nAs the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:\n\nIf you want to control this input with a state variable, specify an onChange handler:\n\nIf the value is intentionally read-only, add a readOnly prop to suppress the error:\n\nIf you render a checkbox with checked but no onChange, you will see an error in the console:\n\nAs the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead:\n\nIf you want to control this checkbox with a state variable, specify an onChange handler:\n\nYou need to read e.target.checked rather than e.target.value for checkboxes.\n\nIf the checkbox is intentionally read-only, add a readOnly prop to suppress the error:\n\nIf you control an input, you must update its state variable to the input‚Äôs value from the DOM during onChange.\n\nYou can‚Äôt update it to something other than e.target.value (or e.target.checked for checkboxes):\n\nYou also can‚Äôt update it asynchronously:\n\nTo fix your code, update it synchronously to e.target.value:\n\nIf this doesn‚Äôt fix the problem, it‚Äôs possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you‚Äôre accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the ‚Äúinner‚Äù component to always be considered a different tree).\n\nIf you provide a value to the component, it must remain a string throughout its lifetime.\n\nYou cannot pass value={undefined} first and later pass value=\"some string\" because React won‚Äôt know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.\n\nIf your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.\n\nSimilarly, if you pass checked to a checkbox, ensure it‚Äôs always a boolean.",
  "headings": [
    {
      "level": "h1",
      "text": "<input>",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Reference",
      "id": "reference"
    },
    {
      "level": "h3",
      "text": "<input>",
      "id": "input"
    },
    {
      "level": "h4",
      "text": "Props",
      "id": "props"
    },
    {
      "level": "h4",
      "text": "Caveats",
      "id": "caveats"
    },
    {
      "level": "h2",
      "text": "Usage",
      "id": "usage"
    },
    {
      "level": "h3",
      "text": "Displaying inputs of different types",
      "id": "displaying-inputs-of-different-types"
    },
    {
      "level": "h3",
      "text": "Providing a label for an input",
      "id": "providing-a-label-for-an-input"
    },
    {
      "level": "h3",
      "text": "Providing an initial value for an input",
      "id": "providing-an-initial-value-for-an-input"
    },
    {
      "level": "h3",
      "text": "Reading the input values when submitting a form",
      "id": "reading-the-input-values-when-submitting-a-form"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Controlling an input with a state variable",
      "id": "controlling-an-input-with-a-state-variable"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Optimizing re-rendering on every keystroke",
      "id": "optimizing-re-rendering-on-every-keystroke"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h3",
      "text": "My text input doesn‚Äôt update when I type into it",
      "id": "my-text-input-doesnt-update-when-i-type-into-it"
    },
    {
      "level": "h3",
      "text": "My checkbox doesn‚Äôt update when I click on it",
      "id": "my-checkbox-doesnt-update-when-i-click-on-it"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h3",
      "text": "My input caret jumps to the beginning on every keystroke",
      "id": "my-input-caret-jumps-to-the-beginning-on-every-keystroke"
    },
    {
      "level": "h3",
      "text": "I‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù",
      "id": "im-getting-an-error-a-component-is-changing-an-uncontrolled-input-to-be-controlled"
    }
  ],
  "code_samples": [
    {
      "code": "<input name=\"myInput\" />",
      "language": "jsx"
    },
    {
      "code": "function Form() {  const [firstName, setFirstName] = useState(''); // Declare a state variable...  // ...  return (    <input      value={firstName} // ...force the input's value to match the state variable...      onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits!    />  );}",
      "language": "jsx"
    },
    {
      "code": "function Form() {  const [firstName, setFirstName] = useState('');  return (    <>      <label>        First name:        <input value={firstName} onChange={e => setFirstName(e.target.value)} />      </label>      {firstName !== '' && <p>Your name is {firstName}.</p>}      ...",
      "language": "jsx"
    },
    {
      "code": "function Form() {  // ...  const [age, setAge] = useState('');  const ageAsNumber = Number(age);  return (    <>      <label>        Age:        <input          value={age}          onChange={e => setAge(e.target.value)}          type=\"number\"        />        <button onClick={() => setAge(ageAsNumber + 10)}>          Add 10 years        </button>",
      "language": "jsx"
    },
    {
      "code": "function App() {  const [firstName, setFirstName] = useState('');  return (    <>      <form>        <input value={firstName} onChange={e => setFirstName(e.target.value)} />      </form>      <PageContent />    </>  );}",
      "language": "jsx"
    },
    {
      "code": "function App() {  return (    <>      <SignupForm />      <PageContent />    </>  );}function SignupForm() {  const [firstName, setFirstName] = useState('');  return (    <form>      <input value={firstName} onChange={e => setFirstName(e.target.value)} />    </form>  );}",
      "language": "jsx"
    },
    {
      "code": "// üî¥ Bug: controlled text input with no onChange handler<input value={something} />",
      "language": "jsx"
    },
    {
      "code": "// ‚úÖ Good: uncontrolled input with an initial value<input defaultValue={something} />",
      "language": "jsx"
    },
    {
      "code": "// ‚úÖ Good: controlled input with onChange<input value={something} onChange={e => setSomething(e.target.value)} />",
      "language": "jsx"
    },
    {
      "code": "// ‚úÖ Good: readonly controlled input without on change<input value={something} readOnly={true} />",
      "language": "jsx"
    },
    {
      "code": "// üî¥ Bug: controlled checkbox with no onChange handler<input type=\"checkbox\" checked={something} />",
      "language": "jsx"
    },
    {
      "code": "// ‚úÖ Good: uncontrolled checkbox with an initial value<input type=\"checkbox\" defaultChecked={something} />",
      "language": "jsx"
    },
    {
      "code": "// ‚úÖ Good: controlled checkbox with onChange<input type=\"checkbox\" checked={something} onChange={e => setSomething(e.target.checked)} />",
      "language": "jsx"
    },
    {
      "code": "// ‚úÖ Good: readonly controlled input without on change<input type=\"checkbox\" checked={something} readOnly={true} />",
      "language": "jsx"
    },
    {
      "code": "function handleChange(e) {  // üî¥ Bug: updating an input to something other than e.target.value  setFirstName(e.target.value.toUpperCase());}",
      "language": "javascript"
    },
    {
      "code": "function handleChange(e) {  // üî¥ Bug: updating an input asynchronously  setTimeout(() => {    setFirstName(e.target.value);  }, 100);}",
      "language": "javascript"
    },
    {
      "code": "function handleChange(e) {  // ‚úÖ Updating a controlled input to e.target.value synchronously  setFirstName(e.target.value);}",
      "language": "javascript"
    }
  ],
  "patterns": [
    {
      "description": "API ReferenceComponents<input>The built-in browser <input> component lets you render different kinds of form inputs.<input /> Reference <input> Usage Displaying inputs of different types Providing a label for an input Providing an initial value for an input Reading the input values when submitting a form Controlling an input with a state variable Optimizing re-rendering on every keystroke Troubleshooting My text input doesn‚Äôt update when I type into it My checkbox doesn‚Äôt update when I click on it My input caret jumps to the beginning on every keystroke I‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù Reference <input> To display an input, render the built-in browser <input> component. <input name=\"myInput\" /> See more examples below. Props <input> supports all common element props. formAction: A string or function. Overrides the parent <form action> for type=\"submit\" and type=\"image\". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>. You can make an input controlled by passing one of these props: checked: A boolean. For a checkbox input or a radio button, controls whether it is selected. value: A string. For a text input, controls its text. (For a radio button, specifies its form data.) When you pass either of them, you must also pass an onChange handler that updates the passed value. These <input> props are only relevant for uncontrolled inputs: defaultChecked: A boolean. Specifies the initial value for type=\"checkbox\" and type=\"radio\" inputs. defaultValue: A string. Specifies the initial value for a text input. These <input> props are relevant both for uncontrolled and controlled inputs: accept: A string. Specifies which filetypes are accepted by a type=\"file\" input. alt: A string. Specifies the alternative image text for a type=\"image\" input. capture: A string. Specifies the media (microphone, video, or camera) captured by a type=\"file\" input. autoComplete: A string. Specifies one of the possible autocomplete behaviors. autoFocus: A boolean. If true, React will focus the element on mount. dirname: A string. Specifies the form field name for the element‚Äôs directionality. disabled: A boolean. If true, the input will not be interactive and will appear dimmed. children: <input> does not accept children. form: A string. Specifies the id of the <form> this input belongs to. If omitted, it‚Äôs the closest parent form. formAction: A string. Overrides the parent <form action> for type=\"submit\" and type=\"image\". formEnctype: A string. Overrides the parent <form enctype> for type=\"submit\" and type=\"image\". formMethod: A string. Overrides the parent <form method> for type=\"submit\" and type=\"image\". formNoValidate: A string. Overrides the parent <form noValidate> for type=\"submit\" and type=\"image\". formTarget: A string. Overrides the parent <form target> for type=\"submit\" and type=\"image\". height: A string. Specifies the image height for type=\"image\". list: A string. Specifies the id of the <datalist> with the autocomplete options. max: A number. Specifies the maximum value of numerical and datetime inputs. maxLength: A number. Specifies the maximum length of text and other inputs. min: A number. Specifies the minimum value of numerical and datetime inputs. minLength: A number. Specifies the minimum length of text and other inputs. multiple: A boolean. Specifies whether multiple values are allowed for <type=\"file\" and type=\"email\". name: A string. Specifies the name for this input that‚Äôs submitted with the form. onChange: An Event handler function. Required for controlled inputs. Fires immediately when the input‚Äôs value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event. onChangeCapture: A version of onChange that fires in the capture phase. onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly. onInputCapture: A version of onInput that fires in the capture phase. onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles. onInvalidCapture: A version of onInvalid that fires in the capture phase. onSelect: An Event handler function. Fires after the selection inside the <input> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection). onSelectCapture: A version of onSelect that fires in the capture phase. pattern: A string. Specifies the pattern that the value must match. placeholder: A string. Displayed in a dimmed color when the input value is empty. readOnly: A boolean. If true, the input is not editable by the user. required: A boolean. If true, the value must be provided for the form to submit. size: A number. Similar to setting width, but the unit depends on the control. src: A string. Specifies the image source for a type=\"image\" input. step: A positive number or an 'any' string. Specifies the distance between valid values. type: A string. One of the input types. width: A string. Specifies the image width for a type=\"image\" input. Caveats Checkboxes need checked (or defaultChecked), not value (or defaultValue). If a text input receives a string value prop, it will be treated as controlled. If a checkbox or a radio button receives a boolean checked prop, it will be treated as controlled. An input can‚Äôt be both controlled and uncontrolled at the same time. An input cannot switch between being controlled or uncontrolled over its lifetime. Every controlled input needs an onChange event handler that synchronously updates its backing value. Usage Displaying inputs of different types To display an input, render an <input> component. By default, it will be a text input. You can pass type=\"checkbox\" for a checkbox, type=\"radio\" for a radio button, or one of the other input types. App.jsApp.jsReloadClearForkexport default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); } Show more Providing a label for an input Typically, you will place every <input> inside a <label> tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input. If you can‚Äôt nest <input> into a <label>, associate them by passing the same ID to <input id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId. App.jsApp.jsReloadClearForkimport { useId } from 'react'; export default function Form() { const ageInputId = useId(); return ( <> <label> Your first name: <input name=\"firstName\" /> </label> <hr /> <label htmlFor={ageInputId}>Your age:</label> <input id={ageInputId} name=\"age\" type=\"number\" /> </> ); } Show more Providing an initial value for an input You can optionally specify the initial value for any input. Pass it as the defaultValue string for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked boolean instead. App.jsApp.jsReloadClearForkexport default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); } Show more Reading the input values when submitting a form Add a <form> around your inputs with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target). App.jsApp.jsReloadClearForkexport default function MyForm() { function handleSubmit(e) { // Prevent the browser from reloading the page e.preventDefault(); // Read the form data const form = e.target; const formData = new FormData(form); // You can pass formData as a fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // Or you can work with it as a plain object: const formJson = Object.fromEntries(formData.entries()); console.log(formJson); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label><input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3</label> </p> <hr /> <button type=\"reset\">Reset form</button> <button type=\"submit\">Submit form</button> </form> ); } Show more NoteGive a name to every <input>, for example <input name=\"firstName\" defaultValue=\"Taylor\" />. The name you specified will be used as a key in the form data, for example { firstName: \"Taylor\" }. PitfallBy default, a <button> inside a <form> without a type attribute will submit it. This can be surprising! If you have your own custom Button React component, consider using <button type=\"button\"> instead of <button> (with no type). Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form. Controlling an input with a state variable An input like <input /> is uncontrolled. Even if you pass an initial value like <input defaultValue=\"Initial text\" />, your JSX only specifies the initial value. It does not control what the value should be right now. To render a controlled input, pass the value prop to it (or checked for checkboxes and radios). React will force the input to always have the value you passed. Usually, you would do this by declaring a state variable: function Form() { const [firstName, setFirstName] = useState(''); // Declare a state variable... // ... return ( <input value={firstName} // ...force the input's value to match the state variable... onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits! /> );} A controlled input makes sense if you needed state anyway‚Äîfor example, to re-render your UI on every edit: function Form() { const [firstName, setFirstName] = useState(''); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> {firstName !== '' && <p>Your name is {firstName}.</p>} ... It‚Äôs also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button): function Form() { // ... const [age, setAge] = useState(''); const ageAsNumber = Number(age); return ( <> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> The value you pass to controlled components should not be undefined or null. If you need the initial value to be empty (such as with the firstName field below), initialize your state variable to an empty string (''). App.jsApp.jsReloadClearForkimport { useState } from 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [age, setAge] = useState('20'); const ageAsNumber = Number(age); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> </label> {firstName !== '' && <p>Your name is {firstName}.</p> } {ageAsNumber > 0 && <p>Your age is {ageAsNumber}.</p> } </> ); } Show more PitfallIf you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified. Optimizing re-rendering on every keystroke When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There‚Äôs a few ways you can optimize re-rendering performance. For example, suppose you start with a form that re-renders all page content on every keystroke: function App() { const [firstName, setFirstName] = useState(''); return ( <> <form> <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </form> <PageContent /> </> );} Since <PageContent /> doesn‚Äôt rely on the input state, you can move the input state into its own component: function App() { return ( <> <SignupForm /> <PageContent /> </> );}function SignupForm() { const [firstName, setFirstName] = useState(''); return ( <form> <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </form> );} This significantly improves performance because now only SignupForm re-renders on every keystroke. If there is no way to avoid re-rendering (for example, if PageContent depends on the search input‚Äôs value), useDeferredValue lets you keep the controlled input responsive even in the middle of a large re-render. Troubleshooting My text input doesn‚Äôt update when I type into it If you render an input with value but no onChange, you will see an error in the console: // üî¥ Bug: controlled text input with no onChange handler<input value={something} /> ConsoleYou provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly. As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead: // ‚úÖ Good: uncontrolled input with an initial value<input defaultValue={something} /> If you want to control this input with a state variable, specify an onChange handler: // ‚úÖ Good: controlled input with onChange<input value={something} onChange={e => setSomething(e.target.value)} /> If the value is intentionally read-only, add a readOnly prop to suppress the error: // ‚úÖ Good: readonly controlled input without on change<input value={something} readOnly={true} /> My checkbox doesn‚Äôt update when I click on it If you render a checkbox with checked but no onChange, you will see an error in the console: // üî¥ Bug: controlled checkbox with no onChange handler<input type=\"checkbox\" checked={something} /> ConsoleYou provided a checked prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultChecked. Otherwise, set either onChange or readOnly. As the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead: // ‚úÖ Good: uncontrolled checkbox with an initial value<input type=\"checkbox\" defaultChecked={something} /> If you want to control this checkbox with a state variable, specify an onChange handler: // ‚úÖ Good: controlled checkbox with onChange<input type=\"checkbox\" checked={something} onChange={e => setSomething(e.target.checked)} /> PitfallYou need to read e.target.checked rather than e.target.value for checkboxes. If the checkbox is intentionally read-only, add a readOnly prop to suppress the error: // ‚úÖ Good: readonly controlled input without on change<input type=\"checkbox\" checked={something} readOnly={true} /> My input caret jumps to the beginning on every keystroke If you control an input, you must update its state variable to the input‚Äôs value from the DOM during onChange. You can‚Äôt update it to something other than e.target.value (or e.target.checked for checkboxes): function handleChange(e) { // üî¥ Bug: updating an input to something other than e.target.value setFirstName(e.target.value.toUpperCase());} You also can‚Äôt update it asynchronously: function handleChange(e) { // üî¥ Bug: updating an input asynchronously setTimeout(() => { setFirstName(e.target.value); }, 100);} To fix your code, update it synchronously to e.target.value: function handleChange(e) { // ‚úÖ Updating a controlled input to e.target.value synchronously setFirstName(e.target.value);} If this doesn‚Äôt fix the problem, it‚Äôs possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you‚Äôre accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the ‚Äúinner‚Äù component to always be considered a different tree). I‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù If you provide a value to the component, it must remain a string throughout its lifetime. You cannot pass value={undefined} first and later pass value=\"some string\" because React won‚Äôt know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined. If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string. Similarly, if you pass checked to a checkbox, ensure it‚Äôs always a boolean.Previous<form>Next<option>",
      "code": "<input>"
    },
    {
      "description": "The built-in browser <input> component lets you render different kinds of form inputs.<input /> Reference <input> Usage Displaying inputs of different types Providing a label for an input Providing an initial value for an input Reading the input values when submitting a form Controlling an input with a state variable Optimizing re-rendering on every keystroke Troubleshooting My text input doesn‚Äôt update when I type into it My checkbox doesn‚Äôt update when I click on it My input caret jumps to the beginning on every keystroke I‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù Reference <input> To display an input, render the built-in browser <input> component. <input name=\"myInput\" /> See more examples below. Props <input> supports all common element props. formAction: A string or function. Overrides the parent <form action> for type=\"submit\" and type=\"image\". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>. You can make an input controlled by passing one of these props: checked: A boolean. For a checkbox input or a radio button, controls whether it is selected. value: A string. For a text input, controls its text. (For a radio button, specifies its form data.) When you pass either of them, you must also pass an onChange handler that updates the passed value. These <input> props are only relevant for uncontrolled inputs: defaultChecked: A boolean. Specifies the initial value for type=\"checkbox\" and type=\"radio\" inputs. defaultValue: A string. Specifies the initial value for a text input. These <input> props are relevant both for uncontrolled and controlled inputs: accept: A string. Specifies which filetypes are accepted by a type=\"file\" input. alt: A string. Specifies the alternative image text for a type=\"image\" input. capture: A string. Specifies the media (microphone, video, or camera) captured by a type=\"file\" input. autoComplete: A string. Specifies one of the possible autocomplete behaviors. autoFocus: A boolean. If true, React will focus the element on mount. dirname: A string. Specifies the form field name for the element‚Äôs directionality. disabled: A boolean. If true, the input will not be interactive and will appear dimmed. children: <input> does not accept children. form: A string. Specifies the id of the <form> this input belongs to. If omitted, it‚Äôs the closest parent form. formAction: A string. Overrides the parent <form action> for type=\"submit\" and type=\"image\". formEnctype: A string. Overrides the parent <form enctype> for type=\"submit\" and type=\"image\". formMethod: A string. Overrides the parent <form method> for type=\"submit\" and type=\"image\". formNoValidate: A string. Overrides the parent <form noValidate> for type=\"submit\" and type=\"image\". formTarget: A string. Overrides the parent <form target> for type=\"submit\" and type=\"image\". height: A string. Specifies the image height for type=\"image\". list: A string. Specifies the id of the <datalist> with the autocomplete options. max: A number. Specifies the maximum value of numerical and datetime inputs. maxLength: A number. Specifies the maximum length of text and other inputs. min: A number. Specifies the minimum value of numerical and datetime inputs. minLength: A number. Specifies the minimum length of text and other inputs. multiple: A boolean. Specifies whether multiple values are allowed for <type=\"file\" and type=\"email\". name: A string. Specifies the name for this input that‚Äôs submitted with the form. onChange: An Event handler function. Required for controlled inputs. Fires immediately when the input‚Äôs value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event. onChangeCapture: A version of onChange that fires in the capture phase. onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly. onInputCapture: A version of onInput that fires in the capture phase. onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles. onInvalidCapture: A version of onInvalid that fires in the capture phase. onSelect: An Event handler function. Fires after the selection inside the <input> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection). onSelectCapture: A version of onSelect that fires in the capture phase. pattern: A string. Specifies the pattern that the value must match. placeholder: A string. Displayed in a dimmed color when the input value is empty. readOnly: A boolean. If true, the input is not editable by the user. required: A boolean. If true, the value must be provided for the form to submit. size: A number. Similar to setting width, but the unit depends on the control. src: A string. Specifies the image source for a type=\"image\" input. step: A positive number or an 'any' string. Specifies the distance between valid values. type: A string. One of the input types. width: A string. Specifies the image width for a type=\"image\" input. Caveats Checkboxes need checked (or defaultChecked), not value (or defaultValue). If a text input receives a string value prop, it will be treated as controlled. If a checkbox or a radio button receives a boolean checked prop, it will be treated as controlled. An input can‚Äôt be both controlled and uncontrolled at the same time. An input cannot switch between being controlled or uncontrolled over its lifetime. Every controlled input needs an onChange event handler that synchronously updates its backing value. Usage Displaying inputs of different types To display an input, render an <input> component. By default, it will be a text input. You can pass type=\"checkbox\" for a checkbox, type=\"radio\" for a radio button, or one of the other input types. App.jsApp.jsReloadClearForkexport default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); } Show more Providing a label for an input Typically, you will place every <input> inside a <label> tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input. If you can‚Äôt nest <input> into a <label>, associate them by passing the same ID to <input id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId. App.jsApp.jsReloadClearForkimport { useId } from 'react'; export default function Form() { const ageInputId = useId(); return ( <> <label> Your first name: <input name=\"firstName\" /> </label> <hr /> <label htmlFor={ageInputId}>Your age:</label> <input id={ageInputId} name=\"age\" type=\"number\" /> </> ); } Show more Providing an initial value for an input You can optionally specify the initial value for any input. Pass it as the defaultValue string for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked boolean instead. App.jsApp.jsReloadClearForkexport default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); } Show more Reading the input values when submitting a form Add a <form> around your inputs with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target). App.jsApp.jsReloadClearForkexport default function MyForm() { function handleSubmit(e) { // Prevent the browser from reloading the page e.preventDefault(); // Read the form data const form = e.target; const formData = new FormData(form); // You can pass formData as a fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // Or you can work with it as a plain object: const formJson = Object.fromEntries(formData.entries()); console.log(formJson); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label><input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3</label> </p> <hr /> <button type=\"reset\">Reset form</button> <button type=\"submit\">Submit form</button> </form> ); } Show more NoteGive a name to every <input>, for example <input name=\"firstName\" defaultValue=\"Taylor\" />. The name you specified will be used as a key in the form data, for example { firstName: \"Taylor\" }. PitfallBy default, a <button> inside a <form> without a type attribute will submit it. This can be surprising! If you have your own custom Button React component, consider using <button type=\"button\"> instead of <button> (with no type). Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form. Controlling an input with a state variable An input like <input /> is uncontrolled. Even if you pass an initial value like <input defaultValue=\"Initial text\" />, your JSX only specifies the initial value. It does not control what the value should be right now. To render a controlled input, pass the value prop to it (or checked for checkboxes and radios). React will force the input to always have the value you passed. Usually, you would do this by declaring a state variable: function Form() { const [firstName, setFirstName] = useState(''); // Declare a state variable... // ... return ( <input value={firstName} // ...force the input's value to match the state variable... onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits! /> );} A controlled input makes sense if you needed state anyway‚Äîfor example, to re-render your UI on every edit: function Form() { const [firstName, setFirstName] = useState(''); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> {firstName !== '' && <p>Your name is {firstName}.</p>} ... It‚Äôs also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button): function Form() { // ... const [age, setAge] = useState(''); const ageAsNumber = Number(age); return ( <> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> The value you pass to controlled components should not be undefined or null. If you need the initial value to be empty (such as with the firstName field below), initialize your state variable to an empty string (''). App.jsApp.jsReloadClearForkimport { useState } from 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [age, setAge] = useState('20'); const ageAsNumber = Number(age); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> </label> {firstName !== '' && <p>Your name is {firstName}.</p> } {ageAsNumber > 0 && <p>Your age is {ageAsNumber}.</p> } </> ); } Show more PitfallIf you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified. Optimizing re-rendering on every keystroke When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There‚Äôs a few ways you can optimize re-rendering performance. For example, suppose you start with a form that re-renders all page content on every keystroke: function App() { const [firstName, setFirstName] = useState(''); return ( <> <form> <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </form> <PageContent /> </> );} Since <PageContent /> doesn‚Äôt rely on the input state, you can move the input state into its own component: function App() { return ( <> <SignupForm /> <PageContent /> </> );}function SignupForm() { const [firstName, setFirstName] = useState(''); return ( <form> <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </form> );} This significantly improves performance because now only SignupForm re-renders on every keystroke. If there is no way to avoid re-rendering (for example, if PageContent depends on the search input‚Äôs value), useDeferredValue lets you keep the controlled input responsive even in the middle of a large re-render. Troubleshooting My text input doesn‚Äôt update when I type into it If you render an input with value but no onChange, you will see an error in the console: // üî¥ Bug: controlled text input with no onChange handler<input value={something} /> ConsoleYou provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly. As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead: // ‚úÖ Good: uncontrolled input with an initial value<input defaultValue={something} /> If you want to control this input with a state variable, specify an onChange handler: // ‚úÖ Good: controlled input with onChange<input value={something} onChange={e => setSomething(e.target.value)} /> If the value is intentionally read-only, add a readOnly prop to suppress the error: // ‚úÖ Good: readonly controlled input without on change<input value={something} readOnly={true} /> My checkbox doesn‚Äôt update when I click on it If you render a checkbox with checked but no onChange, you will see an error in the console: // üî¥ Bug: controlled checkbox with no onChange handler<input type=\"checkbox\" checked={something} /> ConsoleYou provided a checked prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultChecked. Otherwise, set either onChange or readOnly. As the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead: // ‚úÖ Good: uncontrolled checkbox with an initial value<input type=\"checkbox\" defaultChecked={something} /> If you want to control this checkbox with a state variable, specify an onChange handler: // ‚úÖ Good: controlled checkbox with onChange<input type=\"checkbox\" checked={something} onChange={e => setSomething(e.target.checked)} /> PitfallYou need to read e.target.checked rather than e.target.value for checkboxes. If the checkbox is intentionally read-only, add a readOnly prop to suppress the error: // ‚úÖ Good: readonly controlled input without on change<input type=\"checkbox\" checked={something} readOnly={true} /> My input caret jumps to the beginning on every keystroke If you control an input, you must update its state variable to the input‚Äôs value from the DOM during onChange. You can‚Äôt update it to something other than e.target.value (or e.target.checked for checkboxes): function handleChange(e) { // üî¥ Bug: updating an input to something other than e.target.value setFirstName(e.target.value.toUpperCase());} You also can‚Äôt update it asynchronously: function handleChange(e) { // üî¥ Bug: updating an input asynchronously setTimeout(() => { setFirstName(e.target.value); }, 100);} To fix your code, update it synchronously to e.target.value: function handleChange(e) { // ‚úÖ Updating a controlled input to e.target.value synchronously setFirstName(e.target.value);} If this doesn‚Äôt fix the problem, it‚Äôs possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you‚Äôre accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the ‚Äúinner‚Äù component to always be considered a different tree). I‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù If you provide a value to the component, it must remain a string throughout its lifetime. You cannot pass value={undefined} first and later pass value=\"some string\" because React won‚Äôt know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined. If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string. Similarly, if you pass checked to a checkbox, ensure it‚Äôs always a boolean.Previous<form>Next<option>",
      "code": "<input>"
    },
    {
      "description": "The built-in browser <input> component lets you render different kinds of form inputs.<input /> Reference <input> Usage Displaying inputs of different types Providing a label for an input Providing an initial value for an input Reading the input values when submitting a form Controlling an input with a state variable Optimizing re-rendering on every keystroke Troubleshooting My text input doesn‚Äôt update when I type into it My checkbox doesn‚Äôt update when I click on it My input caret jumps to the beginning on every keystroke I‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù Reference <input> To display an input, render the built-in browser <input> component. <input name=\"myInput\" /> See more examples below. Props <input> supports all common element props. formAction: A string or function. Overrides the parent <form action> for type=\"submit\" and type=\"image\". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>. You can make an input controlled by passing one of these props: checked: A boolean. For a checkbox input or a radio button, controls whether it is selected. value: A string. For a text input, controls its text. (For a radio button, specifies its form data.) When you pass either of them, you must also pass an onChange handler that updates the passed value. These <input> props are only relevant for uncontrolled inputs: defaultChecked: A boolean. Specifies the initial value for type=\"checkbox\" and type=\"radio\" inputs. defaultValue: A string. Specifies the initial value for a text input. These <input> props are relevant both for uncontrolled and controlled inputs: accept: A string. Specifies which filetypes are accepted by a type=\"file\" input. alt: A string. Specifies the alternative image text for a type=\"image\" input. capture: A string. Specifies the media (microphone, video, or camera) captured by a type=\"file\" input. autoComplete: A string. Specifies one of the possible autocomplete behaviors. autoFocus: A boolean. If true, React will focus the element on mount. dirname: A string. Specifies the form field name for the element‚Äôs directionality. disabled: A boolean. If true, the input will not be interactive and will appear dimmed. children: <input> does not accept children. form: A string. Specifies the id of the <form> this input belongs to. If omitted, it‚Äôs the closest parent form. formAction: A string. Overrides the parent <form action> for type=\"submit\" and type=\"image\". formEnctype: A string. Overrides the parent <form enctype> for type=\"submit\" and type=\"image\". formMethod: A string. Overrides the parent <form method> for type=\"submit\" and type=\"image\". formNoValidate: A string. Overrides the parent <form noValidate> for type=\"submit\" and type=\"image\". formTarget: A string. Overrides the parent <form target> for type=\"submit\" and type=\"image\". height: A string. Specifies the image height for type=\"image\". list: A string. Specifies the id of the <datalist> with the autocomplete options. max: A number. Specifies the maximum value of numerical and datetime inputs. maxLength: A number. Specifies the maximum length of text and other inputs. min: A number. Specifies the minimum value of numerical and datetime inputs. minLength: A number. Specifies the minimum length of text and other inputs. multiple: A boolean. Specifies whether multiple values are allowed for <type=\"file\" and type=\"email\". name: A string. Specifies the name for this input that‚Äôs submitted with the form. onChange: An Event handler function. Required for controlled inputs. Fires immediately when the input‚Äôs value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event. onChangeCapture: A version of onChange that fires in the capture phase. onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly. onInputCapture: A version of onInput that fires in the capture phase. onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles. onInvalidCapture: A version of onInvalid that fires in the capture phase. onSelect: An Event handler function. Fires after the selection inside the <input> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection). onSelectCapture: A version of onSelect that fires in the capture phase. pattern: A string. Specifies the pattern that the value must match. placeholder: A string. Displayed in a dimmed color when the input value is empty. readOnly: A boolean. If true, the input is not editable by the user. required: A boolean. If true, the value must be provided for the form to submit. size: A number. Similar to setting width, but the unit depends on the control. src: A string. Specifies the image source for a type=\"image\" input. step: A positive number or an 'any' string. Specifies the distance between valid values. type: A string. One of the input types. width: A string. Specifies the image width for a type=\"image\" input. Caveats Checkboxes need checked (or defaultChecked), not value (or defaultValue). If a text input receives a string value prop, it will be treated as controlled. If a checkbox or a radio button receives a boolean checked prop, it will be treated as controlled. An input can‚Äôt be both controlled and uncontrolled at the same time. An input cannot switch between being controlled or uncontrolled over its lifetime. Every controlled input needs an onChange event handler that synchronously updates its backing value. Usage Displaying inputs of different types To display an input, render an <input> component. By default, it will be a text input. You can pass type=\"checkbox\" for a checkbox, type=\"radio\" for a radio button, or one of the other input types. App.jsApp.jsReloadClearForkexport default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); } Show more Providing a label for an input Typically, you will place every <input> inside a <label> tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input. If you can‚Äôt nest <input> into a <label>, associate them by passing the same ID to <input id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId. App.jsApp.jsReloadClearForkimport { useId } from 'react'; export default function Form() { const ageInputId = useId(); return ( <> <label> Your first name: <input name=\"firstName\" /> </label> <hr /> <label htmlFor={ageInputId}>Your age:</label> <input id={ageInputId} name=\"age\" type=\"number\" /> </> ); } Show more Providing an initial value for an input You can optionally specify the initial value for any input. Pass it as the defaultValue string for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked boolean instead. App.jsApp.jsReloadClearForkexport default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); } Show more Reading the input values when submitting a form Add a <form> around your inputs with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target). App.jsApp.jsReloadClearForkexport default function MyForm() { function handleSubmit(e) { // Prevent the browser from reloading the page e.preventDefault(); // Read the form data const form = e.target; const formData = new FormData(form); // You can pass formData as a fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // Or you can work with it as a plain object: const formJson = Object.fromEntries(formData.entries()); console.log(formJson); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label><input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3</label> </p> <hr /> <button type=\"reset\">Reset form</button> <button type=\"submit\">Submit form</button> </form> ); } Show more NoteGive a name to every <input>, for example <input name=\"firstName\" defaultValue=\"Taylor\" />. The name you specified will be used as a key in the form data, for example { firstName: \"Taylor\" }. PitfallBy default, a <button> inside a <form> without a type attribute will submit it. This can be surprising! If you have your own custom Button React component, consider using <button type=\"button\"> instead of <button> (with no type). Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form. Controlling an input with a state variable An input like <input /> is uncontrolled. Even if you pass an initial value like <input defaultValue=\"Initial text\" />, your JSX only specifies the initial value. It does not control what the value should be right now. To render a controlled input, pass the value prop to it (or checked for checkboxes and radios). React will force the input to always have the value you passed. Usually, you would do this by declaring a state variable: function Form() { const [firstName, setFirstName] = useState(''); // Declare a state variable... // ... return ( <input value={firstName} // ...force the input's value to match the state variable... onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits! /> );} A controlled input makes sense if you needed state anyway‚Äîfor example, to re-render your UI on every edit: function Form() { const [firstName, setFirstName] = useState(''); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> {firstName !== '' && <p>Your name is {firstName}.</p>} ... It‚Äôs also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button): function Form() { // ... const [age, setAge] = useState(''); const ageAsNumber = Number(age); return ( <> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> The value you pass to controlled components should not be undefined or null. If you need the initial value to be empty (such as with the firstName field below), initialize your state variable to an empty string (''). App.jsApp.jsReloadClearForkimport { useState } from 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [age, setAge] = useState('20'); const ageAsNumber = Number(age); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> </label> {firstName !== '' && <p>Your name is {firstName}.</p> } {ageAsNumber > 0 && <p>Your age is {ageAsNumber}.</p> } </> ); } Show more PitfallIf you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified. Optimizing re-rendering on every keystroke When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There‚Äôs a few ways you can optimize re-rendering performance. For example, suppose you start with a form that re-renders all page content on every keystroke: function App() { const [firstName, setFirstName] = useState(''); return ( <> <form> <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </form> <PageContent /> </> );} Since <PageContent /> doesn‚Äôt rely on the input state, you can move the input state into its own component: function App() { return ( <> <SignupForm /> <PageContent /> </> );}function SignupForm() { const [firstName, setFirstName] = useState(''); return ( <form> <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </form> );} This significantly improves performance because now only SignupForm re-renders on every keystroke. If there is no way to avoid re-rendering (for example, if PageContent depends on the search input‚Äôs value), useDeferredValue lets you keep the controlled input responsive even in the middle of a large re-render. Troubleshooting My text input doesn‚Äôt update when I type into it If you render an input with value but no onChange, you will see an error in the console: // üî¥ Bug: controlled text input with no onChange handler<input value={something} /> ConsoleYou provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly. As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead: // ‚úÖ Good: uncontrolled input with an initial value<input defaultValue={something} /> If you want to control this input with a state variable, specify an onChange handler: // ‚úÖ Good: controlled input with onChange<input value={something} onChange={e => setSomething(e.target.value)} /> If the value is intentionally read-only, add a readOnly prop to suppress the error: // ‚úÖ Good: readonly controlled input without on change<input value={something} readOnly={true} /> My checkbox doesn‚Äôt update when I click on it If you render a checkbox with checked but no onChange, you will see an error in the console: // üî¥ Bug: controlled checkbox with no onChange handler<input type=\"checkbox\" checked={something} /> ConsoleYou provided a checked prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultChecked. Otherwise, set either onChange or readOnly. As the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead: // ‚úÖ Good: uncontrolled checkbox with an initial value<input type=\"checkbox\" defaultChecked={something} /> If you want to control this checkbox with a state variable, specify an onChange handler: // ‚úÖ Good: controlled checkbox with onChange<input type=\"checkbox\" checked={something} onChange={e => setSomething(e.target.checked)} /> PitfallYou need to read e.target.checked rather than e.target.value for checkboxes. If the checkbox is intentionally read-only, add a readOnly prop to suppress the error: // ‚úÖ Good: readonly controlled input without on change<input type=\"checkbox\" checked={something} readOnly={true} /> My input caret jumps to the beginning on every keystroke If you control an input, you must update its state variable to the input‚Äôs value from the DOM during onChange. You can‚Äôt update it to something other than e.target.value (or e.target.checked for checkboxes): function handleChange(e) { // üî¥ Bug: updating an input to something other than e.target.value setFirstName(e.target.value.toUpperCase());} You also can‚Äôt update it asynchronously: function handleChange(e) { // üî¥ Bug: updating an input asynchronously setTimeout(() => { setFirstName(e.target.value); }, 100);} To fix your code, update it synchronously to e.target.value: function handleChange(e) { // ‚úÖ Updating a controlled input to e.target.value synchronously setFirstName(e.target.value);} If this doesn‚Äôt fix the problem, it‚Äôs possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you‚Äôre accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the ‚Äúinner‚Äù component to always be considered a different tree). I‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù If you provide a value to the component, it must remain a string throughout its lifetime. You cannot pass value={undefined} first and later pass value=\"some string\" because React won‚Äôt know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined. If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string. Similarly, if you pass checked to a checkbox, ensure it‚Äôs always a boolean.",
      "code": "<input>"
    },
    {
      "description": "The built-in browser <input> component lets you render different kinds of form inputs.<input /> Reference <input> Usage Displaying inputs of different types Providing a label for an input Providing an initial value for an input Reading the input values when submitting a form Controlling an input with a state variable Optimizing re-rendering on every keystroke Troubleshooting My text input doesn‚Äôt update when I type into it My checkbox doesn‚Äôt update when I click on it My input caret jumps to the beginning on every keystroke I‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù Reference <input> To display an input, render the built-in browser <input> component. <input name=\"myInput\" /> See more examples below. Props <input> supports all common element props. formAction: A string or function. Overrides the parent <form action> for type=\"submit\" and type=\"image\". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>. You can make an input controlled by passing one of these props: checked: A boolean. For a checkbox input or a radio button, controls whether it is selected. value: A string. For a text input, controls its text. (For a radio button, specifies its form data.) When you pass either of them, you must also pass an onChange handler that updates the passed value. These <input> props are only relevant for uncontrolled inputs: defaultChecked: A boolean. Specifies the initial value for type=\"checkbox\" and type=\"radio\" inputs. defaultValue: A string. Specifies the initial value for a text input. These <input> props are relevant both for uncontrolled and controlled inputs: accept: A string. Specifies which filetypes are accepted by a type=\"file\" input. alt: A string. Specifies the alternative image text for a type=\"image\" input. capture: A string. Specifies the media (microphone, video, or camera) captured by a type=\"file\" input. autoComplete: A string. Specifies one of the possible autocomplete behaviors. autoFocus: A boolean. If true, React will focus the element on mount. dirname: A string. Specifies the form field name for the element‚Äôs directionality. disabled: A boolean. If true, the input will not be interactive and will appear dimmed. children: <input> does not accept children. form: A string. Specifies the id of the <form> this input belongs to. If omitted, it‚Äôs the closest parent form. formAction: A string. Overrides the parent <form action> for type=\"submit\" and type=\"image\". formEnctype: A string. Overrides the parent <form enctype> for type=\"submit\" and type=\"image\". formMethod: A string. Overrides the parent <form method> for type=\"submit\" and type=\"image\". formNoValidate: A string. Overrides the parent <form noValidate> for type=\"submit\" and type=\"image\". formTarget: A string. Overrides the parent <form target> for type=\"submit\" and type=\"image\". height: A string. Specifies the image height for type=\"image\". list: A string. Specifies the id of the <datalist> with the autocomplete options. max: A number. Specifies the maximum value of numerical and datetime inputs. maxLength: A number. Specifies the maximum length of text and other inputs. min: A number. Specifies the minimum value of numerical and datetime inputs. minLength: A number. Specifies the minimum length of text and other inputs. multiple: A boolean. Specifies whether multiple values are allowed for <type=\"file\" and type=\"email\". name: A string. Specifies the name for this input that‚Äôs submitted with the form. onChange: An Event handler function. Required for controlled inputs. Fires immediately when the input‚Äôs value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event. onChangeCapture: A version of onChange that fires in the capture phase. onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly. onInputCapture: A version of onInput that fires in the capture phase. onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles. onInvalidCapture: A version of onInvalid that fires in the capture phase. onSelect: An Event handler function. Fires after the selection inside the <input> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection). onSelectCapture: A version of onSelect that fires in the capture phase. pattern: A string. Specifies the pattern that the value must match. placeholder: A string. Displayed in a dimmed color when the input value is empty. readOnly: A boolean. If true, the input is not editable by the user. required: A boolean. If true, the value must be provided for the form to submit. size: A number. Similar to setting width, but the unit depends on the control. src: A string. Specifies the image source for a type=\"image\" input. step: A positive number or an 'any' string. Specifies the distance between valid values. type: A string. One of the input types. width: A string. Specifies the image width for a type=\"image\" input. Caveats Checkboxes need checked (or defaultChecked), not value (or defaultValue). If a text input receives a string value prop, it will be treated as controlled. If a checkbox or a radio button receives a boolean checked prop, it will be treated as controlled. An input can‚Äôt be both controlled and uncontrolled at the same time. An input cannot switch between being controlled or uncontrolled over its lifetime. Every controlled input needs an onChange event handler that synchronously updates its backing value. Usage Displaying inputs of different types To display an input, render an <input> component. By default, it will be a text input. You can pass type=\"checkbox\" for a checkbox, type=\"radio\" for a radio button, or one of the other input types.",
      "code": "<input>"
    }
  ],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/reference/react/hooks",
    "https://react.dev/reference/react/useActionState",
    "https://react.dev/reference/react/useCallback",
    "https://react.dev/reference/react/useContext",
    "https://react.dev/reference/react/useDebugValue",
    "https://react.dev/reference/react/useDeferredValue",
    "https://react.dev/reference/react/useEffect",
    "https://react.dev/reference/react/useEffectEvent",
    "https://react.dev/reference/react/useId",
    "https://react.dev/reference/react/useImperativeHandle",
    "https://react.dev/reference/react/useInsertionEffect",
    "https://react.dev/reference/react/useLayoutEffect",
    "https://react.dev/reference/react/useMemo",
    "https://react.dev/reference/react/useOptimistic",
    "https://react.dev/reference/react/useReducer",
    "https://react.dev/reference/react/useRef",
    "https://react.dev/reference/react/useState",
    "https://react.dev/reference/react/useSyncExternalStore",
    "https://react.dev/reference/react/useTransition",
    "https://react.dev/reference/react/components",
    "https://react.dev/reference/react/Fragment",
    "https://react.dev/reference/react/Profiler",
    "https://react.dev/reference/react/StrictMode",
    "https://react.dev/reference/react/Suspense",
    "https://react.dev/reference/react/Activity",
    "https://react.dev/reference/react/ViewTransition",
    "https://react.dev/reference/react/apis",
    "https://react.dev/reference/react/act",
    "https://react.dev/reference/react/addTransitionType",
    "https://react.dev/reference/react/cache",
    "https://react.dev/reference/react/cacheSignal",
    "https://react.dev/reference/react/captureOwnerStack",
    "https://react.dev/reference/react/createContext",
    "https://react.dev/reference/react/lazy",
    "https://react.dev/reference/react/memo",
    "https://react.dev/reference/react/startTransition",
    "https://react.dev/reference/react/use",
    "https://react.dev/reference/react/experimental_taintObjectReference",
    "https://react.dev/reference/react/experimental_taintUniqueValue",
    "https://react.dev/reference/react-dom/hooks",
    "https://react.dev/reference/react-dom/hooks/useFormStatus",
    "https://react.dev/reference/react-dom/components",
    "https://react.dev/reference/react-dom/components/common",
    "https://react.dev/reference/react-dom/components/form",
    "https://react.dev/reference/react-dom/components/input",
    "https://react.dev/reference/react-dom/components/option",
    "https://react.dev/reference/react-dom/components/progress",
    "https://react.dev/reference/react-dom/components/select",
    "https://react.dev/reference/react-dom/components/textarea",
    "https://react.dev/reference/react-dom/components/link",
    "https://react.dev/reference/react-dom/components/meta",
    "https://react.dev/reference/react-dom/components/script",
    "https://react.dev/reference/react-dom/components/style",
    "https://react.dev/reference/react-dom/components/title",
    "https://react.dev/reference/react-dom",
    "https://react.dev/reference/react-dom/createPortal",
    "https://react.dev/reference/react-dom/flushSync",
    "https://react.dev/reference/react-dom/preconnect",
    "https://react.dev/reference/react-dom/prefetchDNS",
    "https://react.dev/reference/react-dom/preinit",
    "https://react.dev/reference/react-dom/preinitModule",
    "https://react.dev/reference/react-dom/preload",
    "https://react.dev/reference/react-dom/preloadModule",
    "https://react.dev/reference/react-dom/client",
    "https://react.dev/reference/react-dom/client/createRoot",
    "https://react.dev/reference/react-dom/client/hydrateRoot",
    "https://react.dev/reference/react-dom/server",
    "https://react.dev/reference/react-dom/server/renderToPipeableStream",
    "https://react.dev/reference/react-dom/server/renderToReadableStream",
    "https://react.dev/reference/react-dom/server/renderToStaticMarkup",
    "https://react.dev/reference/react-dom/server/renderToString",
    "https://react.dev/reference/react-dom/server/resume",
    "https://react.dev/reference/react-dom/server/resumeToPipeableStream",
    "https://react.dev/reference/react-dom/static",
    "https://react.dev/reference/react-dom/static/prerender",
    "https://react.dev/reference/react-dom/static/prerenderToNodeStream",
    "https://react.dev/reference/react-dom/static/resumeAndPrerender",
    "https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream",
    "https://react.dev/reference/react-compiler/configuration",
    "https://react.dev/reference/react-compiler/compilationMode",
    "https://react.dev/reference/react-compiler/gating",
    "https://react.dev/reference/react-compiler/logger",
    "https://react.dev/reference/react-compiler/panicThreshold",
    "https://react.dev/reference/react-compiler/target",
    "https://react.dev/reference/react-compiler/directives",
    "https://react.dev/reference/react-compiler/directives/use-memo",
    "https://react.dev/reference/react-compiler/directives/use-no-memo",
    "https://react.dev/reference/react-compiler/compiling-libraries",
    "https://react.dev/reference/dev-tools/react-performance-tracks",
    "https://react.dev/reference/eslint-plugin-react-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/config",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/gating",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/globals",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/purity",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/refs",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/use-memo",
    "https://react.dev/reference/rules",
    "https://react.dev/reference/rules/components-and-hooks-must-be-pure",
    "https://react.dev/reference/rules/react-calls-components-and-hooks",
    "https://react.dev/reference/rules/rules-of-hooks",
    "https://react.dev/reference/rsc/server-components",
    "https://react.dev/reference/rsc/server-functions",
    "https://react.dev/reference/rsc/directives",
    "https://react.dev/reference/rsc/use-client",
    "https://react.dev/reference/rsc/use-server",
    "https://react.dev/reference/react/legacy",
    "https://react.dev/reference/react/Children",
    "https://react.dev/reference/react/cloneElement",
    "https://react.dev/reference/react/Component",
    "https://react.dev/reference/react/createElement",
    "https://react.dev/reference/react/createRef",
    "https://react.dev/reference/react/forwardRef",
    "https://react.dev/reference/react/isValidElement",
    "https://react.dev/reference/react/PureComponent",
    "https://react.dev/learn/responding-to-events",
    "https://react.dev/learn/preserving-and-resetting-state",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/escape-hatches"
  ]
}