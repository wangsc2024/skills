{
  "url": "https://react.dev/learn/passing-props-to-a-component",
  "title": "Passing Props to a Component",
  "content": "React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.\n\nProps are the information that you pass to a JSX tag. For example, className, src, alt, width, and height are some of the props you can pass to an <img>:\n\nThe props you can pass to an <img> tag are predefined (ReactDOM conforms to the HTML standard). But you can pass any props to your own components, such as <Avatar>, to customize them. Here’s how!\n\nIn this code, the Profile component isn’t passing any props to its child component, Avatar:\n\nYou can give Avatar some props in two steps.\n\nFirst, pass some props to Avatar. For example, let’s pass two props: person (an object), and size (a number):\n\nIf double curly braces after person= confuse you, recall they’re merely an object inside the JSX curlies.\n\nNow you can read these props inside the Avatar component.\n\nYou can read these props by listing their names person, size separated by the commas inside ({ and }) directly after function Avatar. This lets you use them inside the Avatar code, like you would with a variable.\n\nAdd some logic to Avatar that uses the person and size props for rendering, and you’re done.\n\nNow you can configure Avatar to render in many different ways with different props. Try tweaking the values!\n\nProps let you think about parent and child components independently. For example, you can change the person or the size props inside Profile without having to think about how Avatar uses them. Similarly, you can change how the Avatar uses these props, without looking at the Profile.\n\nYou can think of props like “knobs” that you can adjust. They serve the same role as arguments serve for functions—in fact, props are the only argument to your component! React component functions accept a single argument, a props object:\n\nUsually you don’t need the whole props object itself, so you destructure it into individual props.\n\nDon’t miss the pair of { and } curlies inside of ( and ) when declaring props:\n\nThis syntax is called “destructuring” and is equivalent to reading properties from a function parameter:\n\nIf you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting = and the default value right after the parameter:\n\nNow, if <Avatar person={...} /> is rendered with no size prop, the size will be set to 100.\n\nThe default value is only used if the size prop is missing or if you pass size={undefined}. But if you pass size={null} or size={0}, the default value will not be used.\n\nSometimes, passing props gets very repetitive:\n\nThere’s nothing wrong with repetitive code—it can be more legible. But at times you may value conciseness. Some components forward all of their props to their children, like how this Profile does with Avatar. Because they don’t use any of their props directly, it can make sense to use a more concise “spread” syntax:\n\nThis forwards all of Profile’s props to the Avatar without listing each of their names.\n\nUse spread syntax with restraint. If you’re using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX. More on that next!\n\nIt is common to nest built-in browser tags:\n\nSometimes you’ll want to nest your own components the same way:\n\nWhen you nest content inside a JSX tag, the parent component will receive that content in a prop called children. For example, the Card component below will receive a children prop set to <Avatar /> and render it in a wrapper div:\n\nTry replacing the <Avatar> inside <Card> with some text to see how the Card component can wrap any nested content. It doesn’t need to “know” what’s being rendered inside of it. You will see this flexible pattern in many places.\n\nYou can think of a component with a children prop as having a “hole” that can be “filled in” by its parent components with arbitrary JSX. You will often use the children prop for visual wrappers: panels, grids, etc.\n\nIllustrated by Rachel Lee Nabors\n\nThe Clock component below receives two props from its parent component: color and time. (The parent component’s code is omitted because it uses state, which we won’t dive into just yet.)\n\nTry changing the color in the select box below:\n\nThis example illustrates that a component may receive different props over time. Props are not always static! Here, the time prop changes every second, and the color prop changes when you select another color. Props reflect a component’s data at any point in time, rather than only in the beginning.\n\nHowever, props are immutable—a term from computer science meaning “unchangeable”. When a component needs to change its props (for example, in response to a user interaction or new data), it will have to “ask” its parent component to pass it different props—a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them.\n\nDon’t try to “change props”. When you need to respond to the user input (like changing the selected color), you will need to “set state”, which you can learn about in State: A Component’s Memory.\n\nThis Gallery component contains some very similar markup for two profiles. Extract a Profile component out of it to reduce the duplication. You’ll need to choose what props to pass to it.",
  "headings": [
    {
      "level": "h1",
      "text": "Passing Props to a Component",
      "id": ""
    },
    {
      "level": "h3",
      "text": "You will learn",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Familiar props",
      "id": "familiar-props"
    },
    {
      "level": "h2",
      "text": "Passing props to a component",
      "id": "passing-props-to-a-component"
    },
    {
      "level": "h3",
      "text": "Step 1: Pass props to the child component",
      "id": "step-1-pass-props-to-the-child-component"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Step 2: Read props inside the child component",
      "id": "step-2-read-props-inside-the-child-component"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Specifying a default value for a prop",
      "id": "specifying-a-default-value-for-a-prop"
    },
    {
      "level": "h2",
      "text": "Forwarding props with the JSX spread syntax",
      "id": "forwarding-props-with-the-jsx-spread-syntax"
    },
    {
      "level": "h2",
      "text": "Passing JSX as children",
      "id": "passing-jsx-as-children"
    },
    {
      "level": "h2",
      "text": "How props change over time",
      "id": "how-props-change-over-time"
    },
    {
      "level": "h2",
      "text": "Recap",
      "id": "recap"
    },
    {
      "level": "h2",
      "text": "Try out some challenges",
      "id": "challenges"
    },
    {
      "level": "h4",
      "text": "Challenge 1 of 3: Extract a component",
      "id": "extract-a-component"
    }
  ],
  "code_samples": [
    {
      "code": "export default function Profile() {  return (    <Avatar />  );}",
      "language": "jsx"
    },
    {
      "code": "export default function Profile() {  return (    <Avatar      person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}      size={100}    />  );}",
      "language": "javascript"
    },
    {
      "code": "function Avatar({ person, size }) {  // person and size are available here}",
      "language": "javascript"
    },
    {
      "code": "function Avatar(props) {  let person = props.person;  let size = props.size;  // ...}",
      "language": "javascript"
    },
    {
      "code": "function Avatar({ person, size }) {  // ...}",
      "language": "javascript"
    },
    {
      "code": "function Avatar(props) {  let person = props.person;  let size = props.size;  // ...}",
      "language": "javascript"
    },
    {
      "code": "function Avatar({ person, size = 100 }) {  // ...}",
      "language": "javascript"
    },
    {
      "code": "function Profile({ person, size, isSepia, thickBorder }) {  return (    <div className=\"card\">      <Avatar        person={person}        size={size}        isSepia={isSepia}        thickBorder={thickBorder}      />    </div>  );}",
      "language": "jsx"
    },
    {
      "code": "function Profile(props) {  return (    <div className=\"card\">      <Avatar {...props} />    </div>  );}",
      "language": "jsx"
    },
    {
      "code": "<div>  <img /></div>",
      "language": "jsx"
    },
    {
      "code": "<Card>  <Avatar /></Card>",
      "language": "jsx"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/learn/tutorial-tic-tac-toe",
    "https://react.dev/learn/thinking-in-react",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/creating-a-react-app",
    "https://react.dev/learn/build-a-react-app-from-scratch",
    "https://react.dev/learn/add-react-to-an-existing-project",
    "https://react.dev/learn/setup",
    "https://react.dev/learn/editor-setup",
    "https://react.dev/learn/typescript",
    "https://react.dev/learn/react-developer-tools",
    "https://react.dev/learn/react-compiler",
    "https://react.dev/learn/react-compiler/introduction",
    "https://react.dev/learn/react-compiler/installation",
    "https://react.dev/learn/react-compiler/incremental-adoption",
    "https://react.dev/learn/react-compiler/debugging",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/your-first-component",
    "https://react.dev/learn/importing-and-exporting-components",
    "https://react.dev/learn/writing-markup-with-jsx",
    "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/conditional-rendering",
    "https://react.dev/learn/rendering-lists",
    "https://react.dev/learn/keeping-components-pure",
    "https://react.dev/learn/understanding-your-ui-as-a-tree",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/responding-to-events",
    "https://react.dev/learn/state-a-components-memory",
    "https://react.dev/learn/render-and-commit",
    "https://react.dev/learn/state-as-a-snapshot",
    "https://react.dev/learn/queueing-a-series-of-state-updates",
    "https://react.dev/learn/updating-objects-in-state",
    "https://react.dev/learn/updating-arrays-in-state",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/reacting-to-input-with-state",
    "https://react.dev/learn/choosing-the-state-structure",
    "https://react.dev/learn/sharing-state-between-components",
    "https://react.dev/learn/preserving-and-resetting-state",
    "https://react.dev/learn/extracting-state-logic-into-a-reducer",
    "https://react.dev/learn/passing-data-deeply-with-context",
    "https://react.dev/learn/scaling-up-with-reducer-and-context",
    "https://react.dev/learn/escape-hatches",
    "https://react.dev/learn/referencing-values-with-refs",
    "https://react.dev/learn/manipulating-the-dom-with-refs",
    "https://react.dev/learn/synchronizing-with-effects",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/learn/lifecycle-of-reactive-effects",
    "https://react.dev/learn/separating-events-from-effects",
    "https://react.dev/learn/removing-effect-dependencies",
    "https://react.dev/learn/reusing-logic-with-custom-hooks",
    "https://react.dev/reference/react-dom"
  ]
}