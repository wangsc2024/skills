{
  "url": "https://react.dev/learn/add-react-to-an-existing-project",
  "title": "Add React to an Existing Project",
  "content": "If you want to add some interactivity to your existing project, you don’t have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere.\n\nYou need to install Node.js for local development. Although you can try React online or with a simple HTML page, realistically most JavaScript tooling you’ll want to use for development requires Node.js.\n\nLet’s say you have an existing web app at example.com built with another server technology (like Rails), and you want to implement all routes starting with example.com/some-app/ fully with React.\n\nHere’s how we recommend to set it up:\n\nThis ensures the React part of your app can benefit from the best practices baked into those frameworks.\n\nMany React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can’t or don’t want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (next export output for Next.js, default for Gatsby) at /some-app/ instead.\n\nLet’s say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That’s a common way to integrate React—in fact, it’s how most React usage looked at Meta for many years!\n\nYou can do this in two steps:\n\nThe exact approach depends on your existing page setup, so let’s walk through some details.\n\nA modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on the npm registry—including React itself! How you do this depends on your existing setup:\n\nIf your app is already split into files that use import statements, try to use the setup you already have. Check whether writing <div /> in your JS code causes a syntax error. If it causes a syntax error, you might need to transform your JavaScript code with Babel, and enable the Babel React preset to use JSX.\n\nIf your app doesn’t have an existing setup for compiling JavaScript modules, set it up with Vite. The Vite community maintains many integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed, follow this guide to manually integrate Vite builds with your backend.\n\nTo check whether your setup works, run this command in your project folder:\n\nThen add these lines of code at the top of your main JavaScript file (it might be called index.js or main.js):\n\nIf the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading.\n\nIntegrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try our community resources or the Vite Chat.\n\nIn the previous step, you put this code at the top of your main file:\n\nOf course, you don’t actually want to clear the existing HTML content!\n\nInstead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example:\n\nThis lets you find that HTML element with document.getElementById and pass it to createRoot so that you can render your own React component inside:\n\nNotice how the original HTML content from index.html is preserved, but your own NavigationBar React component now appears inside the <nav id=\"navigation\"> from your HTML. Read the createRoot usage documentation to learn more about rendering React components inside an existing HTML page.\n\nWhen you adopt React in an existing project, it’s common to start with small interactive components (like buttons), and then gradually keep “moving upwards” until eventually your entire page is built with React. If you ever reach that point, we recommend migrating to a React framework right after to get the most out of React.\n\nReact Native can also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift), follow this guide to add a React Native screen to it.",
  "headings": [
    {
      "level": "h1",
      "text": "Add React to an Existing Project",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Using React for an entire subroute of your existing website",
      "id": "using-react-for-an-entire-subroute-of-your-existing-website"
    },
    {
      "level": "h2",
      "text": "Using React for a part of your existing page",
      "id": "using-react-for-a-part-of-your-existing-page"
    },
    {
      "level": "h3",
      "text": "Step 1: Set up a modular JavaScript environment",
      "id": "step-1-set-up-a-modular-javascript-environment"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Step 2: Render React components anywhere on the page",
      "id": "step-2-render-react-components-anywhere-on-the-page"
    },
    {
      "level": "h2",
      "text": "Using React Native in an existing native mobile app",
      "id": "using-react-native-in-an-existing-native-mobile-app"
    }
  ],
  "code_samples": [
    {
      "code": "npm install react react-dom",
      "language": "unknown"
    },
    {
      "code": "import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id=\"app\"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>);",
      "language": "jsx"
    },
    {
      "code": "<!-- ... somewhere in your html ... --><nav id=\"navigation\"></nav><!-- ... more html ... -->",
      "language": "jsx"
    }
  ],
  "patterns": [
    {
      "description": "Learn ReactInstallationAdd React to an Existing ProjectIf you want to add some interactivity to your existing project, you don’t have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere. NoteYou need to install Node.js for local development. Although you can try React online or with a simple HTML page, realistically most JavaScript tooling you’ll want to use for development requires Node.js. Using React for an entire subroute of your existing website Let’s say you have an existing web app at example.com built with another server technology (like Rails), and you want to implement all routes starting with example.com/some-app/ fully with React. Here’s how we recommend to set it up: Build the React part of your app using one of the React-based frameworks. Specify /some-app as the base path in your framework’s configuration (here’s how: Next.js, Gatsby). Configure your server or a proxy so that all requests under /some-app/ are handled by your React app. This ensures the React part of your app can benefit from the best practices baked into those frameworks. Many React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can’t or don’t want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (next export output for Next.js, default for Gatsby) at /some-app/ instead. Using React for a part of your existing page Let’s say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That’s a common way to integrate React—in fact, it’s how most React usage looked at Meta for many years! You can do this in two steps: Set up a JavaScript environment that lets you use the JSX syntax, split your code into modules with the import / export syntax, and use packages (for example, React) from the npm package registry. Render your React components where you want to see them on the page. The exact approach depends on your existing page setup, so let’s walk through some details. Step 1: Set up a modular JavaScript environment A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on the npm registry—including React itself! How you do this depends on your existing setup: If your app is already split into files that use import statements, try to use the setup you already have. Check whether writing <div /> in your JS code causes a syntax error. If it causes a syntax error, you might need to transform your JavaScript code with Babel, and enable the Babel React preset to use JSX. If your app doesn’t have an existing setup for compiling JavaScript modules, set it up with Vite. The Vite community maintains many integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed, follow this guide to manually integrate Vite builds with your backend. To check whether your setup works, run this command in your project folder: Terminal Copynpm install react react-dom Then add these lines of code at the top of your main JavaScript file (it might be called index.js or main.js): index.jsindex.jsReloadClearForkimport { createRoot } from 'react-dom/client'; // Clear the existing HTML content document.body.innerHTML = '<div id=\"app\"></div>'; // Render your React component instead const root = createRoot(document.getElementById('app')); root.render(<h1>Hello, world</h1>); If the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading. NoteIntegrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try our community resources or the Vite Chat. Step 2: Render React components anywhere on the page In the previous step, you put this code at the top of your main file: import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id=\"app\"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>); Of course, you don’t actually want to clear the existing HTML content! Delete this code. Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example: <!-- ... somewhere in your html ... --><nav id=\"navigation\"></nav><!-- ... more html ... --> This lets you find that HTML element with document.getElementById and pass it to createRoot so that you can render your own React component inside: index.jsindex.htmlindex.jsReloadClearForkimport { createRoot } from 'react-dom/client'; function NavigationBar() { // TODO: Actually implement a navigation bar return <h1>Hello from React!</h1>; } const domNode = document.getElementById('navigation'); const root = createRoot(domNode); root.render(<NavigationBar />); Notice how the original HTML content from index.html is preserved, but your own NavigationBar React component now appears inside the <nav id=\"navigation\"> from your HTML. Read the createRoot usage documentation to learn more about rendering React components inside an existing HTML page. When you adopt React in an existing project, it’s common to start with small interactive components (like buttons), and then gradually keep “moving upwards” until eventually your entire page is built with React. If you ever reach that point, we recommend migrating to a React framework right after to get the most out of React. Using React Native in an existing native mobile app React Native can also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift), follow this guide to add a React Native screen to it.PreviousBuild a React App from ScratchNextSetup",
      "code": "example.com"
    },
    {
      "description": "If you want to add some interactivity to your existing project, you don’t have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere. NoteYou need to install Node.js for local development. Although you can try React online or with a simple HTML page, realistically most JavaScript tooling you’ll want to use for development requires Node.js. Using React for an entire subroute of your existing website Let’s say you have an existing web app at example.com built with another server technology (like Rails), and you want to implement all routes starting with example.com/some-app/ fully with React. Here’s how we recommend to set it up: Build the React part of your app using one of the React-based frameworks. Specify /some-app as the base path in your framework’s configuration (here’s how: Next.js, Gatsby). Configure your server or a proxy so that all requests under /some-app/ are handled by your React app. This ensures the React part of your app can benefit from the best practices baked into those frameworks. Many React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can’t or don’t want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (next export output for Next.js, default for Gatsby) at /some-app/ instead. Using React for a part of your existing page Let’s say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That’s a common way to integrate React—in fact, it’s how most React usage looked at Meta for many years! You can do this in two steps: Set up a JavaScript environment that lets you use the JSX syntax, split your code into modules with the import / export syntax, and use packages (for example, React) from the npm package registry. Render your React components where you want to see them on the page. The exact approach depends on your existing page setup, so let’s walk through some details. Step 1: Set up a modular JavaScript environment A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on the npm registry—including React itself! How you do this depends on your existing setup: If your app is already split into files that use import statements, try to use the setup you already have. Check whether writing <div /> in your JS code causes a syntax error. If it causes a syntax error, you might need to transform your JavaScript code with Babel, and enable the Babel React preset to use JSX. If your app doesn’t have an existing setup for compiling JavaScript modules, set it up with Vite. The Vite community maintains many integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed, follow this guide to manually integrate Vite builds with your backend. To check whether your setup works, run this command in your project folder: Terminal Copynpm install react react-dom Then add these lines of code at the top of your main JavaScript file (it might be called index.js or main.js): index.jsindex.jsReloadClearForkimport { createRoot } from 'react-dom/client'; // Clear the existing HTML content document.body.innerHTML = '<div id=\"app\"></div>'; // Render your React component instead const root = createRoot(document.getElementById('app')); root.render(<h1>Hello, world</h1>); If the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading. NoteIntegrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try our community resources or the Vite Chat. Step 2: Render React components anywhere on the page In the previous step, you put this code at the top of your main file: import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id=\"app\"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>); Of course, you don’t actually want to clear the existing HTML content! Delete this code. Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example: <!-- ... somewhere in your html ... --><nav id=\"navigation\"></nav><!-- ... more html ... --> This lets you find that HTML element with document.getElementById and pass it to createRoot so that you can render your own React component inside: index.jsindex.htmlindex.jsReloadClearForkimport { createRoot } from 'react-dom/client'; function NavigationBar() { // TODO: Actually implement a navigation bar return <h1>Hello from React!</h1>; } const domNode = document.getElementById('navigation'); const root = createRoot(domNode); root.render(<NavigationBar />); Notice how the original HTML content from index.html is preserved, but your own NavigationBar React component now appears inside the <nav id=\"navigation\"> from your HTML. Read the createRoot usage documentation to learn more about rendering React components inside an existing HTML page. When you adopt React in an existing project, it’s common to start with small interactive components (like buttons), and then gradually keep “moving upwards” until eventually your entire page is built with React. If you ever reach that point, we recommend migrating to a React framework right after to get the most out of React. Using React Native in an existing native mobile app React Native can also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift), follow this guide to add a React Native screen to it.PreviousBuild a React App from ScratchNextSetup",
      "code": "example.com"
    },
    {
      "description": "If you want to add some interactivity to your existing project, you don’t have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere. NoteYou need to install Node.js for local development. Although you can try React online or with a simple HTML page, realistically most JavaScript tooling you’ll want to use for development requires Node.js. Using React for an entire subroute of your existing website Let’s say you have an existing web app at example.com built with another server technology (like Rails), and you want to implement all routes starting with example.com/some-app/ fully with React. Here’s how we recommend to set it up: Build the React part of your app using one of the React-based frameworks. Specify /some-app as the base path in your framework’s configuration (here’s how: Next.js, Gatsby). Configure your server or a proxy so that all requests under /some-app/ are handled by your React app. This ensures the React part of your app can benefit from the best practices baked into those frameworks. Many React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can’t or don’t want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (next export output for Next.js, default for Gatsby) at /some-app/ instead. Using React for a part of your existing page Let’s say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That’s a common way to integrate React—in fact, it’s how most React usage looked at Meta for many years! You can do this in two steps: Set up a JavaScript environment that lets you use the JSX syntax, split your code into modules with the import / export syntax, and use packages (for example, React) from the npm package registry. Render your React components where you want to see them on the page. The exact approach depends on your existing page setup, so let’s walk through some details. Step 1: Set up a modular JavaScript environment A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on the npm registry—including React itself! How you do this depends on your existing setup: If your app is already split into files that use import statements, try to use the setup you already have. Check whether writing <div /> in your JS code causes a syntax error. If it causes a syntax error, you might need to transform your JavaScript code with Babel, and enable the Babel React preset to use JSX. If your app doesn’t have an existing setup for compiling JavaScript modules, set it up with Vite. The Vite community maintains many integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed, follow this guide to manually integrate Vite builds with your backend. To check whether your setup works, run this command in your project folder: Terminal Copynpm install react react-dom Then add these lines of code at the top of your main JavaScript file (it might be called index.js or main.js): index.jsindex.jsReloadClearForkimport { createRoot } from 'react-dom/client'; // Clear the existing HTML content document.body.innerHTML = '<div id=\"app\"></div>'; // Render your React component instead const root = createRoot(document.getElementById('app')); root.render(<h1>Hello, world</h1>); If the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading. NoteIntegrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try our community resources or the Vite Chat. Step 2: Render React components anywhere on the page In the previous step, you put this code at the top of your main file: import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id=\"app\"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>); Of course, you don’t actually want to clear the existing HTML content! Delete this code. Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example: <!-- ... somewhere in your html ... --><nav id=\"navigation\"></nav><!-- ... more html ... --> This lets you find that HTML element with document.getElementById and pass it to createRoot so that you can render your own React component inside: index.jsindex.htmlindex.jsReloadClearForkimport { createRoot } from 'react-dom/client'; function NavigationBar() { // TODO: Actually implement a navigation bar return <h1>Hello from React!</h1>; } const domNode = document.getElementById('navigation'); const root = createRoot(domNode); root.render(<NavigationBar />); Notice how the original HTML content from index.html is preserved, but your own NavigationBar React component now appears inside the <nav id=\"navigation\"> from your HTML. Read the createRoot usage documentation to learn more about rendering React components inside an existing HTML page. When you adopt React in an existing project, it’s common to start with small interactive components (like buttons), and then gradually keep “moving upwards” until eventually your entire page is built with React. If you ever reach that point, we recommend migrating to a React framework right after to get the most out of React. Using React Native in an existing native mobile app React Native can also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift), follow this guide to add a React Native screen to it.",
      "code": "example.com"
    },
    {
      "description": "If the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading. NoteIntegrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try our community resources or the Vite Chat. Step 2: Render React components anywhere on the page In the previous step, you put this code at the top of your main file: import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id=\"app\"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>); Of course, you don’t actually want to clear the existing HTML content! Delete this code. Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example: <!-- ... somewhere in your html ... --><nav id=\"navigation\"></nav><!-- ... more html ... --> This lets you find that HTML element with document.getElementById and pass it to createRoot so that you can render your own React component inside:",
      "code": "import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id=\"app\"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>);"
    },
    {
      "description": "Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example:",
      "code": "id"
    }
  ],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/learn/tutorial-tic-tac-toe",
    "https://react.dev/learn/thinking-in-react",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/creating-a-react-app",
    "https://react.dev/learn/build-a-react-app-from-scratch",
    "https://react.dev/learn/add-react-to-an-existing-project",
    "https://react.dev/learn/setup",
    "https://react.dev/learn/editor-setup",
    "https://react.dev/learn/typescript",
    "https://react.dev/learn/react-developer-tools",
    "https://react.dev/learn/react-compiler",
    "https://react.dev/learn/react-compiler/introduction",
    "https://react.dev/learn/react-compiler/installation",
    "https://react.dev/learn/react-compiler/incremental-adoption",
    "https://react.dev/learn/react-compiler/debugging",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/your-first-component",
    "https://react.dev/learn/importing-and-exporting-components",
    "https://react.dev/learn/writing-markup-with-jsx",
    "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/conditional-rendering",
    "https://react.dev/learn/rendering-lists",
    "https://react.dev/learn/keeping-components-pure",
    "https://react.dev/learn/understanding-your-ui-as-a-tree",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/responding-to-events",
    "https://react.dev/learn/state-a-components-memory",
    "https://react.dev/learn/render-and-commit",
    "https://react.dev/learn/state-as-a-snapshot",
    "https://react.dev/learn/queueing-a-series-of-state-updates",
    "https://react.dev/learn/updating-objects-in-state",
    "https://react.dev/learn/updating-arrays-in-state",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/reacting-to-input-with-state",
    "https://react.dev/learn/choosing-the-state-structure",
    "https://react.dev/learn/sharing-state-between-components",
    "https://react.dev/learn/preserving-and-resetting-state",
    "https://react.dev/learn/extracting-state-logic-into-a-reducer",
    "https://react.dev/learn/passing-data-deeply-with-context",
    "https://react.dev/learn/scaling-up-with-reducer-and-context",
    "https://react.dev/learn/escape-hatches",
    "https://react.dev/learn/referencing-values-with-refs",
    "https://react.dev/learn/manipulating-the-dom-with-refs",
    "https://react.dev/learn/synchronizing-with-effects",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/learn/lifecycle-of-reactive-effects",
    "https://react.dev/learn/separating-events-from-effects",
    "https://react.dev/learn/removing-effect-dependencies",
    "https://react.dev/learn/reusing-logic-with-custom-hooks",
    "https://react.dev/reference/react-dom/client/createRoot",
    "https://react.dev/reference/react-dom"
  ]
}