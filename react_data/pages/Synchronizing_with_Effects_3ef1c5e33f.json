{
  "url": "https://react.dev/learn/synchronizing-with-effects",
  "title": "Synchronizing with Effects",
  "content": "Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Effects let you run some code after rendering so that you can synchronize your component with some system outside of React.\n\nBefore getting to Effects, you need to be familiar with two types of logic inside React components:\n\nRendering code (introduced in Describing the UI) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen. Rendering code must be pure. Like a math formula, it should only calculate the result, but not do anything else.\n\nEvent handlers (introduced in Adding Interactivity) are nested functions inside your components that do things rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain ‚Äúside effects‚Äù (they change the program‚Äôs state) caused by a specific user action (for example, a button click or typing).\n\nSometimes this isn‚Äôt enough. Consider a ChatRoom component that must connect to the chat server whenever it‚Äôs visible on the screen. Connecting to a server is not a pure calculation (it‚Äôs a side effect) so it can‚Äôt happen during rendering. However, there is no single particular event like a click that causes ChatRoom to be displayed.\n\nEffects let you specify side effects that are caused by rendering itself, rather than by a particular event. Sending a message in the chat is an event because it is directly caused by the user clicking a specific button. However, setting up a server connection is an Effect because it should happen no matter which interaction caused the component to appear. Effects run at the end of a commit after the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library).\n\nHere and later in this text, capitalized ‚ÄúEffect‚Äù refers to the React-specific definition above, i.e. a side effect caused by rendering. To refer to the broader programming concept, we‚Äôll say ‚Äúside effect‚Äù.\n\nDon‚Äôt rush to add Effects to your components. Keep in mind that Effects are typically used to ‚Äústep out‚Äù of your React code and synchronize with some external system. This includes browser APIs, third-party widgets, network, and so on. If your Effect only adjusts some state based on other state, you might not need an Effect.\n\nTo write an Effect, follow these three steps:\n\nLet‚Äôs look at each of these steps in detail.\n\nTo declare an Effect in your component, import the useEffect Hook from React:\n\nThen, call it at the top level of your component and put some code inside your Effect:\n\nEvery time your component renders, React will update the screen and then run the code inside useEffect. In other words, useEffect ‚Äúdelays‚Äù a piece of code from running until that render is reflected on the screen.\n\nLet‚Äôs see how you can use an Effect to synchronize with an external system. Consider a <VideoPlayer> React component. It would be nice to control whether it‚Äôs playing or paused by passing an isPlaying prop to it:\n\nYour custom VideoPlayer component renders the built-in browser <video> tag:\n\nHowever, the browser <video> tag does not have an isPlaying prop. The only way to control it is to manually call the play() and pause() methods on the DOM element. You need to synchronize the value of isPlaying prop, which tells whether the video should currently be playing, with calls like play() and pause().\n\nWe‚Äôll need to first get a ref to the <video> DOM node.\n\nYou might be tempted to try to call play() or pause() during rendering, but that isn‚Äôt correct:\n\nThe reason this code isn‚Äôt correct is that it tries to do something with the DOM node during rendering. In React, rendering should be a pure calculation of JSX and should not contain side effects like modifying the DOM.\n\nMoreover, when VideoPlayer is called for the first time, its DOM does not exist yet! There isn‚Äôt a DOM node yet to call play() or pause() on, because React doesn‚Äôt know what DOM to create until you return the JSX.\n\nThe solution here is to wrap the side effect with useEffect to move it out of the rendering calculation:\n\nBy wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs.\n\nWhen your VideoPlayer component renders (either the first time or if it re-renders), a few things will happen. First, React will update the screen, ensuring the <video> tag is in the DOM with the right props. Then React will run your Effect. Finally, your Effect will call play() or pause() depending on the value of isPlaying.\n\nPress Play/Pause multiple times and see how the video player stays synchronized to the isPlaying value:\n\nIn this example, the ‚Äúexternal system‚Äù you synchronized to React state was the browser media API. You can use a similar approach to wrap legacy non-React code (like jQuery plugins) into declarative React components.\n\nNote that controlling a video player is much more complex in practice. Calling play() may fail, the user might play or pause using the built-in browser controls, and so on. This example is very simplified and incomplete.\n\nBy default, Effects run after every render. This is why code like this will produce an infinite loop:\n\nEffects run as a result of rendering. Setting state triggers rendering. Setting state immediately in an Effect is like plugging a power outlet into itself. The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.\n\nEffects should usually synchronize your components with an external system. If there‚Äôs no external system and you only want to adjust some state based on other state, you might not need an Effect.\n\nBy default, Effects run after every render. Often, this is not what you want:\n\nTo demonstrate the issue, here is the previous example with a few console.log calls and a text input that updates the parent component‚Äôs state. Notice how typing causes the Effect to re-run:\n\nYou can tell React to skip unnecessarily re-running the Effect by specifying an array of dependencies as the second argument to the useEffect call. Start by adding an empty [] array to the above example on line 14:\n\nYou should see an error saying React Hook useEffect has a missing dependency: 'isPlaying':\n\nThe problem is that the code inside of your Effect depends on the isPlaying prop to decide what to do, but this dependency was not explicitly declared. To fix this issue, add isPlaying to the dependency array:\n\nNow all dependencies are declared, so there is no error. Specifying [isPlaying] as the dependency array tells React that it should skip re-running your Effect if isPlaying is the same as it was during the previous render. With this change, typing into the input doesn‚Äôt cause the Effect to re-run, but pressing Play/Pause does:\n\nThe dependency array can contain multiple dependencies. React will only skip re-running the Effect if all of the dependencies you specify have exactly the same values as they had during the previous render. React compares the dependency values using the Object.is comparison. See the useEffect reference for details.\n\nNotice that you can‚Äôt ‚Äúchoose‚Äù your dependencies. You will get a lint error if the dependencies you specified don‚Äôt match what React expects based on the code inside your Effect. This helps catch many bugs in your code. If you don‚Äôt want some code to re-run, edit the Effect code itself to not ‚Äúneed‚Äù that dependency.\n\nThe behaviors without the dependency array and with an empty [] dependency array are different:\n\nWe‚Äôll take a close look at what ‚Äúmount‚Äù means in the next step.\n\nThis Effect uses both ref and isPlaying, but only isPlaying is declared as a dependency:\n\nThis is because the ref object has a stable identity: React guarantees you‚Äôll always get the same object from the same useRef call on every render. It never changes, so it will never by itself cause the Effect to re-run. Therefore, it does not matter whether you include it or not. Including it is fine too:\n\nThe set functions returned by useState also have stable identity, so you will often see them omitted from the dependencies too. If the linter lets you omit a dependency without errors, it is safe to do.\n\nOmitting always-stable dependencies only works when the linter can ‚Äúsee‚Äù that the object is stable. For example, if ref was passed from a parent component, you would have to specify it in the dependency array. However, this is good because you can‚Äôt know whether the parent component always passes the same ref, or passes one of several refs conditionally. So your Effect would depend on which ref is passed.\n\nConsider a different example. You‚Äôre writing a ChatRoom component that needs to connect to the chat server when it appears. You are given a createConnection() API that returns an object with connect() and disconnect() methods. How do you keep the component connected while it is displayed to the user?\n\nStart by writing the Effect logic:\n\nIt would be slow to connect to the chat after every re-render, so you add the dependency array:\n\nThe code inside the Effect does not use any props or state, so your dependency array is [] (empty). This tells React to only run this code when the component ‚Äúmounts‚Äù, i.e. appears on the screen for the first time.\n\nLet‚Äôs try running this code:\n\nThis Effect only runs on mount, so you might expect \"‚úÖ Connecting...\" to be printed once in the console. However, if you check the console, \"‚úÖ Connecting...\" gets printed twice. Why does it happen?\n\nImagine the ChatRoom component is a part of a larger app with many different screens. The user starts their journey on the ChatRoom page. The component mounts and calls connection.connect(). Then imagine the user navigates to another screen‚Äîfor example, to the Settings page. The ChatRoom component unmounts. Finally, the user clicks Back and ChatRoom mounts again. This would set up a second connection‚Äîbut the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up.\n\nBugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount.\n\nSeeing the \"‚úÖ Connecting...\" log twice helps you notice the real issue: your code doesn‚Äôt close the connection when the component unmounts.\n\nTo fix the issue, return a cleanup function from your Effect:\n\nReact will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let‚Äôs see what happens when the cleanup function is implemented:\n\nNow you get three console logs in development:\n\nThis is the correct behavior in development. By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There‚Äôs an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal‚Äîdon‚Äôt try to make it go away!\n\nIn production, you would only see \"‚úÖ Connecting...\" printed once. Remounting components only happens in development to help you find Effects that need cleanup. You can turn off Strict Mode to opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above.\n\nReact intentionally remounts your components in development to find bugs like in the last example. The right question isn‚Äôt ‚Äúhow to run an Effect once‚Äù, but ‚Äúhow to fix my Effect so that it works after remounting‚Äù.\n\nUsually, the answer is to implement the cleanup function. The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the Effect running once (as in production) and a setup ‚Üí cleanup ‚Üí setup sequence (as you‚Äôd see in development).\n\nMost of the Effects you‚Äôll write will fit into one of the common patterns below.\n\nA common pitfall for preventing Effects firing twice in development is to use a ref to prevent the Effect from running more than once. For example, you could ‚Äúfix‚Äù the above bug with a useRef:\n\nThis makes it so you only see \"‚úÖ Connecting...\" once in development, but it doesn‚Äôt fix the bug.\n\nWhen the user navigates away, the connection still isn‚Äôt closed and when they navigate back, a new connection is created. As the user navigates across the app, the connections would keep piling up, the same as it would before the ‚Äúfix‚Äù.\n\nTo fix the bug, it is not enough to just make the Effect run once. The effect needs to work after re-mounting, which means the connection needs to be cleaned up like in the solution above.\n\nSee the examples below for how to handle common patterns.\n\nSometimes you need to add UI widgets that aren‚Äôt written in React. For example, let‚Äôs say you‚Äôre adding a map component to your page. It has a setZoomLevel() method, and you‚Äôd like to keep the zoom level in sync with a zoomLevel state variable in your React code. Your Effect would look similar to this:\n\nNote that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because calling setZoomLevel twice with the same value does not do anything. It may be slightly slower, but this doesn‚Äôt matter because it won‚Äôt remount needlessly in production.\n\nSome APIs may not allow you to call them twice in a row. For example, the showModal method of the built-in <dialog> element throws if you call it twice. Implement the cleanup function and make it close the dialog:\n\nIn development, your Effect will call showModal(), then immediately close(), and then showModal() again. This has the same user-visible behavior as calling showModal() once, as you would see in production.\n\nIf your Effect subscribes to something, the cleanup function should unsubscribe:\n\nIn development, your Effect will call addEventListener(), then immediately removeEventListener(), and then addEventListener() again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as calling addEventListener() once, as in production.\n\nIf your Effect animates something in, the cleanup function should reset the animation to the initial values:\n\nIn development, opacity will be set to 1, then to 0, and then to 1 again. This should have the same user-visible behavior as setting it to 1 directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state.\n\nIf your Effect fetches something, the cleanup function should either abort the fetch or ignore its result:\n\nYou can‚Äôt ‚Äúundo‚Äù a network request that already happened, but your cleanup function should ensure that the fetch that‚Äôs not relevant anymore does not keep affecting your application. If the userId changes from 'Alice' to 'Bob', cleanup ensures that the 'Alice' response is ignored even if it arrives after 'Bob'.\n\nIn development, you will see two fetches in the Network tab. There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of the ignore variable will be set to true. So even though there is an extra request, it won‚Äôt affect the state thanks to the if (!ignore) check.\n\nIn production, there will only be one request. If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:\n\nThis will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won‚Äôt have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.\n\nWriting fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n\nThis list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n\nYou can continue fetching data directly in Effects if neither of these approaches suit you.\n\nConsider this code that sends an analytics event on the page visit:\n\nIn development, logVisit will be called twice for every URL, so you might be tempted to try to fix that. We recommend keeping this code as is. Like with earlier examples, there is no user-visible behavior difference between running it once and running it twice. From a practical point of view, logVisit should not do anything in development because you don‚Äôt want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.\n\nIn production, there will be no duplicate visit logs.\n\nTo debug the analytics events you‚Äôre sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out of Strict Mode and its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics, intersection observers can help track which components are in the viewport and how long they remain visible.\n\nSome logic should only run once when the application starts. You can put it outside your components:\n\nThis guarantees that such logic only runs once after the browser loads the page.\n\nSometimes, even if you write a cleanup function, there‚Äôs no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:\n\nYou wouldn‚Äôt want to buy the product twice. However, this is also why you shouldn‚Äôt put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don‚Äôt want to buy the product when the user visits a page; you want to buy it when the user clicks the Buy button.\n\nBuying is not caused by rendering; it‚Äôs caused by a specific interaction. It should run only when the user presses the button. Delete the Effect and move your /api/buy request into the Buy button event handler:\n\nThis illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs. From a user‚Äôs perspective, visiting a page shouldn‚Äôt be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development.\n\nThis playground can help you ‚Äúget a feel‚Äù for how Effects work in practice.\n\nThis example uses setTimeout to schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing ‚ÄúMount the component‚Äù:\n\nYou will see three logs at first: Schedule \"a\" log, Cancel \"a\" log, and Schedule \"a\" log again. Three second later there will also be a log saying a. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you‚Äôve implemented cleanup well.\n\nNow edit the input to say abc. If you do it fast enough, you‚Äôll see Schedule \"ab\" log immediately followed by Cancel \"ab\" log and Schedule \"abc\" log. React always cleans up the previous render‚Äôs Effect before the next render‚Äôs Effect. This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.\n\nType something into the input and then immediately press ‚ÄúUnmount the component‚Äù. Notice how unmounting cleans up the last render‚Äôs Effect. Here, it clears the last timeout before it has a chance to fire.\n\nFinally, edit the component above and comment out the cleanup function so that the timeouts don‚Äôt get cancelled. Try typing abcde fast. What do you expect to happen in three seconds? Will console.log(text) inside the timeout print the latest text and produce five abcde logs? Give it a try to check your intuition!\n\nThree seconds later, you should see a sequence of logs (a, ab, abc, abcd, and abcde) rather than five abcde logs. Each Effect ‚Äúcaptures‚Äù the text value from its corresponding render. It doesn‚Äôt matter that the text state changed: an Effect from the render with text = 'ab' will always see 'ab'. In other words, Effects from each render are isolated from each other. If you‚Äôre curious how this works, you can read about closures.\n\nYou can think of useEffect as ‚Äúattaching‚Äù a piece of behavior to the render output. Consider this Effect:\n\nLet‚Äôs see what exactly happens as the user navigates around the app.\n\nThe user visits <ChatRoom roomId=\"general\" />. Let‚Äôs mentally substitute roomId with 'general':\n\nThe Effect is also a part of the rendering output. The first render‚Äôs Effect becomes:\n\nReact runs this Effect, which connects to the 'general' chat room.\n\nLet‚Äôs say <ChatRoom roomId=\"general\" /> re-renders. The JSX output is the same:\n\nReact sees that the rendering output has not changed, so it doesn‚Äôt update the DOM.\n\nThe Effect from the second render looks like this:\n\nReact compares ['general'] from the second render with ['general'] from the first render. Because all dependencies are the same, React ignores the Effect from the second render. It never gets called.\n\nThen, the user visits <ChatRoom roomId=\"travel\" />. This time, the component returns different JSX:\n\nReact updates the DOM to change \"Welcome to general\" into \"Welcome to travel\".\n\nThe Effect from the third render looks like this:\n\nReact compares ['travel'] from the third render with ['general'] from the second render. One dependency is different: Object.is('travel', 'general') is false. The Effect can‚Äôt be skipped.\n\nBefore React can apply the Effect from the third render, it needs to clean up the last Effect that did run. The second render‚Äôs Effect was skipped, so React needs to clean up the first render‚Äôs Effect. If you scroll up to the first render, you‚Äôll see that its cleanup calls disconnect() on the connection that was created with createConnection('general'). This disconnects the app from the 'general' chat room.\n\nAfter that, React runs the third render‚Äôs Effect. It connects to the 'travel' chat room.\n\nFinally, let‚Äôs say the user navigates away, and the ChatRoom component unmounts. React runs the last Effect‚Äôs cleanup function. The last Effect was from the third render. The third render‚Äôs cleanup destroys the createConnection('travel') connection. So the app disconnects from the 'travel' room.\n\nWhen Strict Mode is on, React remounts every component once after mount (state and DOM are preserved). This helps you find Effects that need cleanup and exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.\n\nIn this example, the form renders a <MyInput /> component.\n\nUse the input‚Äôs focus() method to make MyInput automatically focus when it appears on the screen. There is already a commented out implementation, but it doesn‚Äôt quite work. Figure out why it doesn‚Äôt work, and fix it. (If you‚Äôre familiar with the autoFocus attribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)\n\nTo verify that your solution works, press ‚ÄúShow form‚Äù and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press ‚ÄúHide form‚Äù and ‚ÄúShow form‚Äù again. Verify the input is highlighted again.\n\nMyInput should only focus on mount rather than after every render. To verify that the behavior is right, press ‚ÄúShow form‚Äù and then repeatedly press the ‚ÄúMake it uppercase‚Äù checkbox. Clicking the checkbox should not focus the input above it.",
  "headings": [
    {
      "level": "h1",
      "text": "Synchronizing with Effects",
      "id": ""
    },
    {
      "level": "h3",
      "text": "You will learn",
      "id": ""
    },
    {
      "level": "h2",
      "text": "What are Effects and how are they different from events?",
      "id": "what-are-effects-and-how-are-they-different-from-events"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h2",
      "text": "You might not need an Effect",
      "id": "you-might-not-need-an-effect"
    },
    {
      "level": "h2",
      "text": "How to write an Effect",
      "id": "how-to-write-an-effect"
    },
    {
      "level": "h3",
      "text": "Step 1: Declare an Effect",
      "id": "step-1-declare-an-effect"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Step 2: Specify the Effect dependencies",
      "id": "step-2-specify-the-effect-dependencies"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Why was the ref omitted from the dependency array?",
      "id": "why-was-the-ref-omitted-from-the-dependency-array"
    },
    {
      "level": "h3",
      "text": "Step 3: Add cleanup if needed",
      "id": "step-3-add-cleanup-if-needed"
    },
    {
      "level": "h2",
      "text": "How to handle the Effect firing twice in development?",
      "id": "how-to-handle-the-effect-firing-twice-in-development"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Don‚Äôt use refs to prevent Effects from firing",
      "id": "dont-use-refs-to-prevent-effects-from-firing"
    },
    {
      "level": "h3",
      "text": "Controlling non-React widgets",
      "id": "controlling-non-react-widgets"
    },
    {
      "level": "h3",
      "text": "Subscribing to events",
      "id": "subscribing-to-events"
    },
    {
      "level": "h3",
      "text": "Triggering animations",
      "id": "triggering-animations"
    },
    {
      "level": "h3",
      "text": "Fetching data",
      "id": "fetching-data"
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "What are good alternatives to data fetching in Effects?",
      "id": "what-are-good-alternatives-to-data-fetching-in-effects"
    },
    {
      "level": "h3",
      "text": "Sending analytics",
      "id": "sending-analytics"
    },
    {
      "level": "h3",
      "text": "Not an Effect: Initializing the application",
      "id": "not-an-effect-initializing-the-application"
    },
    {
      "level": "h3",
      "text": "Not an Effect: Buying a product",
      "id": "not-an-effect-buying-a-product"
    },
    {
      "level": "h2",
      "text": "Putting it all together",
      "id": "putting-it-all-together"
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Each render has its own Effects",
      "id": "each-render-has-its-own-effects"
    },
    {
      "level": "h4",
      "text": "Initial render",
      "id": "initial-render"
    },
    {
      "level": "h4",
      "text": "Re-render with same dependencies",
      "id": "re-render-with-same-dependencies"
    },
    {
      "level": "h4",
      "text": "Re-render with different dependencies",
      "id": "re-render-with-different-dependencies"
    },
    {
      "level": "h4",
      "text": "Unmount",
      "id": "unmount"
    },
    {
      "level": "h4",
      "text": "Development-only behaviors",
      "id": "development-only-behaviors"
    },
    {
      "level": "h2",
      "text": "Recap",
      "id": "recap"
    },
    {
      "level": "h2",
      "text": "Try out some challenges",
      "id": "challenges"
    },
    {
      "level": "h4",
      "text": "Challenge 1 of 4: Focus a field on mount",
      "id": "focus-a-field-on-mount"
    }
  ],
  "code_samples": [
    {
      "code": "import { useEffect } from 'react';",
      "language": "sql"
    },
    {
      "code": "function MyComponent() {  useEffect(() => {    // Code here will run after *every* render  });  return <div />;}",
      "language": "jsx"
    },
    {
      "code": "<VideoPlayer isPlaying={isPlaying} />;",
      "language": "jsx"
    },
    {
      "code": "function VideoPlayer({ src, isPlaying }) {  // TODO: do something with isPlaying  return <video src={src} />;}",
      "language": "jsx"
    },
    {
      "code": "import { useEffect, useRef } from 'react';function VideoPlayer({ src, isPlaying }) {  const ref = useRef(null);  useEffect(() => {    if (isPlaying) {      ref.current.play();    } else {      ref.current.pause();    }  });  return <video ref={ref} src={src} loop playsInline />;}",
      "language": "jsx"
    },
    {
      "code": "const [count, setCount] = useState(0);useEffect(() => {  setCount(count + 1);});",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {    // ...  }, []);",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {    if (isPlaying) { // It's used here...      // ...    } else {      // ...    }  }, [isPlaying]); // ...so it must be declared here!",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {  // This runs after every render});useEffect(() => {  // This runs only on mount (when the component appears)}, []);useEffect(() => {  // This runs on mount *and also* if either a or b have changed since the last render}, [a, b]);",
      "language": "jsx"
    },
    {
      "code": "function VideoPlayer({ src, isPlaying }) {  const ref = useRef(null);  useEffect(() => {    if (isPlaying) {      ref.current.play();    } else {      ref.current.pause();    }  }, [isPlaying]);",
      "language": "jsx"
    },
    {
      "code": "function VideoPlayer({ src, isPlaying }) {  const ref = useRef(null);  useEffect(() => {    if (isPlaying) {      ref.current.play();    } else {      ref.current.pause();    }  }, [isPlaying, ref]);",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {  const connection = createConnection();  connection.connect();});",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {  const connection = createConnection();  connection.connect();}, []);",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {    const connection = createConnection();    connection.connect();    return () => {      connection.disconnect();    };  }, []);",
      "language": "jsx"
    },
    {
      "code": "const connectionRef = useRef(null);  useEffect(() => {    // üö© This wont fix the bug!!!    if (!connectionRef.current) {      connectionRef.current = createConnection();      connectionRef.current.connect();    }  }, []);",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {  const map = mapRef.current;  map.setZoomLevel(zoomLevel);}, [zoomLevel]);",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {  const dialog = dialogRef.current;  dialog.showModal();  return () => dialog.close();}, []);",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {  function handleScroll(e) {    console.log(window.scrollX, window.scrollY);  }  window.addEventListener('scroll', handleScroll);  return () => window.removeEventListener('scroll', handleScroll);}, []);",
      "language": "javascript"
    },
    {
      "code": "useEffect(() => {  const node = ref.current;  node.style.opacity = 1; // Trigger the animation  return () => {    node.style.opacity = 0; // Reset to the initial value  };}, []);",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {  let ignore = false;  async function startFetching() {    const json = await fetchTodos(userId);    if (!ignore) {      setTodos(json);    }  }  startFetching();  return () => {    ignore = true;  };}, [userId]);",
      "language": "javascript"
    },
    {
      "code": "function TodoList() {  const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);  // ...",
      "language": "javascript"
    },
    {
      "code": "useEffect(() => {  logVisit(url); // Sends a POST request}, [url]);",
      "language": "jsx"
    },
    {
      "code": "if (typeof window !== 'undefined') { // Check if we're running in the browser.  checkAuthToken();  loadDataFromLocalStorage();}function App() {  // ...}",
      "language": "javascript"
    },
    {
      "code": "useEffect(() => {  // üî¥ Wrong: This Effect fires twice in development, exposing a problem in the code.  fetch('/api/buy', { method: 'POST' });}, []);",
      "language": "jsx"
    },
    {
      "code": "function handleClick() {    // ‚úÖ Buying is an event because it is caused by a particular interaction.    fetch('/api/buy', { method: 'POST' });  }",
      "language": "javascript"
    },
    {
      "code": "export default function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]);  return <h1>Welcome to {roomId}!</h1>;}",
      "language": "javascript"
    },
    {
      "code": "// JSX for the first render (roomId = \"general\")  return <h1>Welcome to general!</h1>;",
      "language": "typescript"
    },
    {
      "code": "// Effect for the first render (roomId = \"general\")  () => {    const connection = createConnection('general');    connection.connect();    return () => connection.disconnect();  },  // Dependencies for the first render (roomId = \"general\")  ['general']",
      "language": "javascript"
    },
    {
      "code": "// JSX for the second render (roomId = \"general\")  return <h1>Welcome to general!</h1>;",
      "language": "typescript"
    },
    {
      "code": "// Effect for the second render (roomId = \"general\")  () => {    const connection = createConnection('general');    connection.connect();    return () => connection.disconnect();  },  // Dependencies for the second render (roomId = \"general\")  ['general']",
      "language": "javascript"
    },
    {
      "code": "// JSX for the third render (roomId = \"travel\")  return <h1>Welcome to travel!</h1>;",
      "language": "typescript"
    },
    {
      "code": "// Effect for the third render (roomId = \"travel\")  () => {    const connection = createConnection('travel');    connection.connect();    return () => connection.disconnect();  },  // Dependencies for the third render (roomId = \"travel\")  ['travel']",
      "language": "javascript"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/learn/tutorial-tic-tac-toe",
    "https://react.dev/learn/thinking-in-react",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/creating-a-react-app",
    "https://react.dev/learn/build-a-react-app-from-scratch",
    "https://react.dev/learn/add-react-to-an-existing-project",
    "https://react.dev/learn/setup",
    "https://react.dev/learn/editor-setup",
    "https://react.dev/learn/typescript",
    "https://react.dev/learn/react-developer-tools",
    "https://react.dev/learn/react-compiler",
    "https://react.dev/learn/react-compiler/introduction",
    "https://react.dev/learn/react-compiler/installation",
    "https://react.dev/learn/react-compiler/incremental-adoption",
    "https://react.dev/learn/react-compiler/debugging",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/your-first-component",
    "https://react.dev/learn/importing-and-exporting-components",
    "https://react.dev/learn/writing-markup-with-jsx",
    "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/conditional-rendering",
    "https://react.dev/learn/rendering-lists",
    "https://react.dev/learn/keeping-components-pure",
    "https://react.dev/learn/understanding-your-ui-as-a-tree",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/responding-to-events",
    "https://react.dev/learn/state-a-components-memory",
    "https://react.dev/learn/render-and-commit",
    "https://react.dev/learn/state-as-a-snapshot",
    "https://react.dev/learn/queueing-a-series-of-state-updates",
    "https://react.dev/learn/updating-objects-in-state",
    "https://react.dev/learn/updating-arrays-in-state",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/reacting-to-input-with-state",
    "https://react.dev/learn/choosing-the-state-structure",
    "https://react.dev/learn/sharing-state-between-components",
    "https://react.dev/learn/preserving-and-resetting-state",
    "https://react.dev/learn/extracting-state-logic-into-a-reducer",
    "https://react.dev/learn/passing-data-deeply-with-context",
    "https://react.dev/learn/scaling-up-with-reducer-and-context",
    "https://react.dev/learn/escape-hatches",
    "https://react.dev/learn/referencing-values-with-refs",
    "https://react.dev/learn/manipulating-the-dom-with-refs",
    "https://react.dev/learn/synchronizing-with-effects",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/learn/lifecycle-of-reactive-effects",
    "https://react.dev/learn/separating-events-from-effects",
    "https://react.dev/learn/removing-effect-dependencies",
    "https://react.dev/learn/reusing-logic-with-custom-hooks",
    "https://react.dev/reference/react/useEffect",
    "https://react.dev/reference/react/useRef",
    "https://react.dev/reference/react/useState",
    "https://react.dev/reference/react/StrictMode",
    "https://react.dev/reference/react-dom"
  ]
}