{
  "url": "https://react.dev/learn/removing-effect-dependencies",
  "title": "Removing Effect Dependencies",
  "content": "When you write an Effect, the linter will verify that youâ€™ve included every reactive value (like props and state) that the Effect reads in the list of your Effectâ€™s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects.\n\nWhen you write an Effect, you first specify how to start and stop whatever you want your Effect to be doing:\n\nThen, if you leave the Effect dependencies empty ([]), the linter will suggest the correct dependencies:\n\nFill them in according to what the linter says:\n\nEffects â€œreactâ€ to reactive values. Since roomId is a reactive value (it can change due to a re-render), the linter verifies that youâ€™ve specified it as a dependency. If roomId receives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and â€œreactsâ€ to the dropdown:\n\nNotice that you canâ€™t â€œchooseâ€ the dependencies of your Effect. Every reactive value used by your Effectâ€™s code must be declared in your dependency list. The dependency list is determined by the surrounding code:\n\nReactive values include props and all variables and functions declared directly inside of your component. Since roomId is a reactive value, you canâ€™t remove it from the dependency list. The linter wouldnâ€™t allow it:\n\nAnd the linter would be right! Since roomId may change over time, this would introduce a bug in your code.\n\nTo remove a dependency, â€œproveâ€ to the linter that it doesnâ€™t need to be a dependency. For example, you can move roomId out of your component to prove that itâ€™s not reactive and wonâ€™t change on re-renders:\n\nNow that roomId is not a reactive value (and canâ€™t change on a re-render), it doesnâ€™t need to be a dependency:\n\nThis is why you could now specify an empty ([]) dependency list. Your Effect really doesnâ€™t depend on any reactive value anymore, so it really doesnâ€™t need to re-run when any of the componentâ€™s props or state change.\n\nYou might have noticed a pattern in your workflow:\n\nThe last part is important. If you want to change the dependencies, change the surrounding code first. You can think of the dependency list as a list of all the reactive values used by your Effectâ€™s code. You donâ€™t choose what to put on that list. The list describes your code. To change the dependency list, change the code.\n\nThis might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to â€œfindâ€ the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below.\n\nIf you have an existing codebase, you might have some Effects that suppress the linter like this:\n\nWhen dependencies donâ€™t match the code, there is a very high risk of introducing bugs. By suppressing the linter, you â€œlieâ€ to React about the values your Effect depends on.\n\nInstead, use the techniques below.\n\nSuppressing the linter leads to very unintuitive bugs that are hard to find and fix. Hereâ€™s one example:\n\nLetâ€™s say that you wanted to run the Effect â€œonly on mountâ€. Youâ€™ve read that empty ([]) dependencies do that, so youâ€™ve decided to ignore the linter, and forcefully specified [] as the dependencies.\n\nThis counter was supposed to increment every second by the amount configurable with the two buttons. However, since you â€œliedâ€ to React that this Effect doesnâ€™t depend on anything, React forever keeps using the onTick function from the initial render. During that render, count was 0 and increment was 1. This is why onTick from that render always calls setCount(0 + 1) every second, and you always see 1. Bugs like this are harder to fix when theyâ€™re spread across multiple components.\n\nThereâ€™s always a better solution than ignoring the linter! To fix this code, you need to add onTick to the dependency list. (To ensure the interval is only setup once, make onTick an Effect Event.)\n\nWe recommend treating the dependency lint error as a compilation error. If you donâ€™t suppress it, you will never see bugs like this. The rest of this page documents the alternatives for this and other cases.\n\nEvery time you adjust the Effectâ€™s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is â€œnoâ€:\n\nTo find the right solution, youâ€™ll need to answer a few questions about your Effect. Letâ€™s walk through them.\n\nThe first thing you should think about is whether this code should be an Effect at all.\n\nImagine a form. On submit, you set the submitted state variable to true. You need to send a POST request and show a notification. Youâ€™ve put this logic inside an Effect that â€œreactsâ€ to submitted being true:\n\nLater, you want to style the notification message according to the current theme, so you read the current theme. Since theme is declared in the component body, it is a reactive value, so you add it as a dependency:\n\nBy doing this, youâ€™ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The theme will change, the Effect will re-run, and so it will display the same notification again!\n\nThe problem here is that this shouldnâ€™t be an Effect in the first place. You want to send this POST request and show the notification in response to submitting the form, which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler:\n\nNow that the code is in an event handler, itâ€™s not reactiveâ€”so it will only run when the user submits the form. Read more about choosing between event handlers and Effects and how to delete unnecessary Effects.\n\nThe next question you should ask yourself is whether your Effect is doing several unrelated things.\n\nImagine youâ€™re creating a shipping form where the user needs to choose their city and area. You fetch the list of cities from the server according to the selected country to show them in a dropdown:\n\nThis is a good example of fetching data in an Effect. You are synchronizing the cities state with the network according to the country prop. You canâ€™t do this in an event handler because you need to fetch as soon as ShippingForm is displayed and whenever the country changes (no matter which interaction causes it).\n\nNow letâ€™s say youâ€™re adding a second select box for city areas, which should fetch the areas for the currently selected city. You might start by adding a second fetch call for the list of areas inside the same Effect:\n\nHowever, since the Effect now uses the city state variable, youâ€™ve had to add city to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call fetchCities(country). As a result, you will be unnecessarily refetching the list of cities many times.\n\nThe problem with this code is that youâ€™re synchronizing two different unrelated things:\n\nSplit the logic into two Effects, each of which reacts to the prop that it needs to synchronize with:\n\nNow the first Effect only re-runs if the country changes, while the second Effect re-runs when the city changes. Youâ€™ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they wonâ€™t trigger each other unintentionally.\n\nThe final code is longer than the original, but splitting these Effects is still correct. Each Effect should represent an independent synchronization process. In this example, deleting one Effect doesnâ€™t break the other Effectâ€™s logic. This means they synchronize different things, and itâ€™s good to split them up. If youâ€™re concerned about duplication, you can improve this code by extracting repetitive logic into a custom Hook.\n\nThis Effect updates the messages state variable with a newly created array every time a new message arrives:\n\nIt uses the messages variable to create a new array starting with all the existing messages and adds the new message at the end. However, since messages is a reactive value read by an Effect, it must be a dependency:\n\nAnd making messages a dependency introduces a problem.\n\nEvery time you receive a message, setMessages() causes the component to re-render with a new messages array that includes the received message. However, since this Effect now depends on messages, this will also re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that!\n\nTo fix the issue, donâ€™t read messages inside the Effect. Instead, pass an updater function to setMessages:\n\nNotice how your Effect does not read the messages variable at all now. You only need to pass an updater function like msgs => [...msgs, receivedMessage]. React puts your updater function in a queue and will provide the msgs argument to it during the next render. This is why the Effect itself doesnâ€™t need to depend on messages anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect.\n\nSuppose that you want to play a sound when the user receives a new message unless isMuted is true:\n\nSince your Effect now uses isMuted in its code, you have to add it to the dependencies:\n\nThe problem is that every time isMuted changes (for example, when the user presses the â€œMutedâ€ toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not workâ€”if you do that, isMuted would get â€œstuckâ€ with its old value.)\n\nTo solve this problem, you need to extract the logic that shouldnâ€™t be reactive out of the Effect. You donâ€™t want this Effect to â€œreactâ€ to the changes in isMuted. Move this non-reactive piece of logic into an Effect Event:\n\nEffect Events let you split an Effect into reactive parts (which should â€œreactâ€ to reactive values like roomId and their changes) and non-reactive parts (which only read their latest values, like onMessage reads isMuted). Now that you read isMuted inside an Effect Event, it doesnâ€™t need to be a dependency of your Effect. As a result, the chat wonâ€™t re-connect when you toggle the â€œMutedâ€ setting on and off, solving the original issue!\n\nYou might run into a similar problem when your component receives an event handler as a prop:\n\nSuppose that the parent component passes a different onReceiveMessage function on every render:\n\nSince onReceiveMessage is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event:\n\nEffect Events arenâ€™t reactive, so you donâ€™t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function thatâ€™s different on every re-render.\n\nIn this example, you want to log a visit every time roomId changes. You want to include the current notificationCount with every log, but you donâ€™t want a change to notificationCount to trigger a log event.\n\nThe solution is again to split out the non-reactive code into an Effect Event:\n\nYou want your logic to be reactive with regards to roomId, so you read roomId inside of your Effect. However, you donâ€™t want a change to notificationCount to log an extra visit, so you read notificationCount inside of the Effect Event. Learn more about reading the latest props and state from Effects using Effect Events.\n\nSometimes, you do want your Effect to â€œreactâ€ to a certain value, but that value changes more often than youâ€™d likeâ€”and might not reflect any actual change from the userâ€™s perspective. For example, letâ€™s say that you create an options object in the body of your component, and then read that object from inside of your Effect:\n\nThis object is declared in the component body, so itâ€™s a reactive value. When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect â€œreactsâ€ to its changes:\n\nIt is important to declare it as a dependency! This ensures, for example, that if the roomId changes, your Effect will re-connect to the chat with the new options. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console:\n\nIn the sandbox above, the input only updates the message state variable. From the userâ€™s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.\n\nA new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type.\n\nThis problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesnâ€™t matter that the contents inside of them may be the same!\n\nObject and function dependencies can make your Effect re-synchronize more often than you need.\n\nThis is why, whenever possible, you should try to avoid objects and functions as your Effectâ€™s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.\n\nIf the object does not depend on any props and state, you can move that object outside your component:\n\nThis way, you prove to the linter that itâ€™s not reactive. It canâ€™t change as a result of a re-render, so it doesnâ€™t need to be a dependency. Now re-rendering ChatRoom wonâ€™t cause your Effect to re-synchronize.\n\nThis works for functions too:\n\nSince createOptions is declared outside your component, itâ€™s not a reactive value. This is why it doesnâ€™t need to be specified in your Effectâ€™s dependencies, and why it wonâ€™t ever cause your Effect to re-synchronize.\n\nIf your object depends on some reactive value that may change as a result of a re-render, like a roomId prop, you canâ€™t pull it outside your component. You can, however, move its creation inside of your Effectâ€™s code:\n\nNow that options is declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect is roomId. Since roomId is not an object or function, you can be sure that it wonâ€™t be unintentionally different. In JavaScript, numbers and strings are compared by their content:\n\nThanks to this fix, the chat no longer re-connects if you edit the input:\n\nHowever, it does re-connect when you change the roomId dropdown, as you would expect.\n\nThis works for functions, too:\n\nYou can write your own functions to group pieces of logic inside your Effect. As long as you also declare them inside your Effect, theyâ€™re not reactive values, and so they donâ€™t need to be dependencies of your Effect.\n\nSometimes, you may receive an object from props:\n\nThe risk here is that the parent component will create the object during rendering:\n\nThis would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the object outside the Effect, and avoid having object and function dependencies:\n\nThe logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effect actually depends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, if options.roomId or options.serverUrl really are different, the chat would re-connect.\n\nThe same approach can work for functions. For example, suppose the parent component passes a function:\n\nTo avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you the roomId and serverUrl values that arenâ€™t objects, and that you can read from inside your Effect:\n\nThis only works for pure functions because they are safe to call during rendering. If your function is an event handler, but you donâ€™t want its changes to re-synchronize your Effect, wrap it into an Effect Event instead.\n\nThis Effect sets up an interval that ticks every second. Youâ€™ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesnâ€™t get constantly re-created.",
  "headings": [
    {
      "level": "h1",
      "text": "Removing Effect Dependencies",
      "id": ""
    },
    {
      "level": "h3",
      "text": "You will learn",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Dependencies should match the code",
      "id": "dependencies-should-match-the-code"
    },
    {
      "level": "h3",
      "text": "To remove a dependency, prove that itâ€™s not a dependency",
      "id": "to-remove-a-dependency-prove-that-its-not-a-dependency"
    },
    {
      "level": "h3",
      "text": "To change the dependencies, change the code",
      "id": "to-change-the-dependencies-change-the-code"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Why is suppressing the dependency linter so dangerous?",
      "id": "why-is-suppressing-the-dependency-linter-so-dangerous"
    },
    {
      "level": "h2",
      "text": "Removing unnecessary dependencies",
      "id": "removing-unnecessary-dependencies"
    },
    {
      "level": "h3",
      "text": "Should this code move to an event handler?",
      "id": "should-this-code-move-to-an-event-handler"
    },
    {
      "level": "h3",
      "text": "Is your Effect doing several unrelated things?",
      "id": "is-your-effect-doing-several-unrelated-things"
    },
    {
      "level": "h3",
      "text": "Are you reading some state to calculate the next state?",
      "id": "are-you-reading-some-state-to-calculate-the-next-state"
    },
    {
      "level": "h3",
      "text": "Do you want to read a value without â€œreactingâ€ to its changes?",
      "id": "do-you-want-to-read-a-value-without-reacting-to-its-changes"
    },
    {
      "level": "h4",
      "text": "Wrapping an event handler from the props",
      "id": "wrapping-an-event-handler-from-the-props"
    },
    {
      "level": "h4",
      "text": "Separating reactive and non-reactive code",
      "id": "separating-reactive-and-non-reactive-code"
    },
    {
      "level": "h3",
      "text": "Does some reactive value change unintentionally?",
      "id": "does-some-reactive-value-change-unintentionally"
    },
    {
      "level": "h4",
      "text": "Move static objects and functions outside your component",
      "id": "move-static-objects-and-functions-outside-your-component"
    },
    {
      "level": "h4",
      "text": "Move dynamic objects and functions inside your Effect",
      "id": "move-dynamic-objects-and-functions-inside-your-effect"
    },
    {
      "level": "h4",
      "text": "Read primitive values from objects",
      "id": "read-primitive-values-from-objects"
    },
    {
      "level": "h4",
      "text": "Calculate primitive values from functions",
      "id": "calculate-primitive-values-from-functions"
    },
    {
      "level": "h2",
      "text": "Recap",
      "id": "recap"
    },
    {
      "level": "h2",
      "text": "Try out some challenges",
      "id": "challenges"
    },
    {
      "level": "h4",
      "text": "Challenge 1 of 4: Fix a resetting interval",
      "id": "fix-a-resetting-interval"
    }
  ],
  "code_samples": [
    {
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  \t// ...}",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // âœ… All dependencies declared  // ...}",
      "language": "javascript"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { // This is a reactive value  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value    connection.connect();    return () => connection.disconnect();  }, [roomId]); // âœ… So you must specify that reactive value as a dependency of your Effect  // ...}",
      "language": "javascript"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // ðŸ”´ React Hook useEffect has a missing dependency: 'roomId'  // ...}",
      "language": "javascript"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234';const roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // âœ… All dependencies declared  // ...}",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {  // ...  // ðŸ”´ Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);",
      "language": "jsx"
    },
    {
      "code": "function Form() {  const [submitted, setSubmitted] = useState(false);  useEffect(() => {    if (submitted) {      // ðŸ”´ Avoid: Event-specific logic inside an Effect      post('/api/register');      showNotification('Successfully registered!');    }  }, [submitted]);  function handleSubmit() {    setSubmitted(true);  }  // ...}",
      "language": "jsx"
    },
    {
      "code": "function Form() {  const [submitted, setSubmitted] = useState(false);  const theme = useContext(ThemeContext);  useEffect(() => {    if (submitted) {      // ðŸ”´ Avoid: Event-specific logic inside an Effect      post('/api/register');      showNotification('Successfully registered!', theme);    }  }, [submitted, theme]); // âœ… All dependencies declared  function handleSubmit() {    setSubmitted(true);  }    // ...}",
      "language": "jsx"
    },
    {
      "code": "function Form() {  const theme = useContext(ThemeContext);  function handleSubmit() {    // âœ… Good: Event-specific logic is called from event handlers    post('/api/register');    showNotification('Successfully registered!', theme);  }    // ...}",
      "language": "javascript"
    },
    {
      "code": "function ShippingForm({ country }) {  const [cities, setCities] = useState(null);  const [city, setCity] = useState(null);  useEffect(() => {    let ignore = false;    fetch(`/api/cities?country=${country}`)      .then(response => response.json())      .then(json => {        if (!ignore) {          setCities(json);        }      });    return () => {      ignore = true;    };  }, [country]); // âœ… All dependencies declared  // ...",
      "language": "javascript"
    },
    {
      "code": "function ShippingForm({ country }) {  const [cities, setCities] = useState(null);  const [city, setCity] = useState(null);  const [areas, setAreas] = useState(null);  useEffect(() => {    let ignore = false;    fetch(`/api/cities?country=${country}`)      .then(response => response.json())      .then(json => {        if (!ignore) {          setCities(json);        }      });    // ðŸ”´ Avoid: A single Effect synchronizes two independent processes    if (city) {      fetch(`/api/areas?city=${city}`)        .then(response => response.json())        .then(json => {          if (!ignore) {            setAreas(json);          }        });    }    return () => {      ignore = true;    };  }, [country, city]); // âœ… All dependencies declared  // ...",
      "language": "javascript"
    },
    {
      "code": "function ShippingForm({ country }) {  const [cities, setCities] = useState(null);  useEffect(() => {    let ignore = false;    fetch(`/api/cities?country=${country}`)      .then(response => response.json())      .then(json => {        if (!ignore) {          setCities(json);        }      });    return () => {      ignore = true;    };  }, [country]); // âœ… All dependencies declared  const [city, setCity] = useState(null);  const [areas, setAreas] = useState(null);  useEffect(() => {    if (city) {      let ignore = false;      fetch(`/api/areas?city=${city}`)        .then(response => response.json())        .then(json => {          if (!ignore) {            setAreas(json);          }        });      return () => {        ignore = true;      };    }  }, [city]); // âœ… All dependencies declared  // ...",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages([...messages, receivedMessage]);    });    // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages([...messages, receivedMessage]);    });    return () => connection.disconnect();  }, [roomId, messages]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages(msgs => [...msgs, receivedMessage]);    });    return () => connection.disconnect();  }, [roomId]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  const [isMuted, setIsMuted] = useState(false);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages(msgs => [...msgs, receivedMessage]);      if (!isMuted) {        playSound();      }    });    // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  const [isMuted, setIsMuted] = useState(false);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages(msgs => [...msgs, receivedMessage]);      if (!isMuted) {        playSound();      }    });    return () => connection.disconnect();  }, [roomId, isMuted]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "import { useState, useEffect, useEffectEvent } from 'react';function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  const [isMuted, setIsMuted] = useState(false);  const onMessage = useEffectEvent(receivedMessage => {    setMessages(msgs => [...msgs, receivedMessage]);    if (!isMuted) {      playSound();    }  });  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      onMessage(receivedMessage);    });    return () => connection.disconnect();  }, [roomId]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId, onReceiveMessage }) {  const [messages, setMessages] = useState([]);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      onReceiveMessage(receivedMessage);    });    return () => connection.disconnect();  }, [roomId, onReceiveMessage]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "<ChatRoom  roomId={roomId}  onReceiveMessage={receivedMessage => {    // ...  }}/>",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId, onReceiveMessage }) {  const [messages, setMessages] = useState([]);  const onMessage = useEffectEvent(receivedMessage => {    onReceiveMessage(receivedMessage);  });  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      onMessage(receivedMessage);    });    return () => connection.disconnect();  }, [roomId]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "function Chat({ roomId, notificationCount }) {  const onVisit = useEffectEvent(visitedRoomId => {    logVisit(visitedRoomId, notificationCount);  });  useEffect(() => {    onVisit(roomId);  }, [roomId]); // âœ… All dependencies declared  // ...}",
      "language": "javascript"
    },
    {
      "code": "function ChatRoom({ roomId }) {  // ...  const options = {    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options);    connection.connect();    // ...",
      "language": "javascript"
    },
    {
      "code": "// ...  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "// During the first renderconst options1 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// During the next renderconst options2 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// These are two different objects!console.log(Object.is(options1, options2)); // false",
      "language": "css"
    },
    {
      "code": "const options = {  serverUrl: 'https://localhost:1234',  roomId: 'music'};function ChatRoom() {  const [message, setMessage] = useState('');  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, []); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "function createOptions() {  return {    serverUrl: 'https://localhost:1234',    roomId: 'music'  };}function ChatRoom() {  const [message, setMessage] = useState('');  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, []); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "// During the first renderconst roomId1 = 'music';// During the next renderconst roomId2 = 'music';// These two strings are the same!console.log(Object.is(roomId1, roomId2)); // true",
      "language": "javascript"
    },
    {
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() {      return {        serverUrl: serverUrl,        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ options }) {  const [message, setMessage] = useState('');  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "<ChatRoom  roomId={roomId}  options={{    serverUrl: serverUrl,    roomId: roomId  }}/>",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ options }) {  const [message, setMessage] = useState('');  const { roomId, serverUrl } = options;  useEffect(() => {    const connection = createConnection({      roomId: roomId,      serverUrl: serverUrl    });    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    },
    {
      "code": "<ChatRoom  roomId={roomId}  getOptions={() => {    return {      serverUrl: serverUrl,      roomId: roomId    };  }}/>",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ getOptions }) {  const [message, setMessage] = useState('');  const { roomId, serverUrl } = getOptions();  useEffect(() => {    const connection = createConnection({      roomId: roomId,      serverUrl: serverUrl    });    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]); // âœ… All dependencies declared  // ...",
      "language": "jsx"
    }
  ],
  "patterns": [
    {
      "description": "Learn ReactEscape HatchesRemoving Effect DependenciesWhen you write an Effect, the linter will verify that youâ€™ve included every reactive value (like props and state) that the Effect reads in the list of your Effectâ€™s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects. You will learn How to fix infinite Effect dependency loops What to do when you want to remove a dependency How to read a value from your Effect without â€œreactingâ€ to it How and why to avoid object and function dependencies Why suppressing the dependency linter is dangerous, and what to do instead Dependencies should match the code When you write an Effect, you first specify how to start and stop whatever you want your Effect to be doing: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); // ...} Then, if you leave the Effect dependencies empty ([]), the linter will suggest the correct dependencies: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // <-- Fix the mistake here! return <h1>Welcome to the {roomId} room!</h1>; } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more Fill them in according to what the linter says: function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ...} Effects â€œreactâ€ to reactive values. Since roomId is a reactive value (it can change due to a re-render), the linter verifies that youâ€™ve specified it as a dependency. If roomId receives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and â€œreactsâ€ to the dropdown: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); return <h1>Welcome to the {roomId} room!</h1>; } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more To remove a dependency, prove that itâ€™s not a dependency Notice that you canâ€™t â€œchooseâ€ the dependencies of your Effect. Every reactive value used by your Effectâ€™s code must be declared in your dependency list. The dependency list is determined by the surrounding code: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { // This is a reactive value useEffect(() => { const connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… So you must specify that reactive value as a dependency of your Effect // ...} Reactive values include props and all variables and functions declared directly inside of your component. Since roomId is a reactive value, you canâ€™t remove it from the dependency list. The linter wouldnâ€™t allow it: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // ðŸ”´ React Hook useEffect has a missing dependency: 'roomId' // ...} And the linter would be right! Since roomId may change over time, this would introduce a bug in your code. To remove a dependency, â€œproveâ€ to the linter that it doesnâ€™t need to be a dependency. For example, you can move roomId out of your component to prove that itâ€™s not reactive and wonâ€™t change on re-renders: const serverUrl = 'https://localhost:1234';const roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ...} Now that roomId is not a reactive value (and canâ€™t change on a re-render), it doesnâ€™t need to be a dependency: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; const roomId = 'music'; export default function ChatRoom() { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); return <h1>Welcome to the {roomId} room!</h1>; } This is why you could now specify an empty ([]) dependency list. Your Effect really doesnâ€™t depend on any reactive value anymore, so it really doesnâ€™t need to re-run when any of the componentâ€™s props or state change. To change the dependencies, change the code You might have noticed a pattern in your workflow: First, you change the code of your Effect or how your reactive values are declared. Then, you follow the linter and adjust the dependencies to match the code you have changed. If youâ€™re not happy with the list of dependencies, you go back to the first step (and change the code again). The last part is important. If you want to change the dependencies, change the surrounding code first. You can think of the dependency list as a list of all the reactive values used by your Effectâ€™s code. You donâ€™t choose what to put on that list. The list describes your code. To change the dependency list, change the code. This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to â€œfindâ€ the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below. PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() => { // ... // ðŸ”´ Avoid suppressing the linter like this: // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies donâ€™t match the code, there is a very high risk of introducing bugs. By suppressing the linter, you â€œlieâ€ to React about the values your Effect depends on.Instead, use the techniques below. Deep DiveWhy is suppressing the dependency linter so dangerous? Show DetailsSuppressing the linter leads to very unintuitive bugs that are hard to find and fix. Hereâ€™s one example:App.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; export default function Timer() { const [count, setCount] = useState(0); const [increment, setIncrement] = useState(1); function onTick() { setCount(count + increment); } useEffect(() => { const id = setInterval(onTick, 1000); return () => clearInterval(id); // eslint-disable-next-line react-hooks/exhaustive-deps }, []); return ( <> <h1> Counter: {count} <button onClick={() => setCount(0)}>Reset</button> </h1> <hr /> <p> Every second, increment by: <button disabled={increment === 0} onClick={() => { setIncrement(i => i - 1); }}>â€“</button> <b>{increment}</b> <button onClick={() => { setIncrement(i => i + 1); }}>+</button> </p> </> ); } Show moreLetâ€™s say that you wanted to run the Effect â€œonly on mountâ€. Youâ€™ve read that empty ([]) dependencies do that, so youâ€™ve decided to ignore the linter, and forcefully specified [] as the dependencies.This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you â€œliedâ€ to React that this Effect doesnâ€™t depend on anything, React forever keeps using the onTick function from the initial render. During that render, count was 0 and increment was 1. This is why onTick from that render always calls setCount(0 + 1) every second, and you always see 1. Bugs like this are harder to fix when theyâ€™re spread across multiple components.Thereâ€™s always a better solution than ignoring the linter! To fix this code, you need to add onTick to the dependency list. (To ensure the interval is only setup once, make onTick an Effect Event.)We recommend treating the dependency lint error as a compilation error. If you donâ€™t suppress it, you will never see bugs like this. The rest of this page documents the alternatives for this and other cases. Removing unnecessary dependencies Every time you adjust the Effectâ€™s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is â€œnoâ€: You might want to re-execute different parts of your Effect under different conditions. You might want to only read the latest value of some dependency instead of â€œreactingâ€ to its changes. A dependency may change too often unintentionally because itâ€™s an object or a function. To find the right solution, youâ€™ll need to answer a few questions about your Effect. Letâ€™s walk through them. Should this code move to an event handler? The first thing you should think about is whether this code should be an Effect at all. Imagine a form. On submit, you set the submitted state variable to true. You need to send a POST request and show a notification. Youâ€™ve put this logic inside an Effect that â€œreactsâ€ to submitted being true: function Form() { const [submitted, setSubmitted] = useState(false); useEffect(() => { if (submitted) { // ðŸ”´ Avoid: Event-specific logic inside an Effect post('/api/register'); showNotification('Successfully registered!'); } }, [submitted]); function handleSubmit() { setSubmitted(true); } // ...} Later, you want to style the notification message according to the current theme, so you read the current theme. Since theme is declared in the component body, it is a reactive value, so you add it as a dependency: function Form() { const [submitted, setSubmitted] = useState(false); const theme = useContext(ThemeContext); useEffect(() => { if (submitted) { // ðŸ”´ Avoid: Event-specific logic inside an Effect post('/api/register'); showNotification('Successfully registered!', theme); } }, [submitted, theme]); // âœ… All dependencies declared function handleSubmit() { setSubmitted(true); } // ...} By doing this, youâ€™ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The theme will change, the Effect will re-run, and so it will display the same notification again! The problem here is that this shouldnâ€™t be an Effect in the first place. You want to send this POST request and show the notification in response to submitting the form, which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler: function Form() { const theme = useContext(ThemeContext); function handleSubmit() { // âœ… Good: Event-specific logic is called from event handlers post('/api/register'); showNotification('Successfully registered!', theme); } // ...} Now that the code is in an event handler, itâ€™s not reactiveâ€”so it will only run when the user submits the form. Read more about choosing between event handlers and Effects and how to delete unnecessary Effects. Is your Effect doing several unrelated things? The next question you should ask yourself is whether your Effect is doing several unrelated things. Imagine youâ€™re creating a shipping form where the user needs to choose their city and area. You fetch the list of cities from the server according to the selected country to show them in a dropdown: function ShippingForm({ country }) { const [cities, setCities] = useState(null); const [city, setCity] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); return () => { ignore = true; }; }, [country]); // âœ… All dependencies declared // ... This is a good example of fetching data in an Effect. You are synchronizing the cities state with the network according to the country prop. You canâ€™t do this in an event handler because you need to fetch as soon as ShippingForm is displayed and whenever the country changes (no matter which interaction causes it). Now letâ€™s say youâ€™re adding a second select box for city areas, which should fetch the areas for the currently selected city. You might start by adding a second fetch call for the list of areas inside the same Effect: function ShippingForm({ country }) { const [cities, setCities] = useState(null); const [city, setCity] = useState(null); const [areas, setAreas] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); // ðŸ”´ Avoid: A single Effect synchronizes two independent processes if (city) { fetch(`/api/areas?city=${city}`) .then(response => response.json()) .then(json => { if (!ignore) { setAreas(json); } }); } return () => { ignore = true; }; }, [country, city]); // âœ… All dependencies declared // ... However, since the Effect now uses the city state variable, youâ€™ve had to add city to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call fetchCities(country). As a result, you will be unnecessarily refetching the list of cities many times. The problem with this code is that youâ€™re synchronizing two different unrelated things: You want to synchronize the cities state to the network based on the country prop. You want to synchronize the areas state to the network based on the city state. Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with: function ShippingForm({ country }) { const [cities, setCities] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); return () => { ignore = true; }; }, [country]); // âœ… All dependencies declared const [city, setCity] = useState(null); const [areas, setAreas] = useState(null); useEffect(() => { if (city) { let ignore = false; fetch(`/api/areas?city=${city}`) .then(response => response.json()) .then(json => { if (!ignore) { setAreas(json); } }); return () => { ignore = true; }; } }, [city]); // âœ… All dependencies declared // ... Now the first Effect only re-runs if the country changes, while the second Effect re-runs when the city changes. Youâ€™ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they wonâ€™t trigger each other unintentionally. The final code is longer than the original, but splitting these Effects is still correct. Each Effect should represent an independent synchronization process. In this example, deleting one Effect doesnâ€™t break the other Effectâ€™s logic. This means they synchronize different things, and itâ€™s good to split them up. If youâ€™re concerned about duplication, you can improve this code by extracting repetitive logic into a custom Hook. Are you reading some state to calculate the next state? This Effect updates the messages state variable with a newly created array every time a new message arrives: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages([...messages, receivedMessage]); }); // ... It uses the messages variable to create a new array starting with all the existing messages and adds the new message at the end. However, since messages is a reactive value read by an Effect, it must be a dependency: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages([...messages, receivedMessage]); }); return () => connection.disconnect(); }, [roomId, messages]); // âœ… All dependencies declared // ... And making messages a dependency introduces a problem. Every time you receive a message, setMessages() causes the component to re-render with a new messages array that includes the received message. However, since this Effect now depends on messages, this will also re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that! To fix the issue, donâ€™t read messages inside the Effect. Instead, pass an updater function to setMessages: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Notice how your Effect does not read the messages variable at all now. You only need to pass an updater function like msgs => [...msgs, receivedMessage]. React puts your updater function in a queue and will provide the msgs argument to it during the next render. This is why the Effect itself doesnâ€™t need to depend on messages anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect. Do you want to read a value without â€œreactingâ€ to its changes? Suppose that you want to play a sound when the user receives a new message unless isMuted is true: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); // ... Since your Effect now uses isMuted in its code, you have to add it to the dependencies: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); return () => connection.disconnect(); }, [roomId, isMuted]); // âœ… All dependencies declared // ... The problem is that every time isMuted changes (for example, when the user presses the â€œMutedâ€ toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not workâ€”if you do that, isMuted would get â€œstuckâ€ with its old value.) To solve this problem, you need to extract the logic that shouldnâ€™t be reactive out of the Effect. You donâ€™t want this Effect to â€œreactâ€ to the changes in isMuted. Move this non-reactive piece of logic into an Effect Event: import { useState, useEffect, useEffectEvent } from 'react';function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); const onMessage = useEffectEvent(receivedMessage => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Effect Events let you split an Effect into reactive parts (which should â€œreactâ€ to reactive values like roomId and their changes) and non-reactive parts (which only read their latest values, like onMessage reads isMuted). Now that you read isMuted inside an Effect Event, it doesnâ€™t need to be a dependency of your Effect. As a result, the chat wonâ€™t re-connect when you toggle the â€œMutedâ€ setting on and off, solving the original issue! Wrapping an event handler from the props You might run into a similar problem when your component receives an event handler as a prop: function ChatRoom({ roomId, onReceiveMessage }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onReceiveMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId, onReceiveMessage]); // âœ… All dependencies declared // ... Suppose that the parent component passes a different onReceiveMessage function on every render: <ChatRoom roomId={roomId} onReceiveMessage={receivedMessage => { // ... }}/> Since onReceiveMessage is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event: function ChatRoom({ roomId, onReceiveMessage }) { const [messages, setMessages] = useState([]); const onMessage = useEffectEvent(receivedMessage => { onReceiveMessage(receivedMessage); }); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Effect Events arenâ€™t reactive, so you donâ€™t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function thatâ€™s different on every re-render. Separating reactive and non-reactive code In this example, you want to log a visit every time roomId changes. You want to include the current notificationCount with every log, but you donâ€™t want a change to notificationCount to trigger a log event. The solution is again to split out the non-reactive code into an Effect Event: function Chat({ roomId, notificationCount }) { const onVisit = useEffectEvent(visitedRoomId => { logVisit(visitedRoomId, notificationCount); }); useEffect(() => { onVisit(roomId); }, [roomId]); // âœ… All dependencies declared // ...} You want your logic to be reactive with regards to roomId, so you read roomId inside of your Effect. However, you donâ€™t want a change to notificationCount to log an extra visit, so you read notificationCount inside of the Effect Event. Learn more about reading the latest props and state from Effects using Effect Events. Does some reactive value change unintentionally? Sometimes, you do want your Effect to â€œreactâ€ to a certain value, but that value changes more often than youâ€™d likeâ€”and might not reflect any actual change from the userâ€™s perspective. For example, letâ€™s say that you create an options object in the body of your component, and then read that object from inside of your Effect: function ChatRoom({ roomId }) { // ... const options = { serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); connection.connect(); // ... This object is declared in the component body, so itâ€™s a reactive value. When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect â€œreactsâ€ to its changes: // ... useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // âœ… All dependencies declared // ... It is important to declare it as a dependency! This ensures, for example, that if the roomId changes, your Effect will re-connect to the chat with the new options. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); // Temporarily disable the linter to demonstrate the problem // eslint-disable-next-line react-hooks/exhaustive-deps const options = { serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); return ( <> <h1>Welcome to the {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more In the sandbox above, the input only updates the message state variable. From the userâ€™s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch. A new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type. This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesnâ€™t matter that the contents inside of them may be the same! // During the first renderconst options1 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// During the next renderconst options2 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// These are two different objects!console.log(Object.is(options1, options2)); // false Object and function dependencies can make your Effect re-synchronize more often than you need. This is why, whenever possible, you should try to avoid objects and functions as your Effectâ€™s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them. Move static objects and functions outside your component If the object does not depend on any props and state, you can move that object outside your component: const options = { serverUrl: 'https://localhost:1234', roomId: 'music'};function ChatRoom() { const [message, setMessage] = useState(''); useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ... This way, you prove to the linter that itâ€™s not reactive. It canâ€™t change as a result of a re-render, so it doesnâ€™t need to be a dependency. Now re-rendering ChatRoom wonâ€™t cause your Effect to re-synchronize. This works for functions too: function createOptions() { return { serverUrl: 'https://localhost:1234', roomId: 'music' };}function ChatRoom() { const [message, setMessage] = useState(''); useEffect(() => { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ... Since createOptions is declared outside your component, itâ€™s not a reactive value. This is why it doesnâ€™t need to be specified in your Effectâ€™s dependencies, and why it wonâ€™t ever cause your Effect to re-synchronize. Move dynamic objects and functions inside your Effect If your object depends on some reactive value that may change as a result of a re-render, like a roomId prop, you canâ€™t pull it outside your component. You can, however, move its creation inside of your Effectâ€™s code: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Now that options is declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect is roomId. Since roomId is not an object or function, you can be sure that it wonâ€™t be unintentionally different. In JavaScript, numbers and strings are compared by their content: // During the first renderconst roomId1 = 'music';// During the next renderconst roomId2 = 'music';// These two strings are the same!console.log(Object.is(roomId1, roomId2)); // true Thanks to this fix, the chat no longer re-connects if you edit the input: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); return ( <> <h1>Welcome to the {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more However, it does re-connect when you change the roomId dropdown, as you would expect. This works for functions, too: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... You can write your own functions to group pieces of logic inside your Effect. As long as you also declare them inside your Effect, theyâ€™re not reactive values, and so they donâ€™t need to be dependencies of your Effect. Read primitive values from objects Sometimes, you may receive an object from props: function ChatRoom({ options }) { const [message, setMessage] = useState(''); useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // âœ… All dependencies declared // ... The risk here is that the parent component will create the object during rendering: <ChatRoom roomId={roomId} options={{ serverUrl: serverUrl, roomId: roomId }}/> This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the object outside the Effect, and avoid having object and function dependencies: function ChatRoom({ options }) { const [message, setMessage] = useState(''); const { roomId, serverUrl } = options; useEffect(() => { const connection = createConnection({ roomId: roomId, serverUrl: serverUrl }); connection.connect(); return () => connection.disconnect(); }, [roomId, serverUrl]); // âœ… All dependencies declared // ... The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effect actually depends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, if options.roomId or options.serverUrl really are different, the chat would re-connect. Calculate primitive values from functions The same approach can work for functions. For example, suppose the parent component passes a function: <ChatRoom roomId={roomId} getOptions={() => { return { serverUrl: serverUrl, roomId: roomId }; }}/> To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you the roomId and serverUrl values that arenâ€™t objects, and that you can read from inside your Effect: function ChatRoom({ getOptions }) { const [message, setMessage] = useState(''); const { roomId, serverUrl } = getOptions(); useEffect(() => { const connection = createConnection({ roomId: roomId, serverUrl: serverUrl }); connection.connect(); return () => connection.disconnect(); }, [roomId, serverUrl]); // âœ… All dependencies declared // ... This only works for pure functions because they are safe to call during rendering. If your function is an event handler, but you donâ€™t want its changes to re-synchronize your Effect, wrap it into an Effect Event instead. Recap Dependencies should always match the code. When youâ€™re not happy with your dependencies, what you need to edit is the code. Suppressing the linter leads to very confusing bugs, and you should always avoid it. To remove a dependency, you need to â€œproveâ€ to the linter that itâ€™s not necessary. If some code should run in response to a specific interaction, move that code to an event handler. If different parts of your Effect should re-run for different reasons, split it into several Effects. If you want to update some state based on the previous state, pass an updater function. If you want to read the latest value without â€œreactingâ€ it, extract an Effect Event from your Effect. In JavaScript, objects and functions are considered different if they were created at different times. Try to avoid object and function dependencies. Move them outside the component or inside the Effect. Try out some challenges1. Fix a resetting interval 2. Fix a retriggering animation 3. Fix a reconnecting chat 4. Fix a reconnecting chat, again Challenge 1 of 4: Fix a resetting interval This Effect sets up an interval that ticks every second. Youâ€™ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesnâ€™t get constantly re-created.App.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; export default function Timer() { const [count, setCount] = useState(0); useEffect(() => { console.log('âœ… Creating an interval'); const id = setInterval(() => { console.log('â° Interval tick'); setCount(count + 1); }, 1000); return () => { console.log('âŒ Clearing an interval'); clearInterval(id); }; }, [count]); return <h1>Counter: {count}</h1> } Show more Show hint Show solutionNext ChallengePreviousSeparating Events from EffectsNextReusing Logic with Custom Hooks",
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  \t// ...}"
    },
    {
      "description": "When you write an Effect, the linter will verify that youâ€™ve included every reactive value (like props and state) that the Effect reads in the list of your Effectâ€™s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects. You will learn How to fix infinite Effect dependency loops What to do when you want to remove a dependency How to read a value from your Effect without â€œreactingâ€ to it How and why to avoid object and function dependencies Why suppressing the dependency linter is dangerous, and what to do instead Dependencies should match the code When you write an Effect, you first specify how to start and stop whatever you want your Effect to be doing: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); // ...} Then, if you leave the Effect dependencies empty ([]), the linter will suggest the correct dependencies: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // <-- Fix the mistake here! return <h1>Welcome to the {roomId} room!</h1>; } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more Fill them in according to what the linter says: function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ...} Effects â€œreactâ€ to reactive values. Since roomId is a reactive value (it can change due to a re-render), the linter verifies that youâ€™ve specified it as a dependency. If roomId receives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and â€œreactsâ€ to the dropdown: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); return <h1>Welcome to the {roomId} room!</h1>; } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more To remove a dependency, prove that itâ€™s not a dependency Notice that you canâ€™t â€œchooseâ€ the dependencies of your Effect. Every reactive value used by your Effectâ€™s code must be declared in your dependency list. The dependency list is determined by the surrounding code: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { // This is a reactive value useEffect(() => { const connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… So you must specify that reactive value as a dependency of your Effect // ...} Reactive values include props and all variables and functions declared directly inside of your component. Since roomId is a reactive value, you canâ€™t remove it from the dependency list. The linter wouldnâ€™t allow it: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // ðŸ”´ React Hook useEffect has a missing dependency: 'roomId' // ...} And the linter would be right! Since roomId may change over time, this would introduce a bug in your code. To remove a dependency, â€œproveâ€ to the linter that it doesnâ€™t need to be a dependency. For example, you can move roomId out of your component to prove that itâ€™s not reactive and wonâ€™t change on re-renders: const serverUrl = 'https://localhost:1234';const roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ...} Now that roomId is not a reactive value (and canâ€™t change on a re-render), it doesnâ€™t need to be a dependency: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; const roomId = 'music'; export default function ChatRoom() { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); return <h1>Welcome to the {roomId} room!</h1>; } This is why you could now specify an empty ([]) dependency list. Your Effect really doesnâ€™t depend on any reactive value anymore, so it really doesnâ€™t need to re-run when any of the componentâ€™s props or state change. To change the dependencies, change the code You might have noticed a pattern in your workflow: First, you change the code of your Effect or how your reactive values are declared. Then, you follow the linter and adjust the dependencies to match the code you have changed. If youâ€™re not happy with the list of dependencies, you go back to the first step (and change the code again). The last part is important. If you want to change the dependencies, change the surrounding code first. You can think of the dependency list as a list of all the reactive values used by your Effectâ€™s code. You donâ€™t choose what to put on that list. The list describes your code. To change the dependency list, change the code. This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to â€œfindâ€ the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below. PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() => { // ... // ðŸ”´ Avoid suppressing the linter like this: // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies donâ€™t match the code, there is a very high risk of introducing bugs. By suppressing the linter, you â€œlieâ€ to React about the values your Effect depends on.Instead, use the techniques below. Deep DiveWhy is suppressing the dependency linter so dangerous? Show DetailsSuppressing the linter leads to very unintuitive bugs that are hard to find and fix. Hereâ€™s one example:App.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; export default function Timer() { const [count, setCount] = useState(0); const [increment, setIncrement] = useState(1); function onTick() { setCount(count + increment); } useEffect(() => { const id = setInterval(onTick, 1000); return () => clearInterval(id); // eslint-disable-next-line react-hooks/exhaustive-deps }, []); return ( <> <h1> Counter: {count} <button onClick={() => setCount(0)}>Reset</button> </h1> <hr /> <p> Every second, increment by: <button disabled={increment === 0} onClick={() => { setIncrement(i => i - 1); }}>â€“</button> <b>{increment}</b> <button onClick={() => { setIncrement(i => i + 1); }}>+</button> </p> </> ); } Show moreLetâ€™s say that you wanted to run the Effect â€œonly on mountâ€. Youâ€™ve read that empty ([]) dependencies do that, so youâ€™ve decided to ignore the linter, and forcefully specified [] as the dependencies.This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you â€œliedâ€ to React that this Effect doesnâ€™t depend on anything, React forever keeps using the onTick function from the initial render. During that render, count was 0 and increment was 1. This is why onTick from that render always calls setCount(0 + 1) every second, and you always see 1. Bugs like this are harder to fix when theyâ€™re spread across multiple components.Thereâ€™s always a better solution than ignoring the linter! To fix this code, you need to add onTick to the dependency list. (To ensure the interval is only setup once, make onTick an Effect Event.)We recommend treating the dependency lint error as a compilation error. If you donâ€™t suppress it, you will never see bugs like this. The rest of this page documents the alternatives for this and other cases. Removing unnecessary dependencies Every time you adjust the Effectâ€™s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is â€œnoâ€: You might want to re-execute different parts of your Effect under different conditions. You might want to only read the latest value of some dependency instead of â€œreactingâ€ to its changes. A dependency may change too often unintentionally because itâ€™s an object or a function. To find the right solution, youâ€™ll need to answer a few questions about your Effect. Letâ€™s walk through them. Should this code move to an event handler? The first thing you should think about is whether this code should be an Effect at all. Imagine a form. On submit, you set the submitted state variable to true. You need to send a POST request and show a notification. Youâ€™ve put this logic inside an Effect that â€œreactsâ€ to submitted being true: function Form() { const [submitted, setSubmitted] = useState(false); useEffect(() => { if (submitted) { // ðŸ”´ Avoid: Event-specific logic inside an Effect post('/api/register'); showNotification('Successfully registered!'); } }, [submitted]); function handleSubmit() { setSubmitted(true); } // ...} Later, you want to style the notification message according to the current theme, so you read the current theme. Since theme is declared in the component body, it is a reactive value, so you add it as a dependency: function Form() { const [submitted, setSubmitted] = useState(false); const theme = useContext(ThemeContext); useEffect(() => { if (submitted) { // ðŸ”´ Avoid: Event-specific logic inside an Effect post('/api/register'); showNotification('Successfully registered!', theme); } }, [submitted, theme]); // âœ… All dependencies declared function handleSubmit() { setSubmitted(true); } // ...} By doing this, youâ€™ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The theme will change, the Effect will re-run, and so it will display the same notification again! The problem here is that this shouldnâ€™t be an Effect in the first place. You want to send this POST request and show the notification in response to submitting the form, which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler: function Form() { const theme = useContext(ThemeContext); function handleSubmit() { // âœ… Good: Event-specific logic is called from event handlers post('/api/register'); showNotification('Successfully registered!', theme); } // ...} Now that the code is in an event handler, itâ€™s not reactiveâ€”so it will only run when the user submits the form. Read more about choosing between event handlers and Effects and how to delete unnecessary Effects. Is your Effect doing several unrelated things? The next question you should ask yourself is whether your Effect is doing several unrelated things. Imagine youâ€™re creating a shipping form where the user needs to choose their city and area. You fetch the list of cities from the server according to the selected country to show them in a dropdown: function ShippingForm({ country }) { const [cities, setCities] = useState(null); const [city, setCity] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); return () => { ignore = true; }; }, [country]); // âœ… All dependencies declared // ... This is a good example of fetching data in an Effect. You are synchronizing the cities state with the network according to the country prop. You canâ€™t do this in an event handler because you need to fetch as soon as ShippingForm is displayed and whenever the country changes (no matter which interaction causes it). Now letâ€™s say youâ€™re adding a second select box for city areas, which should fetch the areas for the currently selected city. You might start by adding a second fetch call for the list of areas inside the same Effect: function ShippingForm({ country }) { const [cities, setCities] = useState(null); const [city, setCity] = useState(null); const [areas, setAreas] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); // ðŸ”´ Avoid: A single Effect synchronizes two independent processes if (city) { fetch(`/api/areas?city=${city}`) .then(response => response.json()) .then(json => { if (!ignore) { setAreas(json); } }); } return () => { ignore = true; }; }, [country, city]); // âœ… All dependencies declared // ... However, since the Effect now uses the city state variable, youâ€™ve had to add city to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call fetchCities(country). As a result, you will be unnecessarily refetching the list of cities many times. The problem with this code is that youâ€™re synchronizing two different unrelated things: You want to synchronize the cities state to the network based on the country prop. You want to synchronize the areas state to the network based on the city state. Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with: function ShippingForm({ country }) { const [cities, setCities] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); return () => { ignore = true; }; }, [country]); // âœ… All dependencies declared const [city, setCity] = useState(null); const [areas, setAreas] = useState(null); useEffect(() => { if (city) { let ignore = false; fetch(`/api/areas?city=${city}`) .then(response => response.json()) .then(json => { if (!ignore) { setAreas(json); } }); return () => { ignore = true; }; } }, [city]); // âœ… All dependencies declared // ... Now the first Effect only re-runs if the country changes, while the second Effect re-runs when the city changes. Youâ€™ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they wonâ€™t trigger each other unintentionally. The final code is longer than the original, but splitting these Effects is still correct. Each Effect should represent an independent synchronization process. In this example, deleting one Effect doesnâ€™t break the other Effectâ€™s logic. This means they synchronize different things, and itâ€™s good to split them up. If youâ€™re concerned about duplication, you can improve this code by extracting repetitive logic into a custom Hook. Are you reading some state to calculate the next state? This Effect updates the messages state variable with a newly created array every time a new message arrives: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages([...messages, receivedMessage]); }); // ... It uses the messages variable to create a new array starting with all the existing messages and adds the new message at the end. However, since messages is a reactive value read by an Effect, it must be a dependency: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages([...messages, receivedMessage]); }); return () => connection.disconnect(); }, [roomId, messages]); // âœ… All dependencies declared // ... And making messages a dependency introduces a problem. Every time you receive a message, setMessages() causes the component to re-render with a new messages array that includes the received message. However, since this Effect now depends on messages, this will also re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that! To fix the issue, donâ€™t read messages inside the Effect. Instead, pass an updater function to setMessages: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Notice how your Effect does not read the messages variable at all now. You only need to pass an updater function like msgs => [...msgs, receivedMessage]. React puts your updater function in a queue and will provide the msgs argument to it during the next render. This is why the Effect itself doesnâ€™t need to depend on messages anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect. Do you want to read a value without â€œreactingâ€ to its changes? Suppose that you want to play a sound when the user receives a new message unless isMuted is true: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); // ... Since your Effect now uses isMuted in its code, you have to add it to the dependencies: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); return () => connection.disconnect(); }, [roomId, isMuted]); // âœ… All dependencies declared // ... The problem is that every time isMuted changes (for example, when the user presses the â€œMutedâ€ toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not workâ€”if you do that, isMuted would get â€œstuckâ€ with its old value.) To solve this problem, you need to extract the logic that shouldnâ€™t be reactive out of the Effect. You donâ€™t want this Effect to â€œreactâ€ to the changes in isMuted. Move this non-reactive piece of logic into an Effect Event: import { useState, useEffect, useEffectEvent } from 'react';function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); const onMessage = useEffectEvent(receivedMessage => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Effect Events let you split an Effect into reactive parts (which should â€œreactâ€ to reactive values like roomId and their changes) and non-reactive parts (which only read their latest values, like onMessage reads isMuted). Now that you read isMuted inside an Effect Event, it doesnâ€™t need to be a dependency of your Effect. As a result, the chat wonâ€™t re-connect when you toggle the â€œMutedâ€ setting on and off, solving the original issue! Wrapping an event handler from the props You might run into a similar problem when your component receives an event handler as a prop: function ChatRoom({ roomId, onReceiveMessage }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onReceiveMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId, onReceiveMessage]); // âœ… All dependencies declared // ... Suppose that the parent component passes a different onReceiveMessage function on every render: <ChatRoom roomId={roomId} onReceiveMessage={receivedMessage => { // ... }}/> Since onReceiveMessage is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event: function ChatRoom({ roomId, onReceiveMessage }) { const [messages, setMessages] = useState([]); const onMessage = useEffectEvent(receivedMessage => { onReceiveMessage(receivedMessage); }); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Effect Events arenâ€™t reactive, so you donâ€™t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function thatâ€™s different on every re-render. Separating reactive and non-reactive code In this example, you want to log a visit every time roomId changes. You want to include the current notificationCount with every log, but you donâ€™t want a change to notificationCount to trigger a log event. The solution is again to split out the non-reactive code into an Effect Event: function Chat({ roomId, notificationCount }) { const onVisit = useEffectEvent(visitedRoomId => { logVisit(visitedRoomId, notificationCount); }); useEffect(() => { onVisit(roomId); }, [roomId]); // âœ… All dependencies declared // ...} You want your logic to be reactive with regards to roomId, so you read roomId inside of your Effect. However, you donâ€™t want a change to notificationCount to log an extra visit, so you read notificationCount inside of the Effect Event. Learn more about reading the latest props and state from Effects using Effect Events. Does some reactive value change unintentionally? Sometimes, you do want your Effect to â€œreactâ€ to a certain value, but that value changes more often than youâ€™d likeâ€”and might not reflect any actual change from the userâ€™s perspective. For example, letâ€™s say that you create an options object in the body of your component, and then read that object from inside of your Effect: function ChatRoom({ roomId }) { // ... const options = { serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); connection.connect(); // ... This object is declared in the component body, so itâ€™s a reactive value. When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect â€œreactsâ€ to its changes: // ... useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // âœ… All dependencies declared // ... It is important to declare it as a dependency! This ensures, for example, that if the roomId changes, your Effect will re-connect to the chat with the new options. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); // Temporarily disable the linter to demonstrate the problem // eslint-disable-next-line react-hooks/exhaustive-deps const options = { serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); return ( <> <h1>Welcome to the {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more In the sandbox above, the input only updates the message state variable. From the userâ€™s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch. A new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type. This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesnâ€™t matter that the contents inside of them may be the same! // During the first renderconst options1 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// During the next renderconst options2 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// These are two different objects!console.log(Object.is(options1, options2)); // false Object and function dependencies can make your Effect re-synchronize more often than you need. This is why, whenever possible, you should try to avoid objects and functions as your Effectâ€™s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them. Move static objects and functions outside your component If the object does not depend on any props and state, you can move that object outside your component: const options = { serverUrl: 'https://localhost:1234', roomId: 'music'};function ChatRoom() { const [message, setMessage] = useState(''); useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ... This way, you prove to the linter that itâ€™s not reactive. It canâ€™t change as a result of a re-render, so it doesnâ€™t need to be a dependency. Now re-rendering ChatRoom wonâ€™t cause your Effect to re-synchronize. This works for functions too: function createOptions() { return { serverUrl: 'https://localhost:1234', roomId: 'music' };}function ChatRoom() { const [message, setMessage] = useState(''); useEffect(() => { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ... Since createOptions is declared outside your component, itâ€™s not a reactive value. This is why it doesnâ€™t need to be specified in your Effectâ€™s dependencies, and why it wonâ€™t ever cause your Effect to re-synchronize. Move dynamic objects and functions inside your Effect If your object depends on some reactive value that may change as a result of a re-render, like a roomId prop, you canâ€™t pull it outside your component. You can, however, move its creation inside of your Effectâ€™s code: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Now that options is declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect is roomId. Since roomId is not an object or function, you can be sure that it wonâ€™t be unintentionally different. In JavaScript, numbers and strings are compared by their content: // During the first renderconst roomId1 = 'music';// During the next renderconst roomId2 = 'music';// These two strings are the same!console.log(Object.is(roomId1, roomId2)); // true Thanks to this fix, the chat no longer re-connects if you edit the input: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); return ( <> <h1>Welcome to the {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more However, it does re-connect when you change the roomId dropdown, as you would expect. This works for functions, too: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... You can write your own functions to group pieces of logic inside your Effect. As long as you also declare them inside your Effect, theyâ€™re not reactive values, and so they donâ€™t need to be dependencies of your Effect. Read primitive values from objects Sometimes, you may receive an object from props: function ChatRoom({ options }) { const [message, setMessage] = useState(''); useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // âœ… All dependencies declared // ... The risk here is that the parent component will create the object during rendering: <ChatRoom roomId={roomId} options={{ serverUrl: serverUrl, roomId: roomId }}/> This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the object outside the Effect, and avoid having object and function dependencies: function ChatRoom({ options }) { const [message, setMessage] = useState(''); const { roomId, serverUrl } = options; useEffect(() => { const connection = createConnection({ roomId: roomId, serverUrl: serverUrl }); connection.connect(); return () => connection.disconnect(); }, [roomId, serverUrl]); // âœ… All dependencies declared // ... The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effect actually depends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, if options.roomId or options.serverUrl really are different, the chat would re-connect. Calculate primitive values from functions The same approach can work for functions. For example, suppose the parent component passes a function: <ChatRoom roomId={roomId} getOptions={() => { return { serverUrl: serverUrl, roomId: roomId }; }}/> To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you the roomId and serverUrl values that arenâ€™t objects, and that you can read from inside your Effect: function ChatRoom({ getOptions }) { const [message, setMessage] = useState(''); const { roomId, serverUrl } = getOptions(); useEffect(() => { const connection = createConnection({ roomId: roomId, serverUrl: serverUrl }); connection.connect(); return () => connection.disconnect(); }, [roomId, serverUrl]); // âœ… All dependencies declared // ... This only works for pure functions because they are safe to call during rendering. If your function is an event handler, but you donâ€™t want its changes to re-synchronize your Effect, wrap it into an Effect Event instead. Recap Dependencies should always match the code. When youâ€™re not happy with your dependencies, what you need to edit is the code. Suppressing the linter leads to very confusing bugs, and you should always avoid it. To remove a dependency, you need to â€œproveâ€ to the linter that itâ€™s not necessary. If some code should run in response to a specific interaction, move that code to an event handler. If different parts of your Effect should re-run for different reasons, split it into several Effects. If you want to update some state based on the previous state, pass an updater function. If you want to read the latest value without â€œreactingâ€ it, extract an Effect Event from your Effect. In JavaScript, objects and functions are considered different if they were created at different times. Try to avoid object and function dependencies. Move them outside the component or inside the Effect. Try out some challenges1. Fix a resetting interval 2. Fix a retriggering animation 3. Fix a reconnecting chat 4. Fix a reconnecting chat, again Challenge 1 of 4: Fix a resetting interval This Effect sets up an interval that ticks every second. Youâ€™ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesnâ€™t get constantly re-created.App.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; export default function Timer() { const [count, setCount] = useState(0); useEffect(() => { console.log('âœ… Creating an interval'); const id = setInterval(() => { console.log('â° Interval tick'); setCount(count + 1); }, 1000); return () => { console.log('âŒ Clearing an interval'); clearInterval(id); }; }, [count]); return <h1>Counter: {count}</h1> } Show more Show hint Show solutionNext ChallengePreviousSeparating Events from EffectsNextReusing Logic with Custom Hooks",
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  \t// ...}"
    },
    {
      "description": "When you write an Effect, the linter will verify that youâ€™ve included every reactive value (like props and state) that the Effect reads in the list of your Effectâ€™s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects. You will learn How to fix infinite Effect dependency loops What to do when you want to remove a dependency How to read a value from your Effect without â€œreactingâ€ to it How and why to avoid object and function dependencies Why suppressing the dependency linter is dangerous, and what to do instead Dependencies should match the code When you write an Effect, you first specify how to start and stop whatever you want your Effect to be doing: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); // ...} Then, if you leave the Effect dependencies empty ([]), the linter will suggest the correct dependencies: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // <-- Fix the mistake here! return <h1>Welcome to the {roomId} room!</h1>; } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more Fill them in according to what the linter says: function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ...} Effects â€œreactâ€ to reactive values. Since roomId is a reactive value (it can change due to a re-render), the linter verifies that youâ€™ve specified it as a dependency. If roomId receives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and â€œreactsâ€ to the dropdown: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); return <h1>Welcome to the {roomId} room!</h1>; } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more To remove a dependency, prove that itâ€™s not a dependency Notice that you canâ€™t â€œchooseâ€ the dependencies of your Effect. Every reactive value used by your Effectâ€™s code must be declared in your dependency list. The dependency list is determined by the surrounding code: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { // This is a reactive value useEffect(() => { const connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… So you must specify that reactive value as a dependency of your Effect // ...} Reactive values include props and all variables and functions declared directly inside of your component. Since roomId is a reactive value, you canâ€™t remove it from the dependency list. The linter wouldnâ€™t allow it: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // ðŸ”´ React Hook useEffect has a missing dependency: 'roomId' // ...} And the linter would be right! Since roomId may change over time, this would introduce a bug in your code. To remove a dependency, â€œproveâ€ to the linter that it doesnâ€™t need to be a dependency. For example, you can move roomId out of your component to prove that itâ€™s not reactive and wonâ€™t change on re-renders: const serverUrl = 'https://localhost:1234';const roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ...} Now that roomId is not a reactive value (and canâ€™t change on a re-render), it doesnâ€™t need to be a dependency: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; const roomId = 'music'; export default function ChatRoom() { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); return <h1>Welcome to the {roomId} room!</h1>; } This is why you could now specify an empty ([]) dependency list. Your Effect really doesnâ€™t depend on any reactive value anymore, so it really doesnâ€™t need to re-run when any of the componentâ€™s props or state change. To change the dependencies, change the code You might have noticed a pattern in your workflow: First, you change the code of your Effect or how your reactive values are declared. Then, you follow the linter and adjust the dependencies to match the code you have changed. If youâ€™re not happy with the list of dependencies, you go back to the first step (and change the code again). The last part is important. If you want to change the dependencies, change the surrounding code first. You can think of the dependency list as a list of all the reactive values used by your Effectâ€™s code. You donâ€™t choose what to put on that list. The list describes your code. To change the dependency list, change the code. This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to â€œfindâ€ the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below. PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() => { // ... // ðŸ”´ Avoid suppressing the linter like this: // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies donâ€™t match the code, there is a very high risk of introducing bugs. By suppressing the linter, you â€œlieâ€ to React about the values your Effect depends on.Instead, use the techniques below. Deep DiveWhy is suppressing the dependency linter so dangerous? Show DetailsSuppressing the linter leads to very unintuitive bugs that are hard to find and fix. Hereâ€™s one example:App.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; export default function Timer() { const [count, setCount] = useState(0); const [increment, setIncrement] = useState(1); function onTick() { setCount(count + increment); } useEffect(() => { const id = setInterval(onTick, 1000); return () => clearInterval(id); // eslint-disable-next-line react-hooks/exhaustive-deps }, []); return ( <> <h1> Counter: {count} <button onClick={() => setCount(0)}>Reset</button> </h1> <hr /> <p> Every second, increment by: <button disabled={increment === 0} onClick={() => { setIncrement(i => i - 1); }}>â€“</button> <b>{increment}</b> <button onClick={() => { setIncrement(i => i + 1); }}>+</button> </p> </> ); } Show moreLetâ€™s say that you wanted to run the Effect â€œonly on mountâ€. Youâ€™ve read that empty ([]) dependencies do that, so youâ€™ve decided to ignore the linter, and forcefully specified [] as the dependencies.This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you â€œliedâ€ to React that this Effect doesnâ€™t depend on anything, React forever keeps using the onTick function from the initial render. During that render, count was 0 and increment was 1. This is why onTick from that render always calls setCount(0 + 1) every second, and you always see 1. Bugs like this are harder to fix when theyâ€™re spread across multiple components.Thereâ€™s always a better solution than ignoring the linter! To fix this code, you need to add onTick to the dependency list. (To ensure the interval is only setup once, make onTick an Effect Event.)We recommend treating the dependency lint error as a compilation error. If you donâ€™t suppress it, you will never see bugs like this. The rest of this page documents the alternatives for this and other cases. Removing unnecessary dependencies Every time you adjust the Effectâ€™s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is â€œnoâ€: You might want to re-execute different parts of your Effect under different conditions. You might want to only read the latest value of some dependency instead of â€œreactingâ€ to its changes. A dependency may change too often unintentionally because itâ€™s an object or a function. To find the right solution, youâ€™ll need to answer a few questions about your Effect. Letâ€™s walk through them. Should this code move to an event handler? The first thing you should think about is whether this code should be an Effect at all. Imagine a form. On submit, you set the submitted state variable to true. You need to send a POST request and show a notification. Youâ€™ve put this logic inside an Effect that â€œreactsâ€ to submitted being true: function Form() { const [submitted, setSubmitted] = useState(false); useEffect(() => { if (submitted) { // ðŸ”´ Avoid: Event-specific logic inside an Effect post('/api/register'); showNotification('Successfully registered!'); } }, [submitted]); function handleSubmit() { setSubmitted(true); } // ...} Later, you want to style the notification message according to the current theme, so you read the current theme. Since theme is declared in the component body, it is a reactive value, so you add it as a dependency: function Form() { const [submitted, setSubmitted] = useState(false); const theme = useContext(ThemeContext); useEffect(() => { if (submitted) { // ðŸ”´ Avoid: Event-specific logic inside an Effect post('/api/register'); showNotification('Successfully registered!', theme); } }, [submitted, theme]); // âœ… All dependencies declared function handleSubmit() { setSubmitted(true); } // ...} By doing this, youâ€™ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The theme will change, the Effect will re-run, and so it will display the same notification again! The problem here is that this shouldnâ€™t be an Effect in the first place. You want to send this POST request and show the notification in response to submitting the form, which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler: function Form() { const theme = useContext(ThemeContext); function handleSubmit() { // âœ… Good: Event-specific logic is called from event handlers post('/api/register'); showNotification('Successfully registered!', theme); } // ...} Now that the code is in an event handler, itâ€™s not reactiveâ€”so it will only run when the user submits the form. Read more about choosing between event handlers and Effects and how to delete unnecessary Effects. Is your Effect doing several unrelated things? The next question you should ask yourself is whether your Effect is doing several unrelated things. Imagine youâ€™re creating a shipping form where the user needs to choose their city and area. You fetch the list of cities from the server according to the selected country to show them in a dropdown: function ShippingForm({ country }) { const [cities, setCities] = useState(null); const [city, setCity] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); return () => { ignore = true; }; }, [country]); // âœ… All dependencies declared // ... This is a good example of fetching data in an Effect. You are synchronizing the cities state with the network according to the country prop. You canâ€™t do this in an event handler because you need to fetch as soon as ShippingForm is displayed and whenever the country changes (no matter which interaction causes it). Now letâ€™s say youâ€™re adding a second select box for city areas, which should fetch the areas for the currently selected city. You might start by adding a second fetch call for the list of areas inside the same Effect: function ShippingForm({ country }) { const [cities, setCities] = useState(null); const [city, setCity] = useState(null); const [areas, setAreas] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); // ðŸ”´ Avoid: A single Effect synchronizes two independent processes if (city) { fetch(`/api/areas?city=${city}`) .then(response => response.json()) .then(json => { if (!ignore) { setAreas(json); } }); } return () => { ignore = true; }; }, [country, city]); // âœ… All dependencies declared // ... However, since the Effect now uses the city state variable, youâ€™ve had to add city to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call fetchCities(country). As a result, you will be unnecessarily refetching the list of cities many times. The problem with this code is that youâ€™re synchronizing two different unrelated things: You want to synchronize the cities state to the network based on the country prop. You want to synchronize the areas state to the network based on the city state. Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with: function ShippingForm({ country }) { const [cities, setCities] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); return () => { ignore = true; }; }, [country]); // âœ… All dependencies declared const [city, setCity] = useState(null); const [areas, setAreas] = useState(null); useEffect(() => { if (city) { let ignore = false; fetch(`/api/areas?city=${city}`) .then(response => response.json()) .then(json => { if (!ignore) { setAreas(json); } }); return () => { ignore = true; }; } }, [city]); // âœ… All dependencies declared // ... Now the first Effect only re-runs if the country changes, while the second Effect re-runs when the city changes. Youâ€™ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they wonâ€™t trigger each other unintentionally. The final code is longer than the original, but splitting these Effects is still correct. Each Effect should represent an independent synchronization process. In this example, deleting one Effect doesnâ€™t break the other Effectâ€™s logic. This means they synchronize different things, and itâ€™s good to split them up. If youâ€™re concerned about duplication, you can improve this code by extracting repetitive logic into a custom Hook. Are you reading some state to calculate the next state? This Effect updates the messages state variable with a newly created array every time a new message arrives: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages([...messages, receivedMessage]); }); // ... It uses the messages variable to create a new array starting with all the existing messages and adds the new message at the end. However, since messages is a reactive value read by an Effect, it must be a dependency: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages([...messages, receivedMessage]); }); return () => connection.disconnect(); }, [roomId, messages]); // âœ… All dependencies declared // ... And making messages a dependency introduces a problem. Every time you receive a message, setMessages() causes the component to re-render with a new messages array that includes the received message. However, since this Effect now depends on messages, this will also re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that! To fix the issue, donâ€™t read messages inside the Effect. Instead, pass an updater function to setMessages: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Notice how your Effect does not read the messages variable at all now. You only need to pass an updater function like msgs => [...msgs, receivedMessage]. React puts your updater function in a queue and will provide the msgs argument to it during the next render. This is why the Effect itself doesnâ€™t need to depend on messages anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect. Do you want to read a value without â€œreactingâ€ to its changes? Suppose that you want to play a sound when the user receives a new message unless isMuted is true: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); // ... Since your Effect now uses isMuted in its code, you have to add it to the dependencies: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); return () => connection.disconnect(); }, [roomId, isMuted]); // âœ… All dependencies declared // ... The problem is that every time isMuted changes (for example, when the user presses the â€œMutedâ€ toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not workâ€”if you do that, isMuted would get â€œstuckâ€ with its old value.) To solve this problem, you need to extract the logic that shouldnâ€™t be reactive out of the Effect. You donâ€™t want this Effect to â€œreactâ€ to the changes in isMuted. Move this non-reactive piece of logic into an Effect Event: import { useState, useEffect, useEffectEvent } from 'react';function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); const onMessage = useEffectEvent(receivedMessage => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Effect Events let you split an Effect into reactive parts (which should â€œreactâ€ to reactive values like roomId and their changes) and non-reactive parts (which only read their latest values, like onMessage reads isMuted). Now that you read isMuted inside an Effect Event, it doesnâ€™t need to be a dependency of your Effect. As a result, the chat wonâ€™t re-connect when you toggle the â€œMutedâ€ setting on and off, solving the original issue! Wrapping an event handler from the props You might run into a similar problem when your component receives an event handler as a prop: function ChatRoom({ roomId, onReceiveMessage }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onReceiveMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId, onReceiveMessage]); // âœ… All dependencies declared // ... Suppose that the parent component passes a different onReceiveMessage function on every render: <ChatRoom roomId={roomId} onReceiveMessage={receivedMessage => { // ... }}/> Since onReceiveMessage is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event: function ChatRoom({ roomId, onReceiveMessage }) { const [messages, setMessages] = useState([]); const onMessage = useEffectEvent(receivedMessage => { onReceiveMessage(receivedMessage); }); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Effect Events arenâ€™t reactive, so you donâ€™t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function thatâ€™s different on every re-render. Separating reactive and non-reactive code In this example, you want to log a visit every time roomId changes. You want to include the current notificationCount with every log, but you donâ€™t want a change to notificationCount to trigger a log event. The solution is again to split out the non-reactive code into an Effect Event: function Chat({ roomId, notificationCount }) { const onVisit = useEffectEvent(visitedRoomId => { logVisit(visitedRoomId, notificationCount); }); useEffect(() => { onVisit(roomId); }, [roomId]); // âœ… All dependencies declared // ...} You want your logic to be reactive with regards to roomId, so you read roomId inside of your Effect. However, you donâ€™t want a change to notificationCount to log an extra visit, so you read notificationCount inside of the Effect Event. Learn more about reading the latest props and state from Effects using Effect Events. Does some reactive value change unintentionally? Sometimes, you do want your Effect to â€œreactâ€ to a certain value, but that value changes more often than youâ€™d likeâ€”and might not reflect any actual change from the userâ€™s perspective. For example, letâ€™s say that you create an options object in the body of your component, and then read that object from inside of your Effect: function ChatRoom({ roomId }) { // ... const options = { serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); connection.connect(); // ... This object is declared in the component body, so itâ€™s a reactive value. When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect â€œreactsâ€ to its changes: // ... useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // âœ… All dependencies declared // ... It is important to declare it as a dependency! This ensures, for example, that if the roomId changes, your Effect will re-connect to the chat with the new options. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); // Temporarily disable the linter to demonstrate the problem // eslint-disable-next-line react-hooks/exhaustive-deps const options = { serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); return ( <> <h1>Welcome to the {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more In the sandbox above, the input only updates the message state variable. From the userâ€™s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch. A new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type. This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesnâ€™t matter that the contents inside of them may be the same! // During the first renderconst options1 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// During the next renderconst options2 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// These are two different objects!console.log(Object.is(options1, options2)); // false Object and function dependencies can make your Effect re-synchronize more often than you need. This is why, whenever possible, you should try to avoid objects and functions as your Effectâ€™s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them. Move static objects and functions outside your component If the object does not depend on any props and state, you can move that object outside your component: const options = { serverUrl: 'https://localhost:1234', roomId: 'music'};function ChatRoom() { const [message, setMessage] = useState(''); useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ... This way, you prove to the linter that itâ€™s not reactive. It canâ€™t change as a result of a re-render, so it doesnâ€™t need to be a dependency. Now re-rendering ChatRoom wonâ€™t cause your Effect to re-synchronize. This works for functions too: function createOptions() { return { serverUrl: 'https://localhost:1234', roomId: 'music' };}function ChatRoom() { const [message, setMessage] = useState(''); useEffect(() => { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, []); // âœ… All dependencies declared // ... Since createOptions is declared outside your component, itâ€™s not a reactive value. This is why it doesnâ€™t need to be specified in your Effectâ€™s dependencies, and why it wonâ€™t ever cause your Effect to re-synchronize. Move dynamic objects and functions inside your Effect If your object depends on some reactive value that may change as a result of a re-render, like a roomId prop, you canâ€™t pull it outside your component. You can, however, move its creation inside of your Effectâ€™s code: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Now that options is declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect is roomId. Since roomId is not an object or function, you can be sure that it wonâ€™t be unintentionally different. In JavaScript, numbers and strings are compared by their content: // During the first renderconst roomId1 = 'music';// During the next renderconst roomId2 = 'music';// These two strings are the same!console.log(Object.is(roomId1, roomId2)); // true Thanks to this fix, the chat no longer re-connects if you edit the input: App.jschat.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); return ( <> <h1>Welcome to the {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } Show more However, it does re-connect when you change the roomId dropdown, as you would expect. This works for functions, too: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... You can write your own functions to group pieces of logic inside your Effect. As long as you also declare them inside your Effect, theyâ€™re not reactive values, and so they donâ€™t need to be dependencies of your Effect. Read primitive values from objects Sometimes, you may receive an object from props: function ChatRoom({ options }) { const [message, setMessage] = useState(''); useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // âœ… All dependencies declared // ... The risk here is that the parent component will create the object during rendering: <ChatRoom roomId={roomId} options={{ serverUrl: serverUrl, roomId: roomId }}/> This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the object outside the Effect, and avoid having object and function dependencies: function ChatRoom({ options }) { const [message, setMessage] = useState(''); const { roomId, serverUrl } = options; useEffect(() => { const connection = createConnection({ roomId: roomId, serverUrl: serverUrl }); connection.connect(); return () => connection.disconnect(); }, [roomId, serverUrl]); // âœ… All dependencies declared // ... The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effect actually depends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, if options.roomId or options.serverUrl really are different, the chat would re-connect. Calculate primitive values from functions The same approach can work for functions. For example, suppose the parent component passes a function: <ChatRoom roomId={roomId} getOptions={() => { return { serverUrl: serverUrl, roomId: roomId }; }}/> To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you the roomId and serverUrl values that arenâ€™t objects, and that you can read from inside your Effect: function ChatRoom({ getOptions }) { const [message, setMessage] = useState(''); const { roomId, serverUrl } = getOptions(); useEffect(() => { const connection = createConnection({ roomId: roomId, serverUrl: serverUrl }); connection.connect(); return () => connection.disconnect(); }, [roomId, serverUrl]); // âœ… All dependencies declared // ... This only works for pure functions because they are safe to call during rendering. If your function is an event handler, but you donâ€™t want its changes to re-synchronize your Effect, wrap it into an Effect Event instead. Recap Dependencies should always match the code. When youâ€™re not happy with your dependencies, what you need to edit is the code. Suppressing the linter leads to very confusing bugs, and you should always avoid it. To remove a dependency, you need to â€œproveâ€ to the linter that itâ€™s not necessary. If some code should run in response to a specific interaction, move that code to an event handler. If different parts of your Effect should re-run for different reasons, split it into several Effects. If you want to update some state based on the previous state, pass an updater function. If you want to read the latest value without â€œreactingâ€ it, extract an Effect Event from your Effect. In JavaScript, objects and functions are considered different if they were created at different times. Try to avoid object and function dependencies. Move them outside the component or inside the Effect. Try out some challenges1. Fix a resetting interval 2. Fix a retriggering animation 3. Fix a reconnecting chat 4. Fix a reconnecting chat, again Challenge 1 of 4: Fix a resetting interval This Effect sets up an interval that ticks every second. Youâ€™ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesnâ€™t get constantly re-created.App.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; export default function Timer() { const [count, setCount] = useState(0); useEffect(() => { console.log('âœ… Creating an interval'); const id = setInterval(() => { console.log('â° Interval tick'); setCount(count + 1); }, 1000); return () => { console.log('âŒ Clearing an interval'); clearInterval(id); }; }, [count]); return <h1>Counter: {count}</h1> } Show more Show hint Show solutionNext Challenge",
      "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  \t// ...}"
    },
    {
      "description": "This is why you could now specify an empty ([]) dependency list. Your Effect really doesnâ€™t depend on any reactive value anymore, so it really doesnâ€™t need to re-run when any of the componentâ€™s props or state change. To change the dependencies, change the code You might have noticed a pattern in your workflow: First, you change the code of your Effect or how your reactive values are declared. Then, you follow the linter and adjust the dependencies to match the code you have changed. If youâ€™re not happy with the list of dependencies, you go back to the first step (and change the code again). The last part is important. If you want to change the dependencies, change the surrounding code first. You can think of the dependency list as a list of all the reactive values used by your Effectâ€™s code. You donâ€™t choose what to put on that list. The list describes your code. To change the dependency list, change the code. This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to â€œfindâ€ the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below. PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() => { // ... // ðŸ”´ Avoid suppressing the linter like this: // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies donâ€™t match the code, there is a very high risk of introducing bugs. By suppressing the linter, you â€œlieâ€ to React about the values your Effect depends on.Instead, use the techniques below. Deep DiveWhy is suppressing the dependency linter so dangerous? Show DetailsSuppressing the linter leads to very unintuitive bugs that are hard to find and fix. Hereâ€™s one example:App.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; export default function Timer() { const [count, setCount] = useState(0); const [increment, setIncrement] = useState(1); function onTick() { setCount(count + increment); } useEffect(() => { const id = setInterval(onTick, 1000); return () => clearInterval(id); // eslint-disable-next-line react-hooks/exhaustive-deps }, []); return ( <> <h1> Counter: {count} <button onClick={() => setCount(0)}>Reset</button> </h1> <hr /> <p> Every second, increment by: <button disabled={increment === 0} onClick={() => { setIncrement(i => i - 1); }}>â€“</button> <b>{increment}</b> <button onClick={() => { setIncrement(i => i + 1); }}>+</button> </p> </> ); } Show moreLetâ€™s say that you wanted to run the Effect â€œonly on mountâ€. Youâ€™ve read that empty ([]) dependencies do that, so youâ€™ve decided to ignore the linter, and forcefully specified [] as the dependencies.This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you â€œliedâ€ to React that this Effect doesnâ€™t depend on anything, React forever keeps using the onTick function from the initial render. During that render, count was 0 and increment was 1. This is why onTick from that render always calls setCount(0 + 1) every second, and you always see 1. Bugs like this are harder to fix when theyâ€™re spread across multiple components.Thereâ€™s always a better solution than ignoring the linter! To fix this code, you need to add onTick to the dependency list. (To ensure the interval is only setup once, make onTick an Effect Event.)We recommend treating the dependency lint error as a compilation error. If you donâ€™t suppress it, you will never see bugs like this. The rest of this page documents the alternatives for this and other cases. Removing unnecessary dependencies Every time you adjust the Effectâ€™s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is â€œnoâ€: You might want to re-execute different parts of your Effect under different conditions. You might want to only read the latest value of some dependency instead of â€œreactingâ€ to its changes. A dependency may change too often unintentionally because itâ€™s an object or a function. To find the right solution, youâ€™ll need to answer a few questions about your Effect. Letâ€™s walk through them. Should this code move to an event handler? The first thing you should think about is whether this code should be an Effect at all. Imagine a form. On submit, you set the submitted state variable to true. You need to send a POST request and show a notification. Youâ€™ve put this logic inside an Effect that â€œreactsâ€ to submitted being true: function Form() { const [submitted, setSubmitted] = useState(false); useEffect(() => { if (submitted) { // ðŸ”´ Avoid: Event-specific logic inside an Effect post('/api/register'); showNotification('Successfully registered!'); } }, [submitted]); function handleSubmit() { setSubmitted(true); } // ...} Later, you want to style the notification message according to the current theme, so you read the current theme. Since theme is declared in the component body, it is a reactive value, so you add it as a dependency: function Form() { const [submitted, setSubmitted] = useState(false); const theme = useContext(ThemeContext); useEffect(() => { if (submitted) { // ðŸ”´ Avoid: Event-specific logic inside an Effect post('/api/register'); showNotification('Successfully registered!', theme); } }, [submitted, theme]); // âœ… All dependencies declared function handleSubmit() { setSubmitted(true); } // ...} By doing this, youâ€™ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The theme will change, the Effect will re-run, and so it will display the same notification again! The problem here is that this shouldnâ€™t be an Effect in the first place. You want to send this POST request and show the notification in response to submitting the form, which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler: function Form() { const theme = useContext(ThemeContext); function handleSubmit() { // âœ… Good: Event-specific logic is called from event handlers post('/api/register'); showNotification('Successfully registered!', theme); } // ...} Now that the code is in an event handler, itâ€™s not reactiveâ€”so it will only run when the user submits the form. Read more about choosing between event handlers and Effects and how to delete unnecessary Effects. Is your Effect doing several unrelated things? The next question you should ask yourself is whether your Effect is doing several unrelated things. Imagine youâ€™re creating a shipping form where the user needs to choose their city and area. You fetch the list of cities from the server according to the selected country to show them in a dropdown: function ShippingForm({ country }) { const [cities, setCities] = useState(null); const [city, setCity] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); return () => { ignore = true; }; }, [country]); // âœ… All dependencies declared // ... This is a good example of fetching data in an Effect. You are synchronizing the cities state with the network according to the country prop. You canâ€™t do this in an event handler because you need to fetch as soon as ShippingForm is displayed and whenever the country changes (no matter which interaction causes it). Now letâ€™s say youâ€™re adding a second select box for city areas, which should fetch the areas for the currently selected city. You might start by adding a second fetch call for the list of areas inside the same Effect: function ShippingForm({ country }) { const [cities, setCities] = useState(null); const [city, setCity] = useState(null); const [areas, setAreas] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); // ðŸ”´ Avoid: A single Effect synchronizes two independent processes if (city) { fetch(`/api/areas?city=${city}`) .then(response => response.json()) .then(json => { if (!ignore) { setAreas(json); } }); } return () => { ignore = true; }; }, [country, city]); // âœ… All dependencies declared // ... However, since the Effect now uses the city state variable, youâ€™ve had to add city to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call fetchCities(country). As a result, you will be unnecessarily refetching the list of cities many times. The problem with this code is that youâ€™re synchronizing two different unrelated things: You want to synchronize the cities state to the network based on the country prop. You want to synchronize the areas state to the network based on the city state. Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with: function ShippingForm({ country }) { const [cities, setCities] = useState(null); useEffect(() => { let ignore = false; fetch(`/api/cities?country=${country}`) .then(response => response.json()) .then(json => { if (!ignore) { setCities(json); } }); return () => { ignore = true; }; }, [country]); // âœ… All dependencies declared const [city, setCity] = useState(null); const [areas, setAreas] = useState(null); useEffect(() => { if (city) { let ignore = false; fetch(`/api/areas?city=${city}`) .then(response => response.json()) .then(json => { if (!ignore) { setAreas(json); } }); return () => { ignore = true; }; } }, [city]); // âœ… All dependencies declared // ... Now the first Effect only re-runs if the country changes, while the second Effect re-runs when the city changes. Youâ€™ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they wonâ€™t trigger each other unintentionally. The final code is longer than the original, but splitting these Effects is still correct. Each Effect should represent an independent synchronization process. In this example, deleting one Effect doesnâ€™t break the other Effectâ€™s logic. This means they synchronize different things, and itâ€™s good to split them up. If youâ€™re concerned about duplication, you can improve this code by extracting repetitive logic into a custom Hook. Are you reading some state to calculate the next state? This Effect updates the messages state variable with a newly created array every time a new message arrives: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages([...messages, receivedMessage]); }); // ... It uses the messages variable to create a new array starting with all the existing messages and adds the new message at the end. However, since messages is a reactive value read by an Effect, it must be a dependency: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages([...messages, receivedMessage]); }); return () => connection.disconnect(); }, [roomId, messages]); // âœ… All dependencies declared // ... And making messages a dependency introduces a problem. Every time you receive a message, setMessages() causes the component to re-render with a new messages array that includes the received message. However, since this Effect now depends on messages, this will also re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that! To fix the issue, donâ€™t read messages inside the Effect. Instead, pass an updater function to setMessages: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Notice how your Effect does not read the messages variable at all now. You only need to pass an updater function like msgs => [...msgs, receivedMessage]. React puts your updater function in a queue and will provide the msgs argument to it during the next render. This is why the Effect itself doesnâ€™t need to depend on messages anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect. Do you want to read a value without â€œreactingâ€ to its changes? Suppose that you want to play a sound when the user receives a new message unless isMuted is true: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); // ... Since your Effect now uses isMuted in its code, you have to add it to the dependencies: function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); return () => connection.disconnect(); }, [roomId, isMuted]); // âœ… All dependencies declared // ... The problem is that every time isMuted changes (for example, when the user presses the â€œMutedâ€ toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not workâ€”if you do that, isMuted would get â€œstuckâ€ with its old value.) To solve this problem, you need to extract the logic that shouldnâ€™t be reactive out of the Effect. You donâ€™t want this Effect to â€œreactâ€ to the changes in isMuted. Move this non-reactive piece of logic into an Effect Event: import { useState, useEffect, useEffectEvent } from 'react';function ChatRoom({ roomId }) { const [messages, setMessages] = useState([]); const [isMuted, setIsMuted] = useState(false); const onMessage = useEffectEvent(receivedMessage => { setMessages(msgs => [...msgs, receivedMessage]); if (!isMuted) { playSound(); } }); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Effect Events let you split an Effect into reactive parts (which should â€œreactâ€ to reactive values like roomId and their changes) and non-reactive parts (which only read their latest values, like onMessage reads isMuted). Now that you read isMuted inside an Effect Event, it doesnâ€™t need to be a dependency of your Effect. As a result, the chat wonâ€™t re-connect when you toggle the â€œMutedâ€ setting on and off, solving the original issue! Wrapping an event handler from the props You might run into a similar problem when your component receives an event handler as a prop: function ChatRoom({ roomId, onReceiveMessage }) { const [messages, setMessages] = useState([]); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onReceiveMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId, onReceiveMessage]); // âœ… All dependencies declared // ... Suppose that the parent component passes a different onReceiveMessage function on every render: <ChatRoom roomId={roomId} onReceiveMessage={receivedMessage => { // ... }}/> Since onReceiveMessage is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event: function ChatRoom({ roomId, onReceiveMessage }) { const [messages, setMessages] = useState([]); const onMessage = useEffectEvent(receivedMessage => { onReceiveMessage(receivedMessage); }); useEffect(() => { const connection = createConnection(); connection.connect(); connection.on('message', (receivedMessage) => { onMessage(receivedMessage); }); return () => connection.disconnect(); }, [roomId]); // âœ… All dependencies declared // ... Effect Events arenâ€™t reactive, so you donâ€™t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function thatâ€™s different on every re-render. Separating reactive and non-reactive code In this example, you want to log a visit every time roomId changes. You want to include the current notificationCount with every log, but you donâ€™t want a change to notificationCount to trigger a log event. The solution is again to split out the non-reactive code into an Effect Event: function Chat({ roomId, notificationCount }) { const onVisit = useEffectEvent(visitedRoomId => { logVisit(visitedRoomId, notificationCount); }); useEffect(() => { onVisit(roomId); }, [roomId]); // âœ… All dependencies declared // ...} You want your logic to be reactive with regards to roomId, so you read roomId inside of your Effect. However, you donâ€™t want a change to notificationCount to log an extra visit, so you read notificationCount inside of the Effect Event. Learn more about reading the latest props and state from Effects using Effect Events. Does some reactive value change unintentionally? Sometimes, you do want your Effect to â€œreactâ€ to a certain value, but that value changes more often than youâ€™d likeâ€”and might not reflect any actual change from the userâ€™s perspective. For example, letâ€™s say that you create an options object in the body of your component, and then read that object from inside of your Effect: function ChatRoom({ roomId }) { // ... const options = { serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); connection.connect(); // ... This object is declared in the component body, so itâ€™s a reactive value. When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect â€œreactsâ€ to its changes: // ... useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // âœ… All dependencies declared // ... It is important to declare it as a dependency! This ensures, for example, that if the roomId changes, your Effect will re-connect to the chat with the new options. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console:",
      "code": "[]"
    },
    {
      "description": "Suppressing the linter leads to very unintuitive bugs that are hard to find and fix. Hereâ€™s one example:App.jsApp.jsReloadClearForkimport { useState, useEffect } from 'react'; export default function Timer() { const [count, setCount] = useState(0); const [increment, setIncrement] = useState(1); function onTick() { setCount(count + increment); } useEffect(() => { const id = setInterval(onTick, 1000); return () => clearInterval(id); // eslint-disable-next-line react-hooks/exhaustive-deps }, []); return ( <> <h1> Counter: {count} <button onClick={() => setCount(0)}>Reset</button> </h1> <hr /> <p> Every second, increment by: <button disabled={increment === 0} onClick={() => { setIncrement(i => i - 1); }}>â€“</button> <b>{increment}</b> <button onClick={() => { setIncrement(i => i + 1); }}>+</button> </p> </> ); } Show moreLetâ€™s say that you wanted to run the Effect â€œonly on mountâ€. Youâ€™ve read that empty ([]) dependencies do that, so youâ€™ve decided to ignore the linter, and forcefully specified [] as the dependencies.This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you â€œliedâ€ to React that this Effect doesnâ€™t depend on anything, React forever keeps using the onTick function from the initial render. During that render, count was 0 and increment was 1. This is why onTick from that render always calls setCount(0 + 1) every second, and you always see 1. Bugs like this are harder to fix when theyâ€™re spread across multiple components.Thereâ€™s always a better solution than ignoring the linter! To fix this code, you need to add onTick to the dependency list. (To ensure the interval is only setup once, make onTick an Effect Event.)We recommend treating the dependency lint error as a compilation error. If you donâ€™t suppress it, you will never see bugs like this. The rest of this page documents the alternatives for this and other cases.",
      "code": "import { useState, useEffect } from 'react';\n\nexport default function Timer() {\n  const [count, setCount] = useState(0);\n  const [increment, setIncrement] = useState(1);\n\n  function onTick() {\n\tsetCount(count + increment);\n  }\n\n  useEffect(() => {\n    const id = setInterval(onTick, 1000);\n    return () => clearInterval(id);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return (\n    <>\n      <h1>\n        Counter: {count}\n        <button onClick={() => setCount(0)}>Reset</button>\n      </h1>\n      <hr />\n      <p>\n        Every second, increment by:\n        <button disabled={increment === 0} onClick={() => {\n          setIncrement(i => i - 1);\n        }}>â€“</button>\n        <b>{increment}</b>\n        <button onClick={() => {\n          setIncrement(i => i + 1);\n        }}>+</button>\n      </p>\n    </>\n  );\n}"
    }
  ],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/learn/tutorial-tic-tac-toe",
    "https://react.dev/learn/thinking-in-react",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/creating-a-react-app",
    "https://react.dev/learn/build-a-react-app-from-scratch",
    "https://react.dev/learn/add-react-to-an-existing-project",
    "https://react.dev/learn/setup",
    "https://react.dev/learn/editor-setup",
    "https://react.dev/learn/typescript",
    "https://react.dev/learn/react-developer-tools",
    "https://react.dev/learn/react-compiler",
    "https://react.dev/learn/react-compiler/introduction",
    "https://react.dev/learn/react-compiler/installation",
    "https://react.dev/learn/react-compiler/incremental-adoption",
    "https://react.dev/learn/react-compiler/debugging",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/your-first-component",
    "https://react.dev/learn/importing-and-exporting-components",
    "https://react.dev/learn/writing-markup-with-jsx",
    "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/conditional-rendering",
    "https://react.dev/learn/rendering-lists",
    "https://react.dev/learn/keeping-components-pure",
    "https://react.dev/learn/understanding-your-ui-as-a-tree",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/responding-to-events",
    "https://react.dev/learn/state-a-components-memory",
    "https://react.dev/learn/render-and-commit",
    "https://react.dev/learn/state-as-a-snapshot",
    "https://react.dev/learn/queueing-a-series-of-state-updates",
    "https://react.dev/learn/updating-objects-in-state",
    "https://react.dev/learn/updating-arrays-in-state",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/reacting-to-input-with-state",
    "https://react.dev/learn/choosing-the-state-structure",
    "https://react.dev/learn/sharing-state-between-components",
    "https://react.dev/learn/preserving-and-resetting-state",
    "https://react.dev/learn/extracting-state-logic-into-a-reducer",
    "https://react.dev/learn/passing-data-deeply-with-context",
    "https://react.dev/learn/scaling-up-with-reducer-and-context",
    "https://react.dev/learn/escape-hatches",
    "https://react.dev/learn/referencing-values-with-refs",
    "https://react.dev/learn/manipulating-the-dom-with-refs",
    "https://react.dev/learn/synchronizing-with-effects",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/learn/lifecycle-of-reactive-effects",
    "https://react.dev/learn/separating-events-from-effects",
    "https://react.dev/learn/removing-effect-dependencies",
    "https://react.dev/learn/reusing-logic-with-custom-hooks",
    "https://react.dev/reference/react/useState",
    "https://react.dev/reference/react-dom"
  ]
}