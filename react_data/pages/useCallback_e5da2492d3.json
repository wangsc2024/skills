{
  "url": "https://react.dev/reference/react/useCallback",
  "title": "useCallback",
  "content": "useCallback is a React Hook that lets you cache a function definition between re-renders.\n\nReact Compiler automatically memoizes values and functions, reducing the need for manual useCallback calls. You can use the compiler to handle memoization automatically.\n\nCall useCallback at the top level of your component to cache a function definition between re-renders:\n\nSee more examples below.\n\nfn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.\n\ndependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.\n\nOn the initial render, useCallback returns the fn function you have passed.\n\nDuring subsequent renders, it will either return an already stored fn function from the last render (if the dependencies havenâ€™t changed), or return the fn function you have passed during this render.\n\nWhen you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Letâ€™s first look at the syntax for how to do this, and then see in which cases itâ€™s useful.\n\nTo cache a function between re-renders of your component, wrap its definition into the useCallback Hook:\n\nYou need to pass two things to useCallback:\n\nOn the initial render, the returned function youâ€™ll get from useCallback will be the function you passed.\n\nOn the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render.\n\nIn other words, useCallback caches a function between re-renders until its dependencies change.\n\nLetâ€™s walk through an example to see when this is useful.\n\nSay youâ€™re passing a handleSubmit function down from the ProductPage to the ShippingForm component:\n\nYouâ€™ve noticed that toggling the theme prop freezes the app for a moment, but if you remove <ShippingForm /> from your JSX, it feels fast. This tells you that itâ€™s worth trying to optimize the ShippingForm component.\n\nBy default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that donâ€™t require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo:\n\nWith this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Letâ€™s say you defined handleSubmit without useCallback:\n\nIn JavaScript, a function () {} or () => {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldnâ€™t be a problem, but it means that ShippingForm props will never be the same, and your memo optimization wonâ€™t work. This is where useCallback comes in handy:\n\nBy wrapping handleSubmit in useCallback, you ensure that itâ€™s the same function between the re-renders (until dependencies change). You donâ€™t have to wrap a function in useCallback unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are other reasons you might need useCallback which are described further on this page.\n\nYou should only rely on useCallback as a performance optimization. If your code doesnâ€™t work without it, find the underlying problem and fix it first. Then you may add useCallback back.\n\nYou will often see useMemo alongside useCallback. They are both useful when youâ€™re trying to optimize a child component. They let you memoize (or, in other words, cache) something youâ€™re passing down:\n\nThe difference is in what theyâ€™re letting you cache:\n\nIf youâ€™re already familiar with useMemo, you might find it helpful to think of useCallback as this:\n\nRead more about the difference between useMemo and useCallback.\n\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\n\nCaching a function with useCallback is only valuable in a few cases:\n\nThere is no benefit to wrapping a function in useCallback in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value thatâ€™s â€œalways newâ€ is enough to break memoization for an entire component.\n\nNote that useCallback does not prevent creating the function. Youâ€™re always creating a function (and thatâ€™s fine!), but React ignores it and gives you back a cached function if nothing changed.\n\nIn practice, you can make a lot of memoization unnecessary by following a few principles:\n\nIf a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so itâ€™s good to follow them in any case. In long term, weâ€™re researching doing memoization automatically to solve this once and for all.\n\nIn this example, the ShippingForm component is artificially slowed down so that you can see what happens when a React component youâ€™re rendering is genuinely slow. Try incrementing the counter and toggling the theme.\n\nIncrementing the counter feels slow because it forces the slowed down ShippingForm to re-render. Thatâ€™s expected because the counter has changed, and so you need to reflect the userâ€™s new choice on the screen.\n\nNext, try toggling the theme. Thanks to useCallback together with memo, itâ€™s fast despite the artificial slowdown! ShippingForm skipped re-rendering because the handleSubmit function has not changed. The handleSubmit function has not changed because both productId and referrer (your useCallback dependencies) havenâ€™t changed since last render.\n\nSometimes, you might need to update state based on previous state from a memoized callback.\n\nThis handleAddTodo function specifies todos as a dependency because it computes the next todos from it:\n\nYouâ€™ll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead:\n\nHere, instead of making todos a dependency and reading it inside, you pass an instruction about how to update the state (todos => [...todos, newTodo]) to React. Read more about updater functions.\n\nSometimes, you might want to call a function from inside an Effect:\n\nThis creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare createOptions as a dependency, it will cause your Effect to constantly reconnect to the chat room:\n\nTo solve this, you can wrap the function you need to call from an Effect into useCallback:\n\nThis ensures that the createOptions function is the same between re-renders if the roomId is the same. However, itâ€™s even better to remove the need for a function dependency. Move your function inside the Effect:\n\nNow your code is simpler and doesnâ€™t need useCallback. Learn more about removing Effect dependencies.\n\nIf youâ€™re writing a custom Hook, itâ€™s recommended to wrap any functions that it returns into useCallback:\n\nThis ensures that the consumers of your Hook can optimize their own code when needed.\n\nMake sure youâ€™ve specified the dependency array as a second argument!\n\nIf you forget the dependency array, useCallback will return a new function every time:\n\nThis is the corrected version passing the dependency array as a second argument:\n\nIf this doesnâ€™t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\n\nYou can then right-click on the arrays from different re-renders in the console and select â€œStore as a global variableâ€ for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:\n\nWhen you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well.\n\nSuppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you canâ€™t call useCallback in a loop:\n\nInstead, extract a component for an individual item, and put useCallback there:\n\nAlternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:",
  "headings": [
    {
      "level": "h1",
      "text": "useCallback",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Reference",
      "id": "reference"
    },
    {
      "level": "h3",
      "text": "useCallback(fn, dependencies)",
      "id": "usecallback"
    },
    {
      "level": "h4",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h4",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h4",
      "text": "Caveats",
      "id": "caveats"
    },
    {
      "level": "h2",
      "text": "Usage",
      "id": "usage"
    },
    {
      "level": "h3",
      "text": "Skipping re-rendering of components",
      "id": "skipping-re-rendering-of-components"
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "How is useCallback related to useMemo?",
      "id": "how-is-usecallback-related-to-usememo"
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Should you add useCallback everywhere?",
      "id": "should-you-add-usecallback-everywhere"
    },
    {
      "level": "h4",
      "text": "The difference between useCallback and declaring a function directly",
      "id": "examples-rerendering"
    },
    {
      "level": "h4",
      "text": "Example 1 of 2: Skipping re-rendering with useCallback and memo",
      "id": "skipping-re-rendering-with-usecallback-and-memo"
    },
    {
      "level": "h3",
      "text": "Updating state from a memoized callback",
      "id": "updating-state-from-a-memoized-callback"
    },
    {
      "level": "h3",
      "text": "Preventing an Effect from firing too often",
      "id": "preventing-an-effect-from-firing-too-often"
    },
    {
      "level": "h3",
      "text": "Optimizing a custom Hook",
      "id": "optimizing-a-custom-hook"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h3",
      "text": "Every time my component renders, useCallback returns a different function",
      "id": "every-time-my-component-renders-usecallback-returns-a-different-function"
    },
    {
      "level": "h3",
      "text": "I need to call useCallback for each list item in a loop, but itâ€™s not allowed",
      "id": "i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed"
    }
  ],
  "code_samples": [
    {
      "code": "const cachedFn = useCallback(fn, dependencies)",
      "language": "jsx"
    },
    {
      "code": "import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);",
      "language": "javascript"
    },
    {
      "code": "import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ...",
      "language": "javascript"
    },
    {
      "code": "function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );",
      "language": "jsx"
    },
    {
      "code": "import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});",
      "language": "javascript"
    },
    {
      "code": "function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }  return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}",
      "language": "jsx"
    },
    {
      "code": "function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}",
      "language": "jsx"
    },
    {
      "code": "import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {  const product = useData('/product/' + productId);  const requirements = useMemo(() => { // Calls your function and caches its result    return computeRequirements(product);  }, [product]);  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  return (    <div className={theme}>      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />    </div>  );}",
      "language": "jsx"
    },
    {
      "code": "// Simplified implementation (inside React)function useCallback(fn, dependencies) {  return useMemo(() => fn, dependencies);}",
      "language": "jsx"
    },
    {
      "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos([...todos, newTodo]);  }, [todos]);  // ...",
      "language": "jsx"
    },
    {
      "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos(todos => [...todos, newTodo]);  }, []); // âœ… No need for the todos dependency  // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    // ...",
      "language": "jsx"
    },
    {
      "code": "useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // ðŸ”´ Problem: This dependency changes on every render  // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const createOptions = useCallback(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // âœ… Only changes when roomId changes  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // âœ… Only changes when createOptions changes  // ...",
      "language": "jsx"
    },
    {
      "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() { // âœ… No need for useCallback or function dependencies!      return {        serverUrl: 'https://localhost:1234',        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // âœ… Only changes when roomId changes  // ...",
      "language": "jsx"
    },
    {
      "code": "function useRouter() {  const { dispatch } = useContext(RouterStateContext);  const navigate = useCallback((url) => {    dispatch({ type: 'navigate', url });  }, [dispatch]);  const goBack = useCallback(() => {    dispatch({ type: 'back' });  }, [dispatch]);  return {    navigate,    goBack,  };}",
      "language": "javascript"
    },
    {
      "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // ðŸ”´ Returns a new function every time: no dependency array  // ...",
      "language": "javascript"
    },
    {
      "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // âœ… Does not return a new function unnecessarily  // ...",
      "language": "javascript"
    },
    {
      "code": "const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);",
      "language": "javascript"
    },
    {
      "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...",
      "language": "unknown"
    },
    {
      "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // ðŸ”´ You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}",
      "language": "jsx"
    },
    {
      "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // âœ… Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}",
      "language": "jsx"
    },
    {
      "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});",
      "language": "jsx"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/learn",
    "https://react.dev/reference/react",
    "https://react.dev/reference/react/hooks",
    "https://react.dev/reference/react/useActionState",
    "https://react.dev/reference/react/useCallback",
    "https://react.dev/reference/react/useContext",
    "https://react.dev/reference/react/useDebugValue",
    "https://react.dev/reference/react/useDeferredValue",
    "https://react.dev/reference/react/useEffect",
    "https://react.dev/reference/react/useEffectEvent",
    "https://react.dev/reference/react/useId",
    "https://react.dev/reference/react/useImperativeHandle",
    "https://react.dev/reference/react/useInsertionEffect",
    "https://react.dev/reference/react/useLayoutEffect",
    "https://react.dev/reference/react/useMemo",
    "https://react.dev/reference/react/useOptimistic",
    "https://react.dev/reference/react/useReducer",
    "https://react.dev/reference/react/useRef",
    "https://react.dev/reference/react/useState",
    "https://react.dev/reference/react/useSyncExternalStore",
    "https://react.dev/reference/react/useTransition",
    "https://react.dev/reference/react/components",
    "https://react.dev/reference/react/Fragment",
    "https://react.dev/reference/react/Profiler",
    "https://react.dev/reference/react/StrictMode",
    "https://react.dev/reference/react/Suspense",
    "https://react.dev/reference/react/Activity",
    "https://react.dev/reference/react/ViewTransition",
    "https://react.dev/reference/react/apis",
    "https://react.dev/reference/react/act",
    "https://react.dev/reference/react/addTransitionType",
    "https://react.dev/reference/react/cache",
    "https://react.dev/reference/react/cacheSignal",
    "https://react.dev/reference/react/captureOwnerStack",
    "https://react.dev/reference/react/createContext",
    "https://react.dev/reference/react/lazy",
    "https://react.dev/reference/react/memo",
    "https://react.dev/reference/react/startTransition",
    "https://react.dev/reference/react/use",
    "https://react.dev/reference/react/experimental_taintObjectReference",
    "https://react.dev/reference/react/experimental_taintUniqueValue",
    "https://react.dev/reference/react-dom/hooks",
    "https://react.dev/reference/react-dom/hooks/useFormStatus",
    "https://react.dev/reference/react-dom/components",
    "https://react.dev/reference/react-dom/components/common",
    "https://react.dev/reference/react-dom/components/form",
    "https://react.dev/reference/react-dom/components/input",
    "https://react.dev/reference/react-dom/components/option",
    "https://react.dev/reference/react-dom/components/progress",
    "https://react.dev/reference/react-dom/components/select",
    "https://react.dev/reference/react-dom/components/textarea",
    "https://react.dev/reference/react-dom/components/link",
    "https://react.dev/reference/react-dom/components/meta",
    "https://react.dev/reference/react-dom/components/script",
    "https://react.dev/reference/react-dom/components/style",
    "https://react.dev/reference/react-dom/components/title",
    "https://react.dev/reference/react-dom",
    "https://react.dev/reference/react-dom/createPortal",
    "https://react.dev/reference/react-dom/flushSync",
    "https://react.dev/reference/react-dom/preconnect",
    "https://react.dev/reference/react-dom/prefetchDNS",
    "https://react.dev/reference/react-dom/preinit",
    "https://react.dev/reference/react-dom/preinitModule",
    "https://react.dev/reference/react-dom/preload",
    "https://react.dev/reference/react-dom/preloadModule",
    "https://react.dev/reference/react-dom/client",
    "https://react.dev/reference/react-dom/client/createRoot",
    "https://react.dev/reference/react-dom/client/hydrateRoot",
    "https://react.dev/reference/react-dom/server",
    "https://react.dev/reference/react-dom/server/renderToPipeableStream",
    "https://react.dev/reference/react-dom/server/renderToReadableStream",
    "https://react.dev/reference/react-dom/server/renderToStaticMarkup",
    "https://react.dev/reference/react-dom/server/renderToString",
    "https://react.dev/reference/react-dom/server/resume",
    "https://react.dev/reference/react-dom/server/resumeToPipeableStream",
    "https://react.dev/reference/react-dom/static",
    "https://react.dev/reference/react-dom/static/prerender",
    "https://react.dev/reference/react-dom/static/prerenderToNodeStream",
    "https://react.dev/reference/react-dom/static/resumeAndPrerender",
    "https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream",
    "https://react.dev/reference/react-compiler/configuration",
    "https://react.dev/reference/react-compiler/compilationMode",
    "https://react.dev/reference/react-compiler/gating",
    "https://react.dev/reference/react-compiler/logger",
    "https://react.dev/reference/react-compiler/panicThreshold",
    "https://react.dev/reference/react-compiler/target",
    "https://react.dev/reference/react-compiler/directives",
    "https://react.dev/reference/react-compiler/directives/use-memo",
    "https://react.dev/reference/react-compiler/directives/use-no-memo",
    "https://react.dev/reference/react-compiler/compiling-libraries",
    "https://react.dev/reference/dev-tools/react-performance-tracks",
    "https://react.dev/reference/eslint-plugin-react-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/config",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/gating",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/globals",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/purity",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/refs",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/use-memo",
    "https://react.dev/reference/rules",
    "https://react.dev/reference/rules/components-and-hooks-must-be-pure",
    "https://react.dev/reference/rules/react-calls-components-and-hooks",
    "https://react.dev/reference/rules/rules-of-hooks",
    "https://react.dev/reference/rsc/server-components",
    "https://react.dev/reference/rsc/server-functions",
    "https://react.dev/reference/rsc/directives",
    "https://react.dev/reference/rsc/use-client",
    "https://react.dev/reference/rsc/use-server",
    "https://react.dev/reference/react/legacy",
    "https://react.dev/reference/react/Children",
    "https://react.dev/reference/react/cloneElement",
    "https://react.dev/reference/react/Component",
    "https://react.dev/reference/react/createElement",
    "https://react.dev/reference/react/createRef",
    "https://react.dev/reference/react/forwardRef",
    "https://react.dev/reference/react/isValidElement",
    "https://react.dev/reference/react/PureComponent",
    "https://react.dev/learn/react-compiler",
    "https://react.dev/learn/editor-setup",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/sharing-state-between-components",
    "https://react.dev/learn/keeping-components-pure",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/learn/removing-effect-dependencies",
    "https://react.dev/learn/synchronizing-with-effects",
    "https://react.dev/learn/lifecycle-of-reactive-effects",
    "https://react.dev/learn/reusing-logic-with-custom-hooks",
    "https://react.dev/learn/installation",
    "https://react.dev/learn/describing-the-ui",
    "https://react.dev/learn/adding-interactivity",
    "https://react.dev/learn/managing-state",
    "https://react.dev/learn/escape-hatches"
  ]
}