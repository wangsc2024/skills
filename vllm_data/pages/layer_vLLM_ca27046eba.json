{
  "url": "https://docs.vllm.ai/en/latest/api/vllm/attention/layer/",
  "title": "layer - vLLM",
  "content": "Bases: Module, AttentionLayerBase\n\nThis class takes query, key, and value tensors as input. The input tensors can either contain prompt tokens or generation tokens. The class does the following:\n\nThe KV cache is stored inside this class and is accessed via self.kv_cache.\n\nThe KV cache is stored inside this class and is accessed via self.kv_cache.\n\nAttention metadata (attn_metadata) is set using a context manager in the model runner's execute_model method. It is accessed via forward context using vllm.forward_context.get_forward_context().attn_metadata.\n\nBases: Module, AttentionLayerBase\n\nMulti-Head Latent Attention layer.\n\nThis class takes query, and compressed key/value tensors as input. The class does the following:\n\nOptional scale calculation for MLA inputs.\n\nMirrors Attention.calc_kv_scales. Not all MLA backends require this\n\nInitializes KV cache scaling factors and quantization method.\n\nThis helper function sets up the KV cache quantization attributes that are shared between Attention and MLAAttention layers. It initializes scale tensors for query, key, value, and probability, and configures the quantization method if applicable.\n\nThe attention layer instance to initialize.\n\nOptional quantization configuration.\n\nLayer name prefix for quantization method lookup.\n\nThe KV cache data type string.\n\nWhether to calculate KV scales dynamically.\n\nExtract attention context for a given layer.\n\nThis helper function extracts the attention metadata, attention layer instance, and KV cache tensor for a specific layer.\n\nThe name/identifier of the attention layer.\n\nattn_metadata may be None, but attn_layer and kv_cache are always\n\nextracted from the forward context.",
  "headings": [
    {
      "level": "h1",
      "text": "vllm.attention.layer ¶",
      "id": "vllm.attention.layer"
    },
    {
      "level": "h2",
      "text": "logger module-attribute ¶",
      "id": "vllm.attention.layer.logger"
    },
    {
      "level": "h2",
      "text": "Attention ¶",
      "id": "vllm.attention.layer.Attention"
    },
    {
      "level": "h3",
      "text": "attn_backend instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.attn_backend"
    },
    {
      "level": "h3",
      "text": "attn_type instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.attn_type"
    },
    {
      "level": "h3",
      "text": "backend instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.backend"
    },
    {
      "level": "h3",
      "text": "dtype instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.dtype"
    },
    {
      "level": "h3",
      "text": "has_sink instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.has_sink"
    },
    {
      "level": "h3",
      "text": "head_size instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.head_size"
    },
    {
      "level": "h3",
      "text": "impl instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.impl"
    },
    {
      "level": "h3",
      "text": "k_range instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.k_range"
    },
    {
      "level": "h3",
      "text": "kv_cache instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.kv_cache"
    },
    {
      "level": "h3",
      "text": "kv_cache_torch_dtype instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.kv_cache_torch_dtype"
    },
    {
      "level": "h3",
      "text": "kv_sharing_target_layer_name instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.kv_sharing_target_layer_name"
    },
    {
      "level": "h3",
      "text": "layer_name instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.layer_name"
    },
    {
      "level": "h3",
      "text": "num_heads instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.num_heads"
    },
    {
      "level": "h3",
      "text": "num_kv_heads instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.num_kv_heads"
    },
    {
      "level": "h3",
      "text": "q_range instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.q_range"
    },
    {
      "level": "h3",
      "text": "query_quant instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.query_quant"
    },
    {
      "level": "h3",
      "text": "sliding_window instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.sliding_window"
    },
    {
      "level": "h3",
      "text": "use_direct_call instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.use_direct_call"
    },
    {
      "level": "h3",
      "text": "use_mm_prefix instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.use_mm_prefix"
    },
    {
      "level": "h3",
      "text": "use_output instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.use_output"
    },
    {
      "level": "h3",
      "text": "v_range instance-attribute ¶",
      "id": "vllm.attention.layer.Attention.v_range"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.attention.layer.Attention.__init__"
    },
    {
      "level": "h3",
      "text": "calc_kv_scales ¶",
      "id": "vllm.attention.layer.Attention.calc_kv_scales"
    },
    {
      "level": "h3",
      "text": "extra_repr ¶",
      "id": "vllm.attention.layer.Attention.extra_repr"
    },
    {
      "level": "h3",
      "text": "forward ¶",
      "id": "vllm.attention.layer.Attention.forward"
    },
    {
      "level": "h3",
      "text": "get_attn_backend ¶",
      "id": "vllm.attention.layer.Attention.get_attn_backend"
    },
    {
      "level": "h3",
      "text": "get_kv_cache_spec ¶",
      "id": "vllm.attention.layer.Attention.get_kv_cache_spec"
    },
    {
      "level": "h3",
      "text": "process_weights_after_loading ¶",
      "id": "vllm.attention.layer.Attention.process_weights_after_loading"
    },
    {
      "level": "h2",
      "text": "MLAAttention ¶",
      "id": "vllm.attention.layer.MLAAttention"
    },
    {
      "level": "h3",
      "text": "attn_backend instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.attn_backend"
    },
    {
      "level": "h3",
      "text": "head_size instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.head_size"
    },
    {
      "level": "h3",
      "text": "impl instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.impl"
    },
    {
      "level": "h3",
      "text": "k_range instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.k_range"
    },
    {
      "level": "h3",
      "text": "kv_cache instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.kv_cache"
    },
    {
      "level": "h3",
      "text": "kv_lora_rank instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.kv_lora_rank"
    },
    {
      "level": "h3",
      "text": "layer_name instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.layer_name"
    },
    {
      "level": "h3",
      "text": "num_heads instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.num_heads"
    },
    {
      "level": "h3",
      "text": "q_lora_rank instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.q_lora_rank"
    },
    {
      "level": "h3",
      "text": "q_range instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.q_range"
    },
    {
      "level": "h3",
      "text": "qk_nope_head_dim instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.qk_nope_head_dim"
    },
    {
      "level": "h3",
      "text": "qk_rope_head_dim instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.qk_rope_head_dim"
    },
    {
      "level": "h3",
      "text": "scale instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.scale"
    },
    {
      "level": "h3",
      "text": "use_direct_call instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.use_direct_call"
    },
    {
      "level": "h3",
      "text": "use_sparse instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.use_sparse"
    },
    {
      "level": "h3",
      "text": "v_head_dim instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.v_head_dim"
    },
    {
      "level": "h3",
      "text": "v_range instance-attribute ¶",
      "id": "vllm.attention.layer.MLAAttention.v_range"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.attention.layer.MLAAttention.__init__"
    },
    {
      "level": "h3",
      "text": "calc_kv_scales ¶",
      "id": "vllm.attention.layer.MLAAttention.calc_kv_scales"
    },
    {
      "level": "h3",
      "text": "forward ¶",
      "id": "vllm.attention.layer.MLAAttention.forward"
    },
    {
      "level": "h3",
      "text": "get_attn_backend ¶",
      "id": "vllm.attention.layer.MLAAttention.get_attn_backend"
    },
    {
      "level": "h3",
      "text": "get_kv_cache_spec ¶",
      "id": "vllm.attention.layer.MLAAttention.get_kv_cache_spec"
    },
    {
      "level": "h3",
      "text": "process_weights_after_loading ¶",
      "id": "vllm.attention.layer.MLAAttention.process_weights_after_loading"
    },
    {
      "level": "h2",
      "text": "_init_kv_cache_quant ¶",
      "id": "vllm.attention.layer._init_kv_cache_quant"
    },
    {
      "level": "h2",
      "text": "get_attention_context ¶",
      "id": "vllm.attention.layer.get_attention_context"
    },
    {
      "level": "h2",
      "text": "maybe_calc_kv_scales ¶",
      "id": "vllm.attention.layer.maybe_calc_kv_scales"
    },
    {
      "level": "h2",
      "text": "maybe_calc_kv_scales_fake ¶",
      "id": "vllm.attention.layer.maybe_calc_kv_scales_fake"
    },
    {
      "level": "h2",
      "text": "unified_attention ¶",
      "id": "vllm.attention.layer.unified_attention"
    },
    {
      "level": "h2",
      "text": "unified_attention_fake ¶",
      "id": "vllm.attention.layer.unified_attention_fake"
    },
    {
      "level": "h2",
      "text": "unified_attention_with_output ¶",
      "id": "vllm.attention.layer.unified_attention_with_output"
    },
    {
      "level": "h2",
      "text": "unified_attention_with_output_fake ¶",
      "id": "vllm.attention.layer.unified_attention_with_output_fake"
    },
    {
      "level": "h2",
      "text": "unified_mla_attention ¶",
      "id": "vllm.attention.layer.unified_mla_attention"
    },
    {
      "level": "h2",
      "text": "unified_mla_attention_fake ¶",
      "id": "vllm.attention.layer.unified_mla_attention_fake"
    },
    {
      "level": "h2",
      "text": "unified_mla_attention_with_output ¶",
      "id": "vllm.attention.layer.unified_mla_attention_with_output"
    },
    {
      "level": "h2",
      "text": "unified_mla_attention_with_output_fake ¶",
      "id": "vllm.attention.layer.unified_mla_attention_with_output_fake"
    }
  ],
  "code_samples": [
    {
      "code": "logger = init_logger(__name__)",
      "language": "unknown"
    },
    {
      "code": "logger = init_logger(__name__)",
      "language": "unknown"
    },
    {
      "code": "112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406",
      "language": "unknown"
    },
    {
      "code": "class Attention(nn.Module, AttentionLayerBase):\n    \"\"\"Attention layer.\n\n    This class takes query, key, and value tensors as input. The input tensors\n    can either contain prompt tokens or generation tokens.\n    The class does the following:\n\n    1. Store the input key and value tensors in the KV cache.\n    2. Perform (multi-head/multi-query/grouped-query) attention.\n    3. Return the output tensor.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_heads: int,\n        head_size: int,\n        scale: float,\n        num_kv_heads: int | None = None,\n        alibi_slopes: list[float] | None = None,\n        cache_config: CacheConfig | None = None,\n        quant_config: QuantizationConfig | None = None,\n        logits_soft_cap: float | None = None,\n        per_layer_sliding_window: int | None = None,\n        prefix: str = \"\",\n        attn_type: str = AttentionType.DECODER,\n        kv_sharing_target_layer_name: str | None = None,\n        attn_backend: type[AttentionBackend] | None = None,\n        **extra_impl_args,\n    ) -> None:\n        \"\"\"\n        The KV cache is stored inside this class and is accessed via\n        `self.kv_cache`.\n        \"\"\"\n        super().__init__()\n        if per_layer_sliding_window is not None:\n            # per-layer sliding window\n            sliding_window = per_layer_sliding_window\n        elif cache_config is not None:\n            # model-level sliding window\n            sliding_window = cache_config.sliding_window\n        else:\n            sliding_window = None\n\n        vllm_config = get_current_vllm_config()\n        if cache_config is not None:\n            kv_cache_dtype = cache_config.cache_dtype\n            block_size = cache_config.block_size\n            calculate_kv_scales = cache_config.calculate_kv_scales\n        else:\n            kv_cache_dtype = \"auto\"\n            block_size = 16\n            calculate_kv_scales = False\n        self.kv_cache_torch_dtype = kv_cache_dtype_str_to_dtype(\n            kv_cache_dtype, vllm_config.model_config\n        )\n        if num_kv_heads is None:\n            num_kv_heads = num_heads\n        assert num_heads % num_kv_heads == 0, (\n            f\"num_heads ({num_heads}) is not divisible by num_kv_heads ({num_kv_heads})\"\n        )\n\n        # Initialize KV cache quantization attributes\n        _init_kv_cache_quant(\n            self, quant_config, prefix, kv_cache_dtype, calculate_kv_scales\n        )\n\n        self.num_heads = num_heads\n        self.head_size = head_size\n        self.num_kv_heads = num_kv_heads\n        self.sliding_window = sliding_window\n        self.has_sink = extra_impl_args.get(\"sinks\") is not None\n\n        # NOTE: model_config may be None during certain tests\n        model_config = vllm_config.model_config\n        self.use_mm_prefix = model_config is not None and model_config.is_mm_prefix_lm\n\n        # During model initialization, the default dtype is set as the model\n        # weight and activation dtype.\n        dtype = torch.get_default_dtype()\n        if attn_backend is None:\n            self.attn_backend = get_attn_backend(\n                head_size,\n                dtype,\n                kv_cache_dtype,\n                block_size,\n                use_mla=False,\n                has_sink=self.has_sink,\n                use_mm_prefix=self.use_mm_prefix,\n                attn_type=attn_type,\n            )\n        else:\n            self.attn_backend = attn_backend\n\n        # prefix caching + batch invariance is currently not supported for\n        # FLASHINFER and TRITON_MLA.\n        if (\n            cache_config is not None\n            and cache_config.enable_prefix_caching\n            and vllm_is_batch_invariant()\n            and (\n                self.attn_backend.get_name() == \"FLASHINFER\"\n                or self.attn_backend.get_name() == \"TRITON_MLA\"\n            )\n        ):\n            logger.warning_once(\n                \"Disabling prefix caching for FLASHINFER/TRITON_MLA \"\n                \"with batch invariance, as it is not yet supported.\",\n                scope=\"local\",\n            )\n            cache_config.enable_prefix_caching = False\n\n        impl_cls = self.attn_backend.get_impl_cls()\n        self.impl = impl_cls(\n            num_heads,\n            head_size,\n            scale,\n            num_kv_heads,\n            alibi_slopes,\n            sliding_window,\n            kv_cache_dtype,\n            logits_soft_cap,\n            attn_type,\n            kv_sharing_target_layer_name,\n            **extra_impl_args,\n        )\n        backend_name = self.attn_backend.get_name()\n        self.backend = AttentionBackendEnum.__members__.get(backend_name)\n        self.dtype = dtype\n\n        # For cuda-alike (CUDA and ROCM) and cpu platforms, we control how\n        # torch.compile works by registering the attention as one giant\n        # opaque custom op. For other platforms, we directly call them\n        # and let torch.compile handle them.\n        self.use_direct_call = not current_platform.opaque_attention_op()\n\n        self.use_output = self.attn_backend.accept_output_buffer\n        compilation_config = vllm_config.compilation_config\n        if prefix in compilation_config.static_forward_context:\n            raise ValueError(f\"Duplicate layer name: {prefix}\")\n        compilation_config.static_forward_context[prefix] = self\n        self.layer_name = prefix\n        self.attn_type = attn_type\n\n        if kv_sharing_target_layer_name is not None:\n            validate_kv_sharing_target(\n                prefix,\n                kv_sharing_target_layer_name,\n                compilation_config.static_forward_context,\n            )\n        self.kv_sharing_target_layer_name = kv_sharing_target_layer_name\n\n        # use a placeholder kv cache tensor during init, which will be replaced\n        # by bind_kv_cache\n        # this variable will not be accessed if use_direct_call is True\n        self.kv_cache = [\n            torch.tensor([])\n            for _ in range(vllm_config.parallel_config.pipeline_parallel_size)\n        ]\n\n        # Initialize q/k/v range constants.\n        self.q_range = torch.tensor(envs.Q_SCALE_CONSTANT, dtype=torch.float32)\n        self.k_range = torch.tensor(envs.K_SCALE_CONSTANT, dtype=torch.float32)\n        self.v_range = torch.tensor(envs.V_SCALE_CONSTANT, dtype=torch.float32)\n\n        # for attn backends supporting query quantization\n        self.query_quant = None\n        if (\n            self.kv_cache_dtype.startswith(\"fp8\")\n            and self.impl.supports_quant_query_input\n        ):\n            self.query_quant = QuantFP8(static=True, group_shape=GroupShape.PER_TENSOR)\n\n    def forward(\n        self,\n        query: torch.Tensor,\n        key: torch.Tensor,\n        value: torch.Tensor,\n        # For some alternate attention backends like MLA the attention output\n        # shape does not match the query shape, so we optionally let the model\n        # definition specify the output tensor shape.\n        output_shape: torch.Size | None = None,\n    ) -> torch.Tensor:\n        \"\"\"\n        The KV cache is stored inside this class and is accessed via\n        `self.kv_cache`.\n\n        Attention metadata (`attn_metadata`) is set using a context manager in\n        the model runner's `execute_model` method. It is accessed via forward\n        context using\n        `vllm.forward_context.get_forward_context().attn_metadata`.\n        \"\"\"\n        if self.calculate_kv_scales:\n            torch.ops.vllm.maybe_calc_kv_scales(query, key, value, self.layer_name)\n        output_dtype = query.dtype\n        if self.query_quant is not None:\n            # quantizing with a simple torch operation enables\n            # torch.compile to fuse this into previous ops\n            # which reduces overheads during decoding.\n            # Otherwise queries are quantized using custom ops\n            # which causes decoding overheads\n            assert self.kv_cache_dtype in {\"fp8\", \"fp8_e4m3\"}\n\n            # check if query quantization is supported\n            if self.impl.supports_quant_query_input:\n                query, _ = self.query_quant(query, self._q_scale)\n\n        if self.use_output:\n            output_shape = output_shape if output_shape is not None else query.shape\n            output = torch.empty(output_shape, dtype=output_dtype, device=query.device)\n            hidden_size = output_shape[-1]\n            # Reshape the query, key, and value tensors.\n            # NOTE(woosuk): We do this outside the custom op to minimize the\n            # CPU overheads from the non-CUDA-graph regions.\n            query = query.view(-1, self.num_heads, self.head_size)\n            output = output.view(-1, self.num_heads, self.head_size)\n            if key is not None:\n                key = key.view(-1, self.num_kv_heads, self.head_size)\n            if value is not None:\n                value = value.view(-1, self.num_kv_heads, self.head_size)\n            if self.use_direct_call:\n                forward_context: ForwardContext = get_forward_context()\n                attn_metadata = forward_context.attn_metadata\n                if isinstance(attn_metadata, dict):\n                    attn_metadata = attn_metadata[self.layer_name]\n                self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n                self.impl.forward(\n                    self, query, key, value, self_kv_cache, attn_metadata, output=output\n                )\n            else:\n                torch.ops.vllm.unified_attention_with_output(\n                    query, key, value, output, self.layer_name\n                )\n            return output.view(-1, hidden_size)\n        else:\n            if self.use_direct_call:\n                forward_context = get_forward_context()\n                attn_metadata = forward_context.attn_metadata\n                if isinstance(attn_metadata, dict):\n                    attn_metadata = attn_metadata[self.layer_name]\n                self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n                return self.impl.forward(\n                    self, query, key, value, self_kv_cache, attn_metadata\n                )\n            else:\n                return torch.ops.vllm.unified_attention(\n                    query, key, value, self.layer_name\n                )\n\n    def calc_kv_scales(self, query, key, value):\n        self._q_scale.copy_(torch.abs(query).max() / self.q_range)\n        self._k_scale.copy_(torch.abs(key).max() / self.k_range)\n        self._v_scale.copy_(torch.abs(value).max() / self.v_range)\n        self._q_scale_float = self._q_scale.item()\n        self._k_scale_float = self._k_scale.item()\n        self._v_scale_float = self._v_scale.item()\n        # We only calculate the scales once\n        self.calculate_kv_scales = False\n\n    def extra_repr(self) -> str:\n        s = f\"head_size={self.impl.head_size}\"  # type: ignore\n        s += f\", num_heads={self.impl.num_heads}\"  # type: ignore\n        s += f\", num_kv_heads={self.impl.num_kv_heads}\"  # type: ignore\n        s += f\", scale={self.impl.scale}\"  # type: ignore\n        s += f\", backend={self.impl.__class__.__name__}\"\n        return s\n\n    def process_weights_after_loading(self, act_dtype: torch.dtype):\n        self.impl.process_weights_after_loading(act_dtype)\n\n    def get_attn_backend(self) -> type[AttentionBackend]:\n        return self.attn_backend\n\n    def get_kv_cache_spec(self, vllm_config: VllmConfig) -> KVCacheSpec:\n        # Block size may get updated after model loading, refresh it\n        block_size = vllm_config.cache_config.block_size\n        # Should not be called for enc-dec or encoder-only attention.\n        assert self.attn_type == AttentionType.DECODER\n        if self.sliding_window is not None:\n            assert not vllm_config.model_config.use_mla, (\n                \"MLA is not supported for slidingwindow\"\n            )\n            return SlidingWindowSpec(\n                block_size=block_size,\n                num_kv_heads=self.num_kv_heads,\n                head_size=self.head_size,\n                dtype=self.kv_cache_torch_dtype,\n                sliding_window=self.sliding_window,\n            )\n        else:\n            return FullAttentionSpec(\n                block_size=block_size,\n                num_kv_heads=self.num_kv_heads,\n                head_size=self.head_size,\n                dtype=self.kv_cache_torch_dtype,\n            )",
      "language": "python"
    },
    {
      "code": "class Attention(nn.Module, AttentionLayerBase):\n    \"\"\"Attention layer.\n\n    This class takes query, key, and value tensors as input. The input tensors\n    can either contain prompt tokens or generation tokens.\n    The class does the following:\n\n    1. Store the input key and value tensors in the KV cache.\n    2. Perform (multi-head/multi-query/grouped-query) attention.\n    3. Return the output tensor.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_heads: int,\n        head_size: int,\n        scale: float,\n        num_kv_heads: int | None = None,\n        alibi_slopes: list[float] | None = None,\n        cache_config: CacheConfig | None = None,\n        quant_config: QuantizationConfig | None = None,\n        logits_soft_cap: float | None = None,\n        per_layer_sliding_window: int | None = None,\n        prefix: str = \"\",\n        attn_type: str = AttentionType.DECODER,\n        kv_sharing_target_layer_name: str | None = None,\n        attn_backend: type[AttentionBackend] | None = None,\n        **extra_impl_args,\n    ) -> None:\n        \"\"\"\n        The KV cache is stored inside this class and is accessed via\n        `self.kv_cache`.\n        \"\"\"\n        super().__init__()\n        if per_layer_sliding_window is not None:\n            # per-layer sliding window\n            sliding_window = per_layer_sliding_window\n        elif cache_config is not None:\n            # model-level sliding window\n            sliding_window = cache_config.sliding_window\n        else:\n            sliding_window = None\n\n        vllm_config = get_current_vllm_config()\n        if cache_config is not None:\n            kv_cache_dtype = cache_config.cache_dtype\n            block_size = cache_config.block_size\n            calculate_kv_scales = cache_config.calculate_kv_scales\n        else:\n            kv_cache_dtype = \"auto\"\n            block_size = 16\n            calculate_kv_scales = False\n        self.kv_cache_torch_dtype = kv_cache_dtype_str_to_dtype(\n            kv_cache_dtype, vllm_config.model_config\n        )\n        if num_kv_heads is None:\n            num_kv_heads = num_heads\n        assert num_heads % num_kv_heads == 0, (\n            f\"num_heads ({num_heads}) is not divisible by num_kv_heads ({num_kv_heads})\"\n        )\n\n        # Initialize KV cache quantization attributes\n        _init_kv_cache_quant(\n            self, quant_config, prefix, kv_cache_dtype, calculate_kv_scales\n        )\n\n        self.num_heads = num_heads\n        self.head_size = head_size\n        self.num_kv_heads = num_kv_heads\n        self.sliding_window = sliding_window\n        self.has_sink = extra_impl_args.get(\"sinks\") is not None\n\n        # NOTE: model_config may be None during certain tests\n        model_config = vllm_config.model_config\n        self.use_mm_prefix = model_config is not None and model_config.is_mm_prefix_lm\n\n        # During model initialization, the default dtype is set as the model\n        # weight and activation dtype.\n        dtype = torch.get_default_dtype()\n        if attn_backend is None:\n            self.attn_backend = get_attn_backend(\n                head_size,\n                dtype,\n                kv_cache_dtype,\n                block_size,\n                use_mla=False,\n                has_sink=self.has_sink,\n                use_mm_prefix=self.use_mm_prefix,\n                attn_type=attn_type,\n            )\n        else:\n            self.attn_backend = attn_backend\n\n        # prefix caching + batch invariance is currently not supported for\n        # FLASHINFER and TRITON_MLA.\n        if (\n            cache_config is not None\n            and cache_config.enable_prefix_caching\n            and vllm_is_batch_invariant()\n            and (\n                self.attn_backend.get_name() == \"FLASHINFER\"\n                or self.attn_backend.get_name() == \"TRITON_MLA\"\n            )\n        ):\n            logger.warning_once(\n                \"Disabling prefix caching for FLASHINFER/TRITON_MLA \"\n                \"with batch invariance, as it is not yet supported.\",\n                scope=\"local\",\n            )\n            cache_config.enable_prefix_caching = False\n\n        impl_cls = self.attn_backend.get_impl_cls()\n        self.impl = impl_cls(\n            num_heads,\n            head_size,\n            scale,\n            num_kv_heads,\n            alibi_slopes,\n            sliding_window,\n            kv_cache_dtype,\n            logits_soft_cap,\n            attn_type,\n            kv_sharing_target_layer_name,\n            **extra_impl_args,\n        )\n        backend_name = self.attn_backend.get_name()\n        self.backend = AttentionBackendEnum.__members__.get(backend_name)\n        self.dtype = dtype\n\n        # For cuda-alike (CUDA and ROCM) and cpu platforms, we control how\n        # torch.compile works by registering the attention as one giant\n        # opaque custom op. For other platforms, we directly call them\n        # and let torch.compile handle them.\n        self.use_direct_call = not current_platform.opaque_attention_op()\n\n        self.use_output = self.attn_backend.accept_output_buffer\n        compilation_config = vllm_config.compilation_config\n        if prefix in compilation_config.static_forward_context:\n            raise ValueError(f\"Duplicate layer name: {prefix}\")\n        compilation_config.static_forward_context[prefix] = self\n        self.layer_name = prefix\n        self.attn_type = attn_type\n\n        if kv_sharing_target_layer_name is not None:\n            validate_kv_sharing_target(\n                prefix,\n                kv_sharing_target_layer_name,\n                compilation_config.static_forward_context,\n            )\n        self.kv_sharing_target_layer_name = kv_sharing_target_layer_name\n\n        # use a placeholder kv cache tensor during init, which will be replaced\n        # by bind_kv_cache\n        # this variable will not be accessed if use_direct_call is True\n        self.kv_cache = [\n            torch.tensor([])\n            for _ in range(vllm_config.parallel_config.pipeline_parallel_size)\n        ]\n\n        # Initialize q/k/v range constants.\n        self.q_range = torch.tensor(envs.Q_SCALE_CONSTANT, dtype=torch.float32)\n        self.k_range = torch.tensor(envs.K_SCALE_CONSTANT, dtype=torch.float32)\n        self.v_range = torch.tensor(envs.V_SCALE_CONSTANT, dtype=torch.float32)\n\n        # for attn backends supporting query quantization\n        self.query_quant = None\n        if (\n            self.kv_cache_dtype.startswith(\"fp8\")\n            and self.impl.supports_quant_query_input\n        ):\n            self.query_quant = QuantFP8(static=True, group_shape=GroupShape.PER_TENSOR)\n\n    def forward(\n        self,\n        query: torch.Tensor,\n        key: torch.Tensor,\n        value: torch.Tensor,\n        # For some alternate attention backends like MLA the attention output\n        # shape does not match the query shape, so we optionally let the model\n        # definition specify the output tensor shape.\n        output_shape: torch.Size | None = None,\n    ) -> torch.Tensor:\n        \"\"\"\n        The KV cache is stored inside this class and is accessed via\n        `self.kv_cache`.\n\n        Attention metadata (`attn_metadata`) is set using a context manager in\n        the model runner's `execute_model` method. It is accessed via forward\n        context using\n        `vllm.forward_context.get_forward_context().attn_metadata`.\n        \"\"\"\n        if self.calculate_kv_scales:\n            torch.ops.vllm.maybe_calc_kv_scales(query, key, value, self.layer_name)\n        output_dtype = query.dtype\n        if self.query_quant is not None:\n            # quantizing with a simple torch operation enables\n            # torch.compile to fuse this into previous ops\n            # which reduces overheads during decoding.\n            # Otherwise queries are quantized using custom ops\n            # which causes decoding overheads\n            assert self.kv_cache_dtype in {\"fp8\", \"fp8_e4m3\"}\n\n            # check if query quantization is supported\n            if self.impl.supports_quant_query_input:\n                query, _ = self.query_quant(query, self._q_scale)\n\n        if self.use_output:\n            output_shape = output_shape if output_shape is not None else query.shape\n            output = torch.empty(output_shape, dtype=output_dtype, device=query.device)\n            hidden_size = output_shape[-1]\n            # Reshape the query, key, and value tensors.\n            # NOTE(woosuk): We do this outside the custom op to minimize the\n            # CPU overheads from the non-CUDA-graph regions.\n            query = query.view(-1, self.num_heads, self.head_size)\n            output = output.view(-1, self.num_heads, self.head_size)\n            if key is not None:\n                key = key.view(-1, self.num_kv_heads, self.head_size)\n            if value is not None:\n                value = value.view(-1, self.num_kv_heads, self.head_size)\n            if self.use_direct_call:\n                forward_context: ForwardContext = get_forward_context()\n                attn_metadata = forward_context.attn_metadata\n                if isinstance(attn_metadata, dict):\n                    attn_metadata = attn_metadata[self.layer_name]\n                self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n                self.impl.forward(\n                    self, query, key, value, self_kv_cache, attn_metadata, output=output\n                )\n            else:\n                torch.ops.vllm.unified_attention_with_output(\n                    query, key, value, output, self.layer_name\n                )\n            return output.view(-1, hidden_size)\n        else:\n            if self.use_direct_call:\n                forward_context = get_forward_context()\n                attn_metadata = forward_context.attn_metadata\n                if isinstance(attn_metadata, dict):\n                    attn_metadata = attn_metadata[self.layer_name]\n                self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n                return self.impl.forward(\n                    self, query, key, value, self_kv_cache, attn_metadata\n                )\n            else:\n                return torch.ops.vllm.unified_attention(\n                    query, key, value, self.layer_name\n                )\n\n    def calc_kv_scales(self, query, key, value):\n        self._q_scale.copy_(torch.abs(query).max() / self.q_range)\n        self._k_scale.copy_(torch.abs(key).max() / self.k_range)\n        self._v_scale.copy_(torch.abs(value).max() / self.v_range)\n        self._q_scale_float = self._q_scale.item()\n        self._k_scale_float = self._k_scale.item()\n        self._v_scale_float = self._v_scale.item()\n        # We only calculate the scales once\n        self.calculate_kv_scales = False\n\n    def extra_repr(self) -> str:\n        s = f\"head_size={self.impl.head_size}\"  # type: ignore\n        s += f\", num_heads={self.impl.num_heads}\"  # type: ignore\n        s += f\", num_kv_heads={self.impl.num_kv_heads}\"  # type: ignore\n        s += f\", scale={self.impl.scale}\"  # type: ignore\n        s += f\", backend={self.impl.__class__.__name__}\"\n        return s\n\n    def process_weights_after_loading(self, act_dtype: torch.dtype):\n        self.impl.process_weights_after_loading(act_dtype)\n\n    def get_attn_backend(self) -> type[AttentionBackend]:\n        return self.attn_backend\n\n    def get_kv_cache_spec(self, vllm_config: VllmConfig) -> KVCacheSpec:\n        # Block size may get updated after model loading, refresh it\n        block_size = vllm_config.cache_config.block_size\n        # Should not be called for enc-dec or encoder-only attention.\n        assert self.attn_type == AttentionType.DECODER\n        if self.sliding_window is not None:\n            assert not vllm_config.model_config.use_mla, (\n                \"MLA is not supported for slidingwindow\"\n            )\n            return SlidingWindowSpec(\n                block_size=block_size,\n                num_kv_heads=self.num_kv_heads,\n                head_size=self.head_size,\n                dtype=self.kv_cache_torch_dtype,\n                sliding_window=self.sliding_window,\n            )\n        else:\n            return FullAttentionSpec(\n                block_size=block_size,\n                num_kv_heads=self.num_kv_heads,\n                head_size=self.head_size,\n                dtype=self.kv_cache_torch_dtype,\n            )",
      "language": "python"
    },
    {
      "code": "attn_backend = get_attn_backend(\n    head_size,\n    dtype,\n    kv_cache_dtype,\n    block_size,\n    use_mla=False,\n    has_sink=has_sink,\n    use_mm_prefix=use_mm_prefix,\n    attn_type=attn_type,\n)",
      "language": "unknown"
    },
    {
      "code": "attn_backend = get_attn_backend(\n    head_size,\n    dtype,\n    kv_cache_dtype,\n    block_size,\n    use_mla=False,\n    has_sink=has_sink,\n    use_mm_prefix=use_mm_prefix,\n    attn_type=attn_type,\n)",
      "language": "unknown"
    },
    {
      "code": "attn_type = attn_type",
      "language": "unknown"
    },
    {
      "code": "attn_type = attn_type",
      "language": "unknown"
    },
    {
      "code": "backend = get(backend_name)",
      "language": "unknown"
    },
    {
      "code": "backend = get(backend_name)",
      "language": "unknown"
    },
    {
      "code": "dtype = dtype",
      "language": "unknown"
    },
    {
      "code": "dtype = dtype",
      "language": "unknown"
    },
    {
      "code": "has_sink = get('sinks') is not None",
      "language": "rust"
    },
    {
      "code": "has_sink = get('sinks') is not None",
      "language": "rust"
    },
    {
      "code": "head_size = head_size",
      "language": "unknown"
    },
    {
      "code": "head_size = head_size",
      "language": "unknown"
    },
    {
      "code": "impl = impl_cls(\n    num_heads,\n    head_size,\n    scale,\n    num_kv_heads,\n    alibi_slopes,\n    sliding_window,\n    kv_cache_dtype,\n    logits_soft_cap,\n    attn_type,\n    kv_sharing_target_layer_name,\n    **extra_impl_args,\n)",
      "language": "unknown"
    },
    {
      "code": "impl = impl_cls(\n    num_heads,\n    head_size,\n    scale,\n    num_kv_heads,\n    alibi_slopes,\n    sliding_window,\n    kv_cache_dtype,\n    logits_soft_cap,\n    attn_type,\n    kv_sharing_target_layer_name,\n    **extra_impl_args,\n)",
      "language": "unknown"
    },
    {
      "code": "k_range = tensor(K_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "k_range = tensor(K_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "kv_cache = [\n    (tensor([])) for _ in (range(pipeline_parallel_size))\n]",
      "language": "bash"
    },
    {
      "code": "kv_cache = [\n    (tensor([])) for _ in (range(pipeline_parallel_size))\n]",
      "language": "bash"
    },
    {
      "code": "kv_cache_torch_dtype = kv_cache_dtype_str_to_dtype(\n    kv_cache_dtype, model_config\n)",
      "language": "unknown"
    },
    {
      "code": "kv_cache_torch_dtype = kv_cache_dtype_str_to_dtype(\n    kv_cache_dtype, model_config\n)",
      "language": "unknown"
    },
    {
      "code": "kv_sharing_target_layer_name = kv_sharing_target_layer_name",
      "language": "unknown"
    },
    {
      "code": "kv_sharing_target_layer_name = kv_sharing_target_layer_name",
      "language": "unknown"
    },
    {
      "code": "layer_name = prefix",
      "language": "unknown"
    },
    {
      "code": "layer_name = prefix",
      "language": "unknown"
    },
    {
      "code": "num_heads = num_heads",
      "language": "unknown"
    },
    {
      "code": "num_heads = num_heads",
      "language": "unknown"
    },
    {
      "code": "num_kv_heads = num_kv_heads",
      "language": "unknown"
    },
    {
      "code": "num_kv_heads = num_kv_heads",
      "language": "unknown"
    },
    {
      "code": "q_range = tensor(Q_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "q_range = tensor(Q_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "query_quant = None",
      "language": "rust"
    },
    {
      "code": "query_quant = None",
      "language": "rust"
    },
    {
      "code": "sliding_window = sliding_window",
      "language": "unknown"
    },
    {
      "code": "sliding_window = sliding_window",
      "language": "unknown"
    },
    {
      "code": "use_direct_call = not opaque_attention_op()",
      "language": "unknown"
    },
    {
      "code": "use_direct_call = not opaque_attention_op()",
      "language": "unknown"
    },
    {
      "code": "use_mm_prefix = model_config is not None and is_mm_prefix_lm",
      "language": "rust"
    },
    {
      "code": "use_mm_prefix = model_config is not None and is_mm_prefix_lm",
      "language": "rust"
    },
    {
      "code": "use_output = accept_output_buffer",
      "language": "unknown"
    },
    {
      "code": "use_output = accept_output_buffer",
      "language": "unknown"
    },
    {
      "code": "v_range = tensor(V_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "v_range = tensor(V_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "__init__(\n    num_heads: int,\n    head_size: int,\n    scale: float,\n    num_kv_heads: int | None = None,\n    alibi_slopes: list[float] | None = None,\n    cache_config: CacheConfig | None = None,\n    quant_config: QuantizationConfig | None = None,\n    logits_soft_cap: float | None = None,\n    per_layer_sliding_window: int | None = None,\n    prefix: str = \"\",\n    attn_type: str = DECODER,\n    kv_sharing_target_layer_name: str | None = None,\n    attn_backend: type[AttentionBackend] | None = None,\n    **extra_impl_args,\n) -> None",
      "language": "typescript"
    },
    {
      "code": "__init__(\n    num_heads: int,\n    head_size: int,\n    scale: float,\n    num_kv_heads: int | None = None,\n    alibi_slopes: list[float] | None = None,\n    cache_config: CacheConfig | None = None,\n    quant_config: QuantizationConfig | None = None,\n    logits_soft_cap: float | None = None,\n    per_layer_sliding_window: int | None = None,\n    prefix: str = \"\",\n    attn_type: str = DECODER,\n    kv_sharing_target_layer_name: str | None = None,\n    attn_backend: type[AttentionBackend] | None = None,\n    **extra_impl_args,\n) -> None",
      "language": "typescript"
    },
    {
      "code": "124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282",
      "language": "unknown"
    },
    {
      "code": "def __init__(\n    self,\n    num_heads: int,\n    head_size: int,\n    scale: float,\n    num_kv_heads: int | None = None,\n    alibi_slopes: list[float] | None = None,\n    cache_config: CacheConfig | None = None,\n    quant_config: QuantizationConfig | None = None,\n    logits_soft_cap: float | None = None,\n    per_layer_sliding_window: int | None = None,\n    prefix: str = \"\",\n    attn_type: str = AttentionType.DECODER,\n    kv_sharing_target_layer_name: str | None = None,\n    attn_backend: type[AttentionBackend] | None = None,\n    **extra_impl_args,\n) -> None:\n    \"\"\"\n    The KV cache is stored inside this class and is accessed via\n    `self.kv_cache`.\n    \"\"\"\n    super().__init__()\n    if per_layer_sliding_window is not None:\n        # per-layer sliding window\n        sliding_window = per_layer_sliding_window\n    elif cache_config is not None:\n        # model-level sliding window\n        sliding_window = cache_config.sliding_window\n    else:\n        sliding_window = None\n\n    vllm_config = get_current_vllm_config()\n    if cache_config is not None:\n        kv_cache_dtype = cache_config.cache_dtype\n        block_size = cache_config.block_size\n        calculate_kv_scales = cache_config.calculate_kv_scales\n    else:\n        kv_cache_dtype = \"auto\"\n        block_size = 16\n        calculate_kv_scales = False\n    self.kv_cache_torch_dtype = kv_cache_dtype_str_to_dtype(\n        kv_cache_dtype, vllm_config.model_config\n    )\n    if num_kv_heads is None:\n        num_kv_heads = num_heads\n    assert num_heads % num_kv_heads == 0, (\n        f\"num_heads ({num_heads}) is not divisible by num_kv_heads ({num_kv_heads})\"\n    )\n\n    # Initialize KV cache quantization attributes\n    _init_kv_cache_quant(\n        self, quant_config, prefix, kv_cache_dtype, calculate_kv_scales\n    )\n\n    self.num_heads = num_heads\n    self.head_size = head_size\n    self.num_kv_heads = num_kv_heads\n    self.sliding_window = sliding_window\n    self.has_sink = extra_impl_args.get(\"sinks\") is not None\n\n    # NOTE: model_config may be None during certain tests\n    model_config = vllm_config.model_config\n    self.use_mm_prefix = model_config is not None and model_config.is_mm_prefix_lm\n\n    # During model initialization, the default dtype is set as the model\n    # weight and activation dtype.\n    dtype = torch.get_default_dtype()\n    if attn_backend is None:\n        self.attn_backend = get_attn_backend(\n            head_size,\n            dtype,\n            kv_cache_dtype,\n            block_size,\n            use_mla=False,\n            has_sink=self.has_sink,\n            use_mm_prefix=self.use_mm_prefix,\n            attn_type=attn_type,\n        )\n    else:\n        self.attn_backend = attn_backend\n\n    # prefix caching + batch invariance is currently not supported for\n    # FLASHINFER and TRITON_MLA.\n    if (\n        cache_config is not None\n        and cache_config.enable_prefix_caching\n        and vllm_is_batch_invariant()\n        and (\n            self.attn_backend.get_name() == \"FLASHINFER\"\n            or self.attn_backend.get_name() == \"TRITON_MLA\"\n        )\n    ):\n        logger.warning_once(\n            \"Disabling prefix caching for FLASHINFER/TRITON_MLA \"\n            \"with batch invariance, as it is not yet supported.\",\n            scope=\"local\",\n        )\n        cache_config.enable_prefix_caching = False\n\n    impl_cls = self.attn_backend.get_impl_cls()\n    self.impl = impl_cls(\n        num_heads,\n        head_size,\n        scale,\n        num_kv_heads,\n        alibi_slopes,\n        sliding_window,\n        kv_cache_dtype,\n        logits_soft_cap,\n        attn_type,\n        kv_sharing_target_layer_name,\n        **extra_impl_args,\n    )\n    backend_name = self.attn_backend.get_name()\n    self.backend = AttentionBackendEnum.__members__.get(backend_name)\n    self.dtype = dtype\n\n    # For cuda-alike (CUDA and ROCM) and cpu platforms, we control how\n    # torch.compile works by registering the attention as one giant\n    # opaque custom op. For other platforms, we directly call them\n    # and let torch.compile handle them.\n    self.use_direct_call = not current_platform.opaque_attention_op()\n\n    self.use_output = self.attn_backend.accept_output_buffer\n    compilation_config = vllm_config.compilation_config\n    if prefix in compilation_config.static_forward_context:\n        raise ValueError(f\"Duplicate layer name: {prefix}\")\n    compilation_config.static_forward_context[prefix] = self\n    self.layer_name = prefix\n    self.attn_type = attn_type\n\n    if kv_sharing_target_layer_name is not None:\n        validate_kv_sharing_target(\n            prefix,\n            kv_sharing_target_layer_name,\n            compilation_config.static_forward_context,\n        )\n    self.kv_sharing_target_layer_name = kv_sharing_target_layer_name\n\n    # use a placeholder kv cache tensor during init, which will be replaced\n    # by bind_kv_cache\n    # this variable will not be accessed if use_direct_call is True\n    self.kv_cache = [\n        torch.tensor([])\n        for _ in range(vllm_config.parallel_config.pipeline_parallel_size)\n    ]\n\n    # Initialize q/k/v range constants.\n    self.q_range = torch.tensor(envs.Q_SCALE_CONSTANT, dtype=torch.float32)\n    self.k_range = torch.tensor(envs.K_SCALE_CONSTANT, dtype=torch.float32)\n    self.v_range = torch.tensor(envs.V_SCALE_CONSTANT, dtype=torch.float32)\n\n    # for attn backends supporting query quantization\n    self.query_quant = None\n    if (\n        self.kv_cache_dtype.startswith(\"fp8\")\n        and self.impl.supports_quant_query_input\n    ):\n        self.query_quant = QuantFP8(static=True, group_shape=GroupShape.PER_TENSOR)",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    num_heads: int,\n    head_size: int,\n    scale: float,\n    num_kv_heads: int | None = None,\n    alibi_slopes: list[float] | None = None,\n    cache_config: CacheConfig | None = None,\n    quant_config: QuantizationConfig | None = None,\n    logits_soft_cap: float | None = None,\n    per_layer_sliding_window: int | None = None,\n    prefix: str = \"\",\n    attn_type: str = AttentionType.DECODER,\n    kv_sharing_target_layer_name: str | None = None,\n    attn_backend: type[AttentionBackend] | None = None,\n    **extra_impl_args,\n) -> None:\n    \"\"\"\n    The KV cache is stored inside this class and is accessed via\n    `self.kv_cache`.\n    \"\"\"\n    super().__init__()\n    if per_layer_sliding_window is not None:\n        # per-layer sliding window\n        sliding_window = per_layer_sliding_window\n    elif cache_config is not None:\n        # model-level sliding window\n        sliding_window = cache_config.sliding_window\n    else:\n        sliding_window = None\n\n    vllm_config = get_current_vllm_config()\n    if cache_config is not None:\n        kv_cache_dtype = cache_config.cache_dtype\n        block_size = cache_config.block_size\n        calculate_kv_scales = cache_config.calculate_kv_scales\n    else:\n        kv_cache_dtype = \"auto\"\n        block_size = 16\n        calculate_kv_scales = False\n    self.kv_cache_torch_dtype = kv_cache_dtype_str_to_dtype(\n        kv_cache_dtype, vllm_config.model_config\n    )\n    if num_kv_heads is None:\n        num_kv_heads = num_heads\n    assert num_heads % num_kv_heads == 0, (\n        f\"num_heads ({num_heads}) is not divisible by num_kv_heads ({num_kv_heads})\"\n    )\n\n    # Initialize KV cache quantization attributes\n    _init_kv_cache_quant(\n        self, quant_config, prefix, kv_cache_dtype, calculate_kv_scales\n    )\n\n    self.num_heads = num_heads\n    self.head_size = head_size\n    self.num_kv_heads = num_kv_heads\n    self.sliding_window = sliding_window\n    self.has_sink = extra_impl_args.get(\"sinks\") is not None\n\n    # NOTE: model_config may be None during certain tests\n    model_config = vllm_config.model_config\n    self.use_mm_prefix = model_config is not None and model_config.is_mm_prefix_lm\n\n    # During model initialization, the default dtype is set as the model\n    # weight and activation dtype.\n    dtype = torch.get_default_dtype()\n    if attn_backend is None:\n        self.attn_backend = get_attn_backend(\n            head_size,\n            dtype,\n            kv_cache_dtype,\n            block_size,\n            use_mla=False,\n            has_sink=self.has_sink,\n            use_mm_prefix=self.use_mm_prefix,\n            attn_type=attn_type,\n        )\n    else:\n        self.attn_backend = attn_backend\n\n    # prefix caching + batch invariance is currently not supported for\n    # FLASHINFER and TRITON_MLA.\n    if (\n        cache_config is not None\n        and cache_config.enable_prefix_caching\n        and vllm_is_batch_invariant()\n        and (\n            self.attn_backend.get_name() == \"FLASHINFER\"\n            or self.attn_backend.get_name() == \"TRITON_MLA\"\n        )\n    ):\n        logger.warning_once(\n            \"Disabling prefix caching for FLASHINFER/TRITON_MLA \"\n            \"with batch invariance, as it is not yet supported.\",\n            scope=\"local\",\n        )\n        cache_config.enable_prefix_caching = False\n\n    impl_cls = self.attn_backend.get_impl_cls()\n    self.impl = impl_cls(\n        num_heads,\n        head_size,\n        scale,\n        num_kv_heads,\n        alibi_slopes,\n        sliding_window,\n        kv_cache_dtype,\n        logits_soft_cap,\n        attn_type,\n        kv_sharing_target_layer_name,\n        **extra_impl_args,\n    )\n    backend_name = self.attn_backend.get_name()\n    self.backend = AttentionBackendEnum.__members__.get(backend_name)\n    self.dtype = dtype\n\n    # For cuda-alike (CUDA and ROCM) and cpu platforms, we control how\n    # torch.compile works by registering the attention as one giant\n    # opaque custom op. For other platforms, we directly call them\n    # and let torch.compile handle them.\n    self.use_direct_call = not current_platform.opaque_attention_op()\n\n    self.use_output = self.attn_backend.accept_output_buffer\n    compilation_config = vllm_config.compilation_config\n    if prefix in compilation_config.static_forward_context:\n        raise ValueError(f\"Duplicate layer name: {prefix}\")\n    compilation_config.static_forward_context[prefix] = self\n    self.layer_name = prefix\n    self.attn_type = attn_type\n\n    if kv_sharing_target_layer_name is not None:\n        validate_kv_sharing_target(\n            prefix,\n            kv_sharing_target_layer_name,\n            compilation_config.static_forward_context,\n        )\n    self.kv_sharing_target_layer_name = kv_sharing_target_layer_name\n\n    # use a placeholder kv cache tensor during init, which will be replaced\n    # by bind_kv_cache\n    # this variable will not be accessed if use_direct_call is True\n    self.kv_cache = [\n        torch.tensor([])\n        for _ in range(vllm_config.parallel_config.pipeline_parallel_size)\n    ]\n\n    # Initialize q/k/v range constants.\n    self.q_range = torch.tensor(envs.Q_SCALE_CONSTANT, dtype=torch.float32)\n    self.k_range = torch.tensor(envs.K_SCALE_CONSTANT, dtype=torch.float32)\n    self.v_range = torch.tensor(envs.V_SCALE_CONSTANT, dtype=torch.float32)\n\n    # for attn backends supporting query quantization\n    self.query_quant = None\n    if (\n        self.kv_cache_dtype.startswith(\"fp8\")\n        and self.impl.supports_quant_query_input\n    ):\n        self.query_quant = QuantFP8(static=True, group_shape=GroupShape.PER_TENSOR)",
      "language": "python"
    },
    {
      "code": "calc_kv_scales(query, key, value)",
      "language": "unknown"
    },
    {
      "code": "calc_kv_scales(query, key, value)",
      "language": "unknown"
    },
    {
      "code": "360\n361\n362\n363\n364\n365\n366\n367\n368",
      "language": "unknown"
    },
    {
      "code": "def calc_kv_scales(self, query, key, value):\n    self._q_scale.copy_(torch.abs(query).max() / self.q_range)\n    self._k_scale.copy_(torch.abs(key).max() / self.k_range)\n    self._v_scale.copy_(torch.abs(value).max() / self.v_range)\n    self._q_scale_float = self._q_scale.item()\n    self._k_scale_float = self._k_scale.item()\n    self._v_scale_float = self._v_scale.item()\n    # We only calculate the scales once\n    self.calculate_kv_scales = False",
      "language": "python"
    },
    {
      "code": "def calc_kv_scales(self, query, key, value):\n    self._q_scale.copy_(torch.abs(query).max() / self.q_range)\n    self._k_scale.copy_(torch.abs(key).max() / self.k_range)\n    self._v_scale.copy_(torch.abs(value).max() / self.v_range)\n    self._q_scale_float = self._q_scale.item()\n    self._k_scale_float = self._k_scale.item()\n    self._v_scale_float = self._v_scale.item()\n    # We only calculate the scales once\n    self.calculate_kv_scales = False",
      "language": "python"
    },
    {
      "code": "extra_repr() -> str",
      "language": "php"
    },
    {
      "code": "extra_repr() -> str",
      "language": "php"
    },
    {
      "code": "370\n371\n372\n373\n374\n375\n376",
      "language": "unknown"
    },
    {
      "code": "def extra_repr(self) -> str:\n    s = f\"head_size={self.impl.head_size}\"  # type: ignore\n    s += f\", num_heads={self.impl.num_heads}\"  # type: ignore\n    s += f\", num_kv_heads={self.impl.num_kv_heads}\"  # type: ignore\n    s += f\", scale={self.impl.scale}\"  # type: ignore\n    s += f\", backend={self.impl.__class__.__name__}\"\n    return s",
      "language": "python"
    },
    {
      "code": "def extra_repr(self) -> str:\n    s = f\"head_size={self.impl.head_size}\"  # type: ignore\n    s += f\", num_heads={self.impl.num_heads}\"  # type: ignore\n    s += f\", num_kv_heads={self.impl.num_kv_heads}\"  # type: ignore\n    s += f\", scale={self.impl.scale}\"  # type: ignore\n    s += f\", backend={self.impl.__class__.__name__}\"\n    return s",
      "language": "python"
    },
    {
      "code": "forward(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    output_shape: Size | None = None,\n) -> Tensor",
      "language": "rust"
    },
    {
      "code": "forward(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    output_shape: Size | None = None,\n) -> Tensor",
      "language": "rust"
    },
    {
      "code": "284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358",
      "language": "unknown"
    },
    {
      "code": "def forward(\n    self,\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    # For some alternate attention backends like MLA the attention output\n    # shape does not match the query shape, so we optionally let the model\n    # definition specify the output tensor shape.\n    output_shape: torch.Size | None = None,\n) -> torch.Tensor:\n    \"\"\"\n    The KV cache is stored inside this class and is accessed via\n    `self.kv_cache`.\n\n    Attention metadata (`attn_metadata`) is set using a context manager in\n    the model runner's `execute_model` method. It is accessed via forward\n    context using\n    `vllm.forward_context.get_forward_context().attn_metadata`.\n    \"\"\"\n    if self.calculate_kv_scales:\n        torch.ops.vllm.maybe_calc_kv_scales(query, key, value, self.layer_name)\n    output_dtype = query.dtype\n    if self.query_quant is not None:\n        # quantizing with a simple torch operation enables\n        # torch.compile to fuse this into previous ops\n        # which reduces overheads during decoding.\n        # Otherwise queries are quantized using custom ops\n        # which causes decoding overheads\n        assert self.kv_cache_dtype in {\"fp8\", \"fp8_e4m3\"}\n\n        # check if query quantization is supported\n        if self.impl.supports_quant_query_input:\n            query, _ = self.query_quant(query, self._q_scale)\n\n    if self.use_output:\n        output_shape = output_shape if output_shape is not None else query.shape\n        output = torch.empty(output_shape, dtype=output_dtype, device=query.device)\n        hidden_size = output_shape[-1]\n        # Reshape the query, key, and value tensors.\n        # NOTE(woosuk): We do this outside the custom op to minimize the\n        # CPU overheads from the non-CUDA-graph regions.\n        query = query.view(-1, self.num_heads, self.head_size)\n        output = output.view(-1, self.num_heads, self.head_size)\n        if key is not None:\n            key = key.view(-1, self.num_kv_heads, self.head_size)\n        if value is not None:\n            value = value.view(-1, self.num_kv_heads, self.head_size)\n        if self.use_direct_call:\n            forward_context: ForwardContext = get_forward_context()\n            attn_metadata = forward_context.attn_metadata\n            if isinstance(attn_metadata, dict):\n                attn_metadata = attn_metadata[self.layer_name]\n            self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n            self.impl.forward(\n                self, query, key, value, self_kv_cache, attn_metadata, output=output\n            )\n        else:\n            torch.ops.vllm.unified_attention_with_output(\n                query, key, value, output, self.layer_name\n            )\n        return output.view(-1, hidden_size)\n    else:\n        if self.use_direct_call:\n            forward_context = get_forward_context()\n            attn_metadata = forward_context.attn_metadata\n            if isinstance(attn_metadata, dict):\n                attn_metadata = attn_metadata[self.layer_name]\n            self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n            return self.impl.forward(\n                self, query, key, value, self_kv_cache, attn_metadata\n            )\n        else:\n            return torch.ops.vllm.unified_attention(\n                query, key, value, self.layer_name\n            )",
      "language": "python"
    },
    {
      "code": "def forward(\n    self,\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    # For some alternate attention backends like MLA the attention output\n    # shape does not match the query shape, so we optionally let the model\n    # definition specify the output tensor shape.\n    output_shape: torch.Size | None = None,\n) -> torch.Tensor:\n    \"\"\"\n    The KV cache is stored inside this class and is accessed via\n    `self.kv_cache`.\n\n    Attention metadata (`attn_metadata`) is set using a context manager in\n    the model runner's `execute_model` method. It is accessed via forward\n    context using\n    `vllm.forward_context.get_forward_context().attn_metadata`.\n    \"\"\"\n    if self.calculate_kv_scales:\n        torch.ops.vllm.maybe_calc_kv_scales(query, key, value, self.layer_name)\n    output_dtype = query.dtype\n    if self.query_quant is not None:\n        # quantizing with a simple torch operation enables\n        # torch.compile to fuse this into previous ops\n        # which reduces overheads during decoding.\n        # Otherwise queries are quantized using custom ops\n        # which causes decoding overheads\n        assert self.kv_cache_dtype in {\"fp8\", \"fp8_e4m3\"}\n\n        # check if query quantization is supported\n        if self.impl.supports_quant_query_input:\n            query, _ = self.query_quant(query, self._q_scale)\n\n    if self.use_output:\n        output_shape = output_shape if output_shape is not None else query.shape\n        output = torch.empty(output_shape, dtype=output_dtype, device=query.device)\n        hidden_size = output_shape[-1]\n        # Reshape the query, key, and value tensors.\n        # NOTE(woosuk): We do this outside the custom op to minimize the\n        # CPU overheads from the non-CUDA-graph regions.\n        query = query.view(-1, self.num_heads, self.head_size)\n        output = output.view(-1, self.num_heads, self.head_size)\n        if key is not None:\n            key = key.view(-1, self.num_kv_heads, self.head_size)\n        if value is not None:\n            value = value.view(-1, self.num_kv_heads, self.head_size)\n        if self.use_direct_call:\n            forward_context: ForwardContext = get_forward_context()\n            attn_metadata = forward_context.attn_metadata\n            if isinstance(attn_metadata, dict):\n                attn_metadata = attn_metadata[self.layer_name]\n            self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n            self.impl.forward(\n                self, query, key, value, self_kv_cache, attn_metadata, output=output\n            )\n        else:\n            torch.ops.vllm.unified_attention_with_output(\n                query, key, value, output, self.layer_name\n            )\n        return output.view(-1, hidden_size)\n    else:\n        if self.use_direct_call:\n            forward_context = get_forward_context()\n            attn_metadata = forward_context.attn_metadata\n            if isinstance(attn_metadata, dict):\n                attn_metadata = attn_metadata[self.layer_name]\n            self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n            return self.impl.forward(\n                self, query, key, value, self_kv_cache, attn_metadata\n            )\n        else:\n            return torch.ops.vllm.unified_attention(\n                query, key, value, self.layer_name\n            )",
      "language": "python"
    },
    {
      "code": "get_attn_backend() -> type[AttentionBackend]",
      "language": "php"
    },
    {
      "code": "get_attn_backend() -> type[AttentionBackend]",
      "language": "php"
    },
    {
      "code": "def get_attn_backend(self) -> type[AttentionBackend]:\n    return self.attn_backend",
      "language": "python"
    },
    {
      "code": "def get_attn_backend(self) -> type[AttentionBackend]:\n    return self.attn_backend",
      "language": "python"
    },
    {
      "code": "get_kv_cache_spec(vllm_config: VllmConfig) -> KVCacheSpec",
      "language": "php"
    },
    {
      "code": "get_kv_cache_spec(vllm_config: VllmConfig) -> KVCacheSpec",
      "language": "php"
    },
    {
      "code": "384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406",
      "language": "unknown"
    },
    {
      "code": "def get_kv_cache_spec(self, vllm_config: VllmConfig) -> KVCacheSpec:\n    # Block size may get updated after model loading, refresh it\n    block_size = vllm_config.cache_config.block_size\n    # Should not be called for enc-dec or encoder-only attention.\n    assert self.attn_type == AttentionType.DECODER\n    if self.sliding_window is not None:\n        assert not vllm_config.model_config.use_mla, (\n            \"MLA is not supported for slidingwindow\"\n        )\n        return SlidingWindowSpec(\n            block_size=block_size,\n            num_kv_heads=self.num_kv_heads,\n            head_size=self.head_size,\n            dtype=self.kv_cache_torch_dtype,\n            sliding_window=self.sliding_window,\n        )\n    else:\n        return FullAttentionSpec(\n            block_size=block_size,\n            num_kv_heads=self.num_kv_heads,\n            head_size=self.head_size,\n            dtype=self.kv_cache_torch_dtype,\n        )",
      "language": "python"
    },
    {
      "code": "def get_kv_cache_spec(self, vllm_config: VllmConfig) -> KVCacheSpec:\n    # Block size may get updated after model loading, refresh it\n    block_size = vllm_config.cache_config.block_size\n    # Should not be called for enc-dec or encoder-only attention.\n    assert self.attn_type == AttentionType.DECODER\n    if self.sliding_window is not None:\n        assert not vllm_config.model_config.use_mla, (\n            \"MLA is not supported for slidingwindow\"\n        )\n        return SlidingWindowSpec(\n            block_size=block_size,\n            num_kv_heads=self.num_kv_heads,\n            head_size=self.head_size,\n            dtype=self.kv_cache_torch_dtype,\n            sliding_window=self.sliding_window,\n        )\n    else:\n        return FullAttentionSpec(\n            block_size=block_size,\n            num_kv_heads=self.num_kv_heads,\n            head_size=self.head_size,\n            dtype=self.kv_cache_torch_dtype,\n        )",
      "language": "python"
    },
    {
      "code": "process_weights_after_loading(act_dtype: dtype)",
      "language": "unknown"
    },
    {
      "code": "process_weights_after_loading(act_dtype: dtype)",
      "language": "unknown"
    },
    {
      "code": "def process_weights_after_loading(self, act_dtype: torch.dtype):\n    self.impl.process_weights_after_loading(act_dtype)",
      "language": "python"
    },
    {
      "code": "def process_weights_after_loading(self, act_dtype: torch.dtype):\n    self.impl.process_weights_after_loading(act_dtype)",
      "language": "python"
    },
    {
      "code": "409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624",
      "language": "unknown"
    },
    {
      "code": "class MLAAttention(nn.Module, AttentionLayerBase):\n    \"\"\"Multi-Head Latent Attention layer.\n\n    This class takes query, and compressed key/value tensors as input.\n    The class does the following:\n\n    1. Store the input key and value tensors in the KV cache.\n    2. Perform (multi-head/multi-query/grouped-query) attention.\n    3. Return the output tensor.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_heads: int,\n        scale: float,\n        qk_nope_head_dim: int,\n        qk_rope_head_dim: int,\n        v_head_dim: int,\n        q_lora_rank: int | None,\n        kv_lora_rank: int,\n        kv_b_proj: ColumnParallelLinear,\n        cache_config: CacheConfig | None = None,\n        quant_config: QuantizationConfig | None = None,\n        prefix: str = \"\",\n        use_sparse: bool = False,\n        indexer: object | None = None,\n        **extra_impl_args,\n    ):\n        super().__init__()\n        self.num_heads = num_heads\n        self.scale = scale\n        self.qk_nope_head_dim = qk_nope_head_dim\n        self.qk_rope_head_dim = qk_rope_head_dim\n        self.v_head_dim = v_head_dim\n        self.q_lora_rank = q_lora_rank\n        self.kv_lora_rank = kv_lora_rank\n        self.head_size = kv_lora_rank + qk_rope_head_dim\n        self.layer_name = prefix\n\n        if cache_config is not None:\n            kv_cache_dtype = cache_config.cache_dtype\n            block_size = cache_config.block_size\n            calculate_kv_scales = cache_config.calculate_kv_scales\n        else:\n            kv_cache_dtype = \"auto\"\n            block_size = 16\n            calculate_kv_scales = False\n\n        # Initialize KV cache quantization attributes\n        _init_kv_cache_quant(\n            self, quant_config, prefix, kv_cache_dtype, calculate_kv_scales\n        )\n\n        dtype = torch.get_default_dtype()\n        self.attn_backend = get_attn_backend(\n            self.head_size,\n            dtype,\n            kv_cache_dtype,\n            block_size,\n            use_mla=True,\n            use_sparse=use_sparse,\n        )\n\n        if (\n            cache_config is not None\n            and cache_config.enable_prefix_caching\n            and vllm_is_batch_invariant()\n            and (\n                self.attn_backend.get_name() == \"TRITON_MLA\"\n                or self.attn_backend.get_name() == \"FLASHINFER\"\n            )\n        ):\n            logger.warning_once(\n                \"Disabling prefix caching for TRITON_MLA / FLASHINFER \"\n                \"with batch invariance, as it is not yet supported.\",\n                scope=\"local\",\n            )\n            cache_config.enable_prefix_caching = False\n\n        impl_cls = cast(type[MLAAttentionImpl], self.attn_backend.get_impl_cls())\n        self.impl = impl_cls(\n            num_heads=self.num_heads,\n            head_size=self.head_size,\n            scale=self.scale,\n            num_kv_heads=1,\n            alibi_slopes=None,\n            sliding_window=None,\n            kv_cache_dtype=self.kv_cache_dtype,\n            logits_soft_cap=None,\n            attn_type=AttentionType.DECODER,\n            kv_sharing_target_layer_name=None,\n            # MLA Args\n            q_lora_rank=self.q_lora_rank,\n            kv_lora_rank=self.kv_lora_rank,\n            qk_nope_head_dim=self.qk_nope_head_dim,\n            qk_rope_head_dim=self.qk_rope_head_dim,\n            qk_head_dim=self.qk_nope_head_dim + self.qk_rope_head_dim,\n            v_head_dim=self.v_head_dim,\n            kv_b_proj=kv_b_proj,\n            indexer=indexer,\n            **extra_impl_args,\n        )\n\n        self.use_direct_call = not current_platform.opaque_attention_op()\n\n        compilation_config = get_current_vllm_config().compilation_config\n        if prefix in compilation_config.static_forward_context:\n            raise ValueError(f\"Duplicate layer name: {prefix}\")\n        compilation_config.static_forward_context[prefix] = self\n\n        self.kv_cache = [\n            torch.tensor([])\n            for _ in range(\n                get_current_vllm_config().parallel_config.pipeline_parallel_size\n            )\n        ]\n\n        self.use_sparse = use_sparse\n\n        # Initialize q/k/v range constants.\n        self.q_range = torch.tensor(envs.Q_SCALE_CONSTANT, dtype=torch.float32)\n        self.k_range = torch.tensor(envs.K_SCALE_CONSTANT, dtype=torch.float32)\n        self.v_range = torch.tensor(envs.V_SCALE_CONSTANT, dtype=torch.float32)\n\n    def forward(\n        self,\n        q: torch.Tensor,\n        kv_c_normed: torch.Tensor,\n        k_pe: torch.Tensor,\n        output_shape: torch.Size | None = None,\n    ) -> torch.Tensor:\n        if self.calculate_kv_scales:\n            torch.ops.vllm.maybe_calc_kv_scales(q, kv_c_normed, k_pe, self.layer_name)\n\n        if self.use_direct_call:\n            forward_context: ForwardContext = get_forward_context()\n            attn_metadata = forward_context.attn_metadata\n            if isinstance(attn_metadata, dict):\n                attn_metadata = attn_metadata[self.layer_name]\n            self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n\n            if self.attn_backend.accept_output_buffer:\n                output = torch.empty(output_shape, dtype=q.dtype, device=q.device)\n                self.impl.forward(\n                    self,\n                    q,\n                    kv_c_normed,\n                    k_pe,\n                    self_kv_cache,\n                    attn_metadata,\n                    output=output,\n                )\n                return output\n            else:\n                return self.impl.forward(\n                    self, q, kv_c_normed, k_pe, self_kv_cache, attn_metadata\n                )\n        else:\n            if self.attn_backend.accept_output_buffer:\n                output = torch.empty(output_shape, dtype=q.dtype, device=q.device)\n                torch.ops.vllm.unified_mla_attention_with_output(\n                    q,\n                    kv_c_normed,\n                    k_pe,\n                    output,\n                    self.layer_name,\n                )\n                return output\n            else:\n                return torch.ops.vllm.unified_mla_attention(\n                    q,\n                    kv_c_normed,\n                    k_pe,\n                    self.layer_name,\n                )\n\n    def process_weights_after_loading(self, act_dtype: torch.dtype):\n        if hasattr(self.impl, \"process_weights_after_loading\"):\n            self.impl.process_weights_after_loading(act_dtype)\n\n    def calc_kv_scales(\n        self, q: torch.Tensor, kv_c_normed: torch.Tensor, k_pe: torch.Tensor\n    ) -> None:\n        \"\"\"Optional scale calculation for MLA inputs.\n\n        Mirrors Attention.calc_kv_scales. Not all MLA backends require this\n        \"\"\"\n        # Use safe defaults if ranges are not present\n        q_range = getattr(self, \"q_range\", torch.tensor(1.0))\n        k_range = getattr(self, \"k_range\", torch.tensor(1.0))\n        v_range = getattr(self, \"v_range\", torch.tensor(1.0))\n\n        self._q_scale.copy_(torch.abs(q).max() / q_range)\n        # kv_c_normed is the compressed KV representation; use it for k/v\n        kv_abs_max = torch.abs(kv_c_normed).max()\n        self._k_scale.copy_(kv_abs_max / k_range)\n        self._v_scale.copy_(kv_abs_max / v_range)\n        self._q_scale_float = self._q_scale.item()\n        self._k_scale_float = self._k_scale.item()\n        self._v_scale_float = self._v_scale.item()\n        self.calculate_kv_scales = False\n\n    def get_attn_backend(self) -> type[AttentionBackend]:\n        return self.attn_backend\n\n    def get_kv_cache_spec(self, vllm_config: VllmConfig) -> KVCacheSpec:\n        kv_cache_dtype = kv_cache_dtype_str_to_dtype(\n            self.kv_cache_dtype, vllm_config.model_config\n        )\n        return MLAAttentionSpec(\n            block_size=vllm_config.cache_config.block_size,\n            num_kv_heads=1,\n            head_size=self.head_size,\n            dtype=kv_cache_dtype,\n            cache_dtype_str=vllm_config.cache_config.cache_dtype,\n        )",
      "language": "python"
    },
    {
      "code": "class MLAAttention(nn.Module, AttentionLayerBase):\n    \"\"\"Multi-Head Latent Attention layer.\n\n    This class takes query, and compressed key/value tensors as input.\n    The class does the following:\n\n    1. Store the input key and value tensors in the KV cache.\n    2. Perform (multi-head/multi-query/grouped-query) attention.\n    3. Return the output tensor.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_heads: int,\n        scale: float,\n        qk_nope_head_dim: int,\n        qk_rope_head_dim: int,\n        v_head_dim: int,\n        q_lora_rank: int | None,\n        kv_lora_rank: int,\n        kv_b_proj: ColumnParallelLinear,\n        cache_config: CacheConfig | None = None,\n        quant_config: QuantizationConfig | None = None,\n        prefix: str = \"\",\n        use_sparse: bool = False,\n        indexer: object | None = None,\n        **extra_impl_args,\n    ):\n        super().__init__()\n        self.num_heads = num_heads\n        self.scale = scale\n        self.qk_nope_head_dim = qk_nope_head_dim\n        self.qk_rope_head_dim = qk_rope_head_dim\n        self.v_head_dim = v_head_dim\n        self.q_lora_rank = q_lora_rank\n        self.kv_lora_rank = kv_lora_rank\n        self.head_size = kv_lora_rank + qk_rope_head_dim\n        self.layer_name = prefix\n\n        if cache_config is not None:\n            kv_cache_dtype = cache_config.cache_dtype\n            block_size = cache_config.block_size\n            calculate_kv_scales = cache_config.calculate_kv_scales\n        else:\n            kv_cache_dtype = \"auto\"\n            block_size = 16\n            calculate_kv_scales = False\n\n        # Initialize KV cache quantization attributes\n        _init_kv_cache_quant(\n            self, quant_config, prefix, kv_cache_dtype, calculate_kv_scales\n        )\n\n        dtype = torch.get_default_dtype()\n        self.attn_backend = get_attn_backend(\n            self.head_size,\n            dtype,\n            kv_cache_dtype,\n            block_size,\n            use_mla=True,\n            use_sparse=use_sparse,\n        )\n\n        if (\n            cache_config is not None\n            and cache_config.enable_prefix_caching\n            and vllm_is_batch_invariant()\n            and (\n                self.attn_backend.get_name() == \"TRITON_MLA\"\n                or self.attn_backend.get_name() == \"FLASHINFER\"\n            )\n        ):\n            logger.warning_once(\n                \"Disabling prefix caching for TRITON_MLA / FLASHINFER \"\n                \"with batch invariance, as it is not yet supported.\",\n                scope=\"local\",\n            )\n            cache_config.enable_prefix_caching = False\n\n        impl_cls = cast(type[MLAAttentionImpl], self.attn_backend.get_impl_cls())\n        self.impl = impl_cls(\n            num_heads=self.num_heads,\n            head_size=self.head_size,\n            scale=self.scale,\n            num_kv_heads=1,\n            alibi_slopes=None,\n            sliding_window=None,\n            kv_cache_dtype=self.kv_cache_dtype,\n            logits_soft_cap=None,\n            attn_type=AttentionType.DECODER,\n            kv_sharing_target_layer_name=None,\n            # MLA Args\n            q_lora_rank=self.q_lora_rank,\n            kv_lora_rank=self.kv_lora_rank,\n            qk_nope_head_dim=self.qk_nope_head_dim,\n            qk_rope_head_dim=self.qk_rope_head_dim,\n            qk_head_dim=self.qk_nope_head_dim + self.qk_rope_head_dim,\n            v_head_dim=self.v_head_dim,\n            kv_b_proj=kv_b_proj,\n            indexer=indexer,\n            **extra_impl_args,\n        )\n\n        self.use_direct_call = not current_platform.opaque_attention_op()\n\n        compilation_config = get_current_vllm_config().compilation_config\n        if prefix in compilation_config.static_forward_context:\n            raise ValueError(f\"Duplicate layer name: {prefix}\")\n        compilation_config.static_forward_context[prefix] = self\n\n        self.kv_cache = [\n            torch.tensor([])\n            for _ in range(\n                get_current_vllm_config().parallel_config.pipeline_parallel_size\n            )\n        ]\n\n        self.use_sparse = use_sparse\n\n        # Initialize q/k/v range constants.\n        self.q_range = torch.tensor(envs.Q_SCALE_CONSTANT, dtype=torch.float32)\n        self.k_range = torch.tensor(envs.K_SCALE_CONSTANT, dtype=torch.float32)\n        self.v_range = torch.tensor(envs.V_SCALE_CONSTANT, dtype=torch.float32)\n\n    def forward(\n        self,\n        q: torch.Tensor,\n        kv_c_normed: torch.Tensor,\n        k_pe: torch.Tensor,\n        output_shape: torch.Size | None = None,\n    ) -> torch.Tensor:\n        if self.calculate_kv_scales:\n            torch.ops.vllm.maybe_calc_kv_scales(q, kv_c_normed, k_pe, self.layer_name)\n\n        if self.use_direct_call:\n            forward_context: ForwardContext = get_forward_context()\n            attn_metadata = forward_context.attn_metadata\n            if isinstance(attn_metadata, dict):\n                attn_metadata = attn_metadata[self.layer_name]\n            self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n\n            if self.attn_backend.accept_output_buffer:\n                output = torch.empty(output_shape, dtype=q.dtype, device=q.device)\n                self.impl.forward(\n                    self,\n                    q,\n                    kv_c_normed,\n                    k_pe,\n                    self_kv_cache,\n                    attn_metadata,\n                    output=output,\n                )\n                return output\n            else:\n                return self.impl.forward(\n                    self, q, kv_c_normed, k_pe, self_kv_cache, attn_metadata\n                )\n        else:\n            if self.attn_backend.accept_output_buffer:\n                output = torch.empty(output_shape, dtype=q.dtype, device=q.device)\n                torch.ops.vllm.unified_mla_attention_with_output(\n                    q,\n                    kv_c_normed,\n                    k_pe,\n                    output,\n                    self.layer_name,\n                )\n                return output\n            else:\n                return torch.ops.vllm.unified_mla_attention(\n                    q,\n                    kv_c_normed,\n                    k_pe,\n                    self.layer_name,\n                )\n\n    def process_weights_after_loading(self, act_dtype: torch.dtype):\n        if hasattr(self.impl, \"process_weights_after_loading\"):\n            self.impl.process_weights_after_loading(act_dtype)\n\n    def calc_kv_scales(\n        self, q: torch.Tensor, kv_c_normed: torch.Tensor, k_pe: torch.Tensor\n    ) -> None:\n        \"\"\"Optional scale calculation for MLA inputs.\n\n        Mirrors Attention.calc_kv_scales. Not all MLA backends require this\n        \"\"\"\n        # Use safe defaults if ranges are not present\n        q_range = getattr(self, \"q_range\", torch.tensor(1.0))\n        k_range = getattr(self, \"k_range\", torch.tensor(1.0))\n        v_range = getattr(self, \"v_range\", torch.tensor(1.0))\n\n        self._q_scale.copy_(torch.abs(q).max() / q_range)\n        # kv_c_normed is the compressed KV representation; use it for k/v\n        kv_abs_max = torch.abs(kv_c_normed).max()\n        self._k_scale.copy_(kv_abs_max / k_range)\n        self._v_scale.copy_(kv_abs_max / v_range)\n        self._q_scale_float = self._q_scale.item()\n        self._k_scale_float = self._k_scale.item()\n        self._v_scale_float = self._v_scale.item()\n        self.calculate_kv_scales = False\n\n    def get_attn_backend(self) -> type[AttentionBackend]:\n        return self.attn_backend\n\n    def get_kv_cache_spec(self, vllm_config: VllmConfig) -> KVCacheSpec:\n        kv_cache_dtype = kv_cache_dtype_str_to_dtype(\n            self.kv_cache_dtype, vllm_config.model_config\n        )\n        return MLAAttentionSpec(\n            block_size=vllm_config.cache_config.block_size,\n            num_kv_heads=1,\n            head_size=self.head_size,\n            dtype=kv_cache_dtype,\n            cache_dtype_str=vllm_config.cache_config.cache_dtype,\n        )",
      "language": "python"
    },
    {
      "code": "attn_backend = get_attn_backend(\n    head_size,\n    dtype,\n    kv_cache_dtype,\n    block_size,\n    use_mla=True,\n    use_sparse=use_sparse,\n)",
      "language": "unknown"
    },
    {
      "code": "attn_backend = get_attn_backend(\n    head_size,\n    dtype,\n    kv_cache_dtype,\n    block_size,\n    use_mla=True,\n    use_sparse=use_sparse,\n)",
      "language": "unknown"
    },
    {
      "code": "head_size = kv_lora_rank + qk_rope_head_dim",
      "language": "unknown"
    },
    {
      "code": "head_size = kv_lora_rank + qk_rope_head_dim",
      "language": "unknown"
    },
    {
      "code": "impl = impl_cls(\n    num_heads=num_heads,\n    head_size=head_size,\n    scale=scale,\n    num_kv_heads=1,\n    alibi_slopes=None,\n    sliding_window=None,\n    kv_cache_dtype=kv_cache_dtype,\n    logits_soft_cap=None,\n    attn_type=DECODER,\n    kv_sharing_target_layer_name=None,\n    q_lora_rank=q_lora_rank,\n    kv_lora_rank=kv_lora_rank,\n    qk_nope_head_dim=qk_nope_head_dim,\n    qk_rope_head_dim=qk_rope_head_dim,\n    qk_head_dim=qk_nope_head_dim + qk_rope_head_dim,\n    v_head_dim=v_head_dim,\n    kv_b_proj=kv_b_proj,\n    indexer=indexer,\n    **extra_impl_args,\n)",
      "language": "rust"
    },
    {
      "code": "impl = impl_cls(\n    num_heads=num_heads,\n    head_size=head_size,\n    scale=scale,\n    num_kv_heads=1,\n    alibi_slopes=None,\n    sliding_window=None,\n    kv_cache_dtype=kv_cache_dtype,\n    logits_soft_cap=None,\n    attn_type=DECODER,\n    kv_sharing_target_layer_name=None,\n    q_lora_rank=q_lora_rank,\n    kv_lora_rank=kv_lora_rank,\n    qk_nope_head_dim=qk_nope_head_dim,\n    qk_rope_head_dim=qk_rope_head_dim,\n    qk_head_dim=qk_nope_head_dim + qk_rope_head_dim,\n    v_head_dim=v_head_dim,\n    kv_b_proj=kv_b_proj,\n    indexer=indexer,\n    **extra_impl_args,\n)",
      "language": "rust"
    },
    {
      "code": "k_range = tensor(K_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "k_range = tensor(K_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "kv_cache = [\n    (tensor([])) for _ in (range(pipeline_parallel_size))\n]",
      "language": "bash"
    },
    {
      "code": "kv_cache = [\n    (tensor([])) for _ in (range(pipeline_parallel_size))\n]",
      "language": "bash"
    },
    {
      "code": "kv_lora_rank = kv_lora_rank",
      "language": "unknown"
    },
    {
      "code": "kv_lora_rank = kv_lora_rank",
      "language": "unknown"
    },
    {
      "code": "layer_name = prefix",
      "language": "unknown"
    },
    {
      "code": "layer_name = prefix",
      "language": "unknown"
    },
    {
      "code": "num_heads = num_heads",
      "language": "unknown"
    },
    {
      "code": "num_heads = num_heads",
      "language": "unknown"
    },
    {
      "code": "q_lora_rank = q_lora_rank",
      "language": "unknown"
    },
    {
      "code": "q_lora_rank = q_lora_rank",
      "language": "unknown"
    },
    {
      "code": "q_range = tensor(Q_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "q_range = tensor(Q_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "qk_nope_head_dim = qk_nope_head_dim",
      "language": "unknown"
    },
    {
      "code": "qk_nope_head_dim = qk_nope_head_dim",
      "language": "unknown"
    },
    {
      "code": "qk_rope_head_dim = qk_rope_head_dim",
      "language": "unknown"
    },
    {
      "code": "qk_rope_head_dim = qk_rope_head_dim",
      "language": "unknown"
    },
    {
      "code": "scale = scale",
      "language": "unknown"
    },
    {
      "code": "scale = scale",
      "language": "unknown"
    },
    {
      "code": "use_direct_call = not opaque_attention_op()",
      "language": "unknown"
    },
    {
      "code": "use_direct_call = not opaque_attention_op()",
      "language": "unknown"
    },
    {
      "code": "use_sparse = use_sparse",
      "language": "unknown"
    },
    {
      "code": "use_sparse = use_sparse",
      "language": "unknown"
    },
    {
      "code": "v_head_dim = v_head_dim",
      "language": "unknown"
    },
    {
      "code": "v_head_dim = v_head_dim",
      "language": "unknown"
    },
    {
      "code": "v_range = tensor(V_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "v_range = tensor(V_SCALE_CONSTANT, dtype=float32)",
      "language": "unknown"
    },
    {
      "code": "__init__(\n    num_heads: int,\n    scale: float,\n    qk_nope_head_dim: int,\n    qk_rope_head_dim: int,\n    v_head_dim: int,\n    q_lora_rank: int | None,\n    kv_lora_rank: int,\n    kv_b_proj: ColumnParallelLinear,\n    cache_config: CacheConfig | None = None,\n    quant_config: QuantizationConfig | None = None,\n    prefix: str = \"\",\n    use_sparse: bool = False,\n    indexer: object | None = None,\n    **extra_impl_args,\n)",
      "language": "typescript"
    },
    {
      "code": "__init__(\n    num_heads: int,\n    scale: float,\n    qk_nope_head_dim: int,\n    qk_rope_head_dim: int,\n    v_head_dim: int,\n    q_lora_rank: int | None,\n    kv_lora_rank: int,\n    kv_b_proj: ColumnParallelLinear,\n    cache_config: CacheConfig | None = None,\n    quant_config: QuantizationConfig | None = None,\n    prefix: str = \"\",\n    use_sparse: bool = False,\n    indexer: object | None = None,\n    **extra_impl_args,\n)",
      "language": "typescript"
    },
    {
      "code": "420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531",
      "language": "unknown"
    },
    {
      "code": "def __init__(\n    self,\n    num_heads: int,\n    scale: float,\n    qk_nope_head_dim: int,\n    qk_rope_head_dim: int,\n    v_head_dim: int,\n    q_lora_rank: int | None,\n    kv_lora_rank: int,\n    kv_b_proj: ColumnParallelLinear,\n    cache_config: CacheConfig | None = None,\n    quant_config: QuantizationConfig | None = None,\n    prefix: str = \"\",\n    use_sparse: bool = False,\n    indexer: object | None = None,\n    **extra_impl_args,\n):\n    super().__init__()\n    self.num_heads = num_heads\n    self.scale = scale\n    self.qk_nope_head_dim = qk_nope_head_dim\n    self.qk_rope_head_dim = qk_rope_head_dim\n    self.v_head_dim = v_head_dim\n    self.q_lora_rank = q_lora_rank\n    self.kv_lora_rank = kv_lora_rank\n    self.head_size = kv_lora_rank + qk_rope_head_dim\n    self.layer_name = prefix\n\n    if cache_config is not None:\n        kv_cache_dtype = cache_config.cache_dtype\n        block_size = cache_config.block_size\n        calculate_kv_scales = cache_config.calculate_kv_scales\n    else:\n        kv_cache_dtype = \"auto\"\n        block_size = 16\n        calculate_kv_scales = False\n\n    # Initialize KV cache quantization attributes\n    _init_kv_cache_quant(\n        self, quant_config, prefix, kv_cache_dtype, calculate_kv_scales\n    )\n\n    dtype = torch.get_default_dtype()\n    self.attn_backend = get_attn_backend(\n        self.head_size,\n        dtype,\n        kv_cache_dtype,\n        block_size,\n        use_mla=True,\n        use_sparse=use_sparse,\n    )\n\n    if (\n        cache_config is not None\n        and cache_config.enable_prefix_caching\n        and vllm_is_batch_invariant()\n        and (\n            self.attn_backend.get_name() == \"TRITON_MLA\"\n            or self.attn_backend.get_name() == \"FLASHINFER\"\n        )\n    ):\n        logger.warning_once(\n            \"Disabling prefix caching for TRITON_MLA / FLASHINFER \"\n            \"with batch invariance, as it is not yet supported.\",\n            scope=\"local\",\n        )\n        cache_config.enable_prefix_caching = False\n\n    impl_cls = cast(type[MLAAttentionImpl], self.attn_backend.get_impl_cls())\n    self.impl = impl_cls(\n        num_heads=self.num_heads,\n        head_size=self.head_size,\n        scale=self.scale,\n        num_kv_heads=1,\n        alibi_slopes=None,\n        sliding_window=None,\n        kv_cache_dtype=self.kv_cache_dtype,\n        logits_soft_cap=None,\n        attn_type=AttentionType.DECODER,\n        kv_sharing_target_layer_name=None,\n        # MLA Args\n        q_lora_rank=self.q_lora_rank,\n        kv_lora_rank=self.kv_lora_rank,\n        qk_nope_head_dim=self.qk_nope_head_dim,\n        qk_rope_head_dim=self.qk_rope_head_dim,\n        qk_head_dim=self.qk_nope_head_dim + self.qk_rope_head_dim,\n        v_head_dim=self.v_head_dim,\n        kv_b_proj=kv_b_proj,\n        indexer=indexer,\n        **extra_impl_args,\n    )\n\n    self.use_direct_call = not current_platform.opaque_attention_op()\n\n    compilation_config = get_current_vllm_config().compilation_config\n    if prefix in compilation_config.static_forward_context:\n        raise ValueError(f\"Duplicate layer name: {prefix}\")\n    compilation_config.static_forward_context[prefix] = self\n\n    self.kv_cache = [\n        torch.tensor([])\n        for _ in range(\n            get_current_vllm_config().parallel_config.pipeline_parallel_size\n        )\n    ]\n\n    self.use_sparse = use_sparse\n\n    # Initialize q/k/v range constants.\n    self.q_range = torch.tensor(envs.Q_SCALE_CONSTANT, dtype=torch.float32)\n    self.k_range = torch.tensor(envs.K_SCALE_CONSTANT, dtype=torch.float32)\n    self.v_range = torch.tensor(envs.V_SCALE_CONSTANT, dtype=torch.float32)",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    num_heads: int,\n    scale: float,\n    qk_nope_head_dim: int,\n    qk_rope_head_dim: int,\n    v_head_dim: int,\n    q_lora_rank: int | None,\n    kv_lora_rank: int,\n    kv_b_proj: ColumnParallelLinear,\n    cache_config: CacheConfig | None = None,\n    quant_config: QuantizationConfig | None = None,\n    prefix: str = \"\",\n    use_sparse: bool = False,\n    indexer: object | None = None,\n    **extra_impl_args,\n):\n    super().__init__()\n    self.num_heads = num_heads\n    self.scale = scale\n    self.qk_nope_head_dim = qk_nope_head_dim\n    self.qk_rope_head_dim = qk_rope_head_dim\n    self.v_head_dim = v_head_dim\n    self.q_lora_rank = q_lora_rank\n    self.kv_lora_rank = kv_lora_rank\n    self.head_size = kv_lora_rank + qk_rope_head_dim\n    self.layer_name = prefix\n\n    if cache_config is not None:\n        kv_cache_dtype = cache_config.cache_dtype\n        block_size = cache_config.block_size\n        calculate_kv_scales = cache_config.calculate_kv_scales\n    else:\n        kv_cache_dtype = \"auto\"\n        block_size = 16\n        calculate_kv_scales = False\n\n    # Initialize KV cache quantization attributes\n    _init_kv_cache_quant(\n        self, quant_config, prefix, kv_cache_dtype, calculate_kv_scales\n    )\n\n    dtype = torch.get_default_dtype()\n    self.attn_backend = get_attn_backend(\n        self.head_size,\n        dtype,\n        kv_cache_dtype,\n        block_size,\n        use_mla=True,\n        use_sparse=use_sparse,\n    )\n\n    if (\n        cache_config is not None\n        and cache_config.enable_prefix_caching\n        and vllm_is_batch_invariant()\n        and (\n            self.attn_backend.get_name() == \"TRITON_MLA\"\n            or self.attn_backend.get_name() == \"FLASHINFER\"\n        )\n    ):\n        logger.warning_once(\n            \"Disabling prefix caching for TRITON_MLA / FLASHINFER \"\n            \"with batch invariance, as it is not yet supported.\",\n            scope=\"local\",\n        )\n        cache_config.enable_prefix_caching = False\n\n    impl_cls = cast(type[MLAAttentionImpl], self.attn_backend.get_impl_cls())\n    self.impl = impl_cls(\n        num_heads=self.num_heads,\n        head_size=self.head_size,\n        scale=self.scale,\n        num_kv_heads=1,\n        alibi_slopes=None,\n        sliding_window=None,\n        kv_cache_dtype=self.kv_cache_dtype,\n        logits_soft_cap=None,\n        attn_type=AttentionType.DECODER,\n        kv_sharing_target_layer_name=None,\n        # MLA Args\n        q_lora_rank=self.q_lora_rank,\n        kv_lora_rank=self.kv_lora_rank,\n        qk_nope_head_dim=self.qk_nope_head_dim,\n        qk_rope_head_dim=self.qk_rope_head_dim,\n        qk_head_dim=self.qk_nope_head_dim + self.qk_rope_head_dim,\n        v_head_dim=self.v_head_dim,\n        kv_b_proj=kv_b_proj,\n        indexer=indexer,\n        **extra_impl_args,\n    )\n\n    self.use_direct_call = not current_platform.opaque_attention_op()\n\n    compilation_config = get_current_vllm_config().compilation_config\n    if prefix in compilation_config.static_forward_context:\n        raise ValueError(f\"Duplicate layer name: {prefix}\")\n    compilation_config.static_forward_context[prefix] = self\n\n    self.kv_cache = [\n        torch.tensor([])\n        for _ in range(\n            get_current_vllm_config().parallel_config.pipeline_parallel_size\n        )\n    ]\n\n    self.use_sparse = use_sparse\n\n    # Initialize q/k/v range constants.\n    self.q_range = torch.tensor(envs.Q_SCALE_CONSTANT, dtype=torch.float32)\n    self.k_range = torch.tensor(envs.K_SCALE_CONSTANT, dtype=torch.float32)\n    self.v_range = torch.tensor(envs.V_SCALE_CONSTANT, dtype=torch.float32)",
      "language": "python"
    },
    {
      "code": "calc_kv_scales(\n    q: Tensor, kv_c_normed: Tensor, k_pe: Tensor\n) -> None",
      "language": "rust"
    },
    {
      "code": "calc_kv_scales(\n    q: Tensor, kv_c_normed: Tensor, k_pe: Tensor\n) -> None",
      "language": "rust"
    },
    {
      "code": "589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609",
      "language": "unknown"
    },
    {
      "code": "def calc_kv_scales(\n    self, q: torch.Tensor, kv_c_normed: torch.Tensor, k_pe: torch.Tensor\n) -> None:\n    \"\"\"Optional scale calculation for MLA inputs.\n\n    Mirrors Attention.calc_kv_scales. Not all MLA backends require this\n    \"\"\"\n    # Use safe defaults if ranges are not present\n    q_range = getattr(self, \"q_range\", torch.tensor(1.0))\n    k_range = getattr(self, \"k_range\", torch.tensor(1.0))\n    v_range = getattr(self, \"v_range\", torch.tensor(1.0))\n\n    self._q_scale.copy_(torch.abs(q).max() / q_range)\n    # kv_c_normed is the compressed KV representation; use it for k/v\n    kv_abs_max = torch.abs(kv_c_normed).max()\n    self._k_scale.copy_(kv_abs_max / k_range)\n    self._v_scale.copy_(kv_abs_max / v_range)\n    self._q_scale_float = self._q_scale.item()\n    self._k_scale_float = self._k_scale.item()\n    self._v_scale_float = self._v_scale.item()\n    self.calculate_kv_scales = False",
      "language": "python"
    },
    {
      "code": "def calc_kv_scales(\n    self, q: torch.Tensor, kv_c_normed: torch.Tensor, k_pe: torch.Tensor\n) -> None:\n    \"\"\"Optional scale calculation for MLA inputs.\n\n    Mirrors Attention.calc_kv_scales. Not all MLA backends require this\n    \"\"\"\n    # Use safe defaults if ranges are not present\n    q_range = getattr(self, \"q_range\", torch.tensor(1.0))\n    k_range = getattr(self, \"k_range\", torch.tensor(1.0))\n    v_range = getattr(self, \"v_range\", torch.tensor(1.0))\n\n    self._q_scale.copy_(torch.abs(q).max() / q_range)\n    # kv_c_normed is the compressed KV representation; use it for k/v\n    kv_abs_max = torch.abs(kv_c_normed).max()\n    self._k_scale.copy_(kv_abs_max / k_range)\n    self._v_scale.copy_(kv_abs_max / v_range)\n    self._q_scale_float = self._q_scale.item()\n    self._k_scale_float = self._k_scale.item()\n    self._v_scale_float = self._v_scale.item()\n    self.calculate_kv_scales = False",
      "language": "python"
    },
    {
      "code": "forward(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    output_shape: Size | None = None,\n) -> Tensor",
      "language": "rust"
    },
    {
      "code": "forward(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    output_shape: Size | None = None,\n) -> Tensor",
      "language": "rust"
    },
    {
      "code": "533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583",
      "language": "unknown"
    },
    {
      "code": "def forward(\n    self,\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    output_shape: torch.Size | None = None,\n) -> torch.Tensor:\n    if self.calculate_kv_scales:\n        torch.ops.vllm.maybe_calc_kv_scales(q, kv_c_normed, k_pe, self.layer_name)\n\n    if self.use_direct_call:\n        forward_context: ForwardContext = get_forward_context()\n        attn_metadata = forward_context.attn_metadata\n        if isinstance(attn_metadata, dict):\n            attn_metadata = attn_metadata[self.layer_name]\n        self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n\n        if self.attn_backend.accept_output_buffer:\n            output = torch.empty(output_shape, dtype=q.dtype, device=q.device)\n            self.impl.forward(\n                self,\n                q,\n                kv_c_normed,\n                k_pe,\n                self_kv_cache,\n                attn_metadata,\n                output=output,\n            )\n            return output\n        else:\n            return self.impl.forward(\n                self, q, kv_c_normed, k_pe, self_kv_cache, attn_metadata\n            )\n    else:\n        if self.attn_backend.accept_output_buffer:\n            output = torch.empty(output_shape, dtype=q.dtype, device=q.device)\n            torch.ops.vllm.unified_mla_attention_with_output(\n                q,\n                kv_c_normed,\n                k_pe,\n                output,\n                self.layer_name,\n            )\n            return output\n        else:\n            return torch.ops.vllm.unified_mla_attention(\n                q,\n                kv_c_normed,\n                k_pe,\n                self.layer_name,\n            )",
      "language": "python"
    },
    {
      "code": "def forward(\n    self,\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    output_shape: torch.Size | None = None,\n) -> torch.Tensor:\n    if self.calculate_kv_scales:\n        torch.ops.vllm.maybe_calc_kv_scales(q, kv_c_normed, k_pe, self.layer_name)\n\n    if self.use_direct_call:\n        forward_context: ForwardContext = get_forward_context()\n        attn_metadata = forward_context.attn_metadata\n        if isinstance(attn_metadata, dict):\n            attn_metadata = attn_metadata[self.layer_name]\n        self_kv_cache = self.kv_cache[forward_context.virtual_engine]\n\n        if self.attn_backend.accept_output_buffer:\n            output = torch.empty(output_shape, dtype=q.dtype, device=q.device)\n            self.impl.forward(\n                self,\n                q,\n                kv_c_normed,\n                k_pe,\n                self_kv_cache,\n                attn_metadata,\n                output=output,\n            )\n            return output\n        else:\n            return self.impl.forward(\n                self, q, kv_c_normed, k_pe, self_kv_cache, attn_metadata\n            )\n    else:\n        if self.attn_backend.accept_output_buffer:\n            output = torch.empty(output_shape, dtype=q.dtype, device=q.device)\n            torch.ops.vllm.unified_mla_attention_with_output(\n                q,\n                kv_c_normed,\n                k_pe,\n                output,\n                self.layer_name,\n            )\n            return output\n        else:\n            return torch.ops.vllm.unified_mla_attention(\n                q,\n                kv_c_normed,\n                k_pe,\n                self.layer_name,\n            )",
      "language": "python"
    },
    {
      "code": "get_attn_backend() -> type[AttentionBackend]",
      "language": "php"
    },
    {
      "code": "get_attn_backend() -> type[AttentionBackend]",
      "language": "php"
    },
    {
      "code": "def get_attn_backend(self) -> type[AttentionBackend]:\n    return self.attn_backend",
      "language": "python"
    },
    {
      "code": "def get_attn_backend(self) -> type[AttentionBackend]:\n    return self.attn_backend",
      "language": "python"
    },
    {
      "code": "get_kv_cache_spec(vllm_config: VllmConfig) -> KVCacheSpec",
      "language": "php"
    },
    {
      "code": "get_kv_cache_spec(vllm_config: VllmConfig) -> KVCacheSpec",
      "language": "php"
    },
    {
      "code": "614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624",
      "language": "unknown"
    },
    {
      "code": "def get_kv_cache_spec(self, vllm_config: VllmConfig) -> KVCacheSpec:\n    kv_cache_dtype = kv_cache_dtype_str_to_dtype(\n        self.kv_cache_dtype, vllm_config.model_config\n    )\n    return MLAAttentionSpec(\n        block_size=vllm_config.cache_config.block_size,\n        num_kv_heads=1,\n        head_size=self.head_size,\n        dtype=kv_cache_dtype,\n        cache_dtype_str=vllm_config.cache_config.cache_dtype,\n    )",
      "language": "python"
    },
    {
      "code": "def get_kv_cache_spec(self, vllm_config: VllmConfig) -> KVCacheSpec:\n    kv_cache_dtype = kv_cache_dtype_str_to_dtype(\n        self.kv_cache_dtype, vllm_config.model_config\n    )\n    return MLAAttentionSpec(\n        block_size=vllm_config.cache_config.block_size,\n        num_kv_heads=1,\n        head_size=self.head_size,\n        dtype=kv_cache_dtype,\n        cache_dtype_str=vllm_config.cache_config.cache_dtype,\n    )",
      "language": "python"
    },
    {
      "code": "process_weights_after_loading(act_dtype: dtype)",
      "language": "unknown"
    },
    {
      "code": "process_weights_after_loading(act_dtype: dtype)",
      "language": "unknown"
    },
    {
      "code": "585\n586\n587",
      "language": "unknown"
    },
    {
      "code": "def process_weights_after_loading(self, act_dtype: torch.dtype):\n    if hasattr(self.impl, \"process_weights_after_loading\"):\n        self.impl.process_weights_after_loading(act_dtype)",
      "language": "python"
    },
    {
      "code": "def process_weights_after_loading(self, act_dtype: torch.dtype):\n    if hasattr(self.impl, \"process_weights_after_loading\"):\n        self.impl.process_weights_after_loading(act_dtype)",
      "language": "python"
    },
    {
      "code": "_init_kv_cache_quant(\n    layer: Module,\n    quant_config: QuantizationConfig | None,\n    prefix: str,\n    kv_cache_dtype: str,\n    calculate_kv_scales: bool,\n) -> None",
      "language": "rust"
    },
    {
      "code": "_init_kv_cache_quant(\n    layer: Module,\n    quant_config: QuantizationConfig | None,\n    prefix: str,\n    kv_cache_dtype: str,\n    calculate_kv_scales: bool,\n) -> None",
      "language": "rust"
    },
    {
      "code": "49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109",
      "language": "unknown"
    },
    {
      "code": "def _init_kv_cache_quant(\n    layer: nn.Module,\n    quant_config: QuantizationConfig | None,\n    prefix: str,\n    kv_cache_dtype: str,\n    calculate_kv_scales: bool,\n) -> None:\n    \"\"\"Initializes KV cache scaling factors and quantization method.\n\n    This helper function sets up the KV cache quantization attributes that are\n    shared between Attention and MLAAttention layers. It initializes scale\n    tensors for query, key, value, and probability, and configures the\n    quantization method if applicable.\n\n    Args:\n        layer: The attention layer instance to initialize.\n        quant_config: Optional quantization configuration.\n        prefix: Layer name prefix for quantization method lookup.\n        kv_cache_dtype: The KV cache data type string.\n        calculate_kv_scales: Whether to calculate KV scales dynamically.\n    \"\"\"\n    # The default k/v_scale is set to 1.0. This is ignored\n    # when kv-cache is not fp8, and should be used with\n    # kv-cache in fp8_e5m2. For kv-cache in fp8_e4m3, we\n    # expect the pre-quantized k/v_scale to be loaded along\n    # with the model weights.\n    layer.kv_cache_dtype = kv_cache_dtype\n    layer.calculate_kv_scales = calculate_kv_scales\n    layer._k_scale = torch.tensor(1.0, dtype=torch.float32)\n    layer._v_scale = torch.tensor(1.0, dtype=torch.float32)\n    layer._q_scale = torch.tensor(1.0, dtype=torch.float32)\n    layer._prob_scale = torch.tensor(1.0, dtype=torch.float32)\n\n    # We also keep q/k/v_scale on host (cpu) memory for attention\n    # backends that require the scales to be on host instead of on device.\n    # e.g. Flashinfer\n    layer._q_scale_float = 1.0\n    layer._k_scale_float = 1.0\n    layer._v_scale_float = 1.0\n\n    # The output scale on host memory. This should be the input scale of\n    # the quant op after this attention layer.\n    layer._o_scale_float = None\n\n    quant_method = (\n        quant_config.get_quant_method(layer, prefix=prefix) if quant_config else None\n    )\n    if quant_method is not None and not isinstance(\n        quant_method, UnquantizedLinearMethod\n    ):\n        assert isinstance(quant_method, BaseKVCacheMethod)\n        # TODO (mgoin): kv cache dtype should be specified in the FP8\n        # checkpoint config and become the \"auto\" behavior\n        if kv_cache_dtype == \"fp8_e5m2\":\n            raise ValueError(\"fp8_e5m2 kv-cache is not supported with fp8 checkpoints.\")\n        # If quantization is enabled, we make \"k_scale\" and \"v_scale\"\n        # parameters so that it can be loaded from the model checkpoint.\n        # The k/v_scale will then be converted back to native float32\n        # values after weight loading.\n        layer.quant_method = quant_method\n        layer.quant_method.create_weights(layer)",
      "language": "json"
    },
    {
      "code": "def _init_kv_cache_quant(\n    layer: nn.Module,\n    quant_config: QuantizationConfig | None,\n    prefix: str,\n    kv_cache_dtype: str,\n    calculate_kv_scales: bool,\n) -> None:\n    \"\"\"Initializes KV cache scaling factors and quantization method.\n\n    This helper function sets up the KV cache quantization attributes that are\n    shared between Attention and MLAAttention layers. It initializes scale\n    tensors for query, key, value, and probability, and configures the\n    quantization method if applicable.\n\n    Args:\n        layer: The attention layer instance to initialize.\n        quant_config: Optional quantization configuration.\n        prefix: Layer name prefix for quantization method lookup.\n        kv_cache_dtype: The KV cache data type string.\n        calculate_kv_scales: Whether to calculate KV scales dynamically.\n    \"\"\"\n    # The default k/v_scale is set to 1.0. This is ignored\n    # when kv-cache is not fp8, and should be used with\n    # kv-cache in fp8_e5m2. For kv-cache in fp8_e4m3, we\n    # expect the pre-quantized k/v_scale to be loaded along\n    # with the model weights.\n    layer.kv_cache_dtype = kv_cache_dtype\n    layer.calculate_kv_scales = calculate_kv_scales\n    layer._k_scale = torch.tensor(1.0, dtype=torch.float32)\n    layer._v_scale = torch.tensor(1.0, dtype=torch.float32)\n    layer._q_scale = torch.tensor(1.0, dtype=torch.float32)\n    layer._prob_scale = torch.tensor(1.0, dtype=torch.float32)\n\n    # We also keep q/k/v_scale on host (cpu) memory for attention\n    # backends that require the scales to be on host instead of on device.\n    # e.g. Flashinfer\n    layer._q_scale_float = 1.0\n    layer._k_scale_float = 1.0\n    layer._v_scale_float = 1.0\n\n    # The output scale on host memory. This should be the input scale of\n    # the quant op after this attention layer.\n    layer._o_scale_float = None\n\n    quant_method = (\n        quant_config.get_quant_method(layer, prefix=prefix) if quant_config else None\n    )\n    if quant_method is not None and not isinstance(\n        quant_method, UnquantizedLinearMethod\n    ):\n        assert isinstance(quant_method, BaseKVCacheMethod)\n        # TODO (mgoin): kv cache dtype should be specified in the FP8\n        # checkpoint config and become the \"auto\" behavior\n        if kv_cache_dtype == \"fp8_e5m2\":\n            raise ValueError(\"fp8_e5m2 kv-cache is not supported with fp8 checkpoints.\")\n        # If quantization is enabled, we make \"k_scale\" and \"v_scale\"\n        # parameters so that it can be loaded from the model checkpoint.\n        # The k/v_scale will then be converted back to native float32\n        # values after weight loading.\n        layer.quant_method = quant_method\n        layer.quant_method.create_weights(layer)",
      "language": "json"
    },
    {
      "code": "get_attention_context(\n    layer_name: str,\n) -> tuple[\n    dict | object | None, Attention | MLAAttention, Tensor\n]",
      "language": "rust"
    },
    {
      "code": "get_attention_context(\n    layer_name: str,\n) -> tuple[\n    dict | object | None, Attention | MLAAttention, Tensor\n]",
      "language": "rust"
    },
    {
      "code": "661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688",
      "language": "unknown"
    },
    {
      "code": "def get_attention_context(\n    layer_name: str,\n) -> tuple[dict | object | None, Attention | MLAAttention, torch.Tensor]:\n    \"\"\"Extract attention context for a given layer.\n\n    This helper function extracts the attention metadata, attention layer\n    instance, and KV cache tensor for a specific layer.\n\n    Args:\n        layer_name: The name/identifier of the attention layer.\n\n    Returns:\n        A tuple containing:\n        - attn_metadata: Attention metadata for this specific layer, or None if\n            no metadata available\n        - attn_layer: The attention layer instance (Attention or MLAAttention)\n        - kv_cache: The KV cache tensor for current virtual engine\n\n        Note: attn_metadata may be None, but attn_layer and kv_cache are always\n        extracted from the forward context.\n    \"\"\"\n    forward_context: ForwardContext = get_forward_context()\n    attn_metadata = forward_context.attn_metadata\n    if isinstance(attn_metadata, dict):\n        attn_metadata = attn_metadata[layer_name]\n    attn_layer: Attention | MLAAttention = forward_context.no_compile_layers[layer_name]\n    kv_cache = attn_layer.kv_cache[forward_context.virtual_engine]\n    return attn_metadata, attn_layer, kv_cache",
      "language": "python"
    },
    {
      "code": "def get_attention_context(\n    layer_name: str,\n) -> tuple[dict | object | None, Attention | MLAAttention, torch.Tensor]:\n    \"\"\"Extract attention context for a given layer.\n\n    This helper function extracts the attention metadata, attention layer\n    instance, and KV cache tensor for a specific layer.\n\n    Args:\n        layer_name: The name/identifier of the attention layer.\n\n    Returns:\n        A tuple containing:\n        - attn_metadata: Attention metadata for this specific layer, or None if\n            no metadata available\n        - attn_layer: The attention layer instance (Attention or MLAAttention)\n        - kv_cache: The KV cache tensor for current virtual engine\n\n        Note: attn_metadata may be None, but attn_layer and kv_cache are always\n        extracted from the forward context.\n    \"\"\"\n    forward_context: ForwardContext = get_forward_context()\n    attn_metadata = forward_context.attn_metadata\n    if isinstance(attn_metadata, dict):\n        attn_metadata = attn_metadata[layer_name]\n    attn_layer: Attention | MLAAttention = forward_context.no_compile_layers[layer_name]\n    kv_cache = attn_layer.kv_cache[forward_context.virtual_engine]\n    return attn_metadata, attn_layer, kv_cache",
      "language": "python"
    },
    {
      "code": "maybe_calc_kv_scales(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    layer_name: str,\n) -> None",
      "language": "rust"
    },
    {
      "code": "maybe_calc_kv_scales(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    layer_name: str,\n) -> None",
      "language": "rust"
    },
    {
      "code": "627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641",
      "language": "unknown"
    },
    {
      "code": "def maybe_calc_kv_scales(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    layer_name: str,\n) -> None:\n    forward_context: ForwardContext = get_forward_context()\n    self = forward_context.no_compile_layers[layer_name]\n\n    # Only calculate if the layer's calculate_kv_scales flag is True\n    # This flag gets set to False after the first forward pass\n    if not self.calculate_kv_scales:\n        return\n\n    self.calc_kv_scales(query, key, value)",
      "language": "python"
    },
    {
      "code": "def maybe_calc_kv_scales(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    layer_name: str,\n) -> None:\n    forward_context: ForwardContext = get_forward_context()\n    self = forward_context.no_compile_layers[layer_name]\n\n    # Only calculate if the layer's calculate_kv_scales flag is True\n    # This flag gets set to False after the first forward pass\n    if not self.calculate_kv_scales:\n        return\n\n    self.calc_kv_scales(query, key, value)",
      "language": "python"
    },
    {
      "code": "maybe_calc_kv_scales_fake(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    layer_name: str,\n) -> None",
      "language": "rust"
    },
    {
      "code": "maybe_calc_kv_scales_fake(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    layer_name: str,\n) -> None",
      "language": "rust"
    },
    {
      "code": "644\n645\n646\n647\n648\n649\n650",
      "language": "unknown"
    },
    {
      "code": "def maybe_calc_kv_scales_fake(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    layer_name: str,\n) -> None:\n    return",
      "language": "python"
    },
    {
      "code": "def maybe_calc_kv_scales_fake(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    layer_name: str,\n) -> None:\n    return",
      "language": "python"
    },
    {
      "code": "unified_attention(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    layer_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "unified_attention(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    layer_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701",
      "language": "unknown"
    },
    {
      "code": "@maybe_transfer_kv_layer\ndef unified_attention(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    layer_name: str,\n) -> torch.Tensor:\n    attn_metadata, self, kv_cache = get_attention_context(layer_name)\n    output = self.impl.forward(self, query, key, value, kv_cache, attn_metadata)\n\n    return output",
      "language": "python"
    },
    {
      "code": "@maybe_transfer_kv_layer\ndef unified_attention(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    layer_name: str,\n) -> torch.Tensor:\n    attn_metadata, self, kv_cache = get_attention_context(layer_name)\n    output = self.impl.forward(self, query, key, value, kv_cache, attn_metadata)\n\n    return output",
      "language": "python"
    },
    {
      "code": "unified_attention_fake(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    layer_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "unified_attention_fake(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    layer_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "704\n705\n706\n707\n708\n709\n710",
      "language": "unknown"
    },
    {
      "code": "def unified_attention_fake(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    layer_name: str,\n) -> torch.Tensor:\n    return torch.empty_like(query).contiguous()",
      "language": "python"
    },
    {
      "code": "def unified_attention_fake(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    layer_name: str,\n) -> torch.Tensor:\n    return torch.empty_like(query).contiguous()",
      "language": "python"
    },
    {
      "code": "unified_attention_with_output(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    output: Tensor,\n    layer_name: str,\n    output_scale: Tensor | None = None,\n    output_block_scale: Tensor | None = None,\n) -> None",
      "language": "rust"
    },
    {
      "code": "unified_attention_with_output(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    output: Tensor,\n    layer_name: str,\n    output_scale: Tensor | None = None,\n    output_block_scale: Tensor | None = None,\n) -> None",
      "language": "rust"
    },
    {
      "code": "720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741",
      "language": "unknown"
    },
    {
      "code": "@maybe_transfer_kv_layer\ndef unified_attention_with_output(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    output: torch.Tensor,\n    layer_name: str,\n    output_scale: torch.Tensor | None = None,\n    output_block_scale: torch.Tensor | None = None,\n) -> None:\n    attn_metadata, self, kv_cache = get_attention_context(layer_name)\n    self.impl.forward(\n        self,\n        query,\n        key,\n        value,\n        kv_cache,\n        attn_metadata,\n        output=output,\n        output_scale=output_scale,\n        output_block_scale=output_block_scale,\n    )",
      "language": "python"
    },
    {
      "code": "@maybe_transfer_kv_layer\ndef unified_attention_with_output(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    output: torch.Tensor,\n    layer_name: str,\n    output_scale: torch.Tensor | None = None,\n    output_block_scale: torch.Tensor | None = None,\n) -> None:\n    attn_metadata, self, kv_cache = get_attention_context(layer_name)\n    self.impl.forward(\n        self,\n        query,\n        key,\n        value,\n        kv_cache,\n        attn_metadata,\n        output=output,\n        output_scale=output_scale,\n        output_block_scale=output_block_scale,\n    )",
      "language": "python"
    },
    {
      "code": "unified_attention_with_output_fake(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    output: Tensor,\n    layer_name: str,\n    output_scale: Tensor | None = None,\n    output_block_scale: Tensor | None = None,\n) -> None",
      "language": "rust"
    },
    {
      "code": "unified_attention_with_output_fake(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    output: Tensor,\n    layer_name: str,\n    output_scale: Tensor | None = None,\n    output_block_scale: Tensor | None = None,\n) -> None",
      "language": "rust"
    },
    {
      "code": "744\n745\n746\n747\n748\n749\n750\n751\n752\n753",
      "language": "unknown"
    },
    {
      "code": "def unified_attention_with_output_fake(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    output: torch.Tensor,\n    layer_name: str,\n    output_scale: torch.Tensor | None = None,\n    output_block_scale: torch.Tensor | None = None,\n) -> None:\n    return",
      "language": "python"
    },
    {
      "code": "def unified_attention_with_output_fake(\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    output: torch.Tensor,\n    layer_name: str,\n    output_scale: torch.Tensor | None = None,\n    output_block_scale: torch.Tensor | None = None,\n) -> None:\n    return",
      "language": "python"
    },
    {
      "code": "unified_mla_attention(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    layer_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "unified_mla_attention(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    layer_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774",
      "language": "unknown"
    },
    {
      "code": "@maybe_transfer_kv_layer\ndef unified_mla_attention(\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    layer_name: str,\n) -> torch.Tensor:\n    attn_metadata, self, kv_cache = get_attention_context(layer_name)\n    output = self.impl.forward(self, q, kv_c_normed, k_pe, kv_cache, attn_metadata)\n\n    return output",
      "language": "python"
    },
    {
      "code": "@maybe_transfer_kv_layer\ndef unified_mla_attention(\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    layer_name: str,\n) -> torch.Tensor:\n    attn_metadata, self, kv_cache = get_attention_context(layer_name)\n    output = self.impl.forward(self, q, kv_c_normed, k_pe, kv_cache, attn_metadata)\n\n    return output",
      "language": "python"
    },
    {
      "code": "unified_mla_attention_fake(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    layer_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "unified_mla_attention_fake(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    layer_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "777\n778\n779\n780\n781\n782\n783",
      "language": "unknown"
    },
    {
      "code": "def unified_mla_attention_fake(\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    layer_name: str,\n) -> torch.Tensor:\n    return torch.empty_like(q).contiguous()",
      "language": "python"
    },
    {
      "code": "def unified_mla_attention_fake(\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    layer_name: str,\n) -> torch.Tensor:\n    return torch.empty_like(q).contiguous()",
      "language": "python"
    },
    {
      "code": "unified_mla_attention_with_output(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    output: Tensor,\n    layer_name: str,\n    output_scale: Tensor | None = None,\n    output_block_scale: Tensor | None = None,\n) -> None",
      "language": "rust"
    },
    {
      "code": "unified_mla_attention_with_output(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    output: Tensor,\n    layer_name: str,\n    output_scale: Tensor | None = None,\n    output_block_scale: Tensor | None = None,\n) -> None",
      "language": "rust"
    },
    {
      "code": "795\n796\n797\n798\n799\n800\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816",
      "language": "unknown"
    },
    {
      "code": "@maybe_transfer_kv_layer\ndef unified_mla_attention_with_output(\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    output: torch.Tensor,\n    layer_name: str,\n    output_scale: torch.Tensor | None = None,\n    output_block_scale: torch.Tensor | None = None,\n) -> None:\n    attn_metadata, self, kv_cache = get_attention_context(layer_name)\n    self.impl.forward(\n        self,\n        q,\n        kv_c_normed,\n        k_pe,\n        kv_cache,\n        attn_metadata,\n        output=output,\n        output_scale=output_scale,\n        output_block_scale=output_block_scale,\n    )",
      "language": "python"
    },
    {
      "code": "@maybe_transfer_kv_layer\ndef unified_mla_attention_with_output(\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    output: torch.Tensor,\n    layer_name: str,\n    output_scale: torch.Tensor | None = None,\n    output_block_scale: torch.Tensor | None = None,\n) -> None:\n    attn_metadata, self, kv_cache = get_attention_context(layer_name)\n    self.impl.forward(\n        self,\n        q,\n        kv_c_normed,\n        k_pe,\n        kv_cache,\n        attn_metadata,\n        output=output,\n        output_scale=output_scale,\n        output_block_scale=output_block_scale,\n    )",
      "language": "python"
    },
    {
      "code": "unified_mla_attention_with_output_fake(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    output: Tensor,\n    layer_name: str,\n    output_scale: Tensor | None = None,\n    output_block_scale: Tensor | None = None,\n) -> None",
      "language": "rust"
    },
    {
      "code": "unified_mla_attention_with_output_fake(\n    q: Tensor,\n    kv_c_normed: Tensor,\n    k_pe: Tensor,\n    output: Tensor,\n    layer_name: str,\n    output_scale: Tensor | None = None,\n    output_block_scale: Tensor | None = None,\n) -> None",
      "language": "rust"
    },
    {
      "code": "819\n820\n821\n822\n823\n824\n825\n826\n827\n828",
      "language": "unknown"
    },
    {
      "code": "def unified_mla_attention_with_output_fake(\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    output: torch.Tensor,\n    layer_name: str,\n    output_scale: torch.Tensor | None = None,\n    output_block_scale: torch.Tensor | None = None,\n) -> None:\n    return",
      "language": "python"
    },
    {
      "code": "def unified_mla_attention_with_output_fake(\n    q: torch.Tensor,\n    kv_c_normed: torch.Tensor,\n    k_pe: torch.Tensor,\n    output: torch.Tensor,\n    layer_name: str,\n    output_scale: torch.Tensor | None = None,\n    output_block_scale: torch.Tensor | None = None,\n) -> None:\n    return",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layer/",
    "https://docs.vllm.ai/en/latest/",
    "https://docs.vllm.ai/en/latest/usage/",
    "https://docs.vllm.ai/en/latest/contributing/",
    "https://docs.vllm.ai/en/latest/benchmarking/",
    "https://docs.vllm.ai/en/latest/api/",
    "https://docs.vllm.ai/en/latest/cli/",
    "https://docs.vllm.ai/en/latest/community/contact_us/",
    "https://docs.vllm.ai/en/latest/getting_started/quickstart/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/gpu/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/cpu/",
    "https://docs.vllm.ai/en/latest/examples/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/async_llm_streaming/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/audio_language/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/automatic_prefix_caching/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/basic/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/batch_llm_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/chat_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/context_extension/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/data_parallel/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/disaggregated-prefill-v1/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/disaggregated_prefill/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/encoder_decoder_multimodal/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/kv_load_failure_recovery/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/llm_engine_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/llm_engine_reset_kv/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/load_sharded_state/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/logits_processor/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/lora_with_quantization_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/metrics/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/mistral-small/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/mlpspeculator/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/multilora_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/openai_batch/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/prefix_caching/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/prompt_embed_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen2_5_omni/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen3_omni/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen_1m/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/reproducibility/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_colocate/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_online_quant/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_utils/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/save_sharded_state/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/simple_profiling/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/skip_loading_weights_in_engine_init/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/spec_decode/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/structured_outputs/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/torchrun_dp_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/torchrun_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/vision_language/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/vision_language_multi_image/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/api_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/chart-helm/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/dashboards/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_encoder/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_prefill/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_serving/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_serving_p2p_nccl_xpyd/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/elastic_ep/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/gradio_openai_chatbot_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/gradio_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/kv_events_subscriber/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/multi-node-serving/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/multi_instance_data_parallel/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_for_multimodal/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_required/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_xlam/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_xlam_streaming/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_tool_calls_with_reasoning/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_with_reasoning/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_with_reasoning_streaming/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_completion_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client_with_mcp_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_transcription_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_translation_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/opentelemetry/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/prometheus_grafana/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/prompt_embed_inference_with_openai_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/ray_serve_deepseek/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/retrieval_augmented_generation_with_langchain/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/retrieval_augmented_generation_with_llamaindex/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/run_cluster/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/sagemaker-entrypoint/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/streamlit_openai_chatbot_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/structured_outputs/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/token_generation_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/utils/",
    "https://docs.vllm.ai/en/latest/examples/others/lmcache/",
    "https://docs.vllm.ai/en/latest/examples/others/logging_configuration/",
    "https://docs.vllm.ai/en/latest/examples/others/tensorize_vllm_model/",
    "https://docs.vllm.ai/en/latest/examples/pooling/classify/",
    "https://docs.vllm.ai/en/latest/examples/pooling/embed/",
    "https://docs.vllm.ai/en/latest/examples/pooling/plugin/",
    "https://docs.vllm.ai/en/latest/examples/pooling/pooling/",
    "https://docs.vllm.ai/en/latest/examples/pooling/score/",
    "https://docs.vllm.ai/en/latest/examples/pooling/token_classify/",
    "https://docs.vllm.ai/en/latest/examples/pooling/token_embed/",
    "https://docs.vllm.ai/en/latest/usage/v1_guide/",
    "https://docs.vllm.ai/en/latest/usage/faq/",
    "https://docs.vllm.ai/en/latest/usage/metrics/",
    "https://docs.vllm.ai/en/latest/usage/reproducibility/",
    "https://docs.vllm.ai/en/latest/usage/security/",
    "https://docs.vllm.ai/en/latest/usage/troubleshooting/",
    "https://docs.vllm.ai/en/latest/usage/usage_stats/",
    "https://docs.vllm.ai/en/latest/serving/offline_inference/",
    "https://docs.vllm.ai/en/latest/serving/openai_compatible_server/",
    "https://docs.vllm.ai/en/latest/serving/context_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/data_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/distributed_troubleshooting/",
    "https://docs.vllm.ai/en/latest/serving/expert_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/parallelism_scaling/",
    "https://docs.vllm.ai/en/latest/serving/integrations/langchain/",
    "https://docs.vllm.ai/en/latest/serving/integrations/llamaindex/",
    "https://docs.vllm.ai/en/latest/deployment/docker/",
    "https://docs.vllm.ai/en/latest/deployment/k8s/",
    "https://docs.vllm.ai/en/latest/deployment/nginx/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/anyscale/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/anything-llm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/autogen/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/bentoml/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/cerebrium/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/chatbox/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/dify/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/dstack/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/haystack/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/helm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/hf_inference_endpoints/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/litellm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/lobe-chat/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/lws/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/modal/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/open-webui/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/retrieval_augmented_generation/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/skypilot/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/streamlit/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/triton/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kaito/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kserve/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kthena/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kubeai/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kuberay/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llamastack/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llm-d/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llmaz/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/production-stack/",
    "https://docs.vllm.ai/en/latest/training/rlhf/",
    "https://docs.vllm.ai/en/latest/training/trl/",
    "https://docs.vllm.ai/en/latest/configuration/",
    "https://docs.vllm.ai/en/latest/configuration/conserving_memory/",
    "https://docs.vllm.ai/en/latest/configuration/engine_args/",
    "https://docs.vllm.ai/en/latest/configuration/env_vars/",
    "https://docs.vllm.ai/en/latest/configuration/model_resolution/",
    "https://docs.vllm.ai/en/latest/configuration/optimization/",
    "https://docs.vllm.ai/en/latest/configuration/serve_args/",
    "https://docs.vllm.ai/en/latest/models/supported_models/",
    "https://docs.vllm.ai/en/latest/models/generative_models/",
    "https://docs.vllm.ai/en/latest/models/pooling_models/",
    "https://docs.vllm.ai/en/latest/models/extensions/fastsafetensor/",
    "https://docs.vllm.ai/en/latest/models/extensions/runai_model_streamer/",
    "https://docs.vllm.ai/en/latest/models/extensions/tensorizer/",
    "https://docs.vllm.ai/en/latest/models/hardware_supported_models/cpu/",
    "https://docs.vllm.ai/en/latest/models/hardware_supported_models/xpu/",
    "https://docs.vllm.ai/en/latest/features/",
    "https://docs.vllm.ai/en/latest/features/automatic_prefix_caching/",
    "https://docs.vllm.ai/en/latest/features/batch_invariance/",
    "https://docs.vllm.ai/en/latest/features/custom_arguments/",
    "https://docs.vllm.ai/en/latest/features/custom_logitsprocs/",
    "https://docs.vllm.ai/en/latest/features/disagg_encoder/",
    "https://docs.vllm.ai/en/latest/features/disagg_prefill/",
    "https://docs.vllm.ai/en/latest/features/interleaved_thinking/",
    "https://docs.vllm.ai/en/latest/features/lora/",
    "https://docs.vllm.ai/en/latest/features/mooncake_connector_usage/",
    "https://docs.vllm.ai/en/latest/features/multimodal_inputs/",
    "https://docs.vllm.ai/en/latest/features/nixl_connector_usage/",
    "https://docs.vllm.ai/en/latest/features/prompt_embeds/",
    "https://docs.vllm.ai/en/latest/features/reasoning_outputs/",
    "https://docs.vllm.ai/en/latest/features/sleep_mode/",
    "https://docs.vllm.ai/en/latest/features/spec_decode/",
    "https://docs.vllm.ai/en/latest/features/structured_outputs/",
    "https://docs.vllm.ai/en/latest/features/tool_calling/",
    "https://docs.vllm.ai/en/latest/features/quantization/",
    "https://docs.vllm.ai/en/latest/features/quantization/auto_awq/",
    "https://docs.vllm.ai/en/latest/features/quantization/auto_round/",
    "https://docs.vllm.ai/en/latest/features/quantization/bitblas/",
    "https://docs.vllm.ai/en/latest/features/quantization/bnb/",
    "https://docs.vllm.ai/en/latest/features/quantization/fp8/",
    "https://docs.vllm.ai/en/latest/features/quantization/gguf/",
    "https://docs.vllm.ai/en/latest/features/quantization/gptqmodel/",
    "https://docs.vllm.ai/en/latest/features/quantization/inc/",
    "https://docs.vllm.ai/en/latest/features/quantization/int4/",
    "https://docs.vllm.ai/en/latest/features/quantization/int8/",
    "https://docs.vllm.ai/en/latest/features/quantization/modelopt/",
    "https://docs.vllm.ai/en/latest/features/quantization/quantized_kvcache/",
    "https://docs.vllm.ai/en/latest/features/quantization/quark/",
    "https://docs.vllm.ai/en/latest/features/quantization/torchao/",
    "https://docs.vllm.ai/en/latest/contributing/deprecation_policy/",
    "https://docs.vllm.ai/en/latest/contributing/dockerfile/dockerfile/",
    "https://docs.vllm.ai/en/latest/contributing/incremental_build/",
    "https://docs.vllm.ai/en/latest/contributing/profiling/",
    "https://docs.vllm.ai/en/latest/contributing/vulnerability_management/",
    "https://docs.vllm.ai/en/latest/contributing/model/",
    "https://docs.vllm.ai/en/latest/contributing/model/basic/",
    "https://docs.vllm.ai/en/latest/contributing/model/registration/",
    "https://docs.vllm.ai/en/latest/contributing/model/tests/",
    "https://docs.vllm.ai/en/latest/contributing/model/multimodal/",
    "https://docs.vllm.ai/en/latest/contributing/model/transcription/",
    "https://docs.vllm.ai/en/latest/contributing/ci/failures/",
    "https://docs.vllm.ai/en/latest/contributing/ci/nightly_builds/",
    "https://docs.vllm.ai/en/latest/contributing/ci/update_pytorch_version/",
    "https://docs.vllm.ai/en/latest/design/io_processor_plugins/",
    "https://docs.vllm.ai/en/latest/design/lora_resolver_plugins/",
    "https://docs.vllm.ai/en/latest/design/plugin_system/",
    "https://docs.vllm.ai/en/latest/design/arch_overview/",
    "https://docs.vllm.ai/en/latest/design/cuda_graphs/",
    "https://docs.vllm.ai/en/latest/design/dbo/",
    "https://docs.vllm.ai/en/latest/design/debug_vllm_compile/",
    "https://docs.vllm.ai/en/latest/design/fused_moe_modular_kernel/",
    "https://docs.vllm.ai/en/latest/design/huggingface_integration/",
    "https://docs.vllm.ai/en/latest/design/hybrid_kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/design/logits_processors/",
    "https://docs.vllm.ai/en/latest/design/metrics/",
    "https://docs.vllm.ai/en/latest/design/mm_processing/",
    "https://docs.vllm.ai/en/latest/design/moe_kernel_features/",
    "https://docs.vllm.ai/en/latest/design/multiprocessing/",
    "https://docs.vllm.ai/en/latest/design/optimization_levels/",
    "https://docs.vllm.ai/en/latest/design/p2p_nccl_connector/",
    "https://docs.vllm.ai/en/latest/design/paged_attention/",
    "https://docs.vllm.ai/en/latest/design/prefix_caching/",
    "https://docs.vllm.ai/en/latest/design/torch_compile/",
    "https://docs.vllm.ai/en/latest/benchmarking/cli/",
    "https://docs.vllm.ai/en/latest/benchmarking/sweeps/",
    "https://docs.vllm.ai/en/latest/benchmarking/dashboard/",
    "https://docs.vllm.ai/en/latest/api/vllm/",
    "https://docs.vllm.ai/en/latest/api/vllm/beam_search/",
    "https://docs.vllm.ai/en/latest/api/vllm/collect_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/connections/",
    "https://docs.vllm.ai/en/latest/api/vllm/env_override/",
    "https://docs.vllm.ai/en/latest/api/vllm/envs/",
    "https://docs.vllm.ai/en/latest/api/vllm/forward_context/",
    "https://docs.vllm.ai/en/latest/api/vllm/logger/",
    "https://docs.vllm.ai/en/latest/api/vllm/logits_process/",
    "https://docs.vllm.ai/en/latest/api/vllm/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/pooling_params/",
    "https://docs.vllm.ai/en/latest/api/vllm/sampling_params/",
    "https://docs.vllm.ai/en/latest/api/vllm/scalar_type/",
    "https://docs.vllm.ai/en/latest/api/vllm/scripts/",
    "https://docs.vllm.ai/en/latest/api/vllm/sequence/",
    "https://docs.vllm.ai/en/latest/api/vllm/tasks/",
    "https://docs.vllm.ai/en/latest/api/vllm/tracing/",
    "https://docs.vllm.ai/en/latest/api/vllm/version/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/image/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/video/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/selector/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/chunked_local_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/cross_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/encoder_only_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/mm_encoder_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/chunked_prefill_paged_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/flashmla/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/merge_attn_states/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/paged_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/pallas_kv_cache_update/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/prefix_prefill/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/rocm_aiter_mla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_decode_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_merge_attn_states/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_reshape_and_cache_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_unified_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/vit_attn_wrappers/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/fa_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/kv_sharing_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/kv_transfer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/datasets/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/latency/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/startup/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/throughput/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/endpoint_request_func/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/ready_checker/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/cli/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/param_sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/plot/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/plot_pareto/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/serve_sla/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/server/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/sla_sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/activation_quant_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/base_static_graph/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/caching/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/collective_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/compiler_interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/counter/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/cuda_graph/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/decorators/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fix_functionalization/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fusion_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fx_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/inductor_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/matcher_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/monitor/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/noop_elimination/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/partition_rules/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/pass_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/piecewise_backend/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/post_cleanup/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/qk_norm_rope_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/rocm_aiter_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/sequence_parallelism/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/torch25_custom_graph_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/vllm_inductor_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/compilation/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/device/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/ec_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/kv_events/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/kv_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/load/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/model/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/observability/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/parallel/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/pooler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/profiler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/speculative/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/speech_to_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/structured_outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/vllm/",
    "https://docs.vllm.ai/en/latest/api/vllm/device_allocator/",
    "https://docs.vllm.ai/en/latest/api/vllm/device_allocator/cumem/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/communication_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_events/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/parallel_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/tpu_distributed_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/all2all/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/all_reduce_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/base_device_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cuda_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cuda_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/custom_all_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/mnnvl_compat/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl_allocator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/quick_all_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/ray_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/shm_broadcast/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/shm_object_storage/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/symm_mem/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/tpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/xpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_transfer_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/example_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/async_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/eplb_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/rebalance_execute/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/default/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_transfer_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/decode_bench_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/example_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_mp_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/mooncake_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/multi_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/nixl_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/offloading_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/multi_process_adapter/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/vllm_v1_adapter/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/tensor_memory_pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/arg_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/async_llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/api_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/chat_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/constants/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/context/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/launcher/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/llm/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/logger/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/renderer/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/responses_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/score_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/ssl/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/tool/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/tool_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/serving_messages/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/collect_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/main/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/openai/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/run_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/types/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/latency/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/main/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/startup/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/throughput/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/api_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/cli_args/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/orca_metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/run_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_chat/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_chat_stream_harmony/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_completion/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_models/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_responses/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_transcription/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/speech_to_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/harmony_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/responses_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/conftest/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/sagemaker/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/sagemaker/routes/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/cache/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/middleware/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/health/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/server_info/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/lora/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/profile/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/profile/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rlhf/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rlhf/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rpc/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rpc/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/sleep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/sleep/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/data/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/parse/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/preprocess/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/dump_input/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/formatter/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/lazy/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/log_time/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/lora_model/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/lora_weights/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/model_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/peft_helper/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/resolver/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/worker_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/base_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/column_parallel_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/replicated_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/row_parallel_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/vocal_parallel_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/ipex_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/ipex_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/torch_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/torch_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/fused_moe_lora_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/kernel_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_expand_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_kernel_metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_shrink_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/xla_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/xla_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_selector/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/custom_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/parameter/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/activation/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/attention_layer_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/batch_invariant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/conv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/kda/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/layernorm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/lightning_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/pooler/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/resampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/vocab_parallel_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_delta_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_o/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_scaled_dot_kkt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/cumsum/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/fused_recurrent/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/index_py/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/kda/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/l2norm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/layernorm_guard/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/op/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/solve_tril/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/wy_fast/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/all2all_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/batched_deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/cpu_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/cutlass_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deep_gemm_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deepep_ht_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deepep_ll_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutedsl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutlass_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutlass_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_trtllm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_batched_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_marlin_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe_method_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe_modular_method/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/gpt_oss_triton_kernels_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/layer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/modular_kernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_align_block_size/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_pallas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_permute_unpermute/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_torch_iterative/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/pplx_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/rocm_aiter_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/routing_simulator/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/shared_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/topk_weight_and_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/triton_deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/trtllm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/unquantized_fused_moe_method/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/zero_expert_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/linear_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_mixer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_mixer2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/short_conv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/causal_conv1d/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/layernorm_gated/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/mamba_ssm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_bmm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_chunk_scan/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_chunk_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_combined/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_state_passing/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/auto_round/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq_triton/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/base_config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/bitsandbytes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/cpu_wna16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/deepspeedfp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/experts_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fbgemm_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fp_quant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gguf/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_marlin_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/hqq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/inc/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/input_quant_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/ipex_quant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kv_cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/modelopt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/moe_wna16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/mxfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/petit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/ptpc_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/qutlass_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/rtn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/schema/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/torchao/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/tpu_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/compressed_tensors/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/compressed_tensors_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/triton_scaled_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_scheme/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a4_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a8_int/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a16_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a16_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a8_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a16_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_wNa16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/module/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/schemes/linear_qutlass_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/allspark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/conch/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/cutlass/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/dynamic_4bit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/exllama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/MPLinearKernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/machete/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/aiter/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/cutlass/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/ScaledMMLinearKernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/triton/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/xla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/quark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/quark_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_ocp_mx/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_scheme/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_w8a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_w8a8_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/allspark_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/bitblas_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/flashinfer_fp4_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/flashinfer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/fp8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/gptq_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/int8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/layer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/machete_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_fp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_test/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_test_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp4_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp6_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/nvfp4_emulation_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/nvfp4_moe_support/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/ocp_mx_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/petit_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/quant_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/w8a8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/deepseek_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dual_chunk_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dynamic_ntk_alpha_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dynamic_ntk_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/ernie45_vl_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/linear_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/llama3_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/llama4_vision_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/mrope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/ntk_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/phi3_long_rope_scaled_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/xdrope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/yarn_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/base_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/bitsandbytes_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/default_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/dummy_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/gguf_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/online_quantization/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/runai_streamer_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/sharded_state_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tensorizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tensorizer_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/weight_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/adapters/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/afmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aimv2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/apertus/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/arcee/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/arctic/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aria/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/audioflamingo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aya_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/baichuan/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bailing_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bee/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bert/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bert_with_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/blip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/blip2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bloom/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/chameleon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/chatglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/clip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/cohere2_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/commandr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dbrx/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepencoder/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_v2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dots1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dots_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_vl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/exaone/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/exaone4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/fairseq2_llama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/falcon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/falcon_h1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/flex_olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/fuyu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3n/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3n_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_1v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_moe_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_bigcode/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_j/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_neox/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_oss/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granite/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granite_speech/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoehybrid/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoeshared/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gritlm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/grok1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/h2ovl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hunyuan_v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hunyuan_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hyperclovax_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/idefics2_vision_model/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/idefics3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interfaces/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interfaces_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/intern_vit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internlm2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internlm2_ve/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interns1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interns1_vit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internvl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jais/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jais2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jina_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/keye/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/keye_vl1_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/kimi_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/kimi_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lfm2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lfm2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lightonocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama4_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama_eagle3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_next_video/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_onevision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/longcat_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/longcat_flash_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mamba2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/midashenglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo_v2_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpmv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_m2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_text_01/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_vl_01/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral_large_3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral_large_3_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mixtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mllama4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mlp_speculator/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/modernbert/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/module_mapping/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/molmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/moonvit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mpt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nano_nemotron_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_nas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nvlm_d/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmo2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/opencua/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/openpangu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/openpangu_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/opt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/orion/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ouro/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ovis2_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/paddleocr_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/paligemma/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/persimmon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi3v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm_audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phimoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/pixtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/plamo2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/plamo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_5_omni_thinker/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_5_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_rm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_next_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_omni_moe_thinker/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_vl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/radio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/roberta/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/rvl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/seed_oss/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/siglip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/siglip2navit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/skyworkr1v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/smolvlm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/solar/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/stablelm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/starcoder2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/step3_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/step3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/swin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/tarsier/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/telechat2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/teleflm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/terratorch/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ultravox/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/voxtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/voxtral_streaming/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/whisper/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/whisper_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/zamba2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/causal/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/legacy/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/deep_gemm_warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/kernel_warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/evs/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/hasher/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/image/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/inputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/parse/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/processing/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/profiling/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/video/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/cuda/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/rocm/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/io_processors/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/io_processors/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/lora_resolvers/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/lora_resolvers/filesystem_resolver/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/layerwise_profile/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/lazy_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/ray_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/abs_reasoning_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/basic_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/deepseek_r1_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/deepseek_v3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/ernie45_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/glm4_moe_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/gptoss_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/granite_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/holo2_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/hunyuan_a13b_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/identity_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/minimax_m2_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/mistral_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/olmo3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/qwen3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/seedoss_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/step3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/deepseek_v32/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/deepseek_v32_encoding/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/detokenizer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/hf/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/mistral/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/abstract_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv31_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv32_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/ernie45_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/functiongemma_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/gigachat3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/glm4_moe_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/glm47_moe_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/granite_20b_fc_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/granite_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/hermes_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/hunyuan_a13b_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/internlm2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/jamba_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/kimi_k2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/llama4_pythonic_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/llama_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/longcat_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/minimax_m2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/minimax_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/mistral_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/olmo3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/openai_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/phi4mini_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/pythonic_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/qwen3coder_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/qwen3xml_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/seed_oss_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/step3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/xlam_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/config_parser_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/dynamic_module/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/gguf_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/repo_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/runai_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/s3_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/tokenizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/chat_templates/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/chat_templates/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/afmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/arctic/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/chatglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/dotsocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/falcon/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/flex_olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/hunyuan_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/jais/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/kimi_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/kimi_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/lfm2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/midashenglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/mistral/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/mlp_speculator/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/moonvit/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/nemotron/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/nemotron_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/olmo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/qwen3_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/radio/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/step3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/tarsier2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/ultravox/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/algos/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/deepseek_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/hunyuan_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/hunyuan_vl_image/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/ovis2_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/triton_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/triton_utils/importing/",
    "https://docs.vllm.ai/en/latest/api/vllm/usage/",
    "https://docs.vllm.ai/en/latest/api/vllm/usage/usage_lib/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/argparse_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/async_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/collection_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/counter/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/deep_gemm/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/flashinfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/func_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/gc_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/hashing/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/import_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/jsontree/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/math_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/mem_constants/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/mem_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/nccl/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/network_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/nvtx_pytorch_hooks/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/platform_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/profiling/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/serial_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/system_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/tensor_schema/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/torch_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/cudagraph_dispatcher/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_cache_interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/serial_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/cpu_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flash_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flashinfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flex_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/gdn_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/linear_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba1_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba2_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/pallas/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_aiter_fa/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_aiter_unified_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/short_conv_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/tree_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/triton_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/aiter_triton_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/cutlass_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashattn_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashinfer_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashmla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashmla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/indexer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/rocm_aiter_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/rocm_aiter_mla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/triton_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/block_pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/encoder_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_coordinator/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/single_type_kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/async_scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/request_queue/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/async_llm/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/coordinator/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/core/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/core_client/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/detokenizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/exceptions/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/input_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/output_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/parallel_sampling/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/multiproc_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_distributed_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/uniproc_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/arc_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backend/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/lru_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/mediums/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/spec/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backends/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/cpu_gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/loggers/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/perf/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/prometheus/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/ray_wrappers/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/reader/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/stats/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/pool/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/rejection_sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/builtin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/state/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/bad_words/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/penalties/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/topk_topp_sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/ngram_proposer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/suffix_decoding/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_guidance/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_lm_format_enforcer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_outlines/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_types/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_xgrammar/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/block_table/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/dp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ec_connector_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_ubatch_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/kv_connector_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/lora_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ubatch_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ubatching/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/worker_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/workspace/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/xpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/xpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/async_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/attn_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/block_table/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/cudagraph_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/dp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/states/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/structured_outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/metrics/logits/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/gumbel/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/logprob/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/min_p/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/penalties/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/eagle_cudagraph/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/rejection_sample/",
    "https://docs.vllm.ai/en/latest/cli/serve/",
    "https://docs.vllm.ai/en/latest/cli/chat/",
    "https://docs.vllm.ai/en/latest/cli/complete/",
    "https://docs.vllm.ai/en/latest/cli/run-batch/",
    "https://docs.vllm.ai/en/latest/cli/bench/latency/",
    "https://docs.vllm.ai/en/latest/cli/bench/serve/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/plot/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/plot_pareto/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/serve/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/serve_sla/",
    "https://docs.vllm.ai/en/latest/cli/bench/throughput/",
    "https://docs.vllm.ai/en/latest/community/meetups/",
    "https://docs.vllm.ai/en/latest/community/sponsors/",
    "https://docs.vllm.ai/en/latest/governance/collaboration/",
    "https://docs.vllm.ai/en/latest/governance/committers/",
    "https://docs.vllm.ai/en/latest/governance/process/"
  ]
}