{
  "url": "https://docs.vllm.ai/en/latest/api/vllm/compilation/backends/",
  "title": "backends - vLLM",
  "content": "A manager to manage the compilation process, including caching the compiled graph, loading the compiled graph, and compiling the graph.\n\nThe cache is a dict mapping (runtime_shape, graph_index, backend_name) to any_data returned from the compiler.\n\nWhen serializing the cache, we save it to a Python file for readability. We don't use json here because json doesn't support int as key.\n\nProvide compilation context for the duration of compilation to set any torch global properties we want to scope to a single Inductor compilation (e.g. partition rules, pass context).\n\nInitialize the cache directory for the compiler.\n\nThe organization of the cache directory is as follows: cache_dir=/path/to/hash_str/rank_i_j/prefix/ inside cache_dir, there will be: - vllm_compile_cache.py - computation_graph.py - transformed_code.py\n\nfor multiple prefixes, they can share the same base cache dir of /path/to/hash_str/rank_i_j/ , to store some common compilation artifacts.\n\nCode adapted from torch.fx.passes.shape_prop.ShapeProp. It runs the given graph with fake inputs, and compile some submodules specified by compile_submod_names with the given compilation configs.\n\nNOTE: the order in compile_submod_names matters, because it will be used to determine the order of the compiled piecewise graphs. The first graph will handle logging, and the last graph has some special cudagraph output handling.\n\nThe compilation backend for torch.compile with vLLM. It is used for compilation mode of CompilationMode.VLLM_COMPILE, where we customize the compilation.\n\nThe major work of this backend is to split the graph into piecewise graphs, and pass them to the piecewise backend.\n\nThis backend also adds the PostGradPassManager to Inductor config, which handles the post-grad passes.\n\nContext manager to set the model tag.",
  "headings": [
    {
      "level": "h1",
      "text": "vllm.compilation.backends ¶",
      "id": "vllm.compilation.backends"
    },
    {
      "level": "h2",
      "text": "compilation_start_time module-attribute ¶",
      "id": "vllm.compilation.backends.compilation_start_time"
    },
    {
      "level": "h2",
      "text": "logger module-attribute ¶",
      "id": "vllm.compilation.backends.logger"
    },
    {
      "level": "h2",
      "text": "model_is_encoder module-attribute ¶",
      "id": "vllm.compilation.backends.model_is_encoder"
    },
    {
      "level": "h2",
      "text": "model_tag module-attribute ¶",
      "id": "vllm.compilation.backends.model_tag"
    },
    {
      "level": "h2",
      "text": "CompilerManager ¶",
      "id": "vllm.compilation.backends.CompilerManager"
    },
    {
      "level": "h3",
      "text": "cache instance-attribute ¶",
      "id": "vllm.compilation.backends.CompilerManager.cache"
    },
    {
      "level": "h3",
      "text": "compilation_config instance-attribute ¶",
      "id": "vllm.compilation.backends.CompilerManager.compilation_config"
    },
    {
      "level": "h3",
      "text": "compiler instance-attribute ¶",
      "id": "vllm.compilation.backends.CompilerManager.compiler"
    },
    {
      "level": "h3",
      "text": "is_cache_updated instance-attribute ¶",
      "id": "vllm.compilation.backends.CompilerManager.is_cache_updated"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.compilation.backends.CompilerManager.__init__"
    },
    {
      "level": "h3",
      "text": "compile ¶",
      "id": "vllm.compilation.backends.CompilerManager.compile"
    },
    {
      "level": "h3",
      "text": "compile_context ¶",
      "id": "vllm.compilation.backends.CompilerManager.compile_context"
    },
    {
      "level": "h3",
      "text": "compute_hash ¶",
      "id": "vllm.compilation.backends.CompilerManager.compute_hash"
    },
    {
      "level": "h3",
      "text": "initialize_cache ¶",
      "id": "vllm.compilation.backends.CompilerManager.initialize_cache"
    },
    {
      "level": "h3",
      "text": "load ¶",
      "id": "vllm.compilation.backends.CompilerManager.load"
    },
    {
      "level": "h3",
      "text": "save_to_file ¶",
      "id": "vllm.compilation.backends.CompilerManager.save_to_file"
    },
    {
      "level": "h2",
      "text": "PiecewiseCompileInterpreter ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter"
    },
    {
      "level": "h3",
      "text": "compilation_config instance-attribute ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.compilation_config"
    },
    {
      "level": "h3",
      "text": "compile_submod_names instance-attribute ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.compile_submod_names"
    },
    {
      "level": "h3",
      "text": "extra_traceback instance-attribute ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.extra_traceback"
    },
    {
      "level": "h3",
      "text": "fake_mode instance-attribute ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.fake_mode"
    },
    {
      "level": "h3",
      "text": "vllm_backend instance-attribute ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.vllm_backend"
    },
    {
      "level": "h3",
      "text": "vllm_config instance-attribute ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.vllm_config"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.__init__"
    },
    {
      "level": "h3",
      "text": "call_module ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.call_module"
    },
    {
      "level": "h3",
      "text": "run ¶",
      "id": "vllm.compilation.backends.PiecewiseCompileInterpreter.run"
    },
    {
      "level": "h2",
      "text": "SplitItem dataclass ¶",
      "id": "vllm.compilation.backends.SplitItem"
    },
    {
      "level": "h3",
      "text": "graph instance-attribute ¶",
      "id": "vllm.compilation.backends.SplitItem.graph"
    },
    {
      "level": "h3",
      "text": "graph_id instance-attribute ¶",
      "id": "vllm.compilation.backends.SplitItem.graph_id"
    },
    {
      "level": "h3",
      "text": "is_splitting_graph instance-attribute ¶",
      "id": "vllm.compilation.backends.SplitItem.is_splitting_graph"
    },
    {
      "level": "h3",
      "text": "submod_name instance-attribute ¶",
      "id": "vllm.compilation.backends.SplitItem.submod_name"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.compilation.backends.SplitItem.__init__"
    },
    {
      "level": "h2",
      "text": "VllmBackend ¶",
      "id": "vllm.compilation.backends.VllmBackend"
    },
    {
      "level": "h3",
      "text": "_called class-attribute instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend._called"
    },
    {
      "level": "h3",
      "text": "compilation_config instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.compilation_config"
    },
    {
      "level": "h3",
      "text": "compiler_manager instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.compiler_manager"
    },
    {
      "level": "h3",
      "text": "graph instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.graph"
    },
    {
      "level": "h3",
      "text": "inductor_config instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.inductor_config"
    },
    {
      "level": "h3",
      "text": "input_buffers instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.input_buffers"
    },
    {
      "level": "h3",
      "text": "is_encoder instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.is_encoder"
    },
    {
      "level": "h3",
      "text": "pass_key instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.pass_key"
    },
    {
      "level": "h3",
      "text": "pass_manager instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.pass_manager"
    },
    {
      "level": "h3",
      "text": "piecewise_graphs instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.piecewise_graphs"
    },
    {
      "level": "h3",
      "text": "post_grad_passes instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.post_grad_passes"
    },
    {
      "level": "h3",
      "text": "prefix instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.prefix"
    },
    {
      "level": "h3",
      "text": "returned_callable instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.returned_callable"
    },
    {
      "level": "h3",
      "text": "split_gm instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.split_gm"
    },
    {
      "level": "h3",
      "text": "sym_tensor_indices instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.sym_tensor_indices"
    },
    {
      "level": "h3",
      "text": "vllm_config instance-attribute ¶",
      "id": "vllm.compilation.backends.VllmBackend.vllm_config"
    },
    {
      "level": "h3",
      "text": "__call__ ¶",
      "id": "vllm.compilation.backends.VllmBackend.__call__"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.compilation.backends.VllmBackend.__init__"
    },
    {
      "level": "h3",
      "text": "configure_post_pass ¶",
      "id": "vllm.compilation.backends.VllmBackend.configure_post_pass"
    },
    {
      "level": "h2",
      "text": "make_compiler ¶",
      "id": "vllm.compilation.backends.make_compiler"
    },
    {
      "level": "h2",
      "text": "set_model_tag ¶",
      "id": "vllm.compilation.backends.set_model_tag"
    },
    {
      "level": "h2",
      "text": "split_graph ¶",
      "id": "vllm.compilation.backends.split_graph"
    }
  ],
  "code_samples": [
    {
      "code": "compilation_start_time = 0.0",
      "language": "unknown"
    },
    {
      "code": "compilation_start_time = 0.0",
      "language": "unknown"
    },
    {
      "code": "logger = init_logger(__name__)",
      "language": "unknown"
    },
    {
      "code": "logger = init_logger(__name__)",
      "language": "unknown"
    },
    {
      "code": "model_is_encoder: bool = False",
      "language": "typescript"
    },
    {
      "code": "model_is_encoder: bool = False",
      "language": "typescript"
    },
    {
      "code": "model_tag: str = 'backbone'",
      "language": "typescript"
    },
    {
      "code": "model_tag: str = 'backbone'",
      "language": "typescript"
    },
    {
      "code": "78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285",
      "language": "unknown"
    },
    {
      "code": "class CompilerManager:\n    \"\"\"\n    A manager to manage the compilation process, including\n    caching the compiled graph, loading the compiled graph,\n    and compiling the graph.\n\n    The cache is a dict mapping\n    `(runtime_shape, graph_index, backend_name)`\n    to `any_data` returned from the compiler.\n\n    When serializing the cache, we save it to a Python file\n    for readability. We don't use json here because json doesn't\n    support int as key.\n    \"\"\"\n\n    def __init__(self, compilation_config: CompilationConfig):\n        self.cache: dict[tuple[Range, int, str], Any] = dict()\n        self.is_cache_updated = False\n        self.compilation_config = compilation_config\n        self.compiler = make_compiler(compilation_config)\n\n    def compute_hash(self, vllm_config: VllmConfig) -> str:\n        return self.compiler.compute_hash(vllm_config)\n\n    @contextmanager\n    def compile_context(self, compile_range: Range):\n        \"\"\"Provide compilation context for the duration of compilation to set\n        any torch global properties we want to scope to a single Inductor\n        compilation (e.g. partition rules, pass context).\"\"\"\n        with pass_context(compile_range):\n            if self.compilation_config.use_inductor_graph_partition:\n                with inductor_partition_rule_context(\n                    self.compilation_config.splitting_ops\n                ):\n                    yield\n            else:\n                yield\n\n    def initialize_cache(\n        self, cache_dir: str, disable_cache: bool = False, prefix: str = \"\"\n    ):\n        \"\"\"\n        Initialize the cache directory for the compiler.\n\n        The organization of the cache directory is as follows:\n        cache_dir=/path/to/hash_str/rank_i_j/prefix/\n        inside cache_dir, there will be:\n        - vllm_compile_cache.py\n        - computation_graph.py\n        - transformed_code.py\n\n        for multiple prefixes, they can share the same\n        base cache dir of /path/to/hash_str/rank_i_j/ ,\n        to store some common compilation artifacts.\n        \"\"\"\n\n        self.disable_cache = disable_cache\n        self.cache_dir = cache_dir\n        self.cache_file_path = os.path.join(cache_dir, \"vllm_compile_cache.py\")\n\n        if not disable_cache and os.path.exists(self.cache_file_path):\n            # load the cache from the file\n            with open(self.cache_file_path) as f:\n                # we use ast.literal_eval to parse the data\n                # because it is a safe way to parse Python literals.\n                # do not use eval(), it is unsafe.\n                cache = ast.literal_eval(f.read())\n\n            def check_type(value, ty):\n                if not isinstance(value, ty):\n                    raise TypeError(f\"Expected {ty} but got {type(value)} for {value}\")\n\n            def parse_key(key: Any) -> tuple[Range, int, str]:\n                range_tuple, graph_index, compiler_name = key\n                check_type(graph_index, int)\n                check_type(compiler_name, str)\n                if isinstance(range_tuple, tuple):\n                    start, end = range_tuple\n                    check_type(start, int)\n                    check_type(end, int)\n                    range_tuple = Range(start=start, end=end)\n                check_type(range_tuple, Range)\n                return range_tuple, graph_index, compiler_name\n\n            self.cache = {parse_key(key): value for key, value in cache.items()}\n\n        self.compiler.initialize_cache(\n            cache_dir=cache_dir, disable_cache=disable_cache, prefix=prefix\n        )\n\n    def save_to_file(self):\n        if self.disable_cache or not self.is_cache_updated:\n            return\n        printer = pprint.PrettyPrinter(indent=4)\n        data = printer.pformat(self.cache)\n        with open(self.cache_file_path, \"w\") as f:\n            f.write(data)\n\n    def load(\n        self,\n        graph: fx.GraphModule,\n        example_inputs: list[Any],\n        graph_index: int,\n        compile_range: Range,\n    ) -> Callable | None:\n        if (compile_range, graph_index, self.compiler.name) not in self.cache:\n            return None\n        handle = self.cache[(compile_range, graph_index, self.compiler.name)]\n        compiled_graph = self.compiler.load(\n            handle, graph, example_inputs, graph_index, compile_range\n        )\n        logger.debug(\n            \"Directly load the %s-th graph for compile range %sfrom %s via handle %s\",\n            graph_index,\n            str(compile_range),\n            self.compiler.name,\n            handle,\n        )\n        return compiled_graph\n\n    def compile(\n        self,\n        graph: fx.GraphModule,\n        example_inputs,\n        additional_inductor_config,\n        compilation_config: CompilationConfig,\n        compile_range: Range,\n        graph_index: int = 0,\n        num_graphs: int = 1,\n    ) -> Any:\n        if graph_index == 0:\n            # before compiling the first graph, record the start time\n            global compilation_start_time\n            compilation_start_time = time.time()\n\n        compilation_counter.num_backend_compilations += 1\n\n        compiled_graph = None\n\n        # try to load from the cache\n        compiled_graph = self.load(graph, example_inputs, graph_index, compile_range)\n        if compiled_graph is not None:\n            if graph_index == num_graphs - 1:\n                # after loading the last graph for this shape, record the time.\n                # there can be multiple graphs due to piecewise compilation.\n                now = time.time()\n                elapsed = now - compilation_start_time\n                compilation_config.compilation_time += elapsed\n                logger.info(\n                    \"Directly load the compiled graph(s) for compile range %s \"\n                    \"from the cache, took %.3f s\",\n                    str(compile_range),\n                    elapsed,\n                )\n            return compiled_graph\n\n        # no compiler cached the graph, or the cache is disabled,\n        # we need to compile it\n        if isinstance(self.compiler, InductorAdaptor):\n            # Let compile_fx generate a key for us\n            maybe_key = None\n        else:\n            maybe_key = \"artifact_compile_range_\"\n            maybe_key += f\"{compile_range.start}_{compile_range.end}\"\n            maybe_key += f\"_subgraph_{graph_index}\"\n        with self.compile_context(compile_range):\n            compiled_graph, handle = self.compiler.compile(\n                graph,\n                example_inputs,\n                additional_inductor_config,\n                compile_range,\n                maybe_key,\n            )\n\n        assert compiled_graph is not None, \"Failed to compile the graph\"\n\n        # store the artifact in the cache\n        if is_compile_cache_enabled(additional_inductor_config) and handle is not None:\n            self.cache[(compile_range, graph_index, self.compiler.name)] = handle\n            compilation_counter.num_cache_entries_updated += 1\n            self.is_cache_updated = True\n            if graph_index == 0:\n                # adds some info logging for the first graph\n                logger.info_once(\n                    \"Cache the graph of compile range %s for later use\",\n                    str(compile_range),\n                )\n            logger.debug(\n                \"Store the %s-th graph for compile range%s from %s via handle %s\",\n                graph_index,\n                str(compile_range),\n                self.compiler.name,\n                handle,\n            )\n\n        # after compiling the last graph, record the end time\n        if graph_index == num_graphs - 1:\n            now = time.time()\n            elapsed = now - compilation_start_time\n            compilation_config.compilation_time += elapsed\n            logger.info_once(\n                \"Compiling a graph for compile range %s takes %.2f s\",\n                str(compile_range),\n                elapsed,\n                scope=\"local\",\n            )\n\n        return compiled_graph",
      "language": "python"
    },
    {
      "code": "class CompilerManager:\n    \"\"\"\n    A manager to manage the compilation process, including\n    caching the compiled graph, loading the compiled graph,\n    and compiling the graph.\n\n    The cache is a dict mapping\n    `(runtime_shape, graph_index, backend_name)`\n    to `any_data` returned from the compiler.\n\n    When serializing the cache, we save it to a Python file\n    for readability. We don't use json here because json doesn't\n    support int as key.\n    \"\"\"\n\n    def __init__(self, compilation_config: CompilationConfig):\n        self.cache: dict[tuple[Range, int, str], Any] = dict()\n        self.is_cache_updated = False\n        self.compilation_config = compilation_config\n        self.compiler = make_compiler(compilation_config)\n\n    def compute_hash(self, vllm_config: VllmConfig) -> str:\n        return self.compiler.compute_hash(vllm_config)\n\n    @contextmanager\n    def compile_context(self, compile_range: Range):\n        \"\"\"Provide compilation context for the duration of compilation to set\n        any torch global properties we want to scope to a single Inductor\n        compilation (e.g. partition rules, pass context).\"\"\"\n        with pass_context(compile_range):\n            if self.compilation_config.use_inductor_graph_partition:\n                with inductor_partition_rule_context(\n                    self.compilation_config.splitting_ops\n                ):\n                    yield\n            else:\n                yield\n\n    def initialize_cache(\n        self, cache_dir: str, disable_cache: bool = False, prefix: str = \"\"\n    ):\n        \"\"\"\n        Initialize the cache directory for the compiler.\n\n        The organization of the cache directory is as follows:\n        cache_dir=/path/to/hash_str/rank_i_j/prefix/\n        inside cache_dir, there will be:\n        - vllm_compile_cache.py\n        - computation_graph.py\n        - transformed_code.py\n\n        for multiple prefixes, they can share the same\n        base cache dir of /path/to/hash_str/rank_i_j/ ,\n        to store some common compilation artifacts.\n        \"\"\"\n\n        self.disable_cache = disable_cache\n        self.cache_dir = cache_dir\n        self.cache_file_path = os.path.join(cache_dir, \"vllm_compile_cache.py\")\n\n        if not disable_cache and os.path.exists(self.cache_file_path):\n            # load the cache from the file\n            with open(self.cache_file_path) as f:\n                # we use ast.literal_eval to parse the data\n                # because it is a safe way to parse Python literals.\n                # do not use eval(), it is unsafe.\n                cache = ast.literal_eval(f.read())\n\n            def check_type(value, ty):\n                if not isinstance(value, ty):\n                    raise TypeError(f\"Expected {ty} but got {type(value)} for {value}\")\n\n            def parse_key(key: Any) -> tuple[Range, int, str]:\n                range_tuple, graph_index, compiler_name = key\n                check_type(graph_index, int)\n                check_type(compiler_name, str)\n                if isinstance(range_tuple, tuple):\n                    start, end = range_tuple\n                    check_type(start, int)\n                    check_type(end, int)\n                    range_tuple = Range(start=start, end=end)\n                check_type(range_tuple, Range)\n                return range_tuple, graph_index, compiler_name\n\n            self.cache = {parse_key(key): value for key, value in cache.items()}\n\n        self.compiler.initialize_cache(\n            cache_dir=cache_dir, disable_cache=disable_cache, prefix=prefix\n        )\n\n    def save_to_file(self):\n        if self.disable_cache or not self.is_cache_updated:\n            return\n        printer = pprint.PrettyPrinter(indent=4)\n        data = printer.pformat(self.cache)\n        with open(self.cache_file_path, \"w\") as f:\n            f.write(data)\n\n    def load(\n        self,\n        graph: fx.GraphModule,\n        example_inputs: list[Any],\n        graph_index: int,\n        compile_range: Range,\n    ) -> Callable | None:\n        if (compile_range, graph_index, self.compiler.name) not in self.cache:\n            return None\n        handle = self.cache[(compile_range, graph_index, self.compiler.name)]\n        compiled_graph = self.compiler.load(\n            handle, graph, example_inputs, graph_index, compile_range\n        )\n        logger.debug(\n            \"Directly load the %s-th graph for compile range %sfrom %s via handle %s\",\n            graph_index,\n            str(compile_range),\n            self.compiler.name,\n            handle,\n        )\n        return compiled_graph\n\n    def compile(\n        self,\n        graph: fx.GraphModule,\n        example_inputs,\n        additional_inductor_config,\n        compilation_config: CompilationConfig,\n        compile_range: Range,\n        graph_index: int = 0,\n        num_graphs: int = 1,\n    ) -> Any:\n        if graph_index == 0:\n            # before compiling the first graph, record the start time\n            global compilation_start_time\n            compilation_start_time = time.time()\n\n        compilation_counter.num_backend_compilations += 1\n\n        compiled_graph = None\n\n        # try to load from the cache\n        compiled_graph = self.load(graph, example_inputs, graph_index, compile_range)\n        if compiled_graph is not None:\n            if graph_index == num_graphs - 1:\n                # after loading the last graph for this shape, record the time.\n                # there can be multiple graphs due to piecewise compilation.\n                now = time.time()\n                elapsed = now - compilation_start_time\n                compilation_config.compilation_time += elapsed\n                logger.info(\n                    \"Directly load the compiled graph(s) for compile range %s \"\n                    \"from the cache, took %.3f s\",\n                    str(compile_range),\n                    elapsed,\n                )\n            return compiled_graph\n\n        # no compiler cached the graph, or the cache is disabled,\n        # we need to compile it\n        if isinstance(self.compiler, InductorAdaptor):\n            # Let compile_fx generate a key for us\n            maybe_key = None\n        else:\n            maybe_key = \"artifact_compile_range_\"\n            maybe_key += f\"{compile_range.start}_{compile_range.end}\"\n            maybe_key += f\"_subgraph_{graph_index}\"\n        with self.compile_context(compile_range):\n            compiled_graph, handle = self.compiler.compile(\n                graph,\n                example_inputs,\n                additional_inductor_config,\n                compile_range,\n                maybe_key,\n            )\n\n        assert compiled_graph is not None, \"Failed to compile the graph\"\n\n        # store the artifact in the cache\n        if is_compile_cache_enabled(additional_inductor_config) and handle is not None:\n            self.cache[(compile_range, graph_index, self.compiler.name)] = handle\n            compilation_counter.num_cache_entries_updated += 1\n            self.is_cache_updated = True\n            if graph_index == 0:\n                # adds some info logging for the first graph\n                logger.info_once(\n                    \"Cache the graph of compile range %s for later use\",\n                    str(compile_range),\n                )\n            logger.debug(\n                \"Store the %s-th graph for compile range%s from %s via handle %s\",\n                graph_index,\n                str(compile_range),\n                self.compiler.name,\n                handle,\n            )\n\n        # after compiling the last graph, record the end time\n        if graph_index == num_graphs - 1:\n            now = time.time()\n            elapsed = now - compilation_start_time\n            compilation_config.compilation_time += elapsed\n            logger.info_once(\n                \"Compiling a graph for compile range %s takes %.2f s\",\n                str(compile_range),\n                elapsed,\n                scope=\"local\",\n            )\n\n        return compiled_graph",
      "language": "python"
    },
    {
      "code": "cache: dict[tuple[Range, int, str], Any] = dict()",
      "language": "yaml"
    },
    {
      "code": "cache: dict[tuple[Range, int, str], Any] = dict()",
      "language": "yaml"
    },
    {
      "code": "compilation_config = compilation_config",
      "language": "unknown"
    },
    {
      "code": "compilation_config = compilation_config",
      "language": "unknown"
    },
    {
      "code": "compiler = make_compiler(compilation_config)",
      "language": "unknown"
    },
    {
      "code": "compiler = make_compiler(compilation_config)",
      "language": "unknown"
    },
    {
      "code": "is_cache_updated = False",
      "language": "unknown"
    },
    {
      "code": "is_cache_updated = False",
      "language": "unknown"
    },
    {
      "code": "__init__(compilation_config: CompilationConfig)",
      "language": "python"
    },
    {
      "code": "__init__(compilation_config: CompilationConfig)",
      "language": "python"
    },
    {
      "code": "93\n94\n95\n96\n97",
      "language": "unknown"
    },
    {
      "code": "def __init__(self, compilation_config: CompilationConfig):\n    self.cache: dict[tuple[Range, int, str], Any] = dict()\n    self.is_cache_updated = False\n    self.compilation_config = compilation_config\n    self.compiler = make_compiler(compilation_config)",
      "language": "python"
    },
    {
      "code": "def __init__(self, compilation_config: CompilationConfig):\n    self.cache: dict[tuple[Range, int, str], Any] = dict()\n    self.is_cache_updated = False\n    self.compilation_config = compilation_config\n    self.compiler = make_compiler(compilation_config)",
      "language": "python"
    },
    {
      "code": "compile(\n    graph: GraphModule,\n    example_inputs,\n    additional_inductor_config,\n    compilation_config: CompilationConfig,\n    compile_range: Range,\n    graph_index: int = 0,\n    num_graphs: int = 1,\n) -> Any",
      "language": "typescript"
    },
    {
      "code": "compile(\n    graph: GraphModule,\n    example_inputs,\n    additional_inductor_config,\n    compilation_config: CompilationConfig,\n    compile_range: Range,\n    graph_index: int = 0,\n    num_graphs: int = 1,\n) -> Any",
      "language": "typescript"
    },
    {
      "code": "198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285",
      "language": "unknown"
    },
    {
      "code": "def compile(\n    self,\n    graph: fx.GraphModule,\n    example_inputs,\n    additional_inductor_config,\n    compilation_config: CompilationConfig,\n    compile_range: Range,\n    graph_index: int = 0,\n    num_graphs: int = 1,\n) -> Any:\n    if graph_index == 0:\n        # before compiling the first graph, record the start time\n        global compilation_start_time\n        compilation_start_time = time.time()\n\n    compilation_counter.num_backend_compilations += 1\n\n    compiled_graph = None\n\n    # try to load from the cache\n    compiled_graph = self.load(graph, example_inputs, graph_index, compile_range)\n    if compiled_graph is not None:\n        if graph_index == num_graphs - 1:\n            # after loading the last graph for this shape, record the time.\n            # there can be multiple graphs due to piecewise compilation.\n            now = time.time()\n            elapsed = now - compilation_start_time\n            compilation_config.compilation_time += elapsed\n            logger.info(\n                \"Directly load the compiled graph(s) for compile range %s \"\n                \"from the cache, took %.3f s\",\n                str(compile_range),\n                elapsed,\n            )\n        return compiled_graph\n\n    # no compiler cached the graph, or the cache is disabled,\n    # we need to compile it\n    if isinstance(self.compiler, InductorAdaptor):\n        # Let compile_fx generate a key for us\n        maybe_key = None\n    else:\n        maybe_key = \"artifact_compile_range_\"\n        maybe_key += f\"{compile_range.start}_{compile_range.end}\"\n        maybe_key += f\"_subgraph_{graph_index}\"\n    with self.compile_context(compile_range):\n        compiled_graph, handle = self.compiler.compile(\n            graph,\n            example_inputs,\n            additional_inductor_config,\n            compile_range,\n            maybe_key,\n        )\n\n    assert compiled_graph is not None, \"Failed to compile the graph\"\n\n    # store the artifact in the cache\n    if is_compile_cache_enabled(additional_inductor_config) and handle is not None:\n        self.cache[(compile_range, graph_index, self.compiler.name)] = handle\n        compilation_counter.num_cache_entries_updated += 1\n        self.is_cache_updated = True\n        if graph_index == 0:\n            # adds some info logging for the first graph\n            logger.info_once(\n                \"Cache the graph of compile range %s for later use\",\n                str(compile_range),\n            )\n        logger.debug(\n            \"Store the %s-th graph for compile range%s from %s via handle %s\",\n            graph_index,\n            str(compile_range),\n            self.compiler.name,\n            handle,\n        )\n\n    # after compiling the last graph, record the end time\n    if graph_index == num_graphs - 1:\n        now = time.time()\n        elapsed = now - compilation_start_time\n        compilation_config.compilation_time += elapsed\n        logger.info_once(\n            \"Compiling a graph for compile range %s takes %.2f s\",\n            str(compile_range),\n            elapsed,\n            scope=\"local\",\n        )\n\n    return compiled_graph",
      "language": "python"
    },
    {
      "code": "def compile(\n    self,\n    graph: fx.GraphModule,\n    example_inputs,\n    additional_inductor_config,\n    compilation_config: CompilationConfig,\n    compile_range: Range,\n    graph_index: int = 0,\n    num_graphs: int = 1,\n) -> Any:\n    if graph_index == 0:\n        # before compiling the first graph, record the start time\n        global compilation_start_time\n        compilation_start_time = time.time()\n\n    compilation_counter.num_backend_compilations += 1\n\n    compiled_graph = None\n\n    # try to load from the cache\n    compiled_graph = self.load(graph, example_inputs, graph_index, compile_range)\n    if compiled_graph is not None:\n        if graph_index == num_graphs - 1:\n            # after loading the last graph for this shape, record the time.\n            # there can be multiple graphs due to piecewise compilation.\n            now = time.time()\n            elapsed = now - compilation_start_time\n            compilation_config.compilation_time += elapsed\n            logger.info(\n                \"Directly load the compiled graph(s) for compile range %s \"\n                \"from the cache, took %.3f s\",\n                str(compile_range),\n                elapsed,\n            )\n        return compiled_graph\n\n    # no compiler cached the graph, or the cache is disabled,\n    # we need to compile it\n    if isinstance(self.compiler, InductorAdaptor):\n        # Let compile_fx generate a key for us\n        maybe_key = None\n    else:\n        maybe_key = \"artifact_compile_range_\"\n        maybe_key += f\"{compile_range.start}_{compile_range.end}\"\n        maybe_key += f\"_subgraph_{graph_index}\"\n    with self.compile_context(compile_range):\n        compiled_graph, handle = self.compiler.compile(\n            graph,\n            example_inputs,\n            additional_inductor_config,\n            compile_range,\n            maybe_key,\n        )\n\n    assert compiled_graph is not None, \"Failed to compile the graph\"\n\n    # store the artifact in the cache\n    if is_compile_cache_enabled(additional_inductor_config) and handle is not None:\n        self.cache[(compile_range, graph_index, self.compiler.name)] = handle\n        compilation_counter.num_cache_entries_updated += 1\n        self.is_cache_updated = True\n        if graph_index == 0:\n            # adds some info logging for the first graph\n            logger.info_once(\n                \"Cache the graph of compile range %s for later use\",\n                str(compile_range),\n            )\n        logger.debug(\n            \"Store the %s-th graph for compile range%s from %s via handle %s\",\n            graph_index,\n            str(compile_range),\n            self.compiler.name,\n            handle,\n        )\n\n    # after compiling the last graph, record the end time\n    if graph_index == num_graphs - 1:\n        now = time.time()\n        elapsed = now - compilation_start_time\n        compilation_config.compilation_time += elapsed\n        logger.info_once(\n            \"Compiling a graph for compile range %s takes %.2f s\",\n            str(compile_range),\n            elapsed,\n            scope=\"local\",\n        )\n\n    return compiled_graph",
      "language": "python"
    },
    {
      "code": "compile_context(compile_range: Range)",
      "language": "unknown"
    },
    {
      "code": "compile_context(compile_range: Range)",
      "language": "unknown"
    },
    {
      "code": "102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114",
      "language": "unknown"
    },
    {
      "code": "@contextmanager\ndef compile_context(self, compile_range: Range):\n    \"\"\"Provide compilation context for the duration of compilation to set\n    any torch global properties we want to scope to a single Inductor\n    compilation (e.g. partition rules, pass context).\"\"\"\n    with pass_context(compile_range):\n        if self.compilation_config.use_inductor_graph_partition:\n            with inductor_partition_rule_context(\n                self.compilation_config.splitting_ops\n            ):\n                yield\n        else:\n            yield",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef compile_context(self, compile_range: Range):\n    \"\"\"Provide compilation context for the duration of compilation to set\n    any torch global properties we want to scope to a single Inductor\n    compilation (e.g. partition rules, pass context).\"\"\"\n    with pass_context(compile_range):\n        if self.compilation_config.use_inductor_graph_partition:\n            with inductor_partition_rule_context(\n                self.compilation_config.splitting_ops\n            ):\n                yield\n        else:\n            yield",
      "language": "python"
    },
    {
      "code": "compute_hash(vllm_config: VllmConfig) -> str",
      "language": "php"
    },
    {
      "code": "compute_hash(vllm_config: VllmConfig) -> str",
      "language": "php"
    },
    {
      "code": "def compute_hash(self, vllm_config: VllmConfig) -> str:\n    return self.compiler.compute_hash(vllm_config)",
      "language": "python"
    },
    {
      "code": "def compute_hash(self, vllm_config: VllmConfig) -> str:\n    return self.compiler.compute_hash(vllm_config)",
      "language": "python"
    },
    {
      "code": "initialize_cache(\n    cache_dir: str,\n    disable_cache: bool = False,\n    prefix: str = \"\",\n)",
      "language": "typescript"
    },
    {
      "code": "initialize_cache(\n    cache_dir: str,\n    disable_cache: bool = False,\n    prefix: str = \"\",\n)",
      "language": "typescript"
    },
    {
      "code": "116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166",
      "language": "unknown"
    },
    {
      "code": "def initialize_cache(\n    self, cache_dir: str, disable_cache: bool = False, prefix: str = \"\"\n):\n    \"\"\"\n    Initialize the cache directory for the compiler.\n\n    The organization of the cache directory is as follows:\n    cache_dir=/path/to/hash_str/rank_i_j/prefix/\n    inside cache_dir, there will be:\n    - vllm_compile_cache.py\n    - computation_graph.py\n    - transformed_code.py\n\n    for multiple prefixes, they can share the same\n    base cache dir of /path/to/hash_str/rank_i_j/ ,\n    to store some common compilation artifacts.\n    \"\"\"\n\n    self.disable_cache = disable_cache\n    self.cache_dir = cache_dir\n    self.cache_file_path = os.path.join(cache_dir, \"vllm_compile_cache.py\")\n\n    if not disable_cache and os.path.exists(self.cache_file_path):\n        # load the cache from the file\n        with open(self.cache_file_path) as f:\n            # we use ast.literal_eval to parse the data\n            # because it is a safe way to parse Python literals.\n            # do not use eval(), it is unsafe.\n            cache = ast.literal_eval(f.read())\n\n        def check_type(value, ty):\n            if not isinstance(value, ty):\n                raise TypeError(f\"Expected {ty} but got {type(value)} for {value}\")\n\n        def parse_key(key: Any) -> tuple[Range, int, str]:\n            range_tuple, graph_index, compiler_name = key\n            check_type(graph_index, int)\n            check_type(compiler_name, str)\n            if isinstance(range_tuple, tuple):\n                start, end = range_tuple\n                check_type(start, int)\n                check_type(end, int)\n                range_tuple = Range(start=start, end=end)\n            check_type(range_tuple, Range)\n            return range_tuple, graph_index, compiler_name\n\n        self.cache = {parse_key(key): value for key, value in cache.items()}\n\n    self.compiler.initialize_cache(\n        cache_dir=cache_dir, disable_cache=disable_cache, prefix=prefix\n    )",
      "language": "python"
    },
    {
      "code": "def initialize_cache(\n    self, cache_dir: str, disable_cache: bool = False, prefix: str = \"\"\n):\n    \"\"\"\n    Initialize the cache directory for the compiler.\n\n    The organization of the cache directory is as follows:\n    cache_dir=/path/to/hash_str/rank_i_j/prefix/\n    inside cache_dir, there will be:\n    - vllm_compile_cache.py\n    - computation_graph.py\n    - transformed_code.py\n\n    for multiple prefixes, they can share the same\n    base cache dir of /path/to/hash_str/rank_i_j/ ,\n    to store some common compilation artifacts.\n    \"\"\"\n\n    self.disable_cache = disable_cache\n    self.cache_dir = cache_dir\n    self.cache_file_path = os.path.join(cache_dir, \"vllm_compile_cache.py\")\n\n    if not disable_cache and os.path.exists(self.cache_file_path):\n        # load the cache from the file\n        with open(self.cache_file_path) as f:\n            # we use ast.literal_eval to parse the data\n            # because it is a safe way to parse Python literals.\n            # do not use eval(), it is unsafe.\n            cache = ast.literal_eval(f.read())\n\n        def check_type(value, ty):\n            if not isinstance(value, ty):\n                raise TypeError(f\"Expected {ty} but got {type(value)} for {value}\")\n\n        def parse_key(key: Any) -> tuple[Range, int, str]:\n            range_tuple, graph_index, compiler_name = key\n            check_type(graph_index, int)\n            check_type(compiler_name, str)\n            if isinstance(range_tuple, tuple):\n                start, end = range_tuple\n                check_type(start, int)\n                check_type(end, int)\n                range_tuple = Range(start=start, end=end)\n            check_type(range_tuple, Range)\n            return range_tuple, graph_index, compiler_name\n\n        self.cache = {parse_key(key): value for key, value in cache.items()}\n\n    self.compiler.initialize_cache(\n        cache_dir=cache_dir, disable_cache=disable_cache, prefix=prefix\n    )",
      "language": "python"
    },
    {
      "code": "load(\n    graph: GraphModule,\n    example_inputs: list[Any],\n    graph_index: int,\n    compile_range: Range,\n) -> Callable | None",
      "language": "rust"
    },
    {
      "code": "load(\n    graph: GraphModule,\n    example_inputs: list[Any],\n    graph_index: int,\n    compile_range: Range,\n) -> Callable | None",
      "language": "rust"
    },
    {
      "code": "176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196",
      "language": "unknown"
    },
    {
      "code": "def load(\n    self,\n    graph: fx.GraphModule,\n    example_inputs: list[Any],\n    graph_index: int,\n    compile_range: Range,\n) -> Callable | None:\n    if (compile_range, graph_index, self.compiler.name) not in self.cache:\n        return None\n    handle = self.cache[(compile_range, graph_index, self.compiler.name)]\n    compiled_graph = self.compiler.load(\n        handle, graph, example_inputs, graph_index, compile_range\n    )\n    logger.debug(\n        \"Directly load the %s-th graph for compile range %sfrom %s via handle %s\",\n        graph_index,\n        str(compile_range),\n        self.compiler.name,\n        handle,\n    )\n    return compiled_graph",
      "language": "python"
    },
    {
      "code": "def load(\n    self,\n    graph: fx.GraphModule,\n    example_inputs: list[Any],\n    graph_index: int,\n    compile_range: Range,\n) -> Callable | None:\n    if (compile_range, graph_index, self.compiler.name) not in self.cache:\n        return None\n    handle = self.cache[(compile_range, graph_index, self.compiler.name)]\n    compiled_graph = self.compiler.load(\n        handle, graph, example_inputs, graph_index, compile_range\n    )\n    logger.debug(\n        \"Directly load the %s-th graph for compile range %sfrom %s via handle %s\",\n        graph_index,\n        str(compile_range),\n        self.compiler.name,\n        handle,\n    )\n    return compiled_graph",
      "language": "python"
    },
    {
      "code": "save_to_file()",
      "language": "unknown"
    },
    {
      "code": "save_to_file()",
      "language": "unknown"
    },
    {
      "code": "168\n169\n170\n171\n172\n173\n174",
      "language": "unknown"
    },
    {
      "code": "def save_to_file(self):\n    if self.disable_cache or not self.is_cache_updated:\n        return\n    printer = pprint.PrettyPrinter(indent=4)\n    data = printer.pformat(self.cache)\n    with open(self.cache_file_path, \"w\") as f:\n        f.write(data)",
      "language": "python"
    },
    {
      "code": "def save_to_file(self):\n    if self.disable_cache or not self.is_cache_updated:\n        return\n    printer = pprint.PrettyPrinter(indent=4)\n    data = printer.pformat(self.cache)\n    with open(self.cache_file_path, \"w\") as f:\n        f.write(data)",
      "language": "python"
    },
    {
      "code": "358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460",
      "language": "unknown"
    },
    {
      "code": "class PiecewiseCompileInterpreter(torch.fx.Interpreter):\n    \"\"\"Code adapted from `torch.fx.passes.shape_prop.ShapeProp`.\n    It runs the given graph with fake inputs, and compile some\n    submodules specified by `compile_submod_names` with the given\n    compilation configs.\n\n    NOTE: the order in `compile_submod_names` matters, because\n    it will be used to determine the order of the compiled piecewise\n    graphs. The first graph will handle logging, and the last graph\n    has some special cudagraph output handling.\n    \"\"\"\n\n    def __init__(\n        self,\n        module: torch.fx.GraphModule,\n        compile_submod_names: list[str],\n        vllm_config: VllmConfig,\n        vllm_backend: \"VllmBackend\",\n    ):\n        super().__init__(module)\n        from torch._guards import detect_fake_mode\n\n        self.fake_mode = detect_fake_mode()\n        self.compile_submod_names = compile_submod_names\n        self.compilation_config = vllm_config.compilation_config\n        self.vllm_config = vllm_config\n        self.vllm_backend = vllm_backend\n        # When True, it annoyingly dumps the torch.fx.Graph on errors.\n        self.extra_traceback = False\n\n    def run(self, *args):\n        # maybe instead just assert inputs are fake?\n        fake_args = [\n            self.fake_mode.from_tensor(t) if isinstance(t, torch.Tensor) else t\n            for t in args\n        ]\n        with self.fake_mode, enable_python_dispatcher():\n            return super().run(*fake_args)\n\n    def call_module(\n        self,\n        target: torch.fx.node.Target,\n        args: tuple[torch.fx.node.Argument, ...],\n        kwargs: dict[str, Any],\n    ) -> Any:\n        assert isinstance(target, str)\n\n        output = super().call_module(target, args, kwargs)\n\n        if target in self.compile_submod_names:\n            index = self.compile_submod_names.index(target)\n            submod = self.fetch_attr(target)\n\n            sym_shape_indices = [\n                i for i, x in enumerate(args) if isinstance(x, torch.SymInt)\n            ]\n\n            # Lazy import here to avoid circular import\n            from .piecewise_backend import PiecewiseBackend\n\n            piecewise_backend = PiecewiseBackend(\n                submod,\n                self.vllm_config,\n                index,\n                len(self.compile_submod_names),\n                sym_shape_indices,\n                self.vllm_backend,\n            )\n\n            if (\n                self.compilation_config.cudagraph_mode.has_piecewise_cudagraphs()\n                and not self.compilation_config.use_inductor_graph_partition\n            ):\n                # We're using Dynamo-based piecewise splitting, so we wrap\n                # the whole subgraph with a static graph wrapper.\n                from .cuda_graph import CUDAGraphOptions\n\n                # resolve the static graph wrapper class (e.g. CUDAGraphWrapper\n                # class) as platform dependent.\n                static_graph_wrapper_class = resolve_obj_by_qualname(\n                    current_platform.get_static_graph_wrapper_cls()\n                )\n\n                # Always assign PIECEWISE runtime mode to the\n                # CUDAGraphWrapper for piecewise_backend, to distinguish\n                # it from the FULL cudagraph runtime mode, no matter it\n                # is wrapped on a full or piecewise fx graph.\n                self.module.__dict__[target] = static_graph_wrapper_class(\n                    runnable=piecewise_backend,\n                    vllm_config=self.vllm_config,\n                    runtime_mode=CUDAGraphMode.PIECEWISE,\n                    cudagraph_options=CUDAGraphOptions(\n                        debug_log_enable=piecewise_backend.is_first_graph,\n                        gc_disable=not piecewise_backend.is_first_graph,\n                        weak_ref_output=piecewise_backend.is_last_graph,\n                    ),\n                )\n            else:\n                self.module.__dict__[target] = piecewise_backend\n\n            compilation_counter.num_piecewise_capturable_graphs_seen += 1\n\n        return output",
      "language": "python"
    },
    {
      "code": "class PiecewiseCompileInterpreter(torch.fx.Interpreter):\n    \"\"\"Code adapted from `torch.fx.passes.shape_prop.ShapeProp`.\n    It runs the given graph with fake inputs, and compile some\n    submodules specified by `compile_submod_names` with the given\n    compilation configs.\n\n    NOTE: the order in `compile_submod_names` matters, because\n    it will be used to determine the order of the compiled piecewise\n    graphs. The first graph will handle logging, and the last graph\n    has some special cudagraph output handling.\n    \"\"\"\n\n    def __init__(\n        self,\n        module: torch.fx.GraphModule,\n        compile_submod_names: list[str],\n        vllm_config: VllmConfig,\n        vllm_backend: \"VllmBackend\",\n    ):\n        super().__init__(module)\n        from torch._guards import detect_fake_mode\n\n        self.fake_mode = detect_fake_mode()\n        self.compile_submod_names = compile_submod_names\n        self.compilation_config = vllm_config.compilation_config\n        self.vllm_config = vllm_config\n        self.vllm_backend = vllm_backend\n        # When True, it annoyingly dumps the torch.fx.Graph on errors.\n        self.extra_traceback = False\n\n    def run(self, *args):\n        # maybe instead just assert inputs are fake?\n        fake_args = [\n            self.fake_mode.from_tensor(t) if isinstance(t, torch.Tensor) else t\n            for t in args\n        ]\n        with self.fake_mode, enable_python_dispatcher():\n            return super().run(*fake_args)\n\n    def call_module(\n        self,\n        target: torch.fx.node.Target,\n        args: tuple[torch.fx.node.Argument, ...],\n        kwargs: dict[str, Any],\n    ) -> Any:\n        assert isinstance(target, str)\n\n        output = super().call_module(target, args, kwargs)\n\n        if target in self.compile_submod_names:\n            index = self.compile_submod_names.index(target)\n            submod = self.fetch_attr(target)\n\n            sym_shape_indices = [\n                i for i, x in enumerate(args) if isinstance(x, torch.SymInt)\n            ]\n\n            # Lazy import here to avoid circular import\n            from .piecewise_backend import PiecewiseBackend\n\n            piecewise_backend = PiecewiseBackend(\n                submod,\n                self.vllm_config,\n                index,\n                len(self.compile_submod_names),\n                sym_shape_indices,\n                self.vllm_backend,\n            )\n\n            if (\n                self.compilation_config.cudagraph_mode.has_piecewise_cudagraphs()\n                and not self.compilation_config.use_inductor_graph_partition\n            ):\n                # We're using Dynamo-based piecewise splitting, so we wrap\n                # the whole subgraph with a static graph wrapper.\n                from .cuda_graph import CUDAGraphOptions\n\n                # resolve the static graph wrapper class (e.g. CUDAGraphWrapper\n                # class) as platform dependent.\n                static_graph_wrapper_class = resolve_obj_by_qualname(\n                    current_platform.get_static_graph_wrapper_cls()\n                )\n\n                # Always assign PIECEWISE runtime mode to the\n                # CUDAGraphWrapper for piecewise_backend, to distinguish\n                # it from the FULL cudagraph runtime mode, no matter it\n                # is wrapped on a full or piecewise fx graph.\n                self.module.__dict__[target] = static_graph_wrapper_class(\n                    runnable=piecewise_backend,\n                    vllm_config=self.vllm_config,\n                    runtime_mode=CUDAGraphMode.PIECEWISE,\n                    cudagraph_options=CUDAGraphOptions(\n                        debug_log_enable=piecewise_backend.is_first_graph,\n                        gc_disable=not piecewise_backend.is_first_graph,\n                        weak_ref_output=piecewise_backend.is_last_graph,\n                    ),\n                )\n            else:\n                self.module.__dict__[target] = piecewise_backend\n\n            compilation_counter.num_piecewise_capturable_graphs_seen += 1\n\n        return output",
      "language": "python"
    },
    {
      "code": "compilation_config = compilation_config",
      "language": "unknown"
    },
    {
      "code": "compilation_config = compilation_config",
      "language": "unknown"
    },
    {
      "code": "compile_submod_names = compile_submod_names",
      "language": "unknown"
    },
    {
      "code": "compile_submod_names = compile_submod_names",
      "language": "unknown"
    },
    {
      "code": "extra_traceback = False",
      "language": "unknown"
    },
    {
      "code": "extra_traceback = False",
      "language": "unknown"
    },
    {
      "code": "fake_mode = detect_fake_mode()",
      "language": "unknown"
    },
    {
      "code": "fake_mode = detect_fake_mode()",
      "language": "unknown"
    },
    {
      "code": "vllm_backend = vllm_backend",
      "language": "unknown"
    },
    {
      "code": "vllm_backend = vllm_backend",
      "language": "unknown"
    },
    {
      "code": "vllm_config = vllm_config",
      "language": "unknown"
    },
    {
      "code": "vllm_config = vllm_config",
      "language": "unknown"
    },
    {
      "code": "__init__(\n    module: GraphModule,\n    compile_submod_names: list[str],\n    vllm_config: VllmConfig,\n    vllm_backend: VllmBackend,\n)",
      "language": "python"
    },
    {
      "code": "__init__(\n    module: GraphModule,\n    compile_submod_names: list[str],\n    vllm_config: VllmConfig,\n    vllm_backend: VllmBackend,\n)",
      "language": "python"
    },
    {
      "code": "370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386",
      "language": "unknown"
    },
    {
      "code": "def __init__(\n    self,\n    module: torch.fx.GraphModule,\n    compile_submod_names: list[str],\n    vllm_config: VllmConfig,\n    vllm_backend: \"VllmBackend\",\n):\n    super().__init__(module)\n    from torch._guards import detect_fake_mode\n\n    self.fake_mode = detect_fake_mode()\n    self.compile_submod_names = compile_submod_names\n    self.compilation_config = vllm_config.compilation_config\n    self.vllm_config = vllm_config\n    self.vllm_backend = vllm_backend\n    # When True, it annoyingly dumps the torch.fx.Graph on errors.\n    self.extra_traceback = False",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    module: torch.fx.GraphModule,\n    compile_submod_names: list[str],\n    vllm_config: VllmConfig,\n    vllm_backend: \"VllmBackend\",\n):\n    super().__init__(module)\n    from torch._guards import detect_fake_mode\n\n    self.fake_mode = detect_fake_mode()\n    self.compile_submod_names = compile_submod_names\n    self.compilation_config = vllm_config.compilation_config\n    self.vllm_config = vllm_config\n    self.vllm_backend = vllm_backend\n    # When True, it annoyingly dumps the torch.fx.Graph on errors.\n    self.extra_traceback = False",
      "language": "python"
    },
    {
      "code": "call_module(\n    target: Target,\n    args: tuple[Argument, ...],\n    kwargs: dict[str, Any],\n) -> Any",
      "language": "php"
    },
    {
      "code": "call_module(\n    target: Target,\n    args: tuple[Argument, ...],\n    kwargs: dict[str, Any],\n) -> Any",
      "language": "php"
    },
    {
      "code": "397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460",
      "language": "unknown"
    },
    {
      "code": "def call_module(\n    self,\n    target: torch.fx.node.Target,\n    args: tuple[torch.fx.node.Argument, ...],\n    kwargs: dict[str, Any],\n) -> Any:\n    assert isinstance(target, str)\n\n    output = super().call_module(target, args, kwargs)\n\n    if target in self.compile_submod_names:\n        index = self.compile_submod_names.index(target)\n        submod = self.fetch_attr(target)\n\n        sym_shape_indices = [\n            i for i, x in enumerate(args) if isinstance(x, torch.SymInt)\n        ]\n\n        # Lazy import here to avoid circular import\n        from .piecewise_backend import PiecewiseBackend\n\n        piecewise_backend = PiecewiseBackend(\n            submod,\n            self.vllm_config,\n            index,\n            len(self.compile_submod_names),\n            sym_shape_indices,\n            self.vllm_backend,\n        )\n\n        if (\n            self.compilation_config.cudagraph_mode.has_piecewise_cudagraphs()\n            and not self.compilation_config.use_inductor_graph_partition\n        ):\n            # We're using Dynamo-based piecewise splitting, so we wrap\n            # the whole subgraph with a static graph wrapper.\n            from .cuda_graph import CUDAGraphOptions\n\n            # resolve the static graph wrapper class (e.g. CUDAGraphWrapper\n            # class) as platform dependent.\n            static_graph_wrapper_class = resolve_obj_by_qualname(\n                current_platform.get_static_graph_wrapper_cls()\n            )\n\n            # Always assign PIECEWISE runtime mode to the\n            # CUDAGraphWrapper for piecewise_backend, to distinguish\n            # it from the FULL cudagraph runtime mode, no matter it\n            # is wrapped on a full or piecewise fx graph.\n            self.module.__dict__[target] = static_graph_wrapper_class(\n                runnable=piecewise_backend,\n                vllm_config=self.vllm_config,\n                runtime_mode=CUDAGraphMode.PIECEWISE,\n                cudagraph_options=CUDAGraphOptions(\n                    debug_log_enable=piecewise_backend.is_first_graph,\n                    gc_disable=not piecewise_backend.is_first_graph,\n                    weak_ref_output=piecewise_backend.is_last_graph,\n                ),\n            )\n        else:\n            self.module.__dict__[target] = piecewise_backend\n\n        compilation_counter.num_piecewise_capturable_graphs_seen += 1\n\n    return output",
      "language": "python"
    },
    {
      "code": "def call_module(\n    self,\n    target: torch.fx.node.Target,\n    args: tuple[torch.fx.node.Argument, ...],\n    kwargs: dict[str, Any],\n) -> Any:\n    assert isinstance(target, str)\n\n    output = super().call_module(target, args, kwargs)\n\n    if target in self.compile_submod_names:\n        index = self.compile_submod_names.index(target)\n        submod = self.fetch_attr(target)\n\n        sym_shape_indices = [\n            i for i, x in enumerate(args) if isinstance(x, torch.SymInt)\n        ]\n\n        # Lazy import here to avoid circular import\n        from .piecewise_backend import PiecewiseBackend\n\n        piecewise_backend = PiecewiseBackend(\n            submod,\n            self.vllm_config,\n            index,\n            len(self.compile_submod_names),\n            sym_shape_indices,\n            self.vllm_backend,\n        )\n\n        if (\n            self.compilation_config.cudagraph_mode.has_piecewise_cudagraphs()\n            and not self.compilation_config.use_inductor_graph_partition\n        ):\n            # We're using Dynamo-based piecewise splitting, so we wrap\n            # the whole subgraph with a static graph wrapper.\n            from .cuda_graph import CUDAGraphOptions\n\n            # resolve the static graph wrapper class (e.g. CUDAGraphWrapper\n            # class) as platform dependent.\n            static_graph_wrapper_class = resolve_obj_by_qualname(\n                current_platform.get_static_graph_wrapper_cls()\n            )\n\n            # Always assign PIECEWISE runtime mode to the\n            # CUDAGraphWrapper for piecewise_backend, to distinguish\n            # it from the FULL cudagraph runtime mode, no matter it\n            # is wrapped on a full or piecewise fx graph.\n            self.module.__dict__[target] = static_graph_wrapper_class(\n                runnable=piecewise_backend,\n                vllm_config=self.vllm_config,\n                runtime_mode=CUDAGraphMode.PIECEWISE,\n                cudagraph_options=CUDAGraphOptions(\n                    debug_log_enable=piecewise_backend.is_first_graph,\n                    gc_disable=not piecewise_backend.is_first_graph,\n                    weak_ref_output=piecewise_backend.is_last_graph,\n                ),\n            )\n        else:\n            self.module.__dict__[target] = piecewise_backend\n\n        compilation_counter.num_piecewise_capturable_graphs_seen += 1\n\n    return output",
      "language": "python"
    },
    {
      "code": "388\n389\n390\n391\n392\n393\n394\n395",
      "language": "unknown"
    },
    {
      "code": "def run(self, *args):\n    # maybe instead just assert inputs are fake?\n    fake_args = [\n        self.fake_mode.from_tensor(t) if isinstance(t, torch.Tensor) else t\n        for t in args\n    ]\n    with self.fake_mode, enable_python_dispatcher():\n        return super().run(*fake_args)",
      "language": "python"
    },
    {
      "code": "def run(self, *args):\n    # maybe instead just assert inputs are fake?\n    fake_args = [\n        self.fake_mode.from_tensor(t) if isinstance(t, torch.Tensor) else t\n        for t in args\n    ]\n    with self.fake_mode, enable_python_dispatcher():\n        return super().run(*fake_args)",
      "language": "python"
    },
    {
      "code": "288\n289\n290\n291\n292\n293",
      "language": "unknown"
    },
    {
      "code": "@dataclasses.dataclass\nclass SplitItem:\n    submod_name: str\n    graph_id: int\n    is_splitting_graph: bool\n    graph: fx.GraphModule",
      "language": "python"
    },
    {
      "code": "@dataclasses.dataclass\nclass SplitItem:\n    submod_name: str\n    graph_id: int\n    is_splitting_graph: bool\n    graph: fx.GraphModule",
      "language": "python"
    },
    {
      "code": "graph: GraphModule",
      "language": "yaml"
    },
    {
      "code": "graph: GraphModule",
      "language": "yaml"
    },
    {
      "code": "graph_id: int",
      "language": "yaml"
    },
    {
      "code": "graph_id: int",
      "language": "yaml"
    },
    {
      "code": "is_splitting_graph: bool",
      "language": "yaml"
    },
    {
      "code": "is_splitting_graph: bool",
      "language": "yaml"
    },
    {
      "code": "submod_name: str",
      "language": "yaml"
    },
    {
      "code": "submod_name: str",
      "language": "yaml"
    },
    {
      "code": "__init__(\n    submod_name: str,\n    graph_id: int,\n    is_splitting_graph: bool,\n    graph: GraphModule,\n) -> None",
      "language": "python"
    },
    {
      "code": "__init__(\n    submod_name: str,\n    graph_id: int,\n    is_splitting_graph: bool,\n    graph: GraphModule,\n) -> None",
      "language": "python"
    },
    {
      "code": "489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741\n742\n743\n744\n745\n746\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783\n784\n785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\n800\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816\n817\n818\n819\n820\n821\n822\n823\n824\n825\n826\n827\n828\n829\n830\n831\n832\n833\n834\n835\n836\n837\n838\n839\n840",
      "language": "unknown"
    },
    {
      "code": "class VllmBackend:\n    \"\"\"The compilation backend for `torch.compile` with vLLM.\n    It is used for compilation mode of `CompilationMode.VLLM_COMPILE`,\n    where we customize the compilation.\n\n    The major work of this backend is to split the graph into\n    piecewise graphs, and pass them to the piecewise backend.\n\n    This backend also adds the PostGradPassManager to Inductor config,\n    which handles the post-grad passes.\n    \"\"\"\n\n    vllm_config: VllmConfig\n    compilation_config: CompilationConfig\n    _called: bool = False\n    # the graph we compiled\n    graph: fx.GraphModule\n    # the stiching graph module for all the piecewise graphs\n    split_gm: fx.GraphModule\n    piecewise_graphs: list[SplitItem]\n    returned_callable: Callable\n    # Inductor passes to run on the graph pre-defunctionalization\n    post_grad_passes: Sequence[Callable]\n    sym_tensor_indices: list[int]\n    input_buffers: list[torch.Tensor]\n    compiler_manager: CompilerManager\n    # Copy of CompilationConfig.inductor_compile_config +\n    # an entry for PostGradPassManager\n    inductor_config: dict[str, Any]\n\n    def __init__(\n        self,\n        vllm_config: VllmConfig,\n        prefix: str = \"\",\n        is_encoder: bool = False,\n    ):\n        # if the model is initialized with a non-empty prefix,\n        # then usually it's enough to use that prefix,\n        # e.g. language_model, vision_model, etc.\n        # when multiple parts are initialized as independent\n        # models, we need to use the model_tag to distinguish\n        # them, e.g. backbone (default), eagle_head, etc.\n        self.prefix = prefix or model_tag\n\n        # Mark compilation for encoder.\n        self.is_encoder = is_encoder or model_is_encoder\n\n        # Passes to run on the graph post-grad.\n        self.pass_manager = resolve_obj_by_qualname(\n            current_platform.get_pass_manager_cls()\n        )()\n        self.pass_key = current_platform.pass_key\n\n        self.sym_tensor_indices = []\n        self.input_buffers = []\n\n        self.vllm_config = vllm_config\n        self.compilation_config = vllm_config.compilation_config\n\n        self.compiler_manager: CompilerManager = CompilerManager(\n            self.compilation_config\n        )\n\n        # Deepcopy the inductor config to detach the post-grad custom pass\n        # from CompilationConfig.\n        # We want to avoid PostGradPassManager in CompilationConfig because\n        # in future we need PostGradPassManager.uuid() to be executed\n        # only at compile time.\n        self.inductor_config = deepcopy(self.compilation_config.inductor_compile_config)\n        # `torch.compile` is JIT compiled, so we don't need to\n        # do anything here\n\n    def configure_post_pass(self):\n        self.pass_manager.configure(self.vllm_config)\n\n        # Post-grad custom passes are run using the post_grad_custom_post_pass\n        # hook. If a pass for that hook exists, add it to the pass manager.\n        if self.pass_key in self.inductor_config:\n            if isinstance(self.inductor_config[self.pass_key], PostGradPassManager):\n                raise ValueError(\n                    \"PostGradPassManager can not be kept in CompilationConfig.\"\n                )\n            else:\n                # Config should automatically wrap all inductor passes\n                assert isinstance(\n                    self.compilation_config.inductor_compile_config[self.pass_key],\n                    InductorPass,\n                )\n                self.pass_manager.add(\n                    self.compilation_config.inductor_compile_config[self.pass_key]\n                )\n        self.inductor_config[self.pass_key] = self.pass_manager\n\n    def __call__(\n        self, graph: fx.GraphModule, example_inputs\n    ) -> VllmSerializableFunction:\n        vllm_config = self.vllm_config\n        # Minimal hashing here with existing utilities, reused below.\n\n        env_factors = envs.compile_factors()\n        env_hash = hash_factors(env_factors)\n        # Compute config/compiler/code hashes once and reuse\n        config_hash = vllm_config.compute_hash()\n        compiler_hash = self.compiler_manager.compute_hash(vllm_config)\n        forward_code_files = list(sorted(self.compilation_config.traced_files))\n\n        logger.debug(\n            \"Traced files (to be considered for compilation cache):\\n%s\",\n            lazy(lambda: \"\\n\".join(forward_code_files)),\n        )\n        hash_content = []\n        for filepath in forward_code_files:\n            hash_content.append(filepath)\n            if filepath == \"<string>\":\n                # This means the function was dynamically generated, with\n                # e.g. exec(). We can't actually check these.\n                continue\n            try:\n                with open(filepath) as f:\n                    hash_content.append(f.read())\n            except Exception:\n                logger.warning(\"Failed to read file %s\", filepath)\n                continue\n        code_hash = hashlib.sha256(\"\\n\".join(hash_content).encode()).hexdigest()\n        # Clear after consumption\n        self.compilation_config.traced_files.clear()\n        if not self.compilation_config.cache_dir:\n            # no provided cache dir, generate one based on the known factors\n            # that affects the compilation. if none of the factors change,\n            # the cache dir will be the same so that we can reuse the compiled\n            # graph.\n            factors = [env_hash, config_hash, code_hash, compiler_hash]\n            # Use SHA-256 for cache key hashing to be consistent across\n            # compute_hash functions. Truncate for a short cache dir name.\n            hash_key = hashlib.sha256(str(factors).encode()).hexdigest()[:10]\n            cache_dir = os.path.join(\n                envs.VLLM_CACHE_ROOT, \"torch_compile_cache\", hash_key\n            )\n            self.compilation_config.cache_dir = cache_dir\n\n        cache_dir = self.compilation_config.cache_dir\n        os.makedirs(cache_dir, exist_ok=True)\n        self.compilation_config.cache_dir = cache_dir\n        rank = vllm_config.parallel_config.rank\n        dp_rank = vllm_config.parallel_config.data_parallel_rank\n        local_cache_dir = os.path.join(cache_dir, f\"rank_{rank}_{dp_rank}\", self.prefix)\n        os.makedirs(local_cache_dir, exist_ok=True)\n        self.compilation_config.local_cache_dir = local_cache_dir\n\n        # Honors opt-outs such as CompilationMode.NONE or VLLM_DISABLE_COMPILE_CACHE.\n        disable_cache = not is_compile_cache_enabled(self.inductor_config)\n\n        if disable_cache:\n            logger.info_once(\"vLLM's torch.compile cache is disabled.\", scope=\"local\")\n        else:\n            logger.info_once(\n                \"Using cache directory: %s for vLLM's torch.compile\",\n                local_cache_dir,\n                scope=\"local\",\n            )\n\n        self.compiler_manager.initialize_cache(\n            local_cache_dir, disable_cache, self.prefix\n        )\n\n        # Reuses existing cache key\n\n        logger.debug(\n            \"torch.compile cache factors: env=%s cfg=%s comp=%s code=%s dir=%s\",\n            env_hash,\n            config_hash,\n            compiler_hash,\n            code_hash,\n            local_cache_dir,\n        )\n\n        # Persist and log only hash-relevant factors together.\n        try:\n            logger.debug(\n                \"Compile env factors (raw):\\n%s\\nVllm config hash: %s\",\n                lazy(partial(pprint.pformat, env_factors, width=120)),\n                config_hash,\n            )\n            meta_path = os.path.join(local_cache_dir, \"cache_key_factors.json\")\n            if not os.path.exists(meta_path):\n                with open(meta_path, \"w\") as f:\n                    json.dump(\n                        {\n                            \"env\": env_factors,  # raw factors used for env_hash\n                            \"config_hash\": config_hash,\n                            \"code_hash\": code_hash,\n                            \"compiler_hash\": compiler_hash,\n                        },\n                        f,\n                        indent=2,\n                        sort_keys=True,\n                    )\n        except Exception:\n            # Best-effort only; metadata write failures are non-fatal.\n            logger.warning(\n                (\n                    \"Could not write compile cache metadata at %s; continuing without \"\n                    \"metadata. Compiled cache remains valid; diagnostics may be \"\n                    \"limited.\"\n                ),\n                local_cache_dir,\n                exc_info=True,\n            )\n\n        # when dynamo calls the backend, it means the bytecode\n        # transform and analysis are done\n        compilation_counter.num_graphs_seen += 1\n        from .monitor import torch_compile_start_time\n\n        dynamo_time = time.time() - torch_compile_start_time\n        logger.info_once(\n            \"Dynamo bytecode transform time: %.2f s\", dynamo_time, scope=\"local\"\n        )\n        self.compilation_config.compilation_time += dynamo_time\n\n        # we control the compilation process, each instance can only be\n        # called once\n        assert not self._called, \"VllmBackend can only be called once\"\n\n        self.graph = graph\n        self.configure_post_pass()\n\n        if self.compilation_config.use_inductor_graph_partition:\n            # Let Inductor decide partitioning; avoid FX-level pre-splitting.\n            fx_split_ops: list[str] = []\n        else:\n            fx_split_ops = self.compilation_config.splitting_ops or []\n\n        self.split_gm, self.piecewise_graphs = split_graph(graph, fx_split_ops)\n\n        from torch._dynamo.utils import lazy_format_graph_code\n\n        # depyf will hook lazy_format_graph_code and dump the graph\n        # for debugging, no need to print the graph here\n        lazy_format_graph_code(\"before split\", self.graph)\n        lazy_format_graph_code(\"after split\", self.split_gm)\n\n        compilation_counter.num_piecewise_graphs_seen += len(self.piecewise_graphs)\n        submod_names_to_compile = [\n            item.submod_name\n            for item in self.piecewise_graphs\n            if not item.is_splitting_graph\n        ]\n\n        # Extract fake values from the graph to use them when needed.\n        all_fake_values = []\n        for i in graph.graph.find_nodes(op=\"placeholder\"):\n            all_fake_values.append(i.meta[\"example_value\"])\n\n        fake_args = [\n            all_fake_values[i] if isinstance(t, torch.Tensor) else t\n            for i, t in enumerate(example_inputs)\n        ]\n\n        # propagate the split graph to the piecewise backend,\n        # compile submodules with symbolic shapes\n        PiecewiseCompileInterpreter(\n            self.split_gm, submod_names_to_compile, self.vllm_config, self\n        ).run(*fake_args)\n\n        from torch._guards import detect_fake_mode\n\n        fake_mode = detect_fake_mode()\n\n        if (\n            self.compilation_config.dynamic_shapes_config.evaluate_guards\n            and self.compilation_config.dynamic_shapes_config.type\n            == DynamicShapesType.BACKED\n        ):\n            from torch.utils._sympy.value_ranges import ValueRanges\n\n            # Drop counter-0/1 specializations guards; for backed dynamic shapes,\n            # torch.compile will specialize for 0/1 inputs or otherwise guards that\n            # shape is >= 2. This is because it's really hard not to hit a check\n            # against 0/1. When we evaluate shape guards, we exclude checking those\n            # guards (We would fail always otherwise).\n\n            # We avoid that by updating the ranges of backed sizes when the min is\n            # 2 for any, we assume it's 0.\n            for s, r in fake_mode.shape_env.var_to_range.items():\n                if r.lower == 2:\n                    fake_mode.shape_env.var_to_range[s] = ValueRanges(0, r.upper)\n\n        graph_path = os.path.join(local_cache_dir, \"computation_graph.py\")\n        if not os.path.exists(graph_path):\n            # code adapted from\n            # https://github.com/thuml/depyf/blob/dab831108a752d1facc00acdd6d4243891845c37/depyf/explain/patched_lazy_format_graph_code.py#L30\n            # use `print_readable` because it can include submodules\n            src = (\n                \"from __future__ import annotations\\nimport torch\\n\"\n                + self.split_gm.print_readable(print_output=False)\n            )\n            src = src.replace(\"<lambda>\", \"GraphModule\")\n            with open(graph_path, \"w\") as f:\n                f.write(src)\n\n            logger.debug_once(\n                \"Computation graph saved to %s\", graph_path, scope=\"local\"\n            )\n\n        self._called = True\n\n        if (\n            self.compilation_config.cudagraph_mode == CUDAGraphMode.NONE\n            or not self.compilation_config.cudagraph_copy_inputs\n        ):\n            return VllmSerializableFunction(\n                graph, example_inputs, self.prefix, self.split_gm, self.is_encoder\n            )\n\n        # index of tensors that have symbolic shapes (batch size)\n        # for weights and static buffers, they will have concrete shapes.\n        # symbolic shape only happens for input tensors.\n        from torch.fx.experimental.symbolic_shapes import is_symbolic\n\n        self.sym_tensor_indices = [\n            i\n            for i, x in enumerate(fake_args)\n            if isinstance(x, torch._subclasses.fake_tensor.FakeTensor)\n            and any(is_symbolic(d) for d in x.size())\n        ]\n\n        # compiler managed cudagraph input buffers\n        # we assume the first run with symbolic shapes\n        # has the maximum size among all the tensors\n        self.input_buffers = [\n            example_inputs[x].clone() for x in self.sym_tensor_indices\n        ]\n\n        # this is the callable we return to Dynamo to run\n        def copy_and_call(*args):\n            list_args = list(args)\n            for i, index in enumerate(self.sym_tensor_indices):\n                runtime_tensor = list_args[index]\n                runtime_shape = runtime_tensor.shape[0]\n                static_tensor = self.input_buffers[i][:runtime_shape]\n\n                # copy the tensor to the static buffer\n                static_tensor.copy_(runtime_tensor)\n\n                # replace the tensor in the list_args to the static buffer\n                list_args[index] = static_tensor\n            return self.split_gm(*list_args)\n\n        return VllmSerializableFunction(\n            graph, example_inputs, self.prefix, copy_and_call, self.is_encoder\n        )",
      "language": "python"
    },
    {
      "code": "class VllmBackend:\n    \"\"\"The compilation backend for `torch.compile` with vLLM.\n    It is used for compilation mode of `CompilationMode.VLLM_COMPILE`,\n    where we customize the compilation.\n\n    The major work of this backend is to split the graph into\n    piecewise graphs, and pass them to the piecewise backend.\n\n    This backend also adds the PostGradPassManager to Inductor config,\n    which handles the post-grad passes.\n    \"\"\"\n\n    vllm_config: VllmConfig\n    compilation_config: CompilationConfig\n    _called: bool = False\n    # the graph we compiled\n    graph: fx.GraphModule\n    # the stiching graph module for all the piecewise graphs\n    split_gm: fx.GraphModule\n    piecewise_graphs: list[SplitItem]\n    returned_callable: Callable\n    # Inductor passes to run on the graph pre-defunctionalization\n    post_grad_passes: Sequence[Callable]\n    sym_tensor_indices: list[int]\n    input_buffers: list[torch.Tensor]\n    compiler_manager: CompilerManager\n    # Copy of CompilationConfig.inductor_compile_config +\n    # an entry for PostGradPassManager\n    inductor_config: dict[str, Any]\n\n    def __init__(\n        self,\n        vllm_config: VllmConfig,\n        prefix: str = \"\",\n        is_encoder: bool = False,\n    ):\n        # if the model is initialized with a non-empty prefix,\n        # then usually it's enough to use that prefix,\n        # e.g. language_model, vision_model, etc.\n        # when multiple parts are initialized as independent\n        # models, we need to use the model_tag to distinguish\n        # them, e.g. backbone (default), eagle_head, etc.\n        self.prefix = prefix or model_tag\n\n        # Mark compilation for encoder.\n        self.is_encoder = is_encoder or model_is_encoder\n\n        # Passes to run on the graph post-grad.\n        self.pass_manager = resolve_obj_by_qualname(\n            current_platform.get_pass_manager_cls()\n        )()\n        self.pass_key = current_platform.pass_key\n\n        self.sym_tensor_indices = []\n        self.input_buffers = []\n\n        self.vllm_config = vllm_config\n        self.compilation_config = vllm_config.compilation_config\n\n        self.compiler_manager: CompilerManager = CompilerManager(\n            self.compilation_config\n        )\n\n        # Deepcopy the inductor config to detach the post-grad custom pass\n        # from CompilationConfig.\n        # We want to avoid PostGradPassManager in CompilationConfig because\n        # in future we need PostGradPassManager.uuid() to be executed\n        # only at compile time.\n        self.inductor_config = deepcopy(self.compilation_config.inductor_compile_config)\n        # `torch.compile` is JIT compiled, so we don't need to\n        # do anything here\n\n    def configure_post_pass(self):\n        self.pass_manager.configure(self.vllm_config)\n\n        # Post-grad custom passes are run using the post_grad_custom_post_pass\n        # hook. If a pass for that hook exists, add it to the pass manager.\n        if self.pass_key in self.inductor_config:\n            if isinstance(self.inductor_config[self.pass_key], PostGradPassManager):\n                raise ValueError(\n                    \"PostGradPassManager can not be kept in CompilationConfig.\"\n                )\n            else:\n                # Config should automatically wrap all inductor passes\n                assert isinstance(\n                    self.compilation_config.inductor_compile_config[self.pass_key],\n                    InductorPass,\n                )\n                self.pass_manager.add(\n                    self.compilation_config.inductor_compile_config[self.pass_key]\n                )\n        self.inductor_config[self.pass_key] = self.pass_manager\n\n    def __call__(\n        self, graph: fx.GraphModule, example_inputs\n    ) -> VllmSerializableFunction:\n        vllm_config = self.vllm_config\n        # Minimal hashing here with existing utilities, reused below.\n\n        env_factors = envs.compile_factors()\n        env_hash = hash_factors(env_factors)\n        # Compute config/compiler/code hashes once and reuse\n        config_hash = vllm_config.compute_hash()\n        compiler_hash = self.compiler_manager.compute_hash(vllm_config)\n        forward_code_files = list(sorted(self.compilation_config.traced_files))\n\n        logger.debug(\n            \"Traced files (to be considered for compilation cache):\\n%s\",\n            lazy(lambda: \"\\n\".join(forward_code_files)),\n        )\n        hash_content = []\n        for filepath in forward_code_files:\n            hash_content.append(filepath)\n            if filepath == \"<string>\":\n                # This means the function was dynamically generated, with\n                # e.g. exec(). We can't actually check these.\n                continue\n            try:\n                with open(filepath) as f:\n                    hash_content.append(f.read())\n            except Exception:\n                logger.warning(\"Failed to read file %s\", filepath)\n                continue\n        code_hash = hashlib.sha256(\"\\n\".join(hash_content).encode()).hexdigest()\n        # Clear after consumption\n        self.compilation_config.traced_files.clear()\n        if not self.compilation_config.cache_dir:\n            # no provided cache dir, generate one based on the known factors\n            # that affects the compilation. if none of the factors change,\n            # the cache dir will be the same so that we can reuse the compiled\n            # graph.\n            factors = [env_hash, config_hash, code_hash, compiler_hash]\n            # Use SHA-256 for cache key hashing to be consistent across\n            # compute_hash functions. Truncate for a short cache dir name.\n            hash_key = hashlib.sha256(str(factors).encode()).hexdigest()[:10]\n            cache_dir = os.path.join(\n                envs.VLLM_CACHE_ROOT, \"torch_compile_cache\", hash_key\n            )\n            self.compilation_config.cache_dir = cache_dir\n\n        cache_dir = self.compilation_config.cache_dir\n        os.makedirs(cache_dir, exist_ok=True)\n        self.compilation_config.cache_dir = cache_dir\n        rank = vllm_config.parallel_config.rank\n        dp_rank = vllm_config.parallel_config.data_parallel_rank\n        local_cache_dir = os.path.join(cache_dir, f\"rank_{rank}_{dp_rank}\", self.prefix)\n        os.makedirs(local_cache_dir, exist_ok=True)\n        self.compilation_config.local_cache_dir = local_cache_dir\n\n        # Honors opt-outs such as CompilationMode.NONE or VLLM_DISABLE_COMPILE_CACHE.\n        disable_cache = not is_compile_cache_enabled(self.inductor_config)\n\n        if disable_cache:\n            logger.info_once(\"vLLM's torch.compile cache is disabled.\", scope=\"local\")\n        else:\n            logger.info_once(\n                \"Using cache directory: %s for vLLM's torch.compile\",\n                local_cache_dir,\n                scope=\"local\",\n            )\n\n        self.compiler_manager.initialize_cache(\n            local_cache_dir, disable_cache, self.prefix\n        )\n\n        # Reuses existing cache key\n\n        logger.debug(\n            \"torch.compile cache factors: env=%s cfg=%s comp=%s code=%s dir=%s\",\n            env_hash,\n            config_hash,\n            compiler_hash,\n            code_hash,\n            local_cache_dir,\n        )\n\n        # Persist and log only hash-relevant factors together.\n        try:\n            logger.debug(\n                \"Compile env factors (raw):\\n%s\\nVllm config hash: %s\",\n                lazy(partial(pprint.pformat, env_factors, width=120)),\n                config_hash,\n            )\n            meta_path = os.path.join(local_cache_dir, \"cache_key_factors.json\")\n            if not os.path.exists(meta_path):\n                with open(meta_path, \"w\") as f:\n                    json.dump(\n                        {\n                            \"env\": env_factors,  # raw factors used for env_hash\n                            \"config_hash\": config_hash,\n                            \"code_hash\": code_hash,\n                            \"compiler_hash\": compiler_hash,\n                        },\n                        f,\n                        indent=2,\n                        sort_keys=True,\n                    )\n        except Exception:\n            # Best-effort only; metadata write failures are non-fatal.\n            logger.warning(\n                (\n                    \"Could not write compile cache metadata at %s; continuing without \"\n                    \"metadata. Compiled cache remains valid; diagnostics may be \"\n                    \"limited.\"\n                ),\n                local_cache_dir,\n                exc_info=True,\n            )\n\n        # when dynamo calls the backend, it means the bytecode\n        # transform and analysis are done\n        compilation_counter.num_graphs_seen += 1\n        from .monitor import torch_compile_start_time\n\n        dynamo_time = time.time() - torch_compile_start_time\n        logger.info_once(\n            \"Dynamo bytecode transform time: %.2f s\", dynamo_time, scope=\"local\"\n        )\n        self.compilation_config.compilation_time += dynamo_time\n\n        # we control the compilation process, each instance can only be\n        # called once\n        assert not self._called, \"VllmBackend can only be called once\"\n\n        self.graph = graph\n        self.configure_post_pass()\n\n        if self.compilation_config.use_inductor_graph_partition:\n            # Let Inductor decide partitioning; avoid FX-level pre-splitting.\n            fx_split_ops: list[str] = []\n        else:\n            fx_split_ops = self.compilation_config.splitting_ops or []\n\n        self.split_gm, self.piecewise_graphs = split_graph(graph, fx_split_ops)\n\n        from torch._dynamo.utils import lazy_format_graph_code\n\n        # depyf will hook lazy_format_graph_code and dump the graph\n        # for debugging, no need to print the graph here\n        lazy_format_graph_code(\"before split\", self.graph)\n        lazy_format_graph_code(\"after split\", self.split_gm)\n\n        compilation_counter.num_piecewise_graphs_seen += len(self.piecewise_graphs)\n        submod_names_to_compile = [\n            item.submod_name\n            for item in self.piecewise_graphs\n            if not item.is_splitting_graph\n        ]\n\n        # Extract fake values from the graph to use them when needed.\n        all_fake_values = []\n        for i in graph.graph.find_nodes(op=\"placeholder\"):\n            all_fake_values.append(i.meta[\"example_value\"])\n\n        fake_args = [\n            all_fake_values[i] if isinstance(t, torch.Tensor) else t\n            for i, t in enumerate(example_inputs)\n        ]\n\n        # propagate the split graph to the piecewise backend,\n        # compile submodules with symbolic shapes\n        PiecewiseCompileInterpreter(\n            self.split_gm, submod_names_to_compile, self.vllm_config, self\n        ).run(*fake_args)\n\n        from torch._guards import detect_fake_mode\n\n        fake_mode = detect_fake_mode()\n\n        if (\n            self.compilation_config.dynamic_shapes_config.evaluate_guards\n            and self.compilation_config.dynamic_shapes_config.type\n            == DynamicShapesType.BACKED\n        ):\n            from torch.utils._sympy.value_ranges import ValueRanges\n\n            # Drop counter-0/1 specializations guards; for backed dynamic shapes,\n            # torch.compile will specialize for 0/1 inputs or otherwise guards that\n            # shape is >= 2. This is because it's really hard not to hit a check\n            # against 0/1. When we evaluate shape guards, we exclude checking those\n            # guards (We would fail always otherwise).\n\n            # We avoid that by updating the ranges of backed sizes when the min is\n            # 2 for any, we assume it's 0.\n            for s, r in fake_mode.shape_env.var_to_range.items():\n                if r.lower == 2:\n                    fake_mode.shape_env.var_to_range[s] = ValueRanges(0, r.upper)\n\n        graph_path = os.path.join(local_cache_dir, \"computation_graph.py\")\n        if not os.path.exists(graph_path):\n            # code adapted from\n            # https://github.com/thuml/depyf/blob/dab831108a752d1facc00acdd6d4243891845c37/depyf/explain/patched_lazy_format_graph_code.py#L30\n            # use `print_readable` because it can include submodules\n            src = (\n                \"from __future__ import annotations\\nimport torch\\n\"\n                + self.split_gm.print_readable(print_output=False)\n            )\n            src = src.replace(\"<lambda>\", \"GraphModule\")\n            with open(graph_path, \"w\") as f:\n                f.write(src)\n\n            logger.debug_once(\n                \"Computation graph saved to %s\", graph_path, scope=\"local\"\n            )\n\n        self._called = True\n\n        if (\n            self.compilation_config.cudagraph_mode == CUDAGraphMode.NONE\n            or not self.compilation_config.cudagraph_copy_inputs\n        ):\n            return VllmSerializableFunction(\n                graph, example_inputs, self.prefix, self.split_gm, self.is_encoder\n            )\n\n        # index of tensors that have symbolic shapes (batch size)\n        # for weights and static buffers, they will have concrete shapes.\n        # symbolic shape only happens for input tensors.\n        from torch.fx.experimental.symbolic_shapes import is_symbolic\n\n        self.sym_tensor_indices = [\n            i\n            for i, x in enumerate(fake_args)\n            if isinstance(x, torch._subclasses.fake_tensor.FakeTensor)\n            and any(is_symbolic(d) for d in x.size())\n        ]\n\n        # compiler managed cudagraph input buffers\n        # we assume the first run with symbolic shapes\n        # has the maximum size among all the tensors\n        self.input_buffers = [\n            example_inputs[x].clone() for x in self.sym_tensor_indices\n        ]\n\n        # this is the callable we return to Dynamo to run\n        def copy_and_call(*args):\n            list_args = list(args)\n            for i, index in enumerate(self.sym_tensor_indices):\n                runtime_tensor = list_args[index]\n                runtime_shape = runtime_tensor.shape[0]\n                static_tensor = self.input_buffers[i][:runtime_shape]\n\n                # copy the tensor to the static buffer\n                static_tensor.copy_(runtime_tensor)\n\n                # replace the tensor in the list_args to the static buffer\n                list_args[index] = static_tensor\n            return self.split_gm(*list_args)\n\n        return VllmSerializableFunction(\n            graph, example_inputs, self.prefix, copy_and_call, self.is_encoder\n        )",
      "language": "python"
    },
    {
      "code": "_called: bool = False",
      "language": "typescript"
    },
    {
      "code": "_called: bool = False",
      "language": "typescript"
    },
    {
      "code": "compilation_config: CompilationConfig = compilation_config",
      "language": "typescript"
    },
    {
      "code": "compilation_config: CompilationConfig = compilation_config",
      "language": "typescript"
    },
    {
      "code": "compiler_manager: CompilerManager = CompilerManager(\n    compilation_config\n)",
      "language": "typescript"
    },
    {
      "code": "compiler_manager: CompilerManager = CompilerManager(\n    compilation_config\n)",
      "language": "typescript"
    },
    {
      "code": "graph: GraphModule",
      "language": "yaml"
    },
    {
      "code": "graph: GraphModule",
      "language": "yaml"
    },
    {
      "code": "inductor_config: dict[str, Any] = deepcopy(\n    inductor_compile_config\n)",
      "language": "yaml"
    },
    {
      "code": "inductor_config: dict[str, Any] = deepcopy(\n    inductor_compile_config\n)",
      "language": "yaml"
    },
    {
      "code": "input_buffers: list[Tensor] = []",
      "language": "yaml"
    },
    {
      "code": "input_buffers: list[Tensor] = []",
      "language": "yaml"
    },
    {
      "code": "is_encoder = is_encoder or model_is_encoder",
      "language": "unknown"
    },
    {
      "code": "is_encoder = is_encoder or model_is_encoder",
      "language": "unknown"
    },
    {
      "code": "pass_key = pass_key",
      "language": "unknown"
    },
    {
      "code": "pass_key = pass_key",
      "language": "unknown"
    },
    {
      "code": "pass_manager = resolve_obj_by_qualname(\n    get_pass_manager_cls()\n)()",
      "language": "unknown"
    },
    {
      "code": "pass_manager = resolve_obj_by_qualname(\n    get_pass_manager_cls()\n)()",
      "language": "unknown"
    },
    {
      "code": "piecewise_graphs: list[SplitItem]",
      "language": "yaml"
    },
    {
      "code": "piecewise_graphs: list[SplitItem]",
      "language": "yaml"
    },
    {
      "code": "post_grad_passes: Sequence[Callable]",
      "language": "yaml"
    },
    {
      "code": "post_grad_passes: Sequence[Callable]",
      "language": "yaml"
    },
    {
      "code": "prefix = prefix or model_tag",
      "language": "unknown"
    },
    {
      "code": "prefix = prefix or model_tag",
      "language": "unknown"
    },
    {
      "code": "returned_callable: Callable",
      "language": "yaml"
    },
    {
      "code": "returned_callable: Callable",
      "language": "yaml"
    },
    {
      "code": "split_gm: GraphModule",
      "language": "yaml"
    },
    {
      "code": "split_gm: GraphModule",
      "language": "yaml"
    },
    {
      "code": "sym_tensor_indices: list[int] = []",
      "language": "yaml"
    },
    {
      "code": "sym_tensor_indices: list[int] = []",
      "language": "yaml"
    },
    {
      "code": "vllm_config: VllmConfig = vllm_config",
      "language": "typescript"
    },
    {
      "code": "vllm_config: VllmConfig = vllm_config",
      "language": "typescript"
    },
    {
      "code": "__call__(\n    graph: GraphModule, example_inputs\n) -> VllmSerializableFunction",
      "language": "php"
    },
    {
      "code": "__call__(\n    graph: GraphModule, example_inputs\n) -> VllmSerializableFunction",
      "language": "php"
    },
    {
      "code": "582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741\n742\n743\n744\n745\n746\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783\n784\n785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\n800\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816\n817\n818\n819\n820\n821\n822\n823\n824\n825\n826\n827\n828\n829\n830\n831\n832\n833\n834\n835\n836\n837\n838\n839\n840",
      "language": "unknown"
    },
    {
      "code": "def __call__(\n    self, graph: fx.GraphModule, example_inputs\n) -> VllmSerializableFunction:\n    vllm_config = self.vllm_config\n    # Minimal hashing here with existing utilities, reused below.\n\n    env_factors = envs.compile_factors()\n    env_hash = hash_factors(env_factors)\n    # Compute config/compiler/code hashes once and reuse\n    config_hash = vllm_config.compute_hash()\n    compiler_hash = self.compiler_manager.compute_hash(vllm_config)\n    forward_code_files = list(sorted(self.compilation_config.traced_files))\n\n    logger.debug(\n        \"Traced files (to be considered for compilation cache):\\n%s\",\n        lazy(lambda: \"\\n\".join(forward_code_files)),\n    )\n    hash_content = []\n    for filepath in forward_code_files:\n        hash_content.append(filepath)\n        if filepath == \"<string>\":\n            # This means the function was dynamically generated, with\n            # e.g. exec(). We can't actually check these.\n            continue\n        try:\n            with open(filepath) as f:\n                hash_content.append(f.read())\n        except Exception:\n            logger.warning(\"Failed to read file %s\", filepath)\n            continue\n    code_hash = hashlib.sha256(\"\\n\".join(hash_content).encode()).hexdigest()\n    # Clear after consumption\n    self.compilation_config.traced_files.clear()\n    if not self.compilation_config.cache_dir:\n        # no provided cache dir, generate one based on the known factors\n        # that affects the compilation. if none of the factors change,\n        # the cache dir will be the same so that we can reuse the compiled\n        # graph.\n        factors = [env_hash, config_hash, code_hash, compiler_hash]\n        # Use SHA-256 for cache key hashing to be consistent across\n        # compute_hash functions. Truncate for a short cache dir name.\n        hash_key = hashlib.sha256(str(factors).encode()).hexdigest()[:10]\n        cache_dir = os.path.join(\n            envs.VLLM_CACHE_ROOT, \"torch_compile_cache\", hash_key\n        )\n        self.compilation_config.cache_dir = cache_dir\n\n    cache_dir = self.compilation_config.cache_dir\n    os.makedirs(cache_dir, exist_ok=True)\n    self.compilation_config.cache_dir = cache_dir\n    rank = vllm_config.parallel_config.rank\n    dp_rank = vllm_config.parallel_config.data_parallel_rank\n    local_cache_dir = os.path.join(cache_dir, f\"rank_{rank}_{dp_rank}\", self.prefix)\n    os.makedirs(local_cache_dir, exist_ok=True)\n    self.compilation_config.local_cache_dir = local_cache_dir\n\n    # Honors opt-outs such as CompilationMode.NONE or VLLM_DISABLE_COMPILE_CACHE.\n    disable_cache = not is_compile_cache_enabled(self.inductor_config)\n\n    if disable_cache:\n        logger.info_once(\"vLLM's torch.compile cache is disabled.\", scope=\"local\")\n    else:\n        logger.info_once(\n            \"Using cache directory: %s for vLLM's torch.compile\",\n            local_cache_dir,\n            scope=\"local\",\n        )\n\n    self.compiler_manager.initialize_cache(\n        local_cache_dir, disable_cache, self.prefix\n    )\n\n    # Reuses existing cache key\n\n    logger.debug(\n        \"torch.compile cache factors: env=%s cfg=%s comp=%s code=%s dir=%s\",\n        env_hash,\n        config_hash,\n        compiler_hash,\n        code_hash,\n        local_cache_dir,\n    )\n\n    # Persist and log only hash-relevant factors together.\n    try:\n        logger.debug(\n            \"Compile env factors (raw):\\n%s\\nVllm config hash: %s\",\n            lazy(partial(pprint.pformat, env_factors, width=120)),\n            config_hash,\n        )\n        meta_path = os.path.join(local_cache_dir, \"cache_key_factors.json\")\n        if not os.path.exists(meta_path):\n            with open(meta_path, \"w\") as f:\n                json.dump(\n                    {\n                        \"env\": env_factors,  # raw factors used for env_hash\n                        \"config_hash\": config_hash,\n                        \"code_hash\": code_hash,\n                        \"compiler_hash\": compiler_hash,\n                    },\n                    f,\n                    indent=2,\n                    sort_keys=True,\n                )\n    except Exception:\n        # Best-effort only; metadata write failures are non-fatal.\n        logger.warning(\n            (\n                \"Could not write compile cache metadata at %s; continuing without \"\n                \"metadata. Compiled cache remains valid; diagnostics may be \"\n                \"limited.\"\n            ),\n            local_cache_dir,\n            exc_info=True,\n        )\n\n    # when dynamo calls the backend, it means the bytecode\n    # transform and analysis are done\n    compilation_counter.num_graphs_seen += 1\n    from .monitor import torch_compile_start_time\n\n    dynamo_time = time.time() - torch_compile_start_time\n    logger.info_once(\n        \"Dynamo bytecode transform time: %.2f s\", dynamo_time, scope=\"local\"\n    )\n    self.compilation_config.compilation_time += dynamo_time\n\n    # we control the compilation process, each instance can only be\n    # called once\n    assert not self._called, \"VllmBackend can only be called once\"\n\n    self.graph = graph\n    self.configure_post_pass()\n\n    if self.compilation_config.use_inductor_graph_partition:\n        # Let Inductor decide partitioning; avoid FX-level pre-splitting.\n        fx_split_ops: list[str] = []\n    else:\n        fx_split_ops = self.compilation_config.splitting_ops or []\n\n    self.split_gm, self.piecewise_graphs = split_graph(graph, fx_split_ops)\n\n    from torch._dynamo.utils import lazy_format_graph_code\n\n    # depyf will hook lazy_format_graph_code and dump the graph\n    # for debugging, no need to print the graph here\n    lazy_format_graph_code(\"before split\", self.graph)\n    lazy_format_graph_code(\"after split\", self.split_gm)\n\n    compilation_counter.num_piecewise_graphs_seen += len(self.piecewise_graphs)\n    submod_names_to_compile = [\n        item.submod_name\n        for item in self.piecewise_graphs\n        if not item.is_splitting_graph\n    ]\n\n    # Extract fake values from the graph to use them when needed.\n    all_fake_values = []\n    for i in graph.graph.find_nodes(op=\"placeholder\"):\n        all_fake_values.append(i.meta[\"example_value\"])\n\n    fake_args = [\n        all_fake_values[i] if isinstance(t, torch.Tensor) else t\n        for i, t in enumerate(example_inputs)\n    ]\n\n    # propagate the split graph to the piecewise backend,\n    # compile submodules with symbolic shapes\n    PiecewiseCompileInterpreter(\n        self.split_gm, submod_names_to_compile, self.vllm_config, self\n    ).run(*fake_args)\n\n    from torch._guards import detect_fake_mode\n\n    fake_mode = detect_fake_mode()\n\n    if (\n        self.compilation_config.dynamic_shapes_config.evaluate_guards\n        and self.compilation_config.dynamic_shapes_config.type\n        == DynamicShapesType.BACKED\n    ):\n        from torch.utils._sympy.value_ranges import ValueRanges\n\n        # Drop counter-0/1 specializations guards; for backed dynamic shapes,\n        # torch.compile will specialize for 0/1 inputs or otherwise guards that\n        # shape is >= 2. This is because it's really hard not to hit a check\n        # against 0/1. When we evaluate shape guards, we exclude checking those\n        # guards (We would fail always otherwise).\n\n        # We avoid that by updating the ranges of backed sizes when the min is\n        # 2 for any, we assume it's 0.\n        for s, r in fake_mode.shape_env.var_to_range.items():\n            if r.lower == 2:\n                fake_mode.shape_env.var_to_range[s] = ValueRanges(0, r.upper)\n\n    graph_path = os.path.join(local_cache_dir, \"computation_graph.py\")\n    if not os.path.exists(graph_path):\n        # code adapted from\n        # https://github.com/thuml/depyf/blob/dab831108a752d1facc00acdd6d4243891845c37/depyf/explain/patched_lazy_format_graph_code.py#L30\n        # use `print_readable` because it can include submodules\n        src = (\n            \"from __future__ import annotations\\nimport torch\\n\"\n            + self.split_gm.print_readable(print_output=False)\n        )\n        src = src.replace(\"<lambda>\", \"GraphModule\")\n        with open(graph_path, \"w\") as f:\n            f.write(src)\n\n        logger.debug_once(\n            \"Computation graph saved to %s\", graph_path, scope=\"local\"\n        )\n\n    self._called = True\n\n    if (\n        self.compilation_config.cudagraph_mode == CUDAGraphMode.NONE\n        or not self.compilation_config.cudagraph_copy_inputs\n    ):\n        return VllmSerializableFunction(\n            graph, example_inputs, self.prefix, self.split_gm, self.is_encoder\n        )\n\n    # index of tensors that have symbolic shapes (batch size)\n    # for weights and static buffers, they will have concrete shapes.\n    # symbolic shape only happens for input tensors.\n    from torch.fx.experimental.symbolic_shapes import is_symbolic\n\n    self.sym_tensor_indices = [\n        i\n        for i, x in enumerate(fake_args)\n        if isinstance(x, torch._subclasses.fake_tensor.FakeTensor)\n        and any(is_symbolic(d) for d in x.size())\n    ]\n\n    # compiler managed cudagraph input buffers\n    # we assume the first run with symbolic shapes\n    # has the maximum size among all the tensors\n    self.input_buffers = [\n        example_inputs[x].clone() for x in self.sym_tensor_indices\n    ]\n\n    # this is the callable we return to Dynamo to run\n    def copy_and_call(*args):\n        list_args = list(args)\n        for i, index in enumerate(self.sym_tensor_indices):\n            runtime_tensor = list_args[index]\n            runtime_shape = runtime_tensor.shape[0]\n            static_tensor = self.input_buffers[i][:runtime_shape]\n\n            # copy the tensor to the static buffer\n            static_tensor.copy_(runtime_tensor)\n\n            # replace the tensor in the list_args to the static buffer\n            list_args[index] = static_tensor\n        return self.split_gm(*list_args)\n\n    return VllmSerializableFunction(\n        graph, example_inputs, self.prefix, copy_and_call, self.is_encoder\n    )",
      "language": "python"
    },
    {
      "code": "def __call__(\n    self, graph: fx.GraphModule, example_inputs\n) -> VllmSerializableFunction:\n    vllm_config = self.vllm_config\n    # Minimal hashing here with existing utilities, reused below.\n\n    env_factors = envs.compile_factors()\n    env_hash = hash_factors(env_factors)\n    # Compute config/compiler/code hashes once and reuse\n    config_hash = vllm_config.compute_hash()\n    compiler_hash = self.compiler_manager.compute_hash(vllm_config)\n    forward_code_files = list(sorted(self.compilation_config.traced_files))\n\n    logger.debug(\n        \"Traced files (to be considered for compilation cache):\\n%s\",\n        lazy(lambda: \"\\n\".join(forward_code_files)),\n    )\n    hash_content = []\n    for filepath in forward_code_files:\n        hash_content.append(filepath)\n        if filepath == \"<string>\":\n            # This means the function was dynamically generated, with\n            # e.g. exec(). We can't actually check these.\n            continue\n        try:\n            with open(filepath) as f:\n                hash_content.append(f.read())\n        except Exception:\n            logger.warning(\"Failed to read file %s\", filepath)\n            continue\n    code_hash = hashlib.sha256(\"\\n\".join(hash_content).encode()).hexdigest()\n    # Clear after consumption\n    self.compilation_config.traced_files.clear()\n    if not self.compilation_config.cache_dir:\n        # no provided cache dir, generate one based on the known factors\n        # that affects the compilation. if none of the factors change,\n        # the cache dir will be the same so that we can reuse the compiled\n        # graph.\n        factors = [env_hash, config_hash, code_hash, compiler_hash]\n        # Use SHA-256 for cache key hashing to be consistent across\n        # compute_hash functions. Truncate for a short cache dir name.\n        hash_key = hashlib.sha256(str(factors).encode()).hexdigest()[:10]\n        cache_dir = os.path.join(\n            envs.VLLM_CACHE_ROOT, \"torch_compile_cache\", hash_key\n        )\n        self.compilation_config.cache_dir = cache_dir\n\n    cache_dir = self.compilation_config.cache_dir\n    os.makedirs(cache_dir, exist_ok=True)\n    self.compilation_config.cache_dir = cache_dir\n    rank = vllm_config.parallel_config.rank\n    dp_rank = vllm_config.parallel_config.data_parallel_rank\n    local_cache_dir = os.path.join(cache_dir, f\"rank_{rank}_{dp_rank}\", self.prefix)\n    os.makedirs(local_cache_dir, exist_ok=True)\n    self.compilation_config.local_cache_dir = local_cache_dir\n\n    # Honors opt-outs such as CompilationMode.NONE or VLLM_DISABLE_COMPILE_CACHE.\n    disable_cache = not is_compile_cache_enabled(self.inductor_config)\n\n    if disable_cache:\n        logger.info_once(\"vLLM's torch.compile cache is disabled.\", scope=\"local\")\n    else:\n        logger.info_once(\n            \"Using cache directory: %s for vLLM's torch.compile\",\n            local_cache_dir,\n            scope=\"local\",\n        )\n\n    self.compiler_manager.initialize_cache(\n        local_cache_dir, disable_cache, self.prefix\n    )\n\n    # Reuses existing cache key\n\n    logger.debug(\n        \"torch.compile cache factors: env=%s cfg=%s comp=%s code=%s dir=%s\",\n        env_hash,\n        config_hash,\n        compiler_hash,\n        code_hash,\n        local_cache_dir,\n    )\n\n    # Persist and log only hash-relevant factors together.\n    try:\n        logger.debug(\n            \"Compile env factors (raw):\\n%s\\nVllm config hash: %s\",\n            lazy(partial(pprint.pformat, env_factors, width=120)),\n            config_hash,\n        )\n        meta_path = os.path.join(local_cache_dir, \"cache_key_factors.json\")\n        if not os.path.exists(meta_path):\n            with open(meta_path, \"w\") as f:\n                json.dump(\n                    {\n                        \"env\": env_factors,  # raw factors used for env_hash\n                        \"config_hash\": config_hash,\n                        \"code_hash\": code_hash,\n                        \"compiler_hash\": compiler_hash,\n                    },\n                    f,\n                    indent=2,\n                    sort_keys=True,\n                )\n    except Exception:\n        # Best-effort only; metadata write failures are non-fatal.\n        logger.warning(\n            (\n                \"Could not write compile cache metadata at %s; continuing without \"\n                \"metadata. Compiled cache remains valid; diagnostics may be \"\n                \"limited.\"\n            ),\n            local_cache_dir,\n            exc_info=True,\n        )\n\n    # when dynamo calls the backend, it means the bytecode\n    # transform and analysis are done\n    compilation_counter.num_graphs_seen += 1\n    from .monitor import torch_compile_start_time\n\n    dynamo_time = time.time() - torch_compile_start_time\n    logger.info_once(\n        \"Dynamo bytecode transform time: %.2f s\", dynamo_time, scope=\"local\"\n    )\n    self.compilation_config.compilation_time += dynamo_time\n\n    # we control the compilation process, each instance can only be\n    # called once\n    assert not self._called, \"VllmBackend can only be called once\"\n\n    self.graph = graph\n    self.configure_post_pass()\n\n    if self.compilation_config.use_inductor_graph_partition:\n        # Let Inductor decide partitioning; avoid FX-level pre-splitting.\n        fx_split_ops: list[str] = []\n    else:\n        fx_split_ops = self.compilation_config.splitting_ops or []\n\n    self.split_gm, self.piecewise_graphs = split_graph(graph, fx_split_ops)\n\n    from torch._dynamo.utils import lazy_format_graph_code\n\n    # depyf will hook lazy_format_graph_code and dump the graph\n    # for debugging, no need to print the graph here\n    lazy_format_graph_code(\"before split\", self.graph)\n    lazy_format_graph_code(\"after split\", self.split_gm)\n\n    compilation_counter.num_piecewise_graphs_seen += len(self.piecewise_graphs)\n    submod_names_to_compile = [\n        item.submod_name\n        for item in self.piecewise_graphs\n        if not item.is_splitting_graph\n    ]\n\n    # Extract fake values from the graph to use them when needed.\n    all_fake_values = []\n    for i in graph.graph.find_nodes(op=\"placeholder\"):\n        all_fake_values.append(i.meta[\"example_value\"])\n\n    fake_args = [\n        all_fake_values[i] if isinstance(t, torch.Tensor) else t\n        for i, t in enumerate(example_inputs)\n    ]\n\n    # propagate the split graph to the piecewise backend,\n    # compile submodules with symbolic shapes\n    PiecewiseCompileInterpreter(\n        self.split_gm, submod_names_to_compile, self.vllm_config, self\n    ).run(*fake_args)\n\n    from torch._guards import detect_fake_mode\n\n    fake_mode = detect_fake_mode()\n\n    if (\n        self.compilation_config.dynamic_shapes_config.evaluate_guards\n        and self.compilation_config.dynamic_shapes_config.type\n        == DynamicShapesType.BACKED\n    ):\n        from torch.utils._sympy.value_ranges import ValueRanges\n\n        # Drop counter-0/1 specializations guards; for backed dynamic shapes,\n        # torch.compile will specialize for 0/1 inputs or otherwise guards that\n        # shape is >= 2. This is because it's really hard not to hit a check\n        # against 0/1. When we evaluate shape guards, we exclude checking those\n        # guards (We would fail always otherwise).\n\n        # We avoid that by updating the ranges of backed sizes when the min is\n        # 2 for any, we assume it's 0.\n        for s, r in fake_mode.shape_env.var_to_range.items():\n            if r.lower == 2:\n                fake_mode.shape_env.var_to_range[s] = ValueRanges(0, r.upper)\n\n    graph_path = os.path.join(local_cache_dir, \"computation_graph.py\")\n    if not os.path.exists(graph_path):\n        # code adapted from\n        # https://github.com/thuml/depyf/blob/dab831108a752d1facc00acdd6d4243891845c37/depyf/explain/patched_lazy_format_graph_code.py#L30\n        # use `print_readable` because it can include submodules\n        src = (\n            \"from __future__ import annotations\\nimport torch\\n\"\n            + self.split_gm.print_readable(print_output=False)\n        )\n        src = src.replace(\"<lambda>\", \"GraphModule\")\n        with open(graph_path, \"w\") as f:\n            f.write(src)\n\n        logger.debug_once(\n            \"Computation graph saved to %s\", graph_path, scope=\"local\"\n        )\n\n    self._called = True\n\n    if (\n        self.compilation_config.cudagraph_mode == CUDAGraphMode.NONE\n        or not self.compilation_config.cudagraph_copy_inputs\n    ):\n        return VllmSerializableFunction(\n            graph, example_inputs, self.prefix, self.split_gm, self.is_encoder\n        )\n\n    # index of tensors that have symbolic shapes (batch size)\n    # for weights and static buffers, they will have concrete shapes.\n    # symbolic shape only happens for input tensors.\n    from torch.fx.experimental.symbolic_shapes import is_symbolic\n\n    self.sym_tensor_indices = [\n        i\n        for i, x in enumerate(fake_args)\n        if isinstance(x, torch._subclasses.fake_tensor.FakeTensor)\n        and any(is_symbolic(d) for d in x.size())\n    ]\n\n    # compiler managed cudagraph input buffers\n    # we assume the first run with symbolic shapes\n    # has the maximum size among all the tensors\n    self.input_buffers = [\n        example_inputs[x].clone() for x in self.sym_tensor_indices\n    ]\n\n    # this is the callable we return to Dynamo to run\n    def copy_and_call(*args):\n        list_args = list(args)\n        for i, index in enumerate(self.sym_tensor_indices):\n            runtime_tensor = list_args[index]\n            runtime_shape = runtime_tensor.shape[0]\n            static_tensor = self.input_buffers[i][:runtime_shape]\n\n            # copy the tensor to the static buffer\n            static_tensor.copy_(runtime_tensor)\n\n            # replace the tensor in the list_args to the static buffer\n            list_args[index] = static_tensor\n        return self.split_gm(*list_args)\n\n    return VllmSerializableFunction(\n        graph, example_inputs, self.prefix, copy_and_call, self.is_encoder\n    )",
      "language": "python"
    },
    {
      "code": "__init__(\n    vllm_config: VllmConfig,\n    prefix: str = \"\",\n    is_encoder: bool = False,\n)",
      "language": "typescript"
    },
    {
      "code": "__init__(\n    vllm_config: VllmConfig,\n    prefix: str = \"\",\n    is_encoder: bool = False,\n)",
      "language": "typescript"
    },
    {
      "code": "519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557",
      "language": "unknown"
    },
    {
      "code": "def __init__(\n    self,\n    vllm_config: VllmConfig,\n    prefix: str = \"\",\n    is_encoder: bool = False,\n):\n    # if the model is initialized with a non-empty prefix,\n    # then usually it's enough to use that prefix,\n    # e.g. language_model, vision_model, etc.\n    # when multiple parts are initialized as independent\n    # models, we need to use the model_tag to distinguish\n    # them, e.g. backbone (default), eagle_head, etc.\n    self.prefix = prefix or model_tag\n\n    # Mark compilation for encoder.\n    self.is_encoder = is_encoder or model_is_encoder\n\n    # Passes to run on the graph post-grad.\n    self.pass_manager = resolve_obj_by_qualname(\n        current_platform.get_pass_manager_cls()\n    )()\n    self.pass_key = current_platform.pass_key\n\n    self.sym_tensor_indices = []\n    self.input_buffers = []\n\n    self.vllm_config = vllm_config\n    self.compilation_config = vllm_config.compilation_config\n\n    self.compiler_manager: CompilerManager = CompilerManager(\n        self.compilation_config\n    )\n\n    # Deepcopy the inductor config to detach the post-grad custom pass\n    # from CompilationConfig.\n    # We want to avoid PostGradPassManager in CompilationConfig because\n    # in future we need PostGradPassManager.uuid() to be executed\n    # only at compile time.\n    self.inductor_config = deepcopy(self.compilation_config.inductor_compile_config)",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    vllm_config: VllmConfig,\n    prefix: str = \"\",\n    is_encoder: bool = False,\n):\n    # if the model is initialized with a non-empty prefix,\n    # then usually it's enough to use that prefix,\n    # e.g. language_model, vision_model, etc.\n    # when multiple parts are initialized as independent\n    # models, we need to use the model_tag to distinguish\n    # them, e.g. backbone (default), eagle_head, etc.\n    self.prefix = prefix or model_tag\n\n    # Mark compilation for encoder.\n    self.is_encoder = is_encoder or model_is_encoder\n\n    # Passes to run on the graph post-grad.\n    self.pass_manager = resolve_obj_by_qualname(\n        current_platform.get_pass_manager_cls()\n    )()\n    self.pass_key = current_platform.pass_key\n\n    self.sym_tensor_indices = []\n    self.input_buffers = []\n\n    self.vllm_config = vllm_config\n    self.compilation_config = vllm_config.compilation_config\n\n    self.compiler_manager: CompilerManager = CompilerManager(\n        self.compilation_config\n    )\n\n    # Deepcopy the inductor config to detach the post-grad custom pass\n    # from CompilationConfig.\n    # We want to avoid PostGradPassManager in CompilationConfig because\n    # in future we need PostGradPassManager.uuid() to be executed\n    # only at compile time.\n    self.inductor_config = deepcopy(self.compilation_config.inductor_compile_config)",
      "language": "python"
    },
    {
      "code": "configure_post_pass()",
      "language": "unknown"
    },
    {
      "code": "configure_post_pass()",
      "language": "unknown"
    },
    {
      "code": "561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580",
      "language": "unknown"
    },
    {
      "code": "def configure_post_pass(self):\n    self.pass_manager.configure(self.vllm_config)\n\n    # Post-grad custom passes are run using the post_grad_custom_post_pass\n    # hook. If a pass for that hook exists, add it to the pass manager.\n    if self.pass_key in self.inductor_config:\n        if isinstance(self.inductor_config[self.pass_key], PostGradPassManager):\n            raise ValueError(\n                \"PostGradPassManager can not be kept in CompilationConfig.\"\n            )\n        else:\n            # Config should automatically wrap all inductor passes\n            assert isinstance(\n                self.compilation_config.inductor_compile_config[self.pass_key],\n                InductorPass,\n            )\n            self.pass_manager.add(\n                self.compilation_config.inductor_compile_config[self.pass_key]\n            )\n    self.inductor_config[self.pass_key] = self.pass_manager",
      "language": "python"
    },
    {
      "code": "def configure_post_pass(self):\n    self.pass_manager.configure(self.vllm_config)\n\n    # Post-grad custom passes are run using the post_grad_custom_post_pass\n    # hook. If a pass for that hook exists, add it to the pass manager.\n    if self.pass_key in self.inductor_config:\n        if isinstance(self.inductor_config[self.pass_key], PostGradPassManager):\n            raise ValueError(\n                \"PostGradPassManager can not be kept in CompilationConfig.\"\n            )\n        else:\n            # Config should automatically wrap all inductor passes\n            assert isinstance(\n                self.compilation_config.inductor_compile_config[self.pass_key],\n                InductorPass,\n            )\n            self.pass_manager.add(\n                self.compilation_config.inductor_compile_config[self.pass_key]\n            )\n    self.inductor_config[self.pass_key] = self.pass_manager",
      "language": "python"
    },
    {
      "code": "make_compiler(\n    compilation_config: CompilationConfig,\n) -> CompilerInterface",
      "language": "php"
    },
    {
      "code": "make_compiler(\n    compilation_config: CompilationConfig,\n) -> CompilerInterface",
      "language": "php"
    },
    {
      "code": "52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75",
      "language": "unknown"
    },
    {
      "code": "def make_compiler(compilation_config: CompilationConfig) -> CompilerInterface:\n    if compilation_config.backend == \"inductor\":\n        # Use standalone compile only if requested, version is new enough,\n        # and the symbol actually exists in this PyTorch build.\n        if (\n            envs.VLLM_USE_STANDALONE_COMPILE\n            and is_torch_equal_or_newer(\"2.8.0.dev\")\n            and hasattr(torch._inductor, \"standalone_compile\")\n        ):\n            logger.debug(\"Using InductorStandaloneAdaptor\")\n            return InductorStandaloneAdaptor(\n                compilation_config.compile_cache_save_format\n            )\n        else:\n            logger.debug(\"Using InductorAdaptor\")\n            return InductorAdaptor()\n    elif compilation_config.backend == \"eager\":\n        logger.debug(\"Using EagerAdaptor\")\n        return EagerAdaptor()\n    else:\n        logger.debug(\"Using custom backend: %s\", compilation_config.backend)\n        compiler = resolve_obj_by_qualname(current_platform.get_compile_backend())()\n        assert isinstance(compiler, CompilerInterface)\n        return compiler",
      "language": "python"
    },
    {
      "code": "def make_compiler(compilation_config: CompilationConfig) -> CompilerInterface:\n    if compilation_config.backend == \"inductor\":\n        # Use standalone compile only if requested, version is new enough,\n        # and the symbol actually exists in this PyTorch build.\n        if (\n            envs.VLLM_USE_STANDALONE_COMPILE\n            and is_torch_equal_or_newer(\"2.8.0.dev\")\n            and hasattr(torch._inductor, \"standalone_compile\")\n        ):\n            logger.debug(\"Using InductorStandaloneAdaptor\")\n            return InductorStandaloneAdaptor(\n                compilation_config.compile_cache_save_format\n            )\n        else:\n            logger.debug(\"Using InductorAdaptor\")\n            return InductorAdaptor()\n    elif compilation_config.backend == \"eager\":\n        logger.debug(\"Using EagerAdaptor\")\n        return EagerAdaptor()\n    else:\n        logger.debug(\"Using custom backend: %s\", compilation_config.backend)\n        compiler = resolve_obj_by_qualname(current_platform.get_compile_backend())()\n        assert isinstance(compiler, CompilerInterface)\n        return compiler",
      "language": "python"
    },
    {
      "code": "set_model_tag(tag: str, is_encoder: bool = False)",
      "language": "typescript"
    },
    {
      "code": "set_model_tag(tag: str, is_encoder: bool = False)",
      "language": "typescript"
    },
    {
      "code": "469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486",
      "language": "unknown"
    },
    {
      "code": "@contextmanager\ndef set_model_tag(tag: str, is_encoder: bool = False):\n    \"\"\"Context manager to set the model tag.\"\"\"\n    global model_tag\n    global model_is_encoder\n    assert tag != model_tag, (\n        f\"Model tag {tag} is the same as the current tag {model_tag}.\"\n    )\n    old_tag = model_tag\n    old_is_encoder = model_is_encoder\n\n    model_tag = tag\n    model_is_encoder = is_encoder\n    try:\n        yield\n    finally:\n        model_tag = old_tag\n        model_is_encoder = old_is_encoder",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef set_model_tag(tag: str, is_encoder: bool = False):\n    \"\"\"Context manager to set the model tag.\"\"\"\n    global model_tag\n    global model_is_encoder\n    assert tag != model_tag, (\n        f\"Model tag {tag} is the same as the current tag {model_tag}.\"\n    )\n    old_tag = model_tag\n    old_is_encoder = model_is_encoder\n\n    model_tag = tag\n    model_is_encoder = is_encoder\n    try:\n        yield\n    finally:\n        model_tag = old_tag\n        model_is_encoder = old_is_encoder",
      "language": "python"
    },
    {
      "code": "split_graph(\n    graph: GraphModule, splitting_ops: list[str]\n) -> tuple[GraphModule, list[SplitItem]]",
      "language": "php"
    },
    {
      "code": "split_graph(\n    graph: GraphModule, splitting_ops: list[str]\n) -> tuple[GraphModule, list[SplitItem]]",
      "language": "php"
    },
    {
      "code": "296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352",
      "language": "unknown"
    },
    {
      "code": "def split_graph(\n    graph: fx.GraphModule, splitting_ops: list[str]\n) -> tuple[fx.GraphModule, list[SplitItem]]:\n    # split graph by ops\n    subgraph_id = 0\n    node_to_subgraph_id: dict[fx.Node, int] = {}\n    split_op_graphs: list[int] = []\n    for node in graph.graph.nodes:\n        if node.op in (\"output\", \"placeholder\"):\n            continue\n\n        # Check if this is a getitem operation on a node from an earlier subgraph.\n        # If so, assign it to the same subgraph as its input to avoid passing entire\n        # tuple as input to submodules, which is against standalone_compile and\n        # AoTAutograd input requirement.\n        if node.op == \"call_function\" and node.target == operator.getitem:\n            # Assign this getitem to the same subgraph as its input\n            input_node = node.args[0]\n            if input_node.op != \"placeholder\":\n                assert input_node in node_to_subgraph_id\n                node_to_subgraph_id[node] = node_to_subgraph_id[input_node]\n                continue\n\n        if should_split(node, splitting_ops):\n            subgraph_id += 1\n            node_to_subgraph_id[node] = subgraph_id\n            split_op_graphs.append(subgraph_id)\n            subgraph_id += 1\n        else:\n            node_to_subgraph_id[node] = subgraph_id\n\n    # `keep_original_order` is important!\n    # otherwise pytorch might reorder the nodes and\n    # the semantics of the graph will change when we\n    # have mutations in the graph\n    split_gm = torch.fx.passes.split_module.split_module(\n        graph, None, lambda node: node_to_subgraph_id[node], keep_original_order=True\n    )\n\n    outputs = []\n\n    names = [name for (name, module) in split_gm.named_modules()]\n\n    for name in names:\n        if \".\" in name or name == \"\":\n            # recursive child module or the root module\n            continue\n\n        module = getattr(split_gm, name)\n\n        graph_id = int(name.replace(\"submod_\", \"\"))\n        outputs.append(SplitItem(name, graph_id, (graph_id in split_op_graphs), module))\n\n    # sort by integer graph_id, rather than string name\n    outputs.sort(key=lambda x: x.graph_id)\n\n    return split_gm, outputs",
      "language": "python"
    },
    {
      "code": "def split_graph(\n    graph: fx.GraphModule, splitting_ops: list[str]\n) -> tuple[fx.GraphModule, list[SplitItem]]:\n    # split graph by ops\n    subgraph_id = 0\n    node_to_subgraph_id: dict[fx.Node, int] = {}\n    split_op_graphs: list[int] = []\n    for node in graph.graph.nodes:\n        if node.op in (\"output\", \"placeholder\"):\n            continue\n\n        # Check if this is a getitem operation on a node from an earlier subgraph.\n        # If so, assign it to the same subgraph as its input to avoid passing entire\n        # tuple as input to submodules, which is against standalone_compile and\n        # AoTAutograd input requirement.\n        if node.op == \"call_function\" and node.target == operator.getitem:\n            # Assign this getitem to the same subgraph as its input\n            input_node = node.args[0]\n            if input_node.op != \"placeholder\":\n                assert input_node in node_to_subgraph_id\n                node_to_subgraph_id[node] = node_to_subgraph_id[input_node]\n                continue\n\n        if should_split(node, splitting_ops):\n            subgraph_id += 1\n            node_to_subgraph_id[node] = subgraph_id\n            split_op_graphs.append(subgraph_id)\n            subgraph_id += 1\n        else:\n            node_to_subgraph_id[node] = subgraph_id\n\n    # `keep_original_order` is important!\n    # otherwise pytorch might reorder the nodes and\n    # the semantics of the graph will change when we\n    # have mutations in the graph\n    split_gm = torch.fx.passes.split_module.split_module(\n        graph, None, lambda node: node_to_subgraph_id[node], keep_original_order=True\n    )\n\n    outputs = []\n\n    names = [name for (name, module) in split_gm.named_modules()]\n\n    for name in names:\n        if \".\" in name or name == \"\":\n            # recursive child module or the root module\n            continue\n\n        module = getattr(split_gm, name)\n\n        graph_id = int(name.replace(\"submod_\", \"\"))\n        outputs.append(SplitItem(name, graph_id, (graph_id in split_op_graphs), module))\n\n    # sort by integer graph_id, rather than string name\n    outputs.sort(key=lambda x: x.graph_id)\n\n    return split_gm, outputs",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/backends/",
    "https://docs.vllm.ai/en/latest/",
    "https://docs.vllm.ai/en/latest/usage/",
    "https://docs.vllm.ai/en/latest/contributing/",
    "https://docs.vllm.ai/en/latest/benchmarking/",
    "https://docs.vllm.ai/en/latest/api/",
    "https://docs.vllm.ai/en/latest/cli/",
    "https://docs.vllm.ai/en/latest/community/contact_us/",
    "https://docs.vllm.ai/en/latest/getting_started/quickstart/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/gpu/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/cpu/",
    "https://docs.vllm.ai/en/latest/examples/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/async_llm_streaming/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/audio_language/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/automatic_prefix_caching/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/basic/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/batch_llm_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/chat_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/context_extension/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/data_parallel/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/disaggregated-prefill-v1/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/disaggregated_prefill/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/encoder_decoder_multimodal/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/kv_load_failure_recovery/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/llm_engine_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/llm_engine_reset_kv/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/load_sharded_state/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/logits_processor/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/lora_with_quantization_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/metrics/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/mistral-small/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/mlpspeculator/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/multilora_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/openai_batch/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/prefix_caching/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/prompt_embed_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen2_5_omni/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen3_omni/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen_1m/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/reproducibility/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_colocate/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_online_quant/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_utils/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/save_sharded_state/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/simple_profiling/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/skip_loading_weights_in_engine_init/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/spec_decode/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/structured_outputs/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/torchrun_dp_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/torchrun_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/vision_language/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/vision_language_multi_image/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/api_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/chart-helm/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/dashboards/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_encoder/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_prefill/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_serving/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_serving_p2p_nccl_xpyd/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/elastic_ep/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/gradio_openai_chatbot_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/gradio_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/kv_events_subscriber/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/multi-node-serving/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/multi_instance_data_parallel/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_for_multimodal/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_required/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_xlam/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_xlam_streaming/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_tool_calls_with_reasoning/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_with_reasoning/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_with_reasoning_streaming/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_completion_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client_with_mcp_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_transcription_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_translation_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/opentelemetry/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/prometheus_grafana/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/prompt_embed_inference_with_openai_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/ray_serve_deepseek/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/retrieval_augmented_generation_with_langchain/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/retrieval_augmented_generation_with_llamaindex/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/run_cluster/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/sagemaker-entrypoint/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/streamlit_openai_chatbot_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/structured_outputs/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/token_generation_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/utils/",
    "https://docs.vllm.ai/en/latest/examples/others/lmcache/",
    "https://docs.vllm.ai/en/latest/examples/others/logging_configuration/",
    "https://docs.vllm.ai/en/latest/examples/others/tensorize_vllm_model/",
    "https://docs.vllm.ai/en/latest/examples/pooling/classify/",
    "https://docs.vllm.ai/en/latest/examples/pooling/embed/",
    "https://docs.vllm.ai/en/latest/examples/pooling/plugin/",
    "https://docs.vllm.ai/en/latest/examples/pooling/pooling/",
    "https://docs.vllm.ai/en/latest/examples/pooling/score/",
    "https://docs.vllm.ai/en/latest/examples/pooling/token_classify/",
    "https://docs.vllm.ai/en/latest/examples/pooling/token_embed/",
    "https://docs.vllm.ai/en/latest/usage/v1_guide/",
    "https://docs.vllm.ai/en/latest/usage/faq/",
    "https://docs.vllm.ai/en/latest/usage/metrics/",
    "https://docs.vllm.ai/en/latest/usage/reproducibility/",
    "https://docs.vllm.ai/en/latest/usage/security/",
    "https://docs.vllm.ai/en/latest/usage/troubleshooting/",
    "https://docs.vllm.ai/en/latest/usage/usage_stats/",
    "https://docs.vllm.ai/en/latest/serving/offline_inference/",
    "https://docs.vllm.ai/en/latest/serving/openai_compatible_server/",
    "https://docs.vllm.ai/en/latest/serving/context_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/data_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/distributed_troubleshooting/",
    "https://docs.vllm.ai/en/latest/serving/expert_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/parallelism_scaling/",
    "https://docs.vllm.ai/en/latest/serving/integrations/langchain/",
    "https://docs.vllm.ai/en/latest/serving/integrations/llamaindex/",
    "https://docs.vllm.ai/en/latest/deployment/docker/",
    "https://docs.vllm.ai/en/latest/deployment/k8s/",
    "https://docs.vllm.ai/en/latest/deployment/nginx/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/anyscale/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/anything-llm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/autogen/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/bentoml/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/cerebrium/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/chatbox/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/dify/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/dstack/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/haystack/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/helm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/hf_inference_endpoints/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/litellm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/lobe-chat/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/lws/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/modal/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/open-webui/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/retrieval_augmented_generation/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/skypilot/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/streamlit/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/triton/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kaito/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kserve/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kthena/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kubeai/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kuberay/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llamastack/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llm-d/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llmaz/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/production-stack/",
    "https://docs.vllm.ai/en/latest/training/rlhf/",
    "https://docs.vllm.ai/en/latest/training/trl/",
    "https://docs.vllm.ai/en/latest/configuration/",
    "https://docs.vllm.ai/en/latest/configuration/conserving_memory/",
    "https://docs.vllm.ai/en/latest/configuration/engine_args/",
    "https://docs.vllm.ai/en/latest/configuration/env_vars/",
    "https://docs.vllm.ai/en/latest/configuration/model_resolution/",
    "https://docs.vllm.ai/en/latest/configuration/optimization/",
    "https://docs.vllm.ai/en/latest/configuration/serve_args/",
    "https://docs.vllm.ai/en/latest/models/supported_models/",
    "https://docs.vllm.ai/en/latest/models/generative_models/",
    "https://docs.vllm.ai/en/latest/models/pooling_models/",
    "https://docs.vllm.ai/en/latest/models/extensions/fastsafetensor/",
    "https://docs.vllm.ai/en/latest/models/extensions/runai_model_streamer/",
    "https://docs.vllm.ai/en/latest/models/extensions/tensorizer/",
    "https://docs.vllm.ai/en/latest/models/hardware_supported_models/cpu/",
    "https://docs.vllm.ai/en/latest/models/hardware_supported_models/xpu/",
    "https://docs.vllm.ai/en/latest/features/",
    "https://docs.vllm.ai/en/latest/features/automatic_prefix_caching/",
    "https://docs.vllm.ai/en/latest/features/batch_invariance/",
    "https://docs.vllm.ai/en/latest/features/custom_arguments/",
    "https://docs.vllm.ai/en/latest/features/custom_logitsprocs/",
    "https://docs.vllm.ai/en/latest/features/disagg_encoder/",
    "https://docs.vllm.ai/en/latest/features/disagg_prefill/",
    "https://docs.vllm.ai/en/latest/features/interleaved_thinking/",
    "https://docs.vllm.ai/en/latest/features/lora/",
    "https://docs.vllm.ai/en/latest/features/mooncake_connector_usage/",
    "https://docs.vllm.ai/en/latest/features/multimodal_inputs/",
    "https://docs.vllm.ai/en/latest/features/nixl_connector_usage/",
    "https://docs.vllm.ai/en/latest/features/prompt_embeds/",
    "https://docs.vllm.ai/en/latest/features/reasoning_outputs/",
    "https://docs.vllm.ai/en/latest/features/sleep_mode/",
    "https://docs.vllm.ai/en/latest/features/spec_decode/",
    "https://docs.vllm.ai/en/latest/features/structured_outputs/",
    "https://docs.vllm.ai/en/latest/features/tool_calling/",
    "https://docs.vllm.ai/en/latest/features/quantization/",
    "https://docs.vllm.ai/en/latest/features/quantization/auto_awq/",
    "https://docs.vllm.ai/en/latest/features/quantization/auto_round/",
    "https://docs.vllm.ai/en/latest/features/quantization/bitblas/",
    "https://docs.vllm.ai/en/latest/features/quantization/bnb/",
    "https://docs.vllm.ai/en/latest/features/quantization/fp8/",
    "https://docs.vllm.ai/en/latest/features/quantization/gguf/",
    "https://docs.vllm.ai/en/latest/features/quantization/gptqmodel/",
    "https://docs.vllm.ai/en/latest/features/quantization/inc/",
    "https://docs.vllm.ai/en/latest/features/quantization/int4/",
    "https://docs.vllm.ai/en/latest/features/quantization/int8/",
    "https://docs.vllm.ai/en/latest/features/quantization/modelopt/",
    "https://docs.vllm.ai/en/latest/features/quantization/quantized_kvcache/",
    "https://docs.vllm.ai/en/latest/features/quantization/quark/",
    "https://docs.vllm.ai/en/latest/features/quantization/torchao/",
    "https://docs.vllm.ai/en/latest/contributing/deprecation_policy/",
    "https://docs.vllm.ai/en/latest/contributing/dockerfile/dockerfile/",
    "https://docs.vllm.ai/en/latest/contributing/incremental_build/",
    "https://docs.vllm.ai/en/latest/contributing/profiling/",
    "https://docs.vllm.ai/en/latest/contributing/vulnerability_management/",
    "https://docs.vllm.ai/en/latest/contributing/model/",
    "https://docs.vllm.ai/en/latest/contributing/model/basic/",
    "https://docs.vllm.ai/en/latest/contributing/model/registration/",
    "https://docs.vllm.ai/en/latest/contributing/model/tests/",
    "https://docs.vllm.ai/en/latest/contributing/model/multimodal/",
    "https://docs.vllm.ai/en/latest/contributing/model/transcription/",
    "https://docs.vllm.ai/en/latest/contributing/ci/failures/",
    "https://docs.vllm.ai/en/latest/contributing/ci/nightly_builds/",
    "https://docs.vllm.ai/en/latest/contributing/ci/update_pytorch_version/",
    "https://docs.vllm.ai/en/latest/design/io_processor_plugins/",
    "https://docs.vllm.ai/en/latest/design/lora_resolver_plugins/",
    "https://docs.vllm.ai/en/latest/design/plugin_system/",
    "https://docs.vllm.ai/en/latest/design/arch_overview/",
    "https://docs.vllm.ai/en/latest/design/cuda_graphs/",
    "https://docs.vllm.ai/en/latest/design/dbo/",
    "https://docs.vllm.ai/en/latest/design/debug_vllm_compile/",
    "https://docs.vllm.ai/en/latest/design/fused_moe_modular_kernel/",
    "https://docs.vllm.ai/en/latest/design/huggingface_integration/",
    "https://docs.vllm.ai/en/latest/design/hybrid_kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/design/logits_processors/",
    "https://docs.vllm.ai/en/latest/design/metrics/",
    "https://docs.vllm.ai/en/latest/design/mm_processing/",
    "https://docs.vllm.ai/en/latest/design/moe_kernel_features/",
    "https://docs.vllm.ai/en/latest/design/multiprocessing/",
    "https://docs.vllm.ai/en/latest/design/optimization_levels/",
    "https://docs.vllm.ai/en/latest/design/p2p_nccl_connector/",
    "https://docs.vllm.ai/en/latest/design/paged_attention/",
    "https://docs.vllm.ai/en/latest/design/prefix_caching/",
    "https://docs.vllm.ai/en/latest/design/torch_compile/",
    "https://docs.vllm.ai/en/latest/benchmarking/cli/",
    "https://docs.vllm.ai/en/latest/benchmarking/sweeps/",
    "https://docs.vllm.ai/en/latest/benchmarking/dashboard/",
    "https://docs.vllm.ai/en/latest/api/vllm/",
    "https://docs.vllm.ai/en/latest/api/vllm/beam_search/",
    "https://docs.vllm.ai/en/latest/api/vllm/collect_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/connections/",
    "https://docs.vllm.ai/en/latest/api/vllm/env_override/",
    "https://docs.vllm.ai/en/latest/api/vllm/envs/",
    "https://docs.vllm.ai/en/latest/api/vllm/forward_context/",
    "https://docs.vllm.ai/en/latest/api/vllm/logger/",
    "https://docs.vllm.ai/en/latest/api/vllm/logits_process/",
    "https://docs.vllm.ai/en/latest/api/vllm/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/pooling_params/",
    "https://docs.vllm.ai/en/latest/api/vllm/sampling_params/",
    "https://docs.vllm.ai/en/latest/api/vllm/scalar_type/",
    "https://docs.vllm.ai/en/latest/api/vllm/scripts/",
    "https://docs.vllm.ai/en/latest/api/vllm/sequence/",
    "https://docs.vllm.ai/en/latest/api/vllm/tasks/",
    "https://docs.vllm.ai/en/latest/api/vllm/tracing/",
    "https://docs.vllm.ai/en/latest/api/vllm/version/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/image/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/video/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layer/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/selector/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/chunked_local_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/cross_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/encoder_only_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/mm_encoder_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/chunked_prefill_paged_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/flashmla/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/merge_attn_states/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/paged_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/pallas_kv_cache_update/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/prefix_prefill/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/rocm_aiter_mla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_decode_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_merge_attn_states/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_reshape_and_cache_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_unified_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/vit_attn_wrappers/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/fa_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/kv_sharing_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/kv_transfer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/datasets/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/latency/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/startup/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/throughput/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/endpoint_request_func/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/ready_checker/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/cli/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/param_sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/plot/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/plot_pareto/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/serve_sla/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/server/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/sla_sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/activation_quant_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/base_static_graph/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/caching/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/collective_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/compiler_interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/counter/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/cuda_graph/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/decorators/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fix_functionalization/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fusion_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fx_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/inductor_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/matcher_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/monitor/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/noop_elimination/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/partition_rules/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/pass_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/piecewise_backend/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/post_cleanup/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/qk_norm_rope_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/rocm_aiter_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/sequence_parallelism/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/torch25_custom_graph_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/vllm_inductor_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/compilation/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/device/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/ec_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/kv_events/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/kv_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/load/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/model/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/observability/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/parallel/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/pooler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/profiler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/speculative/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/speech_to_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/structured_outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/vllm/",
    "https://docs.vllm.ai/en/latest/api/vllm/device_allocator/",
    "https://docs.vllm.ai/en/latest/api/vllm/device_allocator/cumem/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/communication_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_events/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/parallel_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/tpu_distributed_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/all2all/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/all_reduce_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/base_device_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cuda_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cuda_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/custom_all_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/mnnvl_compat/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl_allocator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/quick_all_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/ray_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/shm_broadcast/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/shm_object_storage/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/symm_mem/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/tpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/xpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_transfer_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/example_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/async_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/eplb_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/rebalance_execute/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/default/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_transfer_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/decode_bench_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/example_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_mp_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/mooncake_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/multi_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/nixl_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/offloading_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/multi_process_adapter/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/vllm_v1_adapter/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/tensor_memory_pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/arg_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/async_llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/api_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/chat_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/constants/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/context/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/launcher/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/llm/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/logger/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/renderer/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/responses_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/score_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/ssl/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/tool/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/tool_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/serving_messages/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/collect_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/main/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/openai/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/run_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/types/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/latency/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/main/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/startup/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/throughput/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/api_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/cli_args/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/orca_metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/run_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_chat/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_chat_stream_harmony/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_completion/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_models/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_responses/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_transcription/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/speech_to_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/harmony_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/responses_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/conftest/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/sagemaker/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/sagemaker/routes/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/cache/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/middleware/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/health/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/server_info/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/lora/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/profile/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/profile/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rlhf/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rlhf/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rpc/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rpc/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/sleep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/sleep/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/data/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/parse/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/preprocess/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/dump_input/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/formatter/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/lazy/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/log_time/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/lora_model/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/lora_weights/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/model_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/peft_helper/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/resolver/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/worker_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/base_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/column_parallel_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/replicated_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/row_parallel_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/vocal_parallel_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/ipex_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/ipex_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/torch_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/torch_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/fused_moe_lora_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/kernel_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_expand_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_kernel_metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_shrink_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/xla_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/xla_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_selector/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/custom_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/parameter/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/activation/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/attention_layer_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/batch_invariant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/conv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/kda/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/layernorm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/lightning_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/pooler/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/resampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/vocab_parallel_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_delta_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_o/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_scaled_dot_kkt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/cumsum/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/fused_recurrent/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/index_py/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/kda/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/l2norm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/layernorm_guard/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/op/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/solve_tril/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/wy_fast/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/all2all_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/batched_deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/cpu_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/cutlass_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deep_gemm_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deepep_ht_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deepep_ll_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutedsl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutlass_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutlass_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_trtllm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_batched_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_marlin_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe_method_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe_modular_method/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/gpt_oss_triton_kernels_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/layer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/modular_kernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_align_block_size/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_pallas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_permute_unpermute/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_torch_iterative/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/pplx_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/rocm_aiter_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/routing_simulator/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/shared_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/topk_weight_and_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/triton_deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/trtllm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/unquantized_fused_moe_method/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/zero_expert_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/linear_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_mixer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_mixer2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/short_conv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/causal_conv1d/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/layernorm_gated/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/mamba_ssm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_bmm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_chunk_scan/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_chunk_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_combined/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_state_passing/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/auto_round/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq_triton/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/base_config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/bitsandbytes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/cpu_wna16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/deepspeedfp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/experts_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fbgemm_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fp_quant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gguf/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_marlin_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/hqq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/inc/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/input_quant_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/ipex_quant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kv_cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/modelopt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/moe_wna16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/mxfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/petit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/ptpc_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/qutlass_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/rtn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/schema/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/torchao/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/tpu_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/compressed_tensors/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/compressed_tensors_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/triton_scaled_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_scheme/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a4_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a8_int/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a16_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a16_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a8_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a16_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_wNa16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/module/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/schemes/linear_qutlass_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/allspark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/conch/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/cutlass/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/dynamic_4bit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/exllama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/MPLinearKernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/machete/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/aiter/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/cutlass/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/ScaledMMLinearKernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/triton/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/xla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/quark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/quark_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_ocp_mx/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_scheme/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_w8a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_w8a8_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/allspark_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/bitblas_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/flashinfer_fp4_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/flashinfer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/fp8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/gptq_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/int8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/layer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/machete_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_fp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_test/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_test_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp4_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp6_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/nvfp4_emulation_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/nvfp4_moe_support/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/ocp_mx_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/petit_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/quant_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/w8a8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/deepseek_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dual_chunk_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dynamic_ntk_alpha_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dynamic_ntk_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/ernie45_vl_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/linear_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/llama3_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/llama4_vision_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/mrope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/ntk_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/phi3_long_rope_scaled_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/xdrope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/yarn_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/base_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/bitsandbytes_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/default_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/dummy_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/gguf_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/online_quantization/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/runai_streamer_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/sharded_state_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tensorizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tensorizer_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/weight_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/adapters/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/afmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aimv2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/apertus/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/arcee/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/arctic/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aria/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/audioflamingo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aya_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/baichuan/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bailing_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bee/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bert/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bert_with_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/blip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/blip2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bloom/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/chameleon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/chatglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/clip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/cohere2_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/commandr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dbrx/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepencoder/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_v2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dots1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dots_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_vl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/exaone/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/exaone4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/fairseq2_llama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/falcon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/falcon_h1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/flex_olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/fuyu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3n/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3n_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_1v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_moe_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_bigcode/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_j/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_neox/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_oss/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granite/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granite_speech/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoehybrid/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoeshared/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gritlm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/grok1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/h2ovl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hunyuan_v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hunyuan_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hyperclovax_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/idefics2_vision_model/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/idefics3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interfaces/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interfaces_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/intern_vit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internlm2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internlm2_ve/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interns1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interns1_vit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internvl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jais/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jais2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jina_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/keye/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/keye_vl1_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/kimi_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/kimi_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lfm2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lfm2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lightonocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama4_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama_eagle3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_next_video/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_onevision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/longcat_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/longcat_flash_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mamba2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/midashenglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo_v2_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpmv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_m2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_text_01/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_vl_01/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral_large_3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral_large_3_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mixtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mllama4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mlp_speculator/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/modernbert/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/module_mapping/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/molmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/moonvit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mpt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nano_nemotron_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_nas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nvlm_d/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmo2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/opencua/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/openpangu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/openpangu_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/opt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/orion/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ouro/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ovis2_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/paddleocr_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/paligemma/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/persimmon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi3v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm_audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phimoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/pixtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/plamo2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/plamo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_5_omni_thinker/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_5_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_rm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_next_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_omni_moe_thinker/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_vl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/radio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/roberta/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/rvl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/seed_oss/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/siglip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/siglip2navit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/skyworkr1v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/smolvlm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/solar/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/stablelm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/starcoder2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/step3_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/step3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/swin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/tarsier/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/telechat2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/teleflm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/terratorch/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ultravox/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/voxtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/voxtral_streaming/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/whisper/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/whisper_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/zamba2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/causal/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/legacy/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/deep_gemm_warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/kernel_warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/evs/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/hasher/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/image/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/inputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/parse/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/processing/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/profiling/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/video/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/cuda/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/rocm/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/io_processors/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/io_processors/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/lora_resolvers/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/lora_resolvers/filesystem_resolver/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/layerwise_profile/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/lazy_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/ray_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/abs_reasoning_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/basic_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/deepseek_r1_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/deepseek_v3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/ernie45_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/glm4_moe_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/gptoss_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/granite_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/holo2_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/hunyuan_a13b_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/identity_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/minimax_m2_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/mistral_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/olmo3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/qwen3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/seedoss_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/step3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/deepseek_v32/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/deepseek_v32_encoding/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/detokenizer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/hf/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/mistral/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/abstract_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv31_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv32_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/ernie45_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/functiongemma_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/gigachat3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/glm4_moe_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/glm47_moe_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/granite_20b_fc_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/granite_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/hermes_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/hunyuan_a13b_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/internlm2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/jamba_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/kimi_k2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/llama4_pythonic_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/llama_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/longcat_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/minimax_m2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/minimax_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/mistral_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/olmo3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/openai_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/phi4mini_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/pythonic_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/qwen3coder_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/qwen3xml_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/seed_oss_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/step3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/xlam_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/config_parser_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/dynamic_module/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/gguf_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/repo_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/runai_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/s3_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/tokenizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/chat_templates/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/chat_templates/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/afmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/arctic/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/chatglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/dotsocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/falcon/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/flex_olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/hunyuan_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/jais/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/kimi_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/kimi_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/lfm2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/midashenglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/mistral/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/mlp_speculator/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/moonvit/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/nemotron/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/nemotron_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/olmo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/qwen3_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/radio/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/step3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/tarsier2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/ultravox/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/algos/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/deepseek_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/hunyuan_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/hunyuan_vl_image/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/ovis2_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/triton_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/triton_utils/importing/",
    "https://docs.vllm.ai/en/latest/api/vllm/usage/",
    "https://docs.vllm.ai/en/latest/api/vllm/usage/usage_lib/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/argparse_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/async_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/collection_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/counter/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/deep_gemm/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/flashinfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/func_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/gc_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/hashing/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/import_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/jsontree/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/math_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/mem_constants/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/mem_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/nccl/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/network_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/nvtx_pytorch_hooks/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/platform_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/profiling/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/serial_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/system_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/tensor_schema/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/torch_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/cudagraph_dispatcher/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_cache_interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/serial_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/cpu_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flash_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flashinfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flex_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/gdn_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/linear_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba1_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba2_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/pallas/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_aiter_fa/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_aiter_unified_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/short_conv_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/tree_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/triton_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/aiter_triton_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/cutlass_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashattn_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashinfer_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashmla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashmla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/indexer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/rocm_aiter_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/rocm_aiter_mla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/triton_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/block_pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/encoder_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_coordinator/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/single_type_kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/async_scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/request_queue/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/async_llm/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/coordinator/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/core/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/core_client/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/detokenizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/exceptions/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/input_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/output_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/parallel_sampling/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/multiproc_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_distributed_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/uniproc_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/arc_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backend/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/lru_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/mediums/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/spec/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backends/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/cpu_gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/loggers/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/perf/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/prometheus/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/ray_wrappers/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/reader/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/stats/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/pool/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/rejection_sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/builtin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/state/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/bad_words/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/penalties/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/topk_topp_sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/ngram_proposer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/suffix_decoding/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_guidance/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_lm_format_enforcer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_outlines/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_types/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_xgrammar/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/block_table/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/dp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ec_connector_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_ubatch_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/kv_connector_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/lora_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ubatch_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ubatching/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/worker_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/workspace/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/xpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/xpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/async_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/attn_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/block_table/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/cudagraph_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/dp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/states/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/structured_outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/metrics/logits/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/gumbel/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/logprob/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/min_p/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/penalties/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/eagle_cudagraph/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/rejection_sample/",
    "https://docs.vllm.ai/en/latest/cli/serve/",
    "https://docs.vllm.ai/en/latest/cli/chat/",
    "https://docs.vllm.ai/en/latest/cli/complete/",
    "https://docs.vllm.ai/en/latest/cli/run-batch/",
    "https://docs.vllm.ai/en/latest/cli/bench/latency/",
    "https://docs.vllm.ai/en/latest/cli/bench/serve/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/plot/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/plot_pareto/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/serve/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/serve_sla/",
    "https://docs.vllm.ai/en/latest/cli/bench/throughput/",
    "https://docs.vllm.ai/en/latest/community/meetups/",
    "https://docs.vllm.ai/en/latest/community/sponsors/",
    "https://docs.vllm.ai/en/latest/governance/collaboration/",
    "https://docs.vllm.ai/en/latest/governance/committers/",
    "https://docs.vllm.ai/en/latest/governance/process/"
  ]
}