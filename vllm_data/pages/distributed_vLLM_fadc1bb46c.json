{
  "url": "https://docs.vllm.ai/en/latest/api/vllm/distributed/",
  "title": "distributed - vLLM",
  "content": "Expert parallelism load balancer (EPLB).\n\nvLLM distributed state.\n\nBase class for device-specific communicator. It can use the cpu_group to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the device_group will also be given.\n\nCombine the hidden states and router logits from the appropriate device. This is a no-op in the base class.\n\nDispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class.\n\nNOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank.\n\nPrepare the communication buffer for the model.\n\nReceives a tensor from the source rank.\n\nSends a tensor to the destination rank in a blocking way\n\nPyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication.\n\nReturn the global rank of the first process in the group\n\nReturn whether the caller is the first process in the group\n\nReturn whether the caller is the last process in the group\n\nReturn the global rank of the last process in the group\n\nReturn the global rank of the process that follows the caller\n\nReturn the global rank of the process that precedes the caller\n\nUser-facing all-reduce function before we actually call the all-reduce operation.\n\nWe need this because Dynamo does not support passing an arbitrary object (self in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator.\n\nIn addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place.\n\nBarrier synchronization among the group. NOTE: don't use device_group here! barrier in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead.\n\nBroadcast the input tensor. NOTE: src is the local rank of the source rank.\n\nBroadcast the input object. NOTE: src is the local rank of the source rank.\n\nBroadcast the input object list. NOTE: src is the local rank of the source rank.\n\nBroadcast the input tensor dictionary. NOTE: src is the local rank of the source rank.\n\nNOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank.\n\nReceives a tensor from the source rank.\n\nReceive the input object list from the source rank.\n\nRecv the input tensor dictionary. NOTE: src is the local rank of the source rank.\n\nan optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group.\n\nall_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis.\n\nSends a tensor to the destination rank in a blocking way\n\nSend the input object list to the destination rank.\n\nSend the input tensor dictionary. NOTE: dst is the local rank of the source rank.\n\nan optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group.\n\nall_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis.\n\nA dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects.\n\nAll gather an object from all ranks.\n\nA robust barrier to synchronize all ranks.\n\nUses a multi-phase approach to ensure all processes reach the barrier before proceeding:\n\nEach process signals it has reached the barrier\n\nEach process signals that it has confirmed the arrival of all other ranks.\n\nRank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first.\n\nMaximum time in seconds to wait for each phase (in seconds)\n\nIf coordination fails or times out\n\nBroadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization.\n\nA replacement for torch.distributed.init_process_group that does not pollute the global state.\n\nIf we have process A and process B called torch.distributed.init_process_group to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue.\n\ntorch.distributed.init_process_group is a global call, while this function is a stateless call. It will return a StatelessProcessGroup object that can be used for exchanging metadata. With this function, process A and process B can call StatelessProcessGroup.create to form a group, and then process A, B, C, and D can call StatelessProcessGroup.create to form another group.\n\nExpire data that is older than data_expiration_seconds seconds.\n\nReceive an object from a source rank.\n\nSend an object to a destination rank.\n\nSet the groups to none and destroy them.\n\ntorch.library.custom_op can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details.\n\nBy default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the target_lib argument.\n\nIMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used.\n\nEnsure that numerator is divisible by the denominator and return the division value.\n\nEnsure that numerator is divisible by the denominator.\n\nHelper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized.\n\nReturn my rank for the decode context model parallel group.\n\nReturn world size for the decode context model parallel group.\n\nReturn the total number of nodes in the distributed environment.\n\nTry to evenly distribute layers across partitions.\n\nIf the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute.\n\nIf pp_size > 2 and the number of remaining layers is 0 < x <= pp_size - 2 then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions.\n\nReturn my rank for the tensor model parallel group.\n\nReturn world size for the tensor model parallel group.\n\ngraph_capture is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a GraphCaptureContext object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream.\n\nThis is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory).\n\nStateless init ProcessGroup with gloo backend compatible with different torch versions.\n\nThe main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured.\n\nInitialize model parallel groups.\n\nnumber of GPUs used for tensor model parallelism.\n\nnumber of GPUs used for pipeline model parallelism.\n\nname of torch distributed communication backend.\n\nLet's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box.\n\nCheck if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.).\n\nUnlike group-specific checks like get_tensor_model_parallel_rank() == 0 or get_pp_group().is_first_rank, this function checks the global rank across all parallelism dimensions.\n\nTrue if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process).\n\nCheck if the current process is the first local rank (rank 0 on its node).\n\nCheck if the installed torch version is >= the target version.\n\na version string, like \"2.6.0\".\n\nWhether the condition meets.\n\nCheck if tensor and pipeline parallel groups are initialized.\n\nPatch the tp group temporarily until this function ends.\n\nThis method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers.\n\nthe tp group coordinator\n\nPrepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance.\n\nResolve an object by its fully-qualified class name.\n\nSplit a tensor along its last dimension.\n\nnumber of partitions to split the tensor\n\nIf True, make each chunk contiguous in memory.\n\nDestroy ProcessGroup returned by stateless_init_torch_distributed_process_group().\n\nA replacement for torch.distributed.init_process_group that does not pollute the global state. The created ProcessGroup object can be used for some operations such as allreduce, because it does not depend on the global rank. However, some operations such as broadcast cannot be used because it depends on the global rank.\n\nThis function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8?\n\nOne possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel.\n\nOur solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10.\n\nSuppress stdout from C libraries at the file descriptor level.\n\nOnly suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG.\n\nwith suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\")\n\nAll-gather the input tensor across model parallel group.\n\nAll-reduce the input tensor across model parallel group.\n\nGather the input tensor across model parallel group.\n\nReduce-Scatter the input tensor across model parallel group.",
  "headings": [
    {
      "level": "h1",
      "text": "vllm.distributed ¶",
      "id": "vllm.distributed"
    },
    {
      "level": "h2",
      "text": "TensorMetadata module-attribute ¶",
      "id": "vllm.distributed.TensorMetadata"
    },
    {
      "level": "h2",
      "text": "USE_SCHED_YIELD module-attribute ¶",
      "id": "vllm.distributed.USE_SCHED_YIELD"
    },
    {
      "level": "h2",
      "text": "get_context_model_parallel_group module-attribute ¶",
      "id": "vllm.distributed.get_context_model_parallel_group"
    },
    {
      "level": "h2",
      "text": "logger module-attribute ¶",
      "id": "vllm.distributed.logger"
    },
    {
      "level": "h2",
      "text": "DeviceCommunicatorBase ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase"
    },
    {
      "level": "h3",
      "text": "all2all_backend instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.all2all_backend"
    },
    {
      "level": "h3",
      "text": "all2all_manager instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.all2all_manager"
    },
    {
      "level": "h3",
      "text": "cpu_group instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.cpu_group"
    },
    {
      "level": "h3",
      "text": "device instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.device"
    },
    {
      "level": "h3",
      "text": "device_group instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.device_group"
    },
    {
      "level": "h3",
      "text": "global_rank instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.global_rank"
    },
    {
      "level": "h3",
      "text": "global_world_size instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.global_world_size"
    },
    {
      "level": "h3",
      "text": "is_ep_communicator instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.is_ep_communicator"
    },
    {
      "level": "h3",
      "text": "rank instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.rank"
    },
    {
      "level": "h3",
      "text": "rank_in_group instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.rank_in_group"
    },
    {
      "level": "h3",
      "text": "ranks instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.ranks"
    },
    {
      "level": "h3",
      "text": "unique_name instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.unique_name"
    },
    {
      "level": "h3",
      "text": "use_all2all instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.use_all2all"
    },
    {
      "level": "h3",
      "text": "world_size instance-attribute ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.world_size"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.__init__"
    },
    {
      "level": "h3",
      "text": "all_gather ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.all_gather"
    },
    {
      "level": "h3",
      "text": "all_gatherv ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.all_gatherv"
    },
    {
      "level": "h3",
      "text": "all_reduce ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.all_reduce"
    },
    {
      "level": "h3",
      "text": "combine ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.combine"
    },
    {
      "level": "h3",
      "text": "destroy ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.destroy"
    },
    {
      "level": "h3",
      "text": "dispatch ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.dispatch"
    },
    {
      "level": "h3",
      "text": "gather ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.gather"
    },
    {
      "level": "h3",
      "text": "prepare_communication_buffer_for_model ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.prepare_communication_buffer_for_model"
    },
    {
      "level": "h3",
      "text": "recv ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.recv"
    },
    {
      "level": "h3",
      "text": "reduce_scatter ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.reduce_scatter"
    },
    {
      "level": "h3",
      "text": "reduce_scatterv ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.reduce_scatterv"
    },
    {
      "level": "h3",
      "text": "send ¶",
      "id": "vllm.distributed.DeviceCommunicatorBase.send"
    },
    {
      "level": "h2",
      "text": "GraphCaptureContext dataclass ¶",
      "id": "vllm.distributed.GraphCaptureContext"
    },
    {
      "level": "h3",
      "text": "stream instance-attribute ¶",
      "id": "vllm.distributed.GraphCaptureContext.stream"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.distributed.GraphCaptureContext.__init__"
    },
    {
      "level": "h2",
      "text": "GroupCoordinator ¶",
      "id": "vllm.distributed.GroupCoordinator"
    },
    {
      "level": "h3",
      "text": "cpu_group instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.cpu_group"
    },
    {
      "level": "h3",
      "text": "device instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.device"
    },
    {
      "level": "h3",
      "text": "device_communicator instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.device_communicator"
    },
    {
      "level": "h3",
      "text": "device_group instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.device_group"
    },
    {
      "level": "h3",
      "text": "first_rank property ¶",
      "id": "vllm.distributed.GroupCoordinator.first_rank"
    },
    {
      "level": "h3",
      "text": "is_first_rank property ¶",
      "id": "vllm.distributed.GroupCoordinator.is_first_rank"
    },
    {
      "level": "h3",
      "text": "is_last_rank property ¶",
      "id": "vllm.distributed.GroupCoordinator.is_last_rank"
    },
    {
      "level": "h3",
      "text": "last_rank property ¶",
      "id": "vllm.distributed.GroupCoordinator.last_rank"
    },
    {
      "level": "h3",
      "text": "local_rank instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.local_rank"
    },
    {
      "level": "h3",
      "text": "mq_broadcaster instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.mq_broadcaster"
    },
    {
      "level": "h3",
      "text": "next_rank property ¶",
      "id": "vllm.distributed.GroupCoordinator.next_rank"
    },
    {
      "level": "h3",
      "text": "prev_rank property ¶",
      "id": "vllm.distributed.GroupCoordinator.prev_rank"
    },
    {
      "level": "h3",
      "text": "rank instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.rank"
    },
    {
      "level": "h3",
      "text": "rank_in_group instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.rank_in_group"
    },
    {
      "level": "h3",
      "text": "ranks instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.ranks"
    },
    {
      "level": "h3",
      "text": "unique_name instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.unique_name"
    },
    {
      "level": "h3",
      "text": "use_cpu_custom_send_recv instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.use_cpu_custom_send_recv"
    },
    {
      "level": "h3",
      "text": "use_custom_op_call instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.use_custom_op_call"
    },
    {
      "level": "h3",
      "text": "use_device_communicator instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.use_device_communicator"
    },
    {
      "level": "h3",
      "text": "world_size instance-attribute ¶",
      "id": "vllm.distributed.GroupCoordinator.world_size"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.distributed.GroupCoordinator.__init__"
    },
    {
      "level": "h3",
      "text": "_all_gather_out_place ¶",
      "id": "vllm.distributed.GroupCoordinator._all_gather_out_place"
    },
    {
      "level": "h3",
      "text": "_all_reduce_out_place ¶",
      "id": "vllm.distributed.GroupCoordinator._all_reduce_out_place"
    },
    {
      "level": "h3",
      "text": "_reduce_scatter_out_place ¶",
      "id": "vllm.distributed.GroupCoordinator._reduce_scatter_out_place"
    },
    {
      "level": "h3",
      "text": "all_gather ¶",
      "id": "vllm.distributed.GroupCoordinator.all_gather"
    },
    {
      "level": "h3",
      "text": "all_gatherv ¶",
      "id": "vllm.distributed.GroupCoordinator.all_gatherv"
    },
    {
      "level": "h3",
      "text": "all_reduce ¶",
      "id": "vllm.distributed.GroupCoordinator.all_reduce"
    },
    {
      "level": "h3",
      "text": "barrier ¶",
      "id": "vllm.distributed.GroupCoordinator.barrier"
    },
    {
      "level": "h3",
      "text": "broadcast ¶",
      "id": "vllm.distributed.GroupCoordinator.broadcast"
    },
    {
      "level": "h3",
      "text": "broadcast_object ¶",
      "id": "vllm.distributed.GroupCoordinator.broadcast_object"
    },
    {
      "level": "h3",
      "text": "broadcast_object_list ¶",
      "id": "vllm.distributed.GroupCoordinator.broadcast_object_list"
    },
    {
      "level": "h3",
      "text": "broadcast_tensor_dict ¶",
      "id": "vllm.distributed.GroupCoordinator.broadcast_tensor_dict"
    },
    {
      "level": "h3",
      "text": "combine ¶",
      "id": "vllm.distributed.GroupCoordinator.combine"
    },
    {
      "level": "h3",
      "text": "create_mq_broadcaster ¶",
      "id": "vllm.distributed.GroupCoordinator.create_mq_broadcaster"
    },
    {
      "level": "h3",
      "text": "create_single_reader_mq_broadcasters ¶",
      "id": "vllm.distributed.GroupCoordinator.create_single_reader_mq_broadcasters"
    },
    {
      "level": "h3",
      "text": "destroy ¶",
      "id": "vllm.distributed.GroupCoordinator.destroy"
    },
    {
      "level": "h3",
      "text": "dispatch ¶",
      "id": "vllm.distributed.GroupCoordinator.dispatch"
    },
    {
      "level": "h3",
      "text": "gather ¶",
      "id": "vllm.distributed.GroupCoordinator.gather"
    },
    {
      "level": "h3",
      "text": "graph_capture ¶",
      "id": "vllm.distributed.GroupCoordinator.graph_capture"
    },
    {
      "level": "h3",
      "text": "prepare_communication_buffer_for_model ¶",
      "id": "vllm.distributed.GroupCoordinator.prepare_communication_buffer_for_model"
    },
    {
      "level": "h3",
      "text": "recv ¶",
      "id": "vllm.distributed.GroupCoordinator.recv"
    },
    {
      "level": "h3",
      "text": "recv_object ¶",
      "id": "vllm.distributed.GroupCoordinator.recv_object"
    },
    {
      "level": "h3",
      "text": "recv_tensor_dict ¶",
      "id": "vllm.distributed.GroupCoordinator.recv_tensor_dict"
    },
    {
      "level": "h3",
      "text": "reduce_scatter ¶",
      "id": "vllm.distributed.GroupCoordinator.reduce_scatter"
    },
    {
      "level": "h3",
      "text": "reduce_scatterv ¶",
      "id": "vllm.distributed.GroupCoordinator.reduce_scatterv"
    },
    {
      "level": "h3",
      "text": "send ¶",
      "id": "vllm.distributed.GroupCoordinator.send"
    },
    {
      "level": "h3",
      "text": "send_object ¶",
      "id": "vllm.distributed.GroupCoordinator.send_object"
    },
    {
      "level": "h3",
      "text": "send_tensor_dict ¶",
      "id": "vllm.distributed.GroupCoordinator.send_tensor_dict"
    },
    {
      "level": "h2",
      "text": "StatelessProcessGroup dataclass ¶",
      "id": "vllm.distributed.StatelessProcessGroup"
    },
    {
      "level": "h3",
      "text": "broadcast_recv_src_counter class-attribute instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.broadcast_recv_src_counter"
    },
    {
      "level": "h3",
      "text": "broadcast_send_counter class-attribute instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.broadcast_send_counter"
    },
    {
      "level": "h3",
      "text": "data_expiration_seconds class-attribute instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.data_expiration_seconds"
    },
    {
      "level": "h3",
      "text": "entries class-attribute instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.entries"
    },
    {
      "level": "h3",
      "text": "rank instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.rank"
    },
    {
      "level": "h3",
      "text": "recv_src_counter class-attribute instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.recv_src_counter"
    },
    {
      "level": "h3",
      "text": "send_dst_counter class-attribute instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.send_dst_counter"
    },
    {
      "level": "h3",
      "text": "socket instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.socket"
    },
    {
      "level": "h3",
      "text": "store instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.store"
    },
    {
      "level": "h3",
      "text": "world_size instance-attribute ¶",
      "id": "vllm.distributed.StatelessProcessGroup.world_size"
    },
    {
      "level": "h3",
      "text": "__init__ ¶",
      "id": "vllm.distributed.StatelessProcessGroup.__init__"
    },
    {
      "level": "h3",
      "text": "__post_init__ ¶",
      "id": "vllm.distributed.StatelessProcessGroup.__post_init__"
    },
    {
      "level": "h3",
      "text": "all_gather_obj ¶",
      "id": "vllm.distributed.StatelessProcessGroup.all_gather_obj"
    },
    {
      "level": "h3",
      "text": "barrier ¶",
      "id": "vllm.distributed.StatelessProcessGroup.barrier"
    },
    {
      "level": "h3",
      "text": "broadcast_obj ¶",
      "id": "vllm.distributed.StatelessProcessGroup.broadcast_obj"
    },
    {
      "level": "h3",
      "text": "create staticmethod ¶",
      "id": "vllm.distributed.StatelessProcessGroup.create"
    },
    {
      "level": "h3",
      "text": "expire_data ¶",
      "id": "vllm.distributed.StatelessProcessGroup.expire_data"
    },
    {
      "level": "h3",
      "text": "recv_obj ¶",
      "id": "vllm.distributed.StatelessProcessGroup.recv_obj"
    },
    {
      "level": "h3",
      "text": "send_obj ¶",
      "id": "vllm.distributed.StatelessProcessGroup.send_obj"
    },
    {
      "level": "h2",
      "text": "all_gather ¶",
      "id": "vllm.distributed.all_gather"
    },
    {
      "level": "h2",
      "text": "all_gather_fake ¶",
      "id": "vllm.distributed.all_gather_fake"
    },
    {
      "level": "h2",
      "text": "all_reduce ¶",
      "id": "vllm.distributed.all_reduce"
    },
    {
      "level": "h2",
      "text": "all_reduce_fake ¶",
      "id": "vllm.distributed.all_reduce_fake"
    },
    {
      "level": "h2",
      "text": "broadcast_tensor_dict ¶",
      "id": "vllm.distributed.broadcast_tensor_dict"
    },
    {
      "level": "h2",
      "text": "cleanup_dist_env_and_memory ¶",
      "id": "vllm.distributed.cleanup_dist_env_and_memory"
    },
    {
      "level": "h2",
      "text": "destroy_distributed_environment ¶",
      "id": "vllm.distributed.destroy_distributed_environment"
    },
    {
      "level": "h2",
      "text": "destroy_model_parallel ¶",
      "id": "vllm.distributed.destroy_model_parallel"
    },
    {
      "level": "h2",
      "text": "direct_register_custom_op ¶",
      "id": "vllm.distributed.direct_register_custom_op"
    },
    {
      "level": "h2",
      "text": "divide ¶",
      "id": "vllm.distributed.divide"
    },
    {
      "level": "h2",
      "text": "ensure_divisibility ¶",
      "id": "vllm.distributed.ensure_divisibility"
    },
    {
      "level": "h2",
      "text": "ensure_model_parallel_initialized ¶",
      "id": "vllm.distributed.ensure_model_parallel_initialized"
    },
    {
      "level": "h2",
      "text": "get_dcp_group ¶",
      "id": "vllm.distributed.get_dcp_group"
    },
    {
      "level": "h2",
      "text": "get_decode_context_model_parallel_rank ¶",
      "id": "vllm.distributed.get_decode_context_model_parallel_rank"
    },
    {
      "level": "h2",
      "text": "get_decode_context_model_parallel_world_size ¶",
      "id": "vllm.distributed.get_decode_context_model_parallel_world_size"
    },
    {
      "level": "h2",
      "text": "get_distributed_init_method ¶",
      "id": "vllm.distributed.get_distributed_init_method"
    },
    {
      "level": "h2",
      "text": "get_dp_group ¶",
      "id": "vllm.distributed.get_dp_group"
    },
    {
      "level": "h2",
      "text": "get_ep_group ¶",
      "id": "vllm.distributed.get_ep_group"
    },
    {
      "level": "h2",
      "text": "get_inner_dp_world_group ¶",
      "id": "vllm.distributed.get_inner_dp_world_group"
    },
    {
      "level": "h2",
      "text": "get_node_count ¶",
      "id": "vllm.distributed.get_node_count"
    },
    {
      "level": "h2",
      "text": "get_pcp_group ¶",
      "id": "vllm.distributed.get_pcp_group"
    },
    {
      "level": "h2",
      "text": "get_pp_group ¶",
      "id": "vllm.distributed.get_pp_group"
    },
    {
      "level": "h2",
      "text": "get_pp_indices ¶",
      "id": "vllm.distributed.get_pp_indices"
    },
    {
      "level": "h2",
      "text": "get_tcp_uri ¶",
      "id": "vllm.distributed.get_tcp_uri"
    },
    {
      "level": "h2",
      "text": "get_tensor_model_parallel_rank ¶",
      "id": "vllm.distributed.get_tensor_model_parallel_rank"
    },
    {
      "level": "h2",
      "text": "get_tensor_model_parallel_world_size ¶",
      "id": "vllm.distributed.get_tensor_model_parallel_world_size"
    },
    {
      "level": "h2",
      "text": "get_tp_group ¶",
      "id": "vllm.distributed.get_tp_group"
    },
    {
      "level": "h2",
      "text": "get_world_group ¶",
      "id": "vllm.distributed.get_world_group"
    },
    {
      "level": "h2",
      "text": "graph_capture ¶",
      "id": "vllm.distributed.graph_capture"
    },
    {
      "level": "h2",
      "text": "in_the_same_node_as ¶",
      "id": "vllm.distributed.in_the_same_node_as"
    },
    {
      "level": "h2",
      "text": "init_distributed_environment ¶",
      "id": "vllm.distributed.init_distributed_environment"
    },
    {
      "level": "h2",
      "text": "init_gloo_process_group ¶",
      "id": "vllm.distributed.init_gloo_process_group"
    },
    {
      "level": "h2",
      "text": "init_logger ¶",
      "id": "vllm.distributed.init_logger"
    },
    {
      "level": "h2",
      "text": "init_model_parallel_group ¶",
      "id": "vllm.distributed.init_model_parallel_group"
    },
    {
      "level": "h2",
      "text": "init_world_group ¶",
      "id": "vllm.distributed.init_world_group"
    },
    {
      "level": "h2",
      "text": "initialize_model_parallel ¶",
      "id": "vllm.distributed.initialize_model_parallel"
    },
    {
      "level": "h2",
      "text": "is_global_first_rank ¶",
      "id": "vllm.distributed.is_global_first_rank"
    },
    {
      "level": "h2",
      "text": "is_local_first_rank ¶",
      "id": "vllm.distributed.is_local_first_rank"
    },
    {
      "level": "h2",
      "text": "is_torch_equal_or_newer ¶",
      "id": "vllm.distributed.is_torch_equal_or_newer"
    },
    {
      "level": "h2",
      "text": "model_parallel_is_initialized ¶",
      "id": "vllm.distributed.model_parallel_is_initialized"
    },
    {
      "level": "h2",
      "text": "patch_tensor_parallel_group ¶",
      "id": "vllm.distributed.patch_tensor_parallel_group"
    },
    {
      "level": "h2",
      "text": "patched_fused_scaled_matmul_reduce_scatter ¶",
      "id": "vllm.distributed.patched_fused_scaled_matmul_reduce_scatter"
    },
    {
      "level": "h2",
      "text": "patched_fused_scaled_matmul_reduce_scatter_fake ¶",
      "id": "vllm.distributed.patched_fused_scaled_matmul_reduce_scatter_fake"
    },
    {
      "level": "h2",
      "text": "prepare_communication_buffer_for_model ¶",
      "id": "vllm.distributed.prepare_communication_buffer_for_model"
    },
    {
      "level": "h2",
      "text": "reduce_scatter ¶",
      "id": "vllm.distributed.reduce_scatter"
    },
    {
      "level": "h2",
      "text": "reduce_scatter_fake ¶",
      "id": "vllm.distributed.reduce_scatter_fake"
    },
    {
      "level": "h2",
      "text": "resolve_obj_by_qualname ¶",
      "id": "vllm.distributed.resolve_obj_by_qualname"
    },
    {
      "level": "h2",
      "text": "sched_yield ¶",
      "id": "vllm.distributed.sched_yield"
    },
    {
      "level": "h2",
      "text": "set_custom_all_reduce ¶",
      "id": "vllm.distributed.set_custom_all_reduce"
    },
    {
      "level": "h2",
      "text": "split_tensor_along_last_dim ¶",
      "id": "vllm.distributed.split_tensor_along_last_dim"
    },
    {
      "level": "h2",
      "text": "stateless_destroy_torch_distributed_process_group ¶",
      "id": "vllm.distributed.stateless_destroy_torch_distributed_process_group"
    },
    {
      "level": "h2",
      "text": "stateless_init_torch_distributed_process_group ¶",
      "id": "vllm.distributed.stateless_init_torch_distributed_process_group"
    },
    {
      "level": "h3",
      "text": "TODO: ask for help from PyTorch team if we need the broadcast operation.¶",
      "id": "vllm.distributed.stateless_init_torch_distributed_process_group--todo-ask-for-help-from-pytorch-team-if-we-need-the-broadcast-operation"
    },
    {
      "level": "h2",
      "text": "supports_custom_op ¶",
      "id": "vllm.distributed.supports_custom_op"
    },
    {
      "level": "h2",
      "text": "suppress_stdout ¶",
      "id": "vllm.distributed.suppress_stdout"
    },
    {
      "level": "h2",
      "text": "tensor_model_parallel_all_gather ¶",
      "id": "vllm.distributed.tensor_model_parallel_all_gather"
    },
    {
      "level": "h2",
      "text": "tensor_model_parallel_all_reduce ¶",
      "id": "vllm.distributed.tensor_model_parallel_all_reduce"
    },
    {
      "level": "h2",
      "text": "tensor_model_parallel_gather ¶",
      "id": "vllm.distributed.tensor_model_parallel_gather"
    },
    {
      "level": "h2",
      "text": "tensor_model_parallel_reduce_scatter ¶",
      "id": "vllm.distributed.tensor_model_parallel_reduce_scatter"
    }
  ],
  "code_samples": [
    {
      "code": "TensorMetadata = namedtuple(\n    \"TensorMetadata\", [\"device\", \"dtype\", \"size\"]\n)",
      "language": "unknown"
    },
    {
      "code": "TensorMetadata = namedtuple(\n    \"TensorMetadata\", [\"device\", \"dtype\", \"size\"]\n)",
      "language": "unknown"
    },
    {
      "code": "USE_SCHED_YIELD = (\n    version_info[:3] >= (3, 11, 1)\n    or version_info[:2] == (3, 10)\n    and version_info[2] >= 8\n)",
      "language": "json"
    },
    {
      "code": "USE_SCHED_YIELD = (\n    version_info[:3] >= (3, 11, 1)\n    or version_info[:2] == (3, 10)\n    and version_info[2] >= 8\n)",
      "language": "json"
    },
    {
      "code": "get_context_model_parallel_group = get_dcp_group",
      "language": "unknown"
    },
    {
      "code": "get_context_model_parallel_group = get_dcp_group",
      "language": "unknown"
    },
    {
      "code": "logger = init_logger(__name__)",
      "language": "unknown"
    },
    {
      "code": "logger = init_logger(__name__)",
      "language": "unknown"
    },
    {
      "code": "92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302",
      "language": "unknown"
    },
    {
      "code": "class DeviceCommunicatorBase:\n    \"\"\"\n    Base class for device-specific communicator.\n    It can use the `cpu_group` to initialize the communicator.\n    If the device has PyTorch integration (PyTorch can recognize its\n    communication backend), the `device_group` will also be given.\n    \"\"\"\n\n    def __init__(\n        self,\n        cpu_group: ProcessGroup,\n        device: torch.device | None = None,\n        device_group: ProcessGroup | None = None,\n        unique_name: str = \"\",\n    ):\n        self.device = device or torch.device(\"cpu\")\n        self.cpu_group = cpu_group\n        self.device_group = device_group\n        self.unique_name = unique_name\n        self.rank = dist.get_rank(cpu_group)\n        self.world_size = dist.get_world_size(cpu_group)\n        self.ranks = dist.get_process_group_ranks(cpu_group)\n        self.global_rank = dist.get_rank()\n        self.global_world_size = dist.get_world_size()\n        self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank)\n\n        use_ep = False\n        all2all_backend = None\n        from vllm.config import get_current_vllm_config\n\n        config = get_current_vllm_config()\n        if config is not None:\n            # as long as we use data parallel (coupled data parallel\n            # where all data parallel ranks execute forward together),\n            # we initialize the all2all manager used in expert parallel.\n            use_ep = config.parallel_config.data_parallel_size > 1\n            all2all_backend = config.parallel_config.all2all_backend\n\n        self.is_ep_communicator = \"ep\" in unique_name\n        self.use_all2all = self.is_ep_communicator and use_ep\n        self.all2all_backend = all2all_backend\n        self.all2all_manager: All2AllManagerBase | None = None\n\n    def all_reduce(self, input_: torch.Tensor) -> torch.Tensor:\n        dist.all_reduce(input_, group=self.device_group)\n        return input_\n\n    def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n        if dim < 0:\n            # Convert negative dim to positive.\n            dim += input_.dim()\n        input_size = input_.size()\n        # NOTE: we have to use concat-style all-gather here,\n        # stack-style all-gather has compatibility issues with\n        # torch.compile . see https://github.com/pytorch/pytorch/issues/138795\n        output_size = (input_size[0] * self.world_size,) + input_size[1:]\n        # Allocate output tensor.\n        output_tensor = torch.empty(\n            output_size, dtype=input_.dtype, device=input_.device\n        )\n        # All-gather.\n        dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group)\n        # Reshape\n        output_tensor = output_tensor.reshape((self.world_size,) + input_size)\n        output_tensor = output_tensor.movedim(0, dim)\n        output_tensor = output_tensor.reshape(\n            input_size[:dim]\n            + (self.world_size * input_size[dim],)\n            + input_size[dim + 1 :]\n        )\n        return output_tensor\n\n    def all_gatherv(\n        self,\n        input_: torch.Tensor | list[torch.Tensor],\n        dim: int = 0,\n        sizes: list[int] | None = None,\n    ) -> torch.Tensor | list[torch.Tensor]:\n        raise NotImplementedError\n\n    def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n        world_size = self.world_size\n        # Bypass the function if we are using only 1 GPU.\n        if world_size == 1:\n            return input_\n        assert -input_.dim() <= dim < input_.dim(), (\n            f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n        )\n\n        if dim < 0:\n            # Convert negative dim to positive.\n            dim += input_.dim()\n\n        # Note: This will produce an incorrect answer if we don't make\n        # the input_tensor contiguous. Possible bug in reduce_scatter_tensor?\n        input_tensor = input_.movedim(0, dim).contiguous()\n\n        assert input_tensor.shape[0] % world_size == 0\n        chunk_size = input_tensor.shape[0] // world_size\n        output_shape = (chunk_size,) + input_tensor.shape[1:]\n\n        output_tensor = torch.empty(\n            output_shape, dtype=input_tensor.dtype, device=input_tensor.device\n        )\n\n        # Perform reduce-scatter operation\n        torch.distributed.reduce_scatter_tensor(\n            output_tensor, input_tensor, group=self.device_group\n        )\n\n        # Reshape before returning\n        return output_tensor.movedim(0, dim).contiguous()\n\n    def reduce_scatterv(\n        self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None\n    ) -> torch.Tensor:\n        raise NotImplementedError\n\n    def gather(\n        self, input_: torch.Tensor, dst: int = 0, dim: int = -1\n    ) -> torch.Tensor | None:\n        \"\"\"\n        NOTE: We assume that the input tensor is on the same device across\n        all the ranks.\n        NOTE: `dst` is the local rank of the destination rank.\n        \"\"\"\n        world_size = self.world_size\n        assert -input_.dim() <= dim < input_.dim(), (\n            f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n        )\n        if dim < 0:\n            # Convert negative dim to positive.\n            dim += input_.dim()\n\n        # Allocate output tensor.\n        if self.rank_in_group == dst:\n            gather_list = [torch.empty_like(input_) for _ in range(world_size)]\n        else:\n            gather_list = None\n        # Gather.\n        torch.distributed.gather(\n            input_, gather_list, dst=self.ranks[dst], group=self.device_group\n        )\n        if self.rank_in_group == dst:\n            output_tensor = torch.cat(gather_list, dim=dim)\n        else:\n            output_tensor = None\n        return output_tensor\n\n    def send(self, tensor: torch.Tensor, dst: int | None = None) -> None:\n        \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\"\n        \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n        if dst is None:\n            dst = (self.rank_in_group + 1) % self.world_size\n        torch.distributed.send(tensor, self.ranks[dst], self.device_group)\n\n    def recv(\n        self, size: torch.Size, dtype: torch.dtype, src: int | None = None\n    ) -> torch.Tensor:\n        \"\"\"Receives a tensor from the source rank.\"\"\"\n        \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n        if src is None:\n            src = (self.rank_in_group - 1) % self.world_size\n\n        tensor = torch.empty(size, dtype=dtype, device=self.device)\n        torch.distributed.recv(tensor, self.ranks[src], self.device_group)\n        return tensor\n\n    def destroy(self):\n        pass\n\n    def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None:\n        \"\"\"\n        Prepare the communication buffer for the model.\n        \"\"\"\n        if not self.is_ep_communicator:\n            return\n\n        moe_modules = [\n            module\n            for module in model.modules()\n            # TODO(bnell): Should use isinstance but can't.  Maybe search for\n            # presence of quant_method.maybe_init_modular_kernel?\n            if (\n                module.__class__.__name__ == \"FusedMoE\"\n                or module.__class__.__name__ == \"SharedFusedMoE\"\n            )\n        ]\n        for module in moe_modules:\n            module.maybe_init_modular_kernel()\n\n    def dispatch(\n        self,\n        hidden_states: torch.Tensor,\n        router_logits: torch.Tensor,\n        is_sequence_parallel: bool = False,\n    ) -> tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Dispatch the hidden states and router logits to the appropriate device.\n        This is a no-op in the base class.\n        \"\"\"\n        return hidden_states, router_logits\n\n    def combine(\n        self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False\n    ) -> torch.Tensor:\n        \"\"\"\n        Combine the hidden states and router logits from the appropriate device.\n        This is a no-op in the base class.\n        \"\"\"\n        return hidden_states",
      "language": "python"
    },
    {
      "code": "class DeviceCommunicatorBase:\n    \"\"\"\n    Base class for device-specific communicator.\n    It can use the `cpu_group` to initialize the communicator.\n    If the device has PyTorch integration (PyTorch can recognize its\n    communication backend), the `device_group` will also be given.\n    \"\"\"\n\n    def __init__(\n        self,\n        cpu_group: ProcessGroup,\n        device: torch.device | None = None,\n        device_group: ProcessGroup | None = None,\n        unique_name: str = \"\",\n    ):\n        self.device = device or torch.device(\"cpu\")\n        self.cpu_group = cpu_group\n        self.device_group = device_group\n        self.unique_name = unique_name\n        self.rank = dist.get_rank(cpu_group)\n        self.world_size = dist.get_world_size(cpu_group)\n        self.ranks = dist.get_process_group_ranks(cpu_group)\n        self.global_rank = dist.get_rank()\n        self.global_world_size = dist.get_world_size()\n        self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank)\n\n        use_ep = False\n        all2all_backend = None\n        from vllm.config import get_current_vllm_config\n\n        config = get_current_vllm_config()\n        if config is not None:\n            # as long as we use data parallel (coupled data parallel\n            # where all data parallel ranks execute forward together),\n            # we initialize the all2all manager used in expert parallel.\n            use_ep = config.parallel_config.data_parallel_size > 1\n            all2all_backend = config.parallel_config.all2all_backend\n\n        self.is_ep_communicator = \"ep\" in unique_name\n        self.use_all2all = self.is_ep_communicator and use_ep\n        self.all2all_backend = all2all_backend\n        self.all2all_manager: All2AllManagerBase | None = None\n\n    def all_reduce(self, input_: torch.Tensor) -> torch.Tensor:\n        dist.all_reduce(input_, group=self.device_group)\n        return input_\n\n    def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n        if dim < 0:\n            # Convert negative dim to positive.\n            dim += input_.dim()\n        input_size = input_.size()\n        # NOTE: we have to use concat-style all-gather here,\n        # stack-style all-gather has compatibility issues with\n        # torch.compile . see https://github.com/pytorch/pytorch/issues/138795\n        output_size = (input_size[0] * self.world_size,) + input_size[1:]\n        # Allocate output tensor.\n        output_tensor = torch.empty(\n            output_size, dtype=input_.dtype, device=input_.device\n        )\n        # All-gather.\n        dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group)\n        # Reshape\n        output_tensor = output_tensor.reshape((self.world_size,) + input_size)\n        output_tensor = output_tensor.movedim(0, dim)\n        output_tensor = output_tensor.reshape(\n            input_size[:dim]\n            + (self.world_size * input_size[dim],)\n            + input_size[dim + 1 :]\n        )\n        return output_tensor\n\n    def all_gatherv(\n        self,\n        input_: torch.Tensor | list[torch.Tensor],\n        dim: int = 0,\n        sizes: list[int] | None = None,\n    ) -> torch.Tensor | list[torch.Tensor]:\n        raise NotImplementedError\n\n    def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n        world_size = self.world_size\n        # Bypass the function if we are using only 1 GPU.\n        if world_size == 1:\n            return input_\n        assert -input_.dim() <= dim < input_.dim(), (\n            f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n        )\n\n        if dim < 0:\n            # Convert negative dim to positive.\n            dim += input_.dim()\n\n        # Note: This will produce an incorrect answer if we don't make\n        # the input_tensor contiguous. Possible bug in reduce_scatter_tensor?\n        input_tensor = input_.movedim(0, dim).contiguous()\n\n        assert input_tensor.shape[0] % world_size == 0\n        chunk_size = input_tensor.shape[0] // world_size\n        output_shape = (chunk_size,) + input_tensor.shape[1:]\n\n        output_tensor = torch.empty(\n            output_shape, dtype=input_tensor.dtype, device=input_tensor.device\n        )\n\n        # Perform reduce-scatter operation\n        torch.distributed.reduce_scatter_tensor(\n            output_tensor, input_tensor, group=self.device_group\n        )\n\n        # Reshape before returning\n        return output_tensor.movedim(0, dim).contiguous()\n\n    def reduce_scatterv(\n        self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None\n    ) -> torch.Tensor:\n        raise NotImplementedError\n\n    def gather(\n        self, input_: torch.Tensor, dst: int = 0, dim: int = -1\n    ) -> torch.Tensor | None:\n        \"\"\"\n        NOTE: We assume that the input tensor is on the same device across\n        all the ranks.\n        NOTE: `dst` is the local rank of the destination rank.\n        \"\"\"\n        world_size = self.world_size\n        assert -input_.dim() <= dim < input_.dim(), (\n            f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n        )\n        if dim < 0:\n            # Convert negative dim to positive.\n            dim += input_.dim()\n\n        # Allocate output tensor.\n        if self.rank_in_group == dst:\n            gather_list = [torch.empty_like(input_) for _ in range(world_size)]\n        else:\n            gather_list = None\n        # Gather.\n        torch.distributed.gather(\n            input_, gather_list, dst=self.ranks[dst], group=self.device_group\n        )\n        if self.rank_in_group == dst:\n            output_tensor = torch.cat(gather_list, dim=dim)\n        else:\n            output_tensor = None\n        return output_tensor\n\n    def send(self, tensor: torch.Tensor, dst: int | None = None) -> None:\n        \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\"\n        \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n        if dst is None:\n            dst = (self.rank_in_group + 1) % self.world_size\n        torch.distributed.send(tensor, self.ranks[dst], self.device_group)\n\n    def recv(\n        self, size: torch.Size, dtype: torch.dtype, src: int | None = None\n    ) -> torch.Tensor:\n        \"\"\"Receives a tensor from the source rank.\"\"\"\n        \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n        if src is None:\n            src = (self.rank_in_group - 1) % self.world_size\n\n        tensor = torch.empty(size, dtype=dtype, device=self.device)\n        torch.distributed.recv(tensor, self.ranks[src], self.device_group)\n        return tensor\n\n    def destroy(self):\n        pass\n\n    def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None:\n        \"\"\"\n        Prepare the communication buffer for the model.\n        \"\"\"\n        if not self.is_ep_communicator:\n            return\n\n        moe_modules = [\n            module\n            for module in model.modules()\n            # TODO(bnell): Should use isinstance but can't.  Maybe search for\n            # presence of quant_method.maybe_init_modular_kernel?\n            if (\n                module.__class__.__name__ == \"FusedMoE\"\n                or module.__class__.__name__ == \"SharedFusedMoE\"\n            )\n        ]\n        for module in moe_modules:\n            module.maybe_init_modular_kernel()\n\n    def dispatch(\n        self,\n        hidden_states: torch.Tensor,\n        router_logits: torch.Tensor,\n        is_sequence_parallel: bool = False,\n    ) -> tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Dispatch the hidden states and router logits to the appropriate device.\n        This is a no-op in the base class.\n        \"\"\"\n        return hidden_states, router_logits\n\n    def combine(\n        self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False\n    ) -> torch.Tensor:\n        \"\"\"\n        Combine the hidden states and router logits from the appropriate device.\n        This is a no-op in the base class.\n        \"\"\"\n        return hidden_states",
      "language": "python"
    },
    {
      "code": "all2all_backend = all2all_backend",
      "language": "unknown"
    },
    {
      "code": "all2all_backend = all2all_backend",
      "language": "unknown"
    },
    {
      "code": "all2all_manager: All2AllManagerBase | None = None",
      "language": "yaml"
    },
    {
      "code": "all2all_manager: All2AllManagerBase | None = None",
      "language": "yaml"
    },
    {
      "code": "cpu_group = cpu_group",
      "language": "unknown"
    },
    {
      "code": "cpu_group = cpu_group",
      "language": "unknown"
    },
    {
      "code": "device = device or device('cpu')",
      "language": "unknown"
    },
    {
      "code": "device = device or device('cpu')",
      "language": "unknown"
    },
    {
      "code": "device_group = device_group",
      "language": "unknown"
    },
    {
      "code": "device_group = device_group",
      "language": "unknown"
    },
    {
      "code": "global_rank = get_rank()",
      "language": "unknown"
    },
    {
      "code": "global_rank = get_rank()",
      "language": "unknown"
    },
    {
      "code": "global_world_size = get_world_size()",
      "language": "unknown"
    },
    {
      "code": "global_world_size = get_world_size()",
      "language": "unknown"
    },
    {
      "code": "is_ep_communicator = 'ep' in unique_name",
      "language": "unknown"
    },
    {
      "code": "is_ep_communicator = 'ep' in unique_name",
      "language": "unknown"
    },
    {
      "code": "rank = get_rank(cpu_group)",
      "language": "unknown"
    },
    {
      "code": "rank = get_rank(cpu_group)",
      "language": "unknown"
    },
    {
      "code": "rank_in_group = get_group_rank(cpu_group, global_rank)",
      "language": "unknown"
    },
    {
      "code": "rank_in_group = get_group_rank(cpu_group, global_rank)",
      "language": "unknown"
    },
    {
      "code": "ranks = get_process_group_ranks(cpu_group)",
      "language": "unknown"
    },
    {
      "code": "ranks = get_process_group_ranks(cpu_group)",
      "language": "unknown"
    },
    {
      "code": "unique_name = unique_name",
      "language": "unknown"
    },
    {
      "code": "unique_name = unique_name",
      "language": "unknown"
    },
    {
      "code": "use_all2all = is_ep_communicator and use_ep",
      "language": "unknown"
    },
    {
      "code": "use_all2all = is_ep_communicator and use_ep",
      "language": "unknown"
    },
    {
      "code": "world_size = get_world_size(cpu_group)",
      "language": "unknown"
    },
    {
      "code": "world_size = get_world_size(cpu_group)",
      "language": "unknown"
    },
    {
      "code": "__init__(\n    cpu_group: ProcessGroup,\n    device: device | None = None,\n    device_group: ProcessGroup | None = None,\n    unique_name: str = \"\",\n)",
      "language": "typescript"
    },
    {
      "code": "__init__(\n    cpu_group: ProcessGroup,\n    device: device | None = None,\n    device_group: ProcessGroup | None = None,\n    unique_name: str = \"\",\n)",
      "language": "typescript"
    },
    {
      "code": "100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133",
      "language": "unknown"
    },
    {
      "code": "def __init__(\n    self,\n    cpu_group: ProcessGroup,\n    device: torch.device | None = None,\n    device_group: ProcessGroup | None = None,\n    unique_name: str = \"\",\n):\n    self.device = device or torch.device(\"cpu\")\n    self.cpu_group = cpu_group\n    self.device_group = device_group\n    self.unique_name = unique_name\n    self.rank = dist.get_rank(cpu_group)\n    self.world_size = dist.get_world_size(cpu_group)\n    self.ranks = dist.get_process_group_ranks(cpu_group)\n    self.global_rank = dist.get_rank()\n    self.global_world_size = dist.get_world_size()\n    self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank)\n\n    use_ep = False\n    all2all_backend = None\n    from vllm.config import get_current_vllm_config\n\n    config = get_current_vllm_config()\n    if config is not None:\n        # as long as we use data parallel (coupled data parallel\n        # where all data parallel ranks execute forward together),\n        # we initialize the all2all manager used in expert parallel.\n        use_ep = config.parallel_config.data_parallel_size > 1\n        all2all_backend = config.parallel_config.all2all_backend\n\n    self.is_ep_communicator = \"ep\" in unique_name\n    self.use_all2all = self.is_ep_communicator and use_ep\n    self.all2all_backend = all2all_backend\n    self.all2all_manager: All2AllManagerBase | None = None",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    cpu_group: ProcessGroup,\n    device: torch.device | None = None,\n    device_group: ProcessGroup | None = None,\n    unique_name: str = \"\",\n):\n    self.device = device or torch.device(\"cpu\")\n    self.cpu_group = cpu_group\n    self.device_group = device_group\n    self.unique_name = unique_name\n    self.rank = dist.get_rank(cpu_group)\n    self.world_size = dist.get_world_size(cpu_group)\n    self.ranks = dist.get_process_group_ranks(cpu_group)\n    self.global_rank = dist.get_rank()\n    self.global_world_size = dist.get_world_size()\n    self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank)\n\n    use_ep = False\n    all2all_backend = None\n    from vllm.config import get_current_vllm_config\n\n    config = get_current_vllm_config()\n    if config is not None:\n        # as long as we use data parallel (coupled data parallel\n        # where all data parallel ranks execute forward together),\n        # we initialize the all2all manager used in expert parallel.\n        use_ep = config.parallel_config.data_parallel_size > 1\n        all2all_backend = config.parallel_config.all2all_backend\n\n    self.is_ep_communicator = \"ep\" in unique_name\n    self.use_all2all = self.is_ep_communicator and use_ep\n    self.all2all_backend = all2all_backend\n    self.all2all_manager: All2AllManagerBase | None = None",
      "language": "python"
    },
    {
      "code": "all_gather(input_: Tensor, dim: int = -1) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "all_gather(input_: Tensor, dim: int = -1) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162",
      "language": "unknown"
    },
    {
      "code": "def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    if dim < 0:\n        # Convert negative dim to positive.\n        dim += input_.dim()\n    input_size = input_.size()\n    # NOTE: we have to use concat-style all-gather here,\n    # stack-style all-gather has compatibility issues with\n    # torch.compile . see https://github.com/pytorch/pytorch/issues/138795\n    output_size = (input_size[0] * self.world_size,) + input_size[1:]\n    # Allocate output tensor.\n    output_tensor = torch.empty(\n        output_size, dtype=input_.dtype, device=input_.device\n    )\n    # All-gather.\n    dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group)\n    # Reshape\n    output_tensor = output_tensor.reshape((self.world_size,) + input_size)\n    output_tensor = output_tensor.movedim(0, dim)\n    output_tensor = output_tensor.reshape(\n        input_size[:dim]\n        + (self.world_size * input_size[dim],)\n        + input_size[dim + 1 :]\n    )\n    return output_tensor",
      "language": "python"
    },
    {
      "code": "def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    if dim < 0:\n        # Convert negative dim to positive.\n        dim += input_.dim()\n    input_size = input_.size()\n    # NOTE: we have to use concat-style all-gather here,\n    # stack-style all-gather has compatibility issues with\n    # torch.compile . see https://github.com/pytorch/pytorch/issues/138795\n    output_size = (input_size[0] * self.world_size,) + input_size[1:]\n    # Allocate output tensor.\n    output_tensor = torch.empty(\n        output_size, dtype=input_.dtype, device=input_.device\n    )\n    # All-gather.\n    dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group)\n    # Reshape\n    output_tensor = output_tensor.reshape((self.world_size,) + input_size)\n    output_tensor = output_tensor.movedim(0, dim)\n    output_tensor = output_tensor.reshape(\n        input_size[:dim]\n        + (self.world_size * input_size[dim],)\n        + input_size[dim + 1 :]\n    )\n    return output_tensor",
      "language": "python"
    },
    {
      "code": "all_gatherv(\n    input_: Tensor | list[Tensor],\n    dim: int = 0,\n    sizes: list[int] | None = None,\n) -> Tensor | list[Tensor]",
      "language": "typescript"
    },
    {
      "code": "all_gatherv(\n    input_: Tensor | list[Tensor],\n    dim: int = 0,\n    sizes: list[int] | None = None,\n) -> Tensor | list[Tensor]",
      "language": "typescript"
    },
    {
      "code": "164\n165\n166\n167\n168\n169\n170",
      "language": "unknown"
    },
    {
      "code": "def all_gatherv(\n    self,\n    input_: torch.Tensor | list[torch.Tensor],\n    dim: int = 0,\n    sizes: list[int] | None = None,\n) -> torch.Tensor | list[torch.Tensor]:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "def all_gatherv(\n    self,\n    input_: torch.Tensor | list[torch.Tensor],\n    dim: int = 0,\n    sizes: list[int] | None = None,\n) -> torch.Tensor | list[torch.Tensor]:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "all_reduce(input_: Tensor) -> Tensor",
      "language": "php"
    },
    {
      "code": "all_reduce(input_: Tensor) -> Tensor",
      "language": "php"
    },
    {
      "code": "135\n136\n137",
      "language": "unknown"
    },
    {
      "code": "def all_reduce(self, input_: torch.Tensor) -> torch.Tensor:\n    dist.all_reduce(input_, group=self.device_group)\n    return input_",
      "language": "python"
    },
    {
      "code": "def all_reduce(self, input_: torch.Tensor) -> torch.Tensor:\n    dist.all_reduce(input_, group=self.device_group)\n    return input_",
      "language": "python"
    },
    {
      "code": "combine(\n    hidden_states: Tensor,\n    is_sequence_parallel: bool = False,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "combine(\n    hidden_states: Tensor,\n    is_sequence_parallel: bool = False,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "295\n296\n297\n298\n299\n300\n301\n302",
      "language": "unknown"
    },
    {
      "code": "def combine(\n    self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False\n) -> torch.Tensor:\n    \"\"\"\n    Combine the hidden states and router logits from the appropriate device.\n    This is a no-op in the base class.\n    \"\"\"\n    return hidden_states",
      "language": "python"
    },
    {
      "code": "def combine(\n    self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False\n) -> torch.Tensor:\n    \"\"\"\n    Combine the hidden states and router logits from the appropriate device.\n    This is a no-op in the base class.\n    \"\"\"\n    return hidden_states",
      "language": "python"
    },
    {
      "code": "def destroy(self):\n    pass",
      "language": "python"
    },
    {
      "code": "def destroy(self):\n    pass",
      "language": "python"
    },
    {
      "code": "dispatch(\n    hidden_states: Tensor,\n    router_logits: Tensor,\n    is_sequence_parallel: bool = False,\n) -> tuple[Tensor, Tensor]",
      "language": "typescript"
    },
    {
      "code": "dispatch(\n    hidden_states: Tensor,\n    router_logits: Tensor,\n    is_sequence_parallel: bool = False,\n) -> tuple[Tensor, Tensor]",
      "language": "typescript"
    },
    {
      "code": "283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293",
      "language": "unknown"
    },
    {
      "code": "def dispatch(\n    self,\n    hidden_states: torch.Tensor,\n    router_logits: torch.Tensor,\n    is_sequence_parallel: bool = False,\n) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Dispatch the hidden states and router logits to the appropriate device.\n    This is a no-op in the base class.\n    \"\"\"\n    return hidden_states, router_logits",
      "language": "python"
    },
    {
      "code": "def dispatch(\n    self,\n    hidden_states: torch.Tensor,\n    router_logits: torch.Tensor,\n    is_sequence_parallel: bool = False,\n) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Dispatch the hidden states and router logits to the appropriate device.\n    This is a no-op in the base class.\n    \"\"\"\n    return hidden_states, router_logits",
      "language": "python"
    },
    {
      "code": "gather(\n    input_: Tensor, dst: int = 0, dim: int = -1\n) -> Tensor | None",
      "language": "typescript"
    },
    {
      "code": "gather(\n    input_: Tensor, dst: int = 0, dim: int = -1\n) -> Tensor | None",
      "language": "typescript"
    },
    {
      "code": "210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239",
      "language": "unknown"
    },
    {
      "code": "def gather(\n    self, input_: torch.Tensor, dst: int = 0, dim: int = -1\n) -> torch.Tensor | None:\n    \"\"\"\n    NOTE: We assume that the input tensor is on the same device across\n    all the ranks.\n    NOTE: `dst` is the local rank of the destination rank.\n    \"\"\"\n    world_size = self.world_size\n    assert -input_.dim() <= dim < input_.dim(), (\n        f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n    )\n    if dim < 0:\n        # Convert negative dim to positive.\n        dim += input_.dim()\n\n    # Allocate output tensor.\n    if self.rank_in_group == dst:\n        gather_list = [torch.empty_like(input_) for _ in range(world_size)]\n    else:\n        gather_list = None\n    # Gather.\n    torch.distributed.gather(\n        input_, gather_list, dst=self.ranks[dst], group=self.device_group\n    )\n    if self.rank_in_group == dst:\n        output_tensor = torch.cat(gather_list, dim=dim)\n    else:\n        output_tensor = None\n    return output_tensor",
      "language": "python"
    },
    {
      "code": "def gather(\n    self, input_: torch.Tensor, dst: int = 0, dim: int = -1\n) -> torch.Tensor | None:\n    \"\"\"\n    NOTE: We assume that the input tensor is on the same device across\n    all the ranks.\n    NOTE: `dst` is the local rank of the destination rank.\n    \"\"\"\n    world_size = self.world_size\n    assert -input_.dim() <= dim < input_.dim(), (\n        f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n    )\n    if dim < 0:\n        # Convert negative dim to positive.\n        dim += input_.dim()\n\n    # Allocate output tensor.\n    if self.rank_in_group == dst:\n        gather_list = [torch.empty_like(input_) for _ in range(world_size)]\n    else:\n        gather_list = None\n    # Gather.\n    torch.distributed.gather(\n        input_, gather_list, dst=self.ranks[dst], group=self.device_group\n    )\n    if self.rank_in_group == dst:\n        output_tensor = torch.cat(gather_list, dim=dim)\n    else:\n        output_tensor = None\n    return output_tensor",
      "language": "python"
    },
    {
      "code": "prepare_communication_buffer_for_model(\n    model: Module,\n) -> None",
      "language": "rust"
    },
    {
      "code": "prepare_communication_buffer_for_model(\n    model: Module,\n) -> None",
      "language": "rust"
    },
    {
      "code": "263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281",
      "language": "unknown"
    },
    {
      "code": "def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None:\n    \"\"\"\n    Prepare the communication buffer for the model.\n    \"\"\"\n    if not self.is_ep_communicator:\n        return\n\n    moe_modules = [\n        module\n        for module in model.modules()\n        # TODO(bnell): Should use isinstance but can't.  Maybe search for\n        # presence of quant_method.maybe_init_modular_kernel?\n        if (\n            module.__class__.__name__ == \"FusedMoE\"\n            or module.__class__.__name__ == \"SharedFusedMoE\"\n        )\n    ]\n    for module in moe_modules:\n        module.maybe_init_modular_kernel()",
      "language": "python"
    },
    {
      "code": "def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None:\n    \"\"\"\n    Prepare the communication buffer for the model.\n    \"\"\"\n    if not self.is_ep_communicator:\n        return\n\n    moe_modules = [\n        module\n        for module in model.modules()\n        # TODO(bnell): Should use isinstance but can't.  Maybe search for\n        # presence of quant_method.maybe_init_modular_kernel?\n        if (\n            module.__class__.__name__ == \"FusedMoE\"\n            or module.__class__.__name__ == \"SharedFusedMoE\"\n        )\n    ]\n    for module in moe_modules:\n        module.maybe_init_modular_kernel()",
      "language": "python"
    },
    {
      "code": "recv(\n    size: Size, dtype: dtype, src: int | None = None\n) -> Tensor",
      "language": "rust"
    },
    {
      "code": "recv(\n    size: Size, dtype: dtype, src: int | None = None\n) -> Tensor",
      "language": "rust"
    },
    {
      "code": "248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258",
      "language": "unknown"
    },
    {
      "code": "def recv(\n    self, size: torch.Size, dtype: torch.dtype, src: int | None = None\n) -> torch.Tensor:\n    \"\"\"Receives a tensor from the source rank.\"\"\"\n    \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n    if src is None:\n        src = (self.rank_in_group - 1) % self.world_size\n\n    tensor = torch.empty(size, dtype=dtype, device=self.device)\n    torch.distributed.recv(tensor, self.ranks[src], self.device_group)\n    return tensor",
      "language": "python"
    },
    {
      "code": "def recv(\n    self, size: torch.Size, dtype: torch.dtype, src: int | None = None\n) -> torch.Tensor:\n    \"\"\"Receives a tensor from the source rank.\"\"\"\n    \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n    if src is None:\n        src = (self.rank_in_group - 1) % self.world_size\n\n    tensor = torch.empty(size, dtype=dtype, device=self.device)\n    torch.distributed.recv(tensor, self.ranks[src], self.device_group)\n    return tensor",
      "language": "python"
    },
    {
      "code": "reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203",
      "language": "unknown"
    },
    {
      "code": "def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    world_size = self.world_size\n    # Bypass the function if we are using only 1 GPU.\n    if world_size == 1:\n        return input_\n    assert -input_.dim() <= dim < input_.dim(), (\n        f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n    )\n\n    if dim < 0:\n        # Convert negative dim to positive.\n        dim += input_.dim()\n\n    # Note: This will produce an incorrect answer if we don't make\n    # the input_tensor contiguous. Possible bug in reduce_scatter_tensor?\n    input_tensor = input_.movedim(0, dim).contiguous()\n\n    assert input_tensor.shape[0] % world_size == 0\n    chunk_size = input_tensor.shape[0] // world_size\n    output_shape = (chunk_size,) + input_tensor.shape[1:]\n\n    output_tensor = torch.empty(\n        output_shape, dtype=input_tensor.dtype, device=input_tensor.device\n    )\n\n    # Perform reduce-scatter operation\n    torch.distributed.reduce_scatter_tensor(\n        output_tensor, input_tensor, group=self.device_group\n    )\n\n    # Reshape before returning\n    return output_tensor.movedim(0, dim).contiguous()",
      "language": "python"
    },
    {
      "code": "def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    world_size = self.world_size\n    # Bypass the function if we are using only 1 GPU.\n    if world_size == 1:\n        return input_\n    assert -input_.dim() <= dim < input_.dim(), (\n        f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n    )\n\n    if dim < 0:\n        # Convert negative dim to positive.\n        dim += input_.dim()\n\n    # Note: This will produce an incorrect answer if we don't make\n    # the input_tensor contiguous. Possible bug in reduce_scatter_tensor?\n    input_tensor = input_.movedim(0, dim).contiguous()\n\n    assert input_tensor.shape[0] % world_size == 0\n    chunk_size = input_tensor.shape[0] // world_size\n    output_shape = (chunk_size,) + input_tensor.shape[1:]\n\n    output_tensor = torch.empty(\n        output_shape, dtype=input_tensor.dtype, device=input_tensor.device\n    )\n\n    # Perform reduce-scatter operation\n    torch.distributed.reduce_scatter_tensor(\n        output_tensor, input_tensor, group=self.device_group\n    )\n\n    # Reshape before returning\n    return output_tensor.movedim(0, dim).contiguous()",
      "language": "python"
    },
    {
      "code": "reduce_scatterv(\n    input_: Tensor,\n    dim: int = -1,\n    sizes: list[int] | None = None,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "reduce_scatterv(\n    input_: Tensor,\n    dim: int = -1,\n    sizes: list[int] | None = None,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "205\n206\n207\n208",
      "language": "unknown"
    },
    {
      "code": "def reduce_scatterv(\n    self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None\n) -> torch.Tensor:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "def reduce_scatterv(\n    self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None\n) -> torch.Tensor:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "send(tensor: Tensor, dst: int | None = None) -> None",
      "language": "rust"
    },
    {
      "code": "send(tensor: Tensor, dst: int | None = None) -> None",
      "language": "rust"
    },
    {
      "code": "241\n242\n243\n244\n245\n246",
      "language": "unknown"
    },
    {
      "code": "def send(self, tensor: torch.Tensor, dst: int | None = None) -> None:\n    \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\"\n    \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n    if dst is None:\n        dst = (self.rank_in_group + 1) % self.world_size\n    torch.distributed.send(tensor, self.ranks[dst], self.device_group)",
      "language": "python"
    },
    {
      "code": "def send(self, tensor: torch.Tensor, dst: int | None = None) -> None:\n    \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\"\n    \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n    if dst is None:\n        dst = (self.rank_in_group + 1) % self.world_size\n    torch.distributed.send(tensor, self.ranks[dst], self.device_group)",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass GraphCaptureContext:\n    stream: torch.cuda.Stream",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass GraphCaptureContext:\n    stream: torch.cuda.Stream",
      "language": "python"
    },
    {
      "code": "stream: Stream",
      "language": "yaml"
    },
    {
      "code": "stream: Stream",
      "language": "yaml"
    },
    {
      "code": "__init__(stream: Stream) -> None",
      "language": "python"
    },
    {
      "code": "__init__(stream: Stream) -> None",
      "language": "python"
    },
    {
      "code": "278\n 279\n 280\n 281\n 282\n 283\n 284\n 285\n 286\n 287\n 288\n 289\n 290\n 291\n 292\n 293\n 294\n 295\n 296\n 297\n 298\n 299\n 300\n 301\n 302\n 303\n 304\n 305\n 306\n 307\n 308\n 309\n 310\n 311\n 312\n 313\n 314\n 315\n 316\n 317\n 318\n 319\n 320\n 321\n 322\n 323\n 324\n 325\n 326\n 327\n 328\n 329\n 330\n 331\n 332\n 333\n 334\n 335\n 336\n 337\n 338\n 339\n 340\n 341\n 342\n 343\n 344\n 345\n 346\n 347\n 348\n 349\n 350\n 351\n 352\n 353\n 354\n 355\n 356\n 357\n 358\n 359\n 360\n 361\n 362\n 363\n 364\n 365\n 366\n 367\n 368\n 369\n 370\n 371\n 372\n 373\n 374\n 375\n 376\n 377\n 378\n 379\n 380\n 381\n 382\n 383\n 384\n 385\n 386\n 387\n 388\n 389\n 390\n 391\n 392\n 393\n 394\n 395\n 396\n 397\n 398\n 399\n 400\n 401\n 402\n 403\n 404\n 405\n 406\n 407\n 408\n 409\n 410\n 411\n 412\n 413\n 414\n 415\n 416\n 417\n 418\n 419\n 420\n 421\n 422\n 423\n 424\n 425\n 426\n 427\n 428\n 429\n 430\n 431\n 432\n 433\n 434\n 435\n 436\n 437\n 438\n 439\n 440\n 441\n 442\n 443\n 444\n 445\n 446\n 447\n 448\n 449\n 450\n 451\n 452\n 453\n 454\n 455\n 456\n 457\n 458\n 459\n 460\n 461\n 462\n 463\n 464\n 465\n 466\n 467\n 468\n 469\n 470\n 471\n 472\n 473\n 474\n 475\n 476\n 477\n 478\n 479\n 480\n 481\n 482\n 483\n 484\n 485\n 486\n 487\n 488\n 489\n 490\n 491\n 492\n 493\n 494\n 495\n 496\n 497\n 498\n 499\n 500\n 501\n 502\n 503\n 504\n 505\n 506\n 507\n 508\n 509\n 510\n 511\n 512\n 513\n 514\n 515\n 516\n 517\n 518\n 519\n 520\n 521\n 522\n 523\n 524\n 525\n 526\n 527\n 528\n 529\n 530\n 531\n 532\n 533\n 534\n 535\n 536\n 537\n 538\n 539\n 540\n 541\n 542\n 543\n 544\n 545\n 546\n 547\n 548\n 549\n 550\n 551\n 552\n 553\n 554\n 555\n 556\n 557\n 558\n 559\n 560\n 561\n 562\n 563\n 564\n 565\n 566\n 567\n 568\n 569\n 570\n 571\n 572\n 573\n 574\n 575\n 576\n 577\n 578\n 579\n 580\n 581\n 582\n 583\n 584\n 585\n 586\n 587\n 588\n 589\n 590\n 591\n 592\n 593\n 594\n 595\n 596\n 597\n 598\n 599\n 600\n 601\n 602\n 603\n 604\n 605\n 606\n 607\n 608\n 609\n 610\n 611\n 612\n 613\n 614\n 615\n 616\n 617\n 618\n 619\n 620\n 621\n 622\n 623\n 624\n 625\n 626\n 627\n 628\n 629\n 630\n 631\n 632\n 633\n 634\n 635\n 636\n 637\n 638\n 639\n 640\n 641\n 642\n 643\n 644\n 645\n 646\n 647\n 648\n 649\n 650\n 651\n 652\n 653\n 654\n 655\n 656\n 657\n 658\n 659\n 660\n 661\n 662\n 663\n 664\n 665\n 666\n 667\n 668\n 669\n 670\n 671\n 672\n 673\n 674\n 675\n 676\n 677\n 678\n 679\n 680\n 681\n 682\n 683\n 684\n 685\n 686\n 687\n 688\n 689\n 690\n 691\n 692\n 693\n 694\n 695\n 696\n 697\n 698\n 699\n 700\n 701\n 702\n 703\n 704\n 705\n 706\n 707\n 708\n 709\n 710\n 711\n 712\n 713\n 714\n 715\n 716\n 717\n 718\n 719\n 720\n 721\n 722\n 723\n 724\n 725\n 726\n 727\n 728\n 729\n 730\n 731\n 732\n 733\n 734\n 735\n 736\n 737\n 738\n 739\n 740\n 741\n 742\n 743\n 744\n 745\n 746\n 747\n 748\n 749\n 750\n 751\n 752\n 753\n 754\n 755\n 756\n 757\n 758\n 759\n 760\n 761\n 762\n 763\n 764\n 765\n 766\n 767\n 768\n 769\n 770\n 771\n 772\n 773\n 774\n 775\n 776\n 777\n 778\n 779\n 780\n 781\n 782\n 783\n 784\n 785\n 786\n 787\n 788\n 789\n 790\n 791\n 792\n 793\n 794\n 795\n 796\n 797\n 798\n 799\n 800\n 801\n 802\n 803\n 804\n 805\n 806\n 807\n 808\n 809\n 810\n 811\n 812\n 813\n 814\n 815\n 816\n 817\n 818\n 819\n 820\n 821\n 822\n 823\n 824\n 825\n 826\n 827\n 828\n 829\n 830\n 831\n 832\n 833\n 834\n 835\n 836\n 837\n 838\n 839\n 840\n 841\n 842\n 843\n 844\n 845\n 846\n 847\n 848\n 849\n 850\n 851\n 852\n 853\n 854\n 855\n 856\n 857\n 858\n 859\n 860\n 861\n 862\n 863\n 864\n 865\n 866\n 867\n 868\n 869\n 870\n 871\n 872\n 873\n 874\n 875\n 876\n 877\n 878\n 879\n 880\n 881\n 882\n 883\n 884\n 885\n 886\n 887\n 888\n 889\n 890\n 891\n 892\n 893\n 894\n 895\n 896\n 897\n 898\n 899\n 900\n 901\n 902\n 903\n 904\n 905\n 906\n 907\n 908\n 909\n 910\n 911\n 912\n 913\n 914\n 915\n 916\n 917\n 918\n 919\n 920\n 921\n 922\n 923\n 924\n 925\n 926\n 927\n 928\n 929\n 930\n 931\n 932\n 933\n 934\n 935\n 936\n 937\n 938\n 939\n 940\n 941\n 942\n 943\n 944\n 945\n 946\n 947\n 948\n 949\n 950\n 951\n 952\n 953\n 954\n 955\n 956\n 957\n 958\n 959\n 960\n 961\n 962\n 963\n 964\n 965\n 966\n 967\n 968\n 969\n 970\n 971\n 972\n 973\n 974\n 975\n 976\n 977\n 978\n 979\n 980\n 981\n 982\n 983\n 984\n 985\n 986\n 987\n 988\n 989\n 990\n 991\n 992\n 993\n 994\n 995\n 996\n 997\n 998\n 999\n1000\n1001\n1002\n1003\n1004\n1005\n1006\n1007\n1008\n1009\n1010\n1011\n1012\n1013\n1014\n1015\n1016\n1017\n1018\n1019\n1020\n1021\n1022\n1023\n1024\n1025\n1026\n1027\n1028\n1029\n1030\n1031",
      "language": "unknown"
    },
    {
      "code": "class GroupCoordinator:\n    \"\"\"\n    PyTorch ProcessGroup wrapper for a group of processes.\n    PyTorch ProcessGroup is bound to one specific communication backend,\n        e.g. NCCL, Gloo, MPI, etc.\n    GroupCoordinator takes charge of all the communication operations among\n        the processes in the group. It manages both CPU and device\n        communication.\n    \"\"\"\n\n    # available attributes:\n    rank: int  # global rank\n    ranks: list[int]  # global ranks in the group\n    world_size: int  # size of the group\n    # difference between `local_rank` and `rank_in_group`:\n    # if we have a group of size 4 across two nodes:\n    # Process | Node | Rank | Local Rank | Rank in Group\n    #   0     |   0  |  0   |     0      |       0\n    #   1     |   0  |  1   |     1      |       1\n    #   2     |   1  |  2   |     0      |       2\n    #   3     |   1  |  3   |     1      |       3\n    local_rank: int  # local rank used to assign devices\n    rank_in_group: int  # rank inside the group\n    cpu_group: ProcessGroup  # group for CPU communication\n    device_group: ProcessGroup  # group for device communication\n    # device communicator (if use_device_communicator=True)\n    device_communicator: DeviceCommunicatorBase | None\n    mq_broadcaster: Any | None  # shared memory broadcaster\n\n    def __init__(\n        self,\n        group_ranks: list[list[int]],\n        local_rank: int,\n        torch_distributed_backend: str | Backend,\n        use_device_communicator: bool,  # whether to use device communicator\n        use_message_queue_broadcaster: bool = False,\n        group_name: str | None = None,\n    ):\n        group_name = group_name or \"anonymous\"\n        self.unique_name = _get_unique_name(group_name)\n        _register_group(self)\n\n        self.rank = torch.distributed.get_rank()\n        self.local_rank = local_rank\n\n        self_device_group = None\n        self_cpu_group = None\n\n        for ranks in group_ranks:\n            device_group = torch.distributed.new_group(\n                ranks, backend=torch_distributed_backend\n            )\n            # a group with `gloo` backend, to allow direct coordination between\n            # processes through the CPU.\n            with suppress_stdout():\n                cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\")\n            if self.rank in ranks:\n                self.ranks = ranks\n                self.world_size = len(ranks)\n                self.rank_in_group = ranks.index(self.rank)\n                self_device_group = device_group\n                self_cpu_group = cpu_group\n\n        assert self_cpu_group is not None\n        assert self_device_group is not None\n\n        self.cpu_group = self_cpu_group\n        self.device_group = self_device_group\n\n        from vllm.platforms import current_platform\n\n        if current_platform.is_cuda_alike():\n            self.device = torch.device(f\"cuda:{local_rank}\")\n        elif current_platform.is_xpu():\n            self.device = torch.device(f\"xpu:{local_rank}\")\n        elif current_platform.is_out_of_tree():\n            self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\")\n        else:\n            self.device = torch.device(\"cpu\")\n\n        self.use_device_communicator = use_device_communicator\n        self.device_communicator = None\n        if use_device_communicator and self.world_size > 1:\n            device_comm_cls = resolve_obj_by_qualname(\n                current_platform.get_device_communicator_cls()\n            )\n            self.device_communicator = device_comm_cls(\n                cpu_group=self.cpu_group,\n                device=self.device,\n                device_group=self.device_group,\n                unique_name=self.unique_name,\n            )\n\n        from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n        self.mq_broadcaster: MessageQueue | None = None\n        if use_message_queue_broadcaster and self.world_size > 1:\n            self.mq_broadcaster = MessageQueue.create_from_process_group(\n                self.cpu_group, 1 << 22, 6\n            )\n\n        from vllm.platforms import current_platform\n\n        self.use_custom_op_call = (\n            current_platform.is_cuda_alike() or current_platform.is_tpu()\n        )\n\n        self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr(\n            torch.ops._C, \"init_shm_manager\"\n        )\n\n    def create_mq_broadcaster(\n        self, writer_rank=0, external_writer_handle=None, blocking=True\n    ):\n        from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n        return MessageQueue.create_from_process_group(\n            self.cpu_group,\n            1 << 22,\n            6,\n            writer_rank=writer_rank,\n            external_writer_handle=external_writer_handle,\n            blocking=blocking,\n        )\n\n    def create_single_reader_mq_broadcasters(\n        self, reader_rank_in_group=0, blocking=False\n    ):\n        from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n        return MessageQueue.create_from_process_group_single_reader(\n            self.cpu_group,\n            1 << 22,\n            6,\n            reader_rank=self.ranks[reader_rank_in_group],\n            blocking=blocking,\n        )\n\n    @property\n    def first_rank(self):\n        \"\"\"Return the global rank of the first process in the group\"\"\"\n        return self.ranks[0]\n\n    @property\n    def last_rank(self):\n        \"\"\"Return the global rank of the last process in the group\"\"\"\n        return self.ranks[-1]\n\n    @property\n    def is_first_rank(self):\n        \"\"\"Return whether the caller is the first process in the group\"\"\"\n        return self.rank == self.first_rank\n\n    @property\n    def is_last_rank(self):\n        \"\"\"Return whether the caller is the last process in the group\"\"\"\n        return self.rank == self.last_rank\n\n    @property\n    def next_rank(self):\n        \"\"\"Return the global rank of the process that follows the caller\"\"\"\n        rank_in_group = self.rank_in_group\n        world_size = self.world_size\n        return self.ranks[(rank_in_group + 1) % world_size]\n\n    @property\n    def prev_rank(self):\n        \"\"\"Return the global rank of the process that precedes the caller\"\"\"\n        rank_in_group = self.rank_in_group\n        world_size = self.world_size\n        return self.ranks[(rank_in_group - 1) % world_size]\n\n    @contextmanager\n    def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None):\n        if graph_capture_context is None:\n            stream = torch.cuda.Stream()\n            graph_capture_context = GraphCaptureContext(stream)\n        else:\n            stream = graph_capture_context.stream\n\n        # only cuda uses this function,\n        # so we don't abstract it into the base class\n        maybe_ca_context = nullcontext()\n        from vllm.distributed.device_communicators.cuda_communicator import (\n            CudaCommunicator,\n        )\n\n        if self.device_communicator is not None:\n            assert isinstance(self.device_communicator, CudaCommunicator)\n            ca_comm = self.device_communicator.ca_comm\n            if ca_comm is not None:\n                maybe_ca_context = ca_comm.capture()  # type: ignore\n\n        # ensure all initialization operations complete before attempting to\n        # capture the graph on another stream\n        curr_stream = torch.cuda.current_stream()\n        if curr_stream != stream:\n            stream.wait_stream(curr_stream)\n\n        with torch.cuda.stream(stream), maybe_ca_context:\n            yield graph_capture_context\n\n    def all_reduce(self, input_: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        User-facing all-reduce function before we actually call the\n        all-reduce operation.\n\n        We need this because Dynamo does not support passing an arbitrary\n        object (`self` in this case) to a custom op. We need to pass the\n         group name as a string, and then look up the group coordinator from\n         the group name, dispatch the all-reduce operation to the group\n         coordinator.\n\n        In addition, PyTorch custom ops do not support mutation or returning\n        a new tensor in the same op. So we always make the all-reduce operation\n        out-of-place.\n        \"\"\"\n        # Bypass the function if we are using only 1 GPU.\n        if self.world_size == 1:\n            return input_\n\n        if self.use_custom_op_call:\n            return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name)\n        else:\n            return self._all_reduce_out_place(input_)\n\n    def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.all_reduce(input_)\n\n    def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n        world_size = self.world_size\n        # Bypass the function if we are using only 1 GPU.\n        if world_size == 1:\n            return input_\n        assert -input_.dim() <= dim < input_.dim(), (\n            f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n        )\n\n        if self.use_custom_op_call:\n            return torch.ops.vllm.all_gather(\n                input_, dim, world_size, group_name=self.unique_name\n            )\n        else:\n            return self._all_gather_out_place(input_, dim)\n\n    def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.all_gather(input_, dim)\n\n    def all_gatherv(\n        self,\n        input_: torch.Tensor | list[torch.Tensor],\n        dim: int = 0,\n        sizes: list[int] | None = None,\n    ):\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.all_gatherv(input_, dim, sizes)\n\n    def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n        world_size = self.world_size\n        # Bypass the function if we are using only 1 GPU.\n        if world_size == 1:\n            return input_\n        assert -input_.dim() <= dim < input_.dim(), (\n            f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n        )\n\n        if self.use_custom_op_call:\n            return torch.ops.vllm.reduce_scatter(\n                input_, dim, world_size, group_name=self.unique_name\n            )\n        else:\n            return self._reduce_scatter_out_place(input_, dim)\n\n    def reduce_scatterv(\n        self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None\n    ) -> torch.Tensor:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.reduce_scatterv(input_, dim, sizes)\n\n    def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.reduce_scatter(input_, dim)\n\n    def gather(\n        self, input_: torch.Tensor, dst: int = 0, dim: int = -1\n    ) -> torch.Tensor | None:\n        \"\"\"\n        NOTE: We assume that the input tensor is on the same device across\n        all the ranks.\n        NOTE: `dst` is the local rank of the destination rank.\n        \"\"\"\n        world_size = self.world_size\n        # Bypass the function if we are using only 1 GPU.\n        if world_size == 1:\n            return input_\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.gather(input_, dst, dim)\n\n    def broadcast(self, input_: torch.Tensor, src: int = 0):\n        \"\"\"Broadcast the input tensor.\n        NOTE: `src` is the local rank of the source rank.\n        \"\"\"\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        # Bypass the function if we are using only 1 GPU.\n        if self.world_size == 1:\n            return input_\n        # Broadcast.\n        torch.distributed.broadcast(\n            input_, src=self.ranks[src], group=self.device_group\n        )\n        return input_\n\n    def broadcast_object(self, obj: Any | None = None, src: int = 0):\n        \"\"\"Broadcast the input object.\n        NOTE: `src` is the local rank of the source rank.\n        \"\"\"\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        # Bypass the function if we are using only 1 GPU.\n        if self.world_size == 1:\n            return obj\n        if self.mq_broadcaster is not None:\n            assert src == 0, \"Message queue broadcaster only supports src=0\"\n            return self.mq_broadcaster.broadcast_object(obj)\n        if self.rank_in_group == src:\n            torch.distributed.broadcast_object_list(\n                [obj], src=self.ranks[src], group=self.cpu_group\n            )\n            return obj\n        else:\n            recv = [None]\n            torch.distributed.broadcast_object_list(\n                recv, src=self.ranks[src], group=self.cpu_group\n            )\n            return recv[0]\n\n    def broadcast_object_list(\n        self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None\n    ):\n        \"\"\"Broadcast the input object list.\n        NOTE: `src` is the local rank of the source rank.\n        \"\"\"\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        # Bypass the function if we are using only 1 GPU.\n        if self.world_size == 1:\n            return obj_list\n        # Broadcast.\n        torch.distributed.broadcast_object_list(\n            obj_list, src=self.ranks[src], group=self.device_group\n        )\n        return obj_list\n\n    def send_object(self, obj: Any, dst: int) -> None:\n        \"\"\"Send the input object list to the destination rank.\"\"\"\n        \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n\n        assert dst < self.world_size, f\"Invalid dst rank ({dst})\"\n\n        assert dst != self.rank_in_group, (\n            \"Invalid destination rank. Destination rank is the same \"\n            \"as the current rank.\"\n        )\n\n        # Serialize object to tensor and get the size as well\n        object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8)\n\n        size_tensor = torch.tensor(\n            [object_tensor.numel()], dtype=torch.long, device=\"cpu\"\n        )\n\n        # Send object size\n\n        torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group)\n\n        # Send object\n        torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group)\n\n        return None\n\n    def recv_object(self, src: int) -> Any:\n        \"\"\"Receive the input object list from the source rank.\"\"\"\n        \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        assert src != self.rank_in_group, (\n            \"Invalid source rank. Source rank is the same as the current rank.\"\n        )\n\n        size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\")\n\n        # Receive object size\n        rank_size = torch.distributed.recv(\n            size_tensor, src=self.ranks[src], group=self.cpu_group\n        )\n\n        # Tensor to receive serialized objects into.\n        object_tensor = torch.empty(  # type: ignore[call-overload]\n            size_tensor.item(),  # type: ignore[arg-type]\n            dtype=torch.uint8,\n            device=\"cpu\",\n        )\n\n        rank_object = torch.distributed.recv(\n            object_tensor, src=self.ranks[src], group=self.cpu_group\n        )\n\n        assert rank_object == rank_size, (\n            \"Received object sender rank does not match the size sender rank.\"\n        )\n\n        obj = pickle.loads(object_tensor.numpy().tobytes())\n\n        return obj\n\n    def broadcast_tensor_dict(\n        self,\n        tensor_dict: dict[str, torch.Tensor | Any] | None = None,\n        src: int = 0,\n        group: ProcessGroup | None = None,\n        metadata_group: ProcessGroup | None = None,\n    ) -> dict[str, torch.Tensor | Any] | None:\n        \"\"\"Broadcast the input tensor dictionary.\n        NOTE: `src` is the local rank of the source rank.\n        \"\"\"\n        # Bypass the function if we are using only 1 GPU.\n        if not torch.distributed.is_initialized() or self.world_size == 1:\n            return tensor_dict\n\n        group = self.device_group\n        metadata_group = self.cpu_group\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        rank_in_group = self.rank_in_group\n        if rank_in_group == src:\n            metadata_list: list[tuple[Any, Any]] = []\n            assert isinstance(tensor_dict, dict), (\n                f\"Expecting a dictionary, got {type(tensor_dict)}\"\n            )\n            metadata_list, tensor_list = _split_tensor_dict(tensor_dict)\n            # `metadata_list` lives in CPU memory.\n            # `broadcast_object_list` has serialization & deserialization,\n            # all happening on CPU. Therefore, we can use the CPU group.\n            self.broadcast_object(metadata_list, src=src)\n            async_handles = []\n            for tensor in tensor_list:\n                if tensor.numel() == 0:\n                    # Skip broadcasting empty tensors.\n                    continue\n                if tensor.is_cpu:\n                    # use metadata_group for CPU tensors\n                    handle = torch.distributed.broadcast(\n                        tensor, src=self.ranks[src], group=metadata_group, async_op=True\n                    )\n                else:\n                    # use group for GPU tensors\n                    handle = torch.distributed.broadcast(\n                        tensor, src=self.ranks[src], group=group, async_op=True\n                    )\n                async_handles.append(handle)\n            for async_handle in async_handles:\n                async_handle.wait()\n\n        else:\n            metadata_list = self.broadcast_object(None, src=src)\n            tensor_dict = {}\n            async_handles = []\n            for key, value in metadata_list:\n                if isinstance(value, TensorMetadata):\n                    tensor = torch.empty(\n                        value.size, dtype=value.dtype, device=value.device\n                    )\n                    if tensor.numel() == 0:\n                        # Skip broadcasting empty tensors.\n                        tensor_dict[key] = tensor\n                        continue\n                    if tensor.is_cpu:\n                        # use metadata_group for CPU tensors\n                        handle = torch.distributed.broadcast(\n                            tensor,\n                            src=self.ranks[src],\n                            group=metadata_group,\n                            async_op=True,\n                        )\n                    else:\n                        # use group for GPU tensors\n                        handle = torch.distributed.broadcast(\n                            tensor, src=self.ranks[src], group=group, async_op=True\n                        )\n                    async_handles.append(handle)\n                    tensor_dict[key] = tensor\n                else:\n                    tensor_dict[key] = value\n            for async_handle in async_handles:\n                async_handle.wait()\n        return tensor_dict\n\n    def send_tensor_dict(\n        self,\n        tensor_dict: dict[str, torch.Tensor | Any],\n        dst: int | None = None,\n        all_gather_group: Optional[\"GroupCoordinator\"] = None,\n        all_gather_tensors: dict[str, bool] | None = None,\n    ) -> dict[str, torch.Tensor | Any] | None:\n        \"\"\"Send the input tensor dictionary.\n        NOTE: `dst` is the local rank of the source rank.\n\n        all_gather_group: The group for the all-gather operation. If provided,\n            an optimization is enabled where each rank in the group sends a\n            slice of a tensor and the receiver reconstructs it using an\n            all-gather, which can improve performance. This is typically the\n            tensor-parallel group.\n        all_gather_tensors: A dictionary to specify which tensors should use\n            the all-gather optimization, which is only effective when\n            `all_gather_group` is provided. By default, this optimization is\n            on for any tensor whose size is divisible by the\n            `all_gather_group`'s world size. However, it should be disabled\n            for tensors that are not fully replicated across the group (e.g.,\n            the residual tensor when sequence parallelism is enabled). This\n            dictionary allows overriding the default behavior on a per-tensor\n            basis.\n        \"\"\"\n        # Bypass the function if we are using only 1 GPU.\n        if not torch.distributed.is_initialized() or self.world_size == 1:\n            return tensor_dict\n        all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size\n        all_gather_rank = (\n            0 if all_gather_group is None else all_gather_group.rank_in_group\n        )\n\n        group = self.device_group\n        metadata_group = self.cpu_group\n\n        if dst is None:\n            dst = (self.rank_in_group + 1) % self.world_size\n        assert dst < self.world_size, f\"Invalid dst rank ({dst})\"\n\n        if self.use_cpu_custom_send_recv:\n            if self.device_communicator is None:\n                raise ValueError(\"No device communicator found\")\n            self.device_communicator.send_tensor_dict(  # type: ignore\n                tensor_dict, dst\n            )\n            return None\n\n        metadata_list: list[tuple[Any, Any]] = []\n        assert isinstance(tensor_dict, dict), (\n            f\"Expecting a dictionary, got {type(tensor_dict)}\"\n        )\n        metadata_list, tensor_list = _split_tensor_dict(tensor_dict)\n        # `metadata_list` lives in CPU memory.\n        # `send_object_list` has serialization & deserialization,\n        # all happening on CPU. Therefore, we can use the CPU group.\n        self.send_object(metadata_list, dst=dst)\n\n        tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)]\n        assert len(tensor_keys) == len(tensor_list)\n\n        for key, tensor in zip(tensor_keys, tensor_list):\n            if tensor.numel() == 0:\n                # Skip sending empty tensors.\n                continue\n\n            # send-allgather: send only a slice, then do allgather.\n            use_all_gather = (\n                all_gather_group is not None and tensor.numel() % all_gather_size == 0\n            )\n            use_all_gather = (\n                all_gather_tensors.get(key, use_all_gather)\n                if all_gather_tensors\n                else use_all_gather\n            )\n            if use_all_gather:\n                tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank]\n\n            if tensor.is_cpu:\n                # use metadata_group for CPU tensors\n                torch.distributed.send(\n                    tensor, dst=self.ranks[dst], group=metadata_group\n                )\n            else:\n                # use group for GPU tensors\n                torch.distributed.send(tensor, dst=self.ranks[dst], group=group)\n        return None\n\n    def recv_tensor_dict(\n        self,\n        src: int | None = None,\n        all_gather_group: Optional[\"GroupCoordinator\"] = None,\n        all_gather_tensors: dict[str, bool] | None = None,\n    ) -> dict[str, torch.Tensor | Any] | None:\n        \"\"\"Recv the input tensor dictionary.\n        NOTE: `src` is the local rank of the source rank.\n\n        all_gather_group: The group for the all-gather operation. If provided,\n            an optimization is enabled where each rank in the group sends a\n            slice of a tensor and the receiver reconstructs it using an\n            all-gather, which can improve performance. This is typically the\n            tensor-parallel group.\n        all_gather_tensors: A dictionary to specify which tensors should use\n            the all-gather optimization, which is only effective when\n            `all_gather_group` is provided. By default, this optimization is\n            on for any tensor whose size is divisible by the\n            `all_gather_group`'s world size. However, it should be disabled\n            for tensors that are not fully replicated across the group (e.g.,\n            the residual tensor when sequence parallelism is enabled). This\n            dictionary allows overriding the default behavior on a per-tensor\n            basis.\n        \"\"\"\n        # Bypass the function if we are using only 1 GPU.\n        if not torch.distributed.is_initialized() or self.world_size == 1:\n            return None\n        all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size\n        all_gather_rank = (\n            0 if all_gather_group is None else all_gather_group.rank_in_group\n        )\n\n        group = self.device_group\n        metadata_group = self.cpu_group\n\n        if src is None:\n            src = (self.rank_in_group - 1) % self.world_size\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        if self.use_cpu_custom_send_recv:\n            if self.device_communicator is None:\n                raise ValueError(\"No device communicator found\")\n            return self.device_communicator.recv_tensor_dict(  # type: ignore\n                src\n            )\n\n        recv_metadata_list = self.recv_object(src=src)\n        tensor_dict: dict[str, Any] = {}\n        for key, value in recv_metadata_list:\n            if isinstance(value, TensorMetadata):\n                tensor = torch.empty(value.size, dtype=value.dtype, device=value.device)\n                if tensor.numel() == 0:\n                    # Skip broadcasting empty tensors.\n                    tensor_dict[key] = tensor\n                    continue\n\n                # send-allgather: send only a slice, then do allgather.\n                use_all_gather = (\n                    all_gather_group is not None\n                    and tensor.numel() % all_gather_size == 0\n                )\n                use_all_gather = (\n                    all_gather_tensors.get(key, use_all_gather)\n                    if all_gather_tensors\n                    else use_all_gather\n                )\n\n                if use_all_gather:\n                    orig_shape = tensor.shape\n                    tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank]\n\n                if tensor.is_cpu:\n                    # use metadata_group for CPU tensors\n                    torch.distributed.recv(\n                        tensor, src=self.ranks[src], group=metadata_group\n                    )\n                else:\n                    # use group for GPU tensors\n                    torch.distributed.recv(tensor, src=self.ranks[src], group=group)\n                if use_all_gather:\n                    # do the allgather\n                    tensor = all_gather_group.all_gather(  # type: ignore\n                        tensor, dim=0\n                    )\n                    tensor = tensor.reshape(orig_shape)\n\n                tensor_dict[key] = tensor\n            else:\n                tensor_dict[key] = value\n        return tensor_dict\n\n    def barrier(self):\n        \"\"\"Barrier synchronization among the group.\n        NOTE: don't use `device_group` here! `barrier` in NCCL is\n        terrible because it is internally a broadcast operation with\n        secretly created GPU tensors. It is easy to mess up the current\n        device. Use the CPU group instead.\n        \"\"\"\n        torch.distributed.barrier(group=self.cpu_group)\n\n    def send(self, tensor: torch.Tensor, dst: int | None = None) -> None:\n        \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\"\n        \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        self.device_communicator.send(tensor, dst)\n\n    def recv(\n        self, size: torch.Size, dtype: torch.dtype, src: int | None = None\n    ) -> torch.Tensor:\n        \"\"\"Receives a tensor from the source rank.\"\"\"\n        \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.recv(size, dtype, src)\n\n    def destroy(self):\n        if hasattr(self, \"device_group\"):\n            torch.distributed.destroy_process_group(self.device_group)\n            del self.device_group\n        if hasattr(self, \"cpu_group\"):\n            torch.distributed.destroy_process_group(self.cpu_group)\n            del self.cpu_group\n        if self.device_communicator is not None:\n            self.device_communicator.destroy()\n        if self.mq_broadcaster is not None:\n            self.mq_broadcaster = None\n\n    def prepare_communication_buffer_for_model(self, model: torch.nn.Module):\n        if self.device_communicator is not None:\n            self.device_communicator.prepare_communication_buffer_for_model(model)\n\n    def dispatch(\n        self,\n        hidden_states: torch.Tensor,\n        router_logits: torch.Tensor,\n        is_sequence_parallel: bool = False,\n        extra_tensors: list[torch.Tensor] | None = None,\n    ) -> (\n        tuple[torch.Tensor, torch.Tensor]\n        | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]]\n    ):\n        if self.device_communicator is not None:\n            return self.device_communicator.dispatch(  # type: ignore[call-arg]\n                hidden_states,\n                router_logits,\n                is_sequence_parallel,\n                extra_tensors,\n            )\n        else:\n            return hidden_states, router_logits\n\n    def combine(\n        self, hidden_states, is_sequence_parallel: bool = False\n    ) -> torch.Tensor:\n        if self.device_communicator is not None:\n            return self.device_communicator.combine(hidden_states, is_sequence_parallel)\n        else:\n            return hidden_states",
      "language": "python"
    },
    {
      "code": "class GroupCoordinator:\n    \"\"\"\n    PyTorch ProcessGroup wrapper for a group of processes.\n    PyTorch ProcessGroup is bound to one specific communication backend,\n        e.g. NCCL, Gloo, MPI, etc.\n    GroupCoordinator takes charge of all the communication operations among\n        the processes in the group. It manages both CPU and device\n        communication.\n    \"\"\"\n\n    # available attributes:\n    rank: int  # global rank\n    ranks: list[int]  # global ranks in the group\n    world_size: int  # size of the group\n    # difference between `local_rank` and `rank_in_group`:\n    # if we have a group of size 4 across two nodes:\n    # Process | Node | Rank | Local Rank | Rank in Group\n    #   0     |   0  |  0   |     0      |       0\n    #   1     |   0  |  1   |     1      |       1\n    #   2     |   1  |  2   |     0      |       2\n    #   3     |   1  |  3   |     1      |       3\n    local_rank: int  # local rank used to assign devices\n    rank_in_group: int  # rank inside the group\n    cpu_group: ProcessGroup  # group for CPU communication\n    device_group: ProcessGroup  # group for device communication\n    # device communicator (if use_device_communicator=True)\n    device_communicator: DeviceCommunicatorBase | None\n    mq_broadcaster: Any | None  # shared memory broadcaster\n\n    def __init__(\n        self,\n        group_ranks: list[list[int]],\n        local_rank: int,\n        torch_distributed_backend: str | Backend,\n        use_device_communicator: bool,  # whether to use device communicator\n        use_message_queue_broadcaster: bool = False,\n        group_name: str | None = None,\n    ):\n        group_name = group_name or \"anonymous\"\n        self.unique_name = _get_unique_name(group_name)\n        _register_group(self)\n\n        self.rank = torch.distributed.get_rank()\n        self.local_rank = local_rank\n\n        self_device_group = None\n        self_cpu_group = None\n\n        for ranks in group_ranks:\n            device_group = torch.distributed.new_group(\n                ranks, backend=torch_distributed_backend\n            )\n            # a group with `gloo` backend, to allow direct coordination between\n            # processes through the CPU.\n            with suppress_stdout():\n                cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\")\n            if self.rank in ranks:\n                self.ranks = ranks\n                self.world_size = len(ranks)\n                self.rank_in_group = ranks.index(self.rank)\n                self_device_group = device_group\n                self_cpu_group = cpu_group\n\n        assert self_cpu_group is not None\n        assert self_device_group is not None\n\n        self.cpu_group = self_cpu_group\n        self.device_group = self_device_group\n\n        from vllm.platforms import current_platform\n\n        if current_platform.is_cuda_alike():\n            self.device = torch.device(f\"cuda:{local_rank}\")\n        elif current_platform.is_xpu():\n            self.device = torch.device(f\"xpu:{local_rank}\")\n        elif current_platform.is_out_of_tree():\n            self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\")\n        else:\n            self.device = torch.device(\"cpu\")\n\n        self.use_device_communicator = use_device_communicator\n        self.device_communicator = None\n        if use_device_communicator and self.world_size > 1:\n            device_comm_cls = resolve_obj_by_qualname(\n                current_platform.get_device_communicator_cls()\n            )\n            self.device_communicator = device_comm_cls(\n                cpu_group=self.cpu_group,\n                device=self.device,\n                device_group=self.device_group,\n                unique_name=self.unique_name,\n            )\n\n        from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n        self.mq_broadcaster: MessageQueue | None = None\n        if use_message_queue_broadcaster and self.world_size > 1:\n            self.mq_broadcaster = MessageQueue.create_from_process_group(\n                self.cpu_group, 1 << 22, 6\n            )\n\n        from vllm.platforms import current_platform\n\n        self.use_custom_op_call = (\n            current_platform.is_cuda_alike() or current_platform.is_tpu()\n        )\n\n        self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr(\n            torch.ops._C, \"init_shm_manager\"\n        )\n\n    def create_mq_broadcaster(\n        self, writer_rank=0, external_writer_handle=None, blocking=True\n    ):\n        from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n        return MessageQueue.create_from_process_group(\n            self.cpu_group,\n            1 << 22,\n            6,\n            writer_rank=writer_rank,\n            external_writer_handle=external_writer_handle,\n            blocking=blocking,\n        )\n\n    def create_single_reader_mq_broadcasters(\n        self, reader_rank_in_group=0, blocking=False\n    ):\n        from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n        return MessageQueue.create_from_process_group_single_reader(\n            self.cpu_group,\n            1 << 22,\n            6,\n            reader_rank=self.ranks[reader_rank_in_group],\n            blocking=blocking,\n        )\n\n    @property\n    def first_rank(self):\n        \"\"\"Return the global rank of the first process in the group\"\"\"\n        return self.ranks[0]\n\n    @property\n    def last_rank(self):\n        \"\"\"Return the global rank of the last process in the group\"\"\"\n        return self.ranks[-1]\n\n    @property\n    def is_first_rank(self):\n        \"\"\"Return whether the caller is the first process in the group\"\"\"\n        return self.rank == self.first_rank\n\n    @property\n    def is_last_rank(self):\n        \"\"\"Return whether the caller is the last process in the group\"\"\"\n        return self.rank == self.last_rank\n\n    @property\n    def next_rank(self):\n        \"\"\"Return the global rank of the process that follows the caller\"\"\"\n        rank_in_group = self.rank_in_group\n        world_size = self.world_size\n        return self.ranks[(rank_in_group + 1) % world_size]\n\n    @property\n    def prev_rank(self):\n        \"\"\"Return the global rank of the process that precedes the caller\"\"\"\n        rank_in_group = self.rank_in_group\n        world_size = self.world_size\n        return self.ranks[(rank_in_group - 1) % world_size]\n\n    @contextmanager\n    def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None):\n        if graph_capture_context is None:\n            stream = torch.cuda.Stream()\n            graph_capture_context = GraphCaptureContext(stream)\n        else:\n            stream = graph_capture_context.stream\n\n        # only cuda uses this function,\n        # so we don't abstract it into the base class\n        maybe_ca_context = nullcontext()\n        from vllm.distributed.device_communicators.cuda_communicator import (\n            CudaCommunicator,\n        )\n\n        if self.device_communicator is not None:\n            assert isinstance(self.device_communicator, CudaCommunicator)\n            ca_comm = self.device_communicator.ca_comm\n            if ca_comm is not None:\n                maybe_ca_context = ca_comm.capture()  # type: ignore\n\n        # ensure all initialization operations complete before attempting to\n        # capture the graph on another stream\n        curr_stream = torch.cuda.current_stream()\n        if curr_stream != stream:\n            stream.wait_stream(curr_stream)\n\n        with torch.cuda.stream(stream), maybe_ca_context:\n            yield graph_capture_context\n\n    def all_reduce(self, input_: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        User-facing all-reduce function before we actually call the\n        all-reduce operation.\n\n        We need this because Dynamo does not support passing an arbitrary\n        object (`self` in this case) to a custom op. We need to pass the\n         group name as a string, and then look up the group coordinator from\n         the group name, dispatch the all-reduce operation to the group\n         coordinator.\n\n        In addition, PyTorch custom ops do not support mutation or returning\n        a new tensor in the same op. So we always make the all-reduce operation\n        out-of-place.\n        \"\"\"\n        # Bypass the function if we are using only 1 GPU.\n        if self.world_size == 1:\n            return input_\n\n        if self.use_custom_op_call:\n            return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name)\n        else:\n            return self._all_reduce_out_place(input_)\n\n    def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.all_reduce(input_)\n\n    def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n        world_size = self.world_size\n        # Bypass the function if we are using only 1 GPU.\n        if world_size == 1:\n            return input_\n        assert -input_.dim() <= dim < input_.dim(), (\n            f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n        )\n\n        if self.use_custom_op_call:\n            return torch.ops.vllm.all_gather(\n                input_, dim, world_size, group_name=self.unique_name\n            )\n        else:\n            return self._all_gather_out_place(input_, dim)\n\n    def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.all_gather(input_, dim)\n\n    def all_gatherv(\n        self,\n        input_: torch.Tensor | list[torch.Tensor],\n        dim: int = 0,\n        sizes: list[int] | None = None,\n    ):\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.all_gatherv(input_, dim, sizes)\n\n    def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n        world_size = self.world_size\n        # Bypass the function if we are using only 1 GPU.\n        if world_size == 1:\n            return input_\n        assert -input_.dim() <= dim < input_.dim(), (\n            f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n        )\n\n        if self.use_custom_op_call:\n            return torch.ops.vllm.reduce_scatter(\n                input_, dim, world_size, group_name=self.unique_name\n            )\n        else:\n            return self._reduce_scatter_out_place(input_, dim)\n\n    def reduce_scatterv(\n        self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None\n    ) -> torch.Tensor:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.reduce_scatterv(input_, dim, sizes)\n\n    def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.reduce_scatter(input_, dim)\n\n    def gather(\n        self, input_: torch.Tensor, dst: int = 0, dim: int = -1\n    ) -> torch.Tensor | None:\n        \"\"\"\n        NOTE: We assume that the input tensor is on the same device across\n        all the ranks.\n        NOTE: `dst` is the local rank of the destination rank.\n        \"\"\"\n        world_size = self.world_size\n        # Bypass the function if we are using only 1 GPU.\n        if world_size == 1:\n            return input_\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.gather(input_, dst, dim)\n\n    def broadcast(self, input_: torch.Tensor, src: int = 0):\n        \"\"\"Broadcast the input tensor.\n        NOTE: `src` is the local rank of the source rank.\n        \"\"\"\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        # Bypass the function if we are using only 1 GPU.\n        if self.world_size == 1:\n            return input_\n        # Broadcast.\n        torch.distributed.broadcast(\n            input_, src=self.ranks[src], group=self.device_group\n        )\n        return input_\n\n    def broadcast_object(self, obj: Any | None = None, src: int = 0):\n        \"\"\"Broadcast the input object.\n        NOTE: `src` is the local rank of the source rank.\n        \"\"\"\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        # Bypass the function if we are using only 1 GPU.\n        if self.world_size == 1:\n            return obj\n        if self.mq_broadcaster is not None:\n            assert src == 0, \"Message queue broadcaster only supports src=0\"\n            return self.mq_broadcaster.broadcast_object(obj)\n        if self.rank_in_group == src:\n            torch.distributed.broadcast_object_list(\n                [obj], src=self.ranks[src], group=self.cpu_group\n            )\n            return obj\n        else:\n            recv = [None]\n            torch.distributed.broadcast_object_list(\n                recv, src=self.ranks[src], group=self.cpu_group\n            )\n            return recv[0]\n\n    def broadcast_object_list(\n        self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None\n    ):\n        \"\"\"Broadcast the input object list.\n        NOTE: `src` is the local rank of the source rank.\n        \"\"\"\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        # Bypass the function if we are using only 1 GPU.\n        if self.world_size == 1:\n            return obj_list\n        # Broadcast.\n        torch.distributed.broadcast_object_list(\n            obj_list, src=self.ranks[src], group=self.device_group\n        )\n        return obj_list\n\n    def send_object(self, obj: Any, dst: int) -> None:\n        \"\"\"Send the input object list to the destination rank.\"\"\"\n        \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n\n        assert dst < self.world_size, f\"Invalid dst rank ({dst})\"\n\n        assert dst != self.rank_in_group, (\n            \"Invalid destination rank. Destination rank is the same \"\n            \"as the current rank.\"\n        )\n\n        # Serialize object to tensor and get the size as well\n        object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8)\n\n        size_tensor = torch.tensor(\n            [object_tensor.numel()], dtype=torch.long, device=\"cpu\"\n        )\n\n        # Send object size\n\n        torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group)\n\n        # Send object\n        torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group)\n\n        return None\n\n    def recv_object(self, src: int) -> Any:\n        \"\"\"Receive the input object list from the source rank.\"\"\"\n        \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        assert src != self.rank_in_group, (\n            \"Invalid source rank. Source rank is the same as the current rank.\"\n        )\n\n        size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\")\n\n        # Receive object size\n        rank_size = torch.distributed.recv(\n            size_tensor, src=self.ranks[src], group=self.cpu_group\n        )\n\n        # Tensor to receive serialized objects into.\n        object_tensor = torch.empty(  # type: ignore[call-overload]\n            size_tensor.item(),  # type: ignore[arg-type]\n            dtype=torch.uint8,\n            device=\"cpu\",\n        )\n\n        rank_object = torch.distributed.recv(\n            object_tensor, src=self.ranks[src], group=self.cpu_group\n        )\n\n        assert rank_object == rank_size, (\n            \"Received object sender rank does not match the size sender rank.\"\n        )\n\n        obj = pickle.loads(object_tensor.numpy().tobytes())\n\n        return obj\n\n    def broadcast_tensor_dict(\n        self,\n        tensor_dict: dict[str, torch.Tensor | Any] | None = None,\n        src: int = 0,\n        group: ProcessGroup | None = None,\n        metadata_group: ProcessGroup | None = None,\n    ) -> dict[str, torch.Tensor | Any] | None:\n        \"\"\"Broadcast the input tensor dictionary.\n        NOTE: `src` is the local rank of the source rank.\n        \"\"\"\n        # Bypass the function if we are using only 1 GPU.\n        if not torch.distributed.is_initialized() or self.world_size == 1:\n            return tensor_dict\n\n        group = self.device_group\n        metadata_group = self.cpu_group\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        rank_in_group = self.rank_in_group\n        if rank_in_group == src:\n            metadata_list: list[tuple[Any, Any]] = []\n            assert isinstance(tensor_dict, dict), (\n                f\"Expecting a dictionary, got {type(tensor_dict)}\"\n            )\n            metadata_list, tensor_list = _split_tensor_dict(tensor_dict)\n            # `metadata_list` lives in CPU memory.\n            # `broadcast_object_list` has serialization & deserialization,\n            # all happening on CPU. Therefore, we can use the CPU group.\n            self.broadcast_object(metadata_list, src=src)\n            async_handles = []\n            for tensor in tensor_list:\n                if tensor.numel() == 0:\n                    # Skip broadcasting empty tensors.\n                    continue\n                if tensor.is_cpu:\n                    # use metadata_group for CPU tensors\n                    handle = torch.distributed.broadcast(\n                        tensor, src=self.ranks[src], group=metadata_group, async_op=True\n                    )\n                else:\n                    # use group for GPU tensors\n                    handle = torch.distributed.broadcast(\n                        tensor, src=self.ranks[src], group=group, async_op=True\n                    )\n                async_handles.append(handle)\n            for async_handle in async_handles:\n                async_handle.wait()\n\n        else:\n            metadata_list = self.broadcast_object(None, src=src)\n            tensor_dict = {}\n            async_handles = []\n            for key, value in metadata_list:\n                if isinstance(value, TensorMetadata):\n                    tensor = torch.empty(\n                        value.size, dtype=value.dtype, device=value.device\n                    )\n                    if tensor.numel() == 0:\n                        # Skip broadcasting empty tensors.\n                        tensor_dict[key] = tensor\n                        continue\n                    if tensor.is_cpu:\n                        # use metadata_group for CPU tensors\n                        handle = torch.distributed.broadcast(\n                            tensor,\n                            src=self.ranks[src],\n                            group=metadata_group,\n                            async_op=True,\n                        )\n                    else:\n                        # use group for GPU tensors\n                        handle = torch.distributed.broadcast(\n                            tensor, src=self.ranks[src], group=group, async_op=True\n                        )\n                    async_handles.append(handle)\n                    tensor_dict[key] = tensor\n                else:\n                    tensor_dict[key] = value\n            for async_handle in async_handles:\n                async_handle.wait()\n        return tensor_dict\n\n    def send_tensor_dict(\n        self,\n        tensor_dict: dict[str, torch.Tensor | Any],\n        dst: int | None = None,\n        all_gather_group: Optional[\"GroupCoordinator\"] = None,\n        all_gather_tensors: dict[str, bool] | None = None,\n    ) -> dict[str, torch.Tensor | Any] | None:\n        \"\"\"Send the input tensor dictionary.\n        NOTE: `dst` is the local rank of the source rank.\n\n        all_gather_group: The group for the all-gather operation. If provided,\n            an optimization is enabled where each rank in the group sends a\n            slice of a tensor and the receiver reconstructs it using an\n            all-gather, which can improve performance. This is typically the\n            tensor-parallel group.\n        all_gather_tensors: A dictionary to specify which tensors should use\n            the all-gather optimization, which is only effective when\n            `all_gather_group` is provided. By default, this optimization is\n            on for any tensor whose size is divisible by the\n            `all_gather_group`'s world size. However, it should be disabled\n            for tensors that are not fully replicated across the group (e.g.,\n            the residual tensor when sequence parallelism is enabled). This\n            dictionary allows overriding the default behavior on a per-tensor\n            basis.\n        \"\"\"\n        # Bypass the function if we are using only 1 GPU.\n        if not torch.distributed.is_initialized() or self.world_size == 1:\n            return tensor_dict\n        all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size\n        all_gather_rank = (\n            0 if all_gather_group is None else all_gather_group.rank_in_group\n        )\n\n        group = self.device_group\n        metadata_group = self.cpu_group\n\n        if dst is None:\n            dst = (self.rank_in_group + 1) % self.world_size\n        assert dst < self.world_size, f\"Invalid dst rank ({dst})\"\n\n        if self.use_cpu_custom_send_recv:\n            if self.device_communicator is None:\n                raise ValueError(\"No device communicator found\")\n            self.device_communicator.send_tensor_dict(  # type: ignore\n                tensor_dict, dst\n            )\n            return None\n\n        metadata_list: list[tuple[Any, Any]] = []\n        assert isinstance(tensor_dict, dict), (\n            f\"Expecting a dictionary, got {type(tensor_dict)}\"\n        )\n        metadata_list, tensor_list = _split_tensor_dict(tensor_dict)\n        # `metadata_list` lives in CPU memory.\n        # `send_object_list` has serialization & deserialization,\n        # all happening on CPU. Therefore, we can use the CPU group.\n        self.send_object(metadata_list, dst=dst)\n\n        tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)]\n        assert len(tensor_keys) == len(tensor_list)\n\n        for key, tensor in zip(tensor_keys, tensor_list):\n            if tensor.numel() == 0:\n                # Skip sending empty tensors.\n                continue\n\n            # send-allgather: send only a slice, then do allgather.\n            use_all_gather = (\n                all_gather_group is not None and tensor.numel() % all_gather_size == 0\n            )\n            use_all_gather = (\n                all_gather_tensors.get(key, use_all_gather)\n                if all_gather_tensors\n                else use_all_gather\n            )\n            if use_all_gather:\n                tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank]\n\n            if tensor.is_cpu:\n                # use metadata_group for CPU tensors\n                torch.distributed.send(\n                    tensor, dst=self.ranks[dst], group=metadata_group\n                )\n            else:\n                # use group for GPU tensors\n                torch.distributed.send(tensor, dst=self.ranks[dst], group=group)\n        return None\n\n    def recv_tensor_dict(\n        self,\n        src: int | None = None,\n        all_gather_group: Optional[\"GroupCoordinator\"] = None,\n        all_gather_tensors: dict[str, bool] | None = None,\n    ) -> dict[str, torch.Tensor | Any] | None:\n        \"\"\"Recv the input tensor dictionary.\n        NOTE: `src` is the local rank of the source rank.\n\n        all_gather_group: The group for the all-gather operation. If provided,\n            an optimization is enabled where each rank in the group sends a\n            slice of a tensor and the receiver reconstructs it using an\n            all-gather, which can improve performance. This is typically the\n            tensor-parallel group.\n        all_gather_tensors: A dictionary to specify which tensors should use\n            the all-gather optimization, which is only effective when\n            `all_gather_group` is provided. By default, this optimization is\n            on for any tensor whose size is divisible by the\n            `all_gather_group`'s world size. However, it should be disabled\n            for tensors that are not fully replicated across the group (e.g.,\n            the residual tensor when sequence parallelism is enabled). This\n            dictionary allows overriding the default behavior on a per-tensor\n            basis.\n        \"\"\"\n        # Bypass the function if we are using only 1 GPU.\n        if not torch.distributed.is_initialized() or self.world_size == 1:\n            return None\n        all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size\n        all_gather_rank = (\n            0 if all_gather_group is None else all_gather_group.rank_in_group\n        )\n\n        group = self.device_group\n        metadata_group = self.cpu_group\n\n        if src is None:\n            src = (self.rank_in_group - 1) % self.world_size\n        assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n        if self.use_cpu_custom_send_recv:\n            if self.device_communicator is None:\n                raise ValueError(\"No device communicator found\")\n            return self.device_communicator.recv_tensor_dict(  # type: ignore\n                src\n            )\n\n        recv_metadata_list = self.recv_object(src=src)\n        tensor_dict: dict[str, Any] = {}\n        for key, value in recv_metadata_list:\n            if isinstance(value, TensorMetadata):\n                tensor = torch.empty(value.size, dtype=value.dtype, device=value.device)\n                if tensor.numel() == 0:\n                    # Skip broadcasting empty tensors.\n                    tensor_dict[key] = tensor\n                    continue\n\n                # send-allgather: send only a slice, then do allgather.\n                use_all_gather = (\n                    all_gather_group is not None\n                    and tensor.numel() % all_gather_size == 0\n                )\n                use_all_gather = (\n                    all_gather_tensors.get(key, use_all_gather)\n                    if all_gather_tensors\n                    else use_all_gather\n                )\n\n                if use_all_gather:\n                    orig_shape = tensor.shape\n                    tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank]\n\n                if tensor.is_cpu:\n                    # use metadata_group for CPU tensors\n                    torch.distributed.recv(\n                        tensor, src=self.ranks[src], group=metadata_group\n                    )\n                else:\n                    # use group for GPU tensors\n                    torch.distributed.recv(tensor, src=self.ranks[src], group=group)\n                if use_all_gather:\n                    # do the allgather\n                    tensor = all_gather_group.all_gather(  # type: ignore\n                        tensor, dim=0\n                    )\n                    tensor = tensor.reshape(orig_shape)\n\n                tensor_dict[key] = tensor\n            else:\n                tensor_dict[key] = value\n        return tensor_dict\n\n    def barrier(self):\n        \"\"\"Barrier synchronization among the group.\n        NOTE: don't use `device_group` here! `barrier` in NCCL is\n        terrible because it is internally a broadcast operation with\n        secretly created GPU tensors. It is easy to mess up the current\n        device. Use the CPU group instead.\n        \"\"\"\n        torch.distributed.barrier(group=self.cpu_group)\n\n    def send(self, tensor: torch.Tensor, dst: int | None = None) -> None:\n        \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\"\n        \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        self.device_communicator.send(tensor, dst)\n\n    def recv(\n        self, size: torch.Size, dtype: torch.dtype, src: int | None = None\n    ) -> torch.Tensor:\n        \"\"\"Receives a tensor from the source rank.\"\"\"\n        \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.recv(size, dtype, src)\n\n    def destroy(self):\n        if hasattr(self, \"device_group\"):\n            torch.distributed.destroy_process_group(self.device_group)\n            del self.device_group\n        if hasattr(self, \"cpu_group\"):\n            torch.distributed.destroy_process_group(self.cpu_group)\n            del self.cpu_group\n        if self.device_communicator is not None:\n            self.device_communicator.destroy()\n        if self.mq_broadcaster is not None:\n            self.mq_broadcaster = None\n\n    def prepare_communication_buffer_for_model(self, model: torch.nn.Module):\n        if self.device_communicator is not None:\n            self.device_communicator.prepare_communication_buffer_for_model(model)\n\n    def dispatch(\n        self,\n        hidden_states: torch.Tensor,\n        router_logits: torch.Tensor,\n        is_sequence_parallel: bool = False,\n        extra_tensors: list[torch.Tensor] | None = None,\n    ) -> (\n        tuple[torch.Tensor, torch.Tensor]\n        | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]]\n    ):\n        if self.device_communicator is not None:\n            return self.device_communicator.dispatch(  # type: ignore[call-arg]\n                hidden_states,\n                router_logits,\n                is_sequence_parallel,\n                extra_tensors,\n            )\n        else:\n            return hidden_states, router_logits\n\n    def combine(\n        self, hidden_states, is_sequence_parallel: bool = False\n    ) -> torch.Tensor:\n        if self.device_communicator is not None:\n            return self.device_communicator.combine(hidden_states, is_sequence_parallel)\n        else:\n            return hidden_states",
      "language": "python"
    },
    {
      "code": "cpu_group: ProcessGroup = self_cpu_group",
      "language": "typescript"
    },
    {
      "code": "cpu_group: ProcessGroup = self_cpu_group",
      "language": "typescript"
    },
    {
      "code": "device = device(f'cuda:{local_rank}')",
      "language": "json"
    },
    {
      "code": "device = device(f'cuda:{local_rank}')",
      "language": "json"
    },
    {
      "code": "device_communicator: DeviceCommunicatorBase | None = None",
      "language": "yaml"
    },
    {
      "code": "device_communicator: DeviceCommunicatorBase | None = None",
      "language": "yaml"
    },
    {
      "code": "device_group: ProcessGroup = self_device_group",
      "language": "typescript"
    },
    {
      "code": "device_group: ProcessGroup = self_device_group",
      "language": "typescript"
    },
    {
      "code": "is_first_rank",
      "language": "unknown"
    },
    {
      "code": "is_first_rank",
      "language": "unknown"
    },
    {
      "code": "is_last_rank",
      "language": "unknown"
    },
    {
      "code": "is_last_rank",
      "language": "unknown"
    },
    {
      "code": "local_rank: int = local_rank",
      "language": "typescript"
    },
    {
      "code": "local_rank: int = local_rank",
      "language": "typescript"
    },
    {
      "code": "mq_broadcaster: MessageQueue | None = None",
      "language": "yaml"
    },
    {
      "code": "mq_broadcaster: MessageQueue | None = None",
      "language": "yaml"
    },
    {
      "code": "rank: int = get_rank()",
      "language": "typescript"
    },
    {
      "code": "rank: int = get_rank()",
      "language": "typescript"
    },
    {
      "code": "rank_in_group: int",
      "language": "yaml"
    },
    {
      "code": "rank_in_group: int",
      "language": "yaml"
    },
    {
      "code": "ranks: list[int]",
      "language": "yaml"
    },
    {
      "code": "ranks: list[int]",
      "language": "yaml"
    },
    {
      "code": "unique_name = _get_unique_name(group_name)",
      "language": "unknown"
    },
    {
      "code": "unique_name = _get_unique_name(group_name)",
      "language": "unknown"
    },
    {
      "code": "use_cpu_custom_send_recv = is_cpu() and hasattr(\n    _C, \"init_shm_manager\"\n)",
      "language": "unknown"
    },
    {
      "code": "use_cpu_custom_send_recv = is_cpu() and hasattr(\n    _C, \"init_shm_manager\"\n)",
      "language": "unknown"
    },
    {
      "code": "use_custom_op_call = is_cuda_alike() or is_tpu()",
      "language": "unknown"
    },
    {
      "code": "use_custom_op_call = is_cuda_alike() or is_tpu()",
      "language": "unknown"
    },
    {
      "code": "use_device_communicator = use_device_communicator",
      "language": "unknown"
    },
    {
      "code": "use_device_communicator = use_device_communicator",
      "language": "unknown"
    },
    {
      "code": "world_size: int",
      "language": "yaml"
    },
    {
      "code": "world_size: int",
      "language": "yaml"
    },
    {
      "code": "__init__(\n    group_ranks: list[list[int]],\n    local_rank: int,\n    torch_distributed_backend: str | Backend,\n    use_device_communicator: bool,\n    use_message_queue_broadcaster: bool = False,\n    group_name: str | None = None,\n)",
      "language": "typescript"
    },
    {
      "code": "__init__(\n    group_ranks: list[list[int]],\n    local_rank: int,\n    torch_distributed_backend: str | Backend,\n    use_device_communicator: bool,\n    use_message_queue_broadcaster: bool = False,\n    group_name: str | None = None,\n)",
      "language": "typescript"
    },
    {
      "code": "307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387",
      "language": "unknown"
    },
    {
      "code": "def __init__(\n    self,\n    group_ranks: list[list[int]],\n    local_rank: int,\n    torch_distributed_backend: str | Backend,\n    use_device_communicator: bool,  # whether to use device communicator\n    use_message_queue_broadcaster: bool = False,\n    group_name: str | None = None,\n):\n    group_name = group_name or \"anonymous\"\n    self.unique_name = _get_unique_name(group_name)\n    _register_group(self)\n\n    self.rank = torch.distributed.get_rank()\n    self.local_rank = local_rank\n\n    self_device_group = None\n    self_cpu_group = None\n\n    for ranks in group_ranks:\n        device_group = torch.distributed.new_group(\n            ranks, backend=torch_distributed_backend\n        )\n        # a group with `gloo` backend, to allow direct coordination between\n        # processes through the CPU.\n        with suppress_stdout():\n            cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\")\n        if self.rank in ranks:\n            self.ranks = ranks\n            self.world_size = len(ranks)\n            self.rank_in_group = ranks.index(self.rank)\n            self_device_group = device_group\n            self_cpu_group = cpu_group\n\n    assert self_cpu_group is not None\n    assert self_device_group is not None\n\n    self.cpu_group = self_cpu_group\n    self.device_group = self_device_group\n\n    from vllm.platforms import current_platform\n\n    if current_platform.is_cuda_alike():\n        self.device = torch.device(f\"cuda:{local_rank}\")\n    elif current_platform.is_xpu():\n        self.device = torch.device(f\"xpu:{local_rank}\")\n    elif current_platform.is_out_of_tree():\n        self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\")\n    else:\n        self.device = torch.device(\"cpu\")\n\n    self.use_device_communicator = use_device_communicator\n    self.device_communicator = None\n    if use_device_communicator and self.world_size > 1:\n        device_comm_cls = resolve_obj_by_qualname(\n            current_platform.get_device_communicator_cls()\n        )\n        self.device_communicator = device_comm_cls(\n            cpu_group=self.cpu_group,\n            device=self.device,\n            device_group=self.device_group,\n            unique_name=self.unique_name,\n        )\n\n    from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n    self.mq_broadcaster: MessageQueue | None = None\n    if use_message_queue_broadcaster and self.world_size > 1:\n        self.mq_broadcaster = MessageQueue.create_from_process_group(\n            self.cpu_group, 1 << 22, 6\n        )\n\n    from vllm.platforms import current_platform\n\n    self.use_custom_op_call = (\n        current_platform.is_cuda_alike() or current_platform.is_tpu()\n    )\n\n    self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr(\n        torch.ops._C, \"init_shm_manager\"\n    )",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    group_ranks: list[list[int]],\n    local_rank: int,\n    torch_distributed_backend: str | Backend,\n    use_device_communicator: bool,  # whether to use device communicator\n    use_message_queue_broadcaster: bool = False,\n    group_name: str | None = None,\n):\n    group_name = group_name or \"anonymous\"\n    self.unique_name = _get_unique_name(group_name)\n    _register_group(self)\n\n    self.rank = torch.distributed.get_rank()\n    self.local_rank = local_rank\n\n    self_device_group = None\n    self_cpu_group = None\n\n    for ranks in group_ranks:\n        device_group = torch.distributed.new_group(\n            ranks, backend=torch_distributed_backend\n        )\n        # a group with `gloo` backend, to allow direct coordination between\n        # processes through the CPU.\n        with suppress_stdout():\n            cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\")\n        if self.rank in ranks:\n            self.ranks = ranks\n            self.world_size = len(ranks)\n            self.rank_in_group = ranks.index(self.rank)\n            self_device_group = device_group\n            self_cpu_group = cpu_group\n\n    assert self_cpu_group is not None\n    assert self_device_group is not None\n\n    self.cpu_group = self_cpu_group\n    self.device_group = self_device_group\n\n    from vllm.platforms import current_platform\n\n    if current_platform.is_cuda_alike():\n        self.device = torch.device(f\"cuda:{local_rank}\")\n    elif current_platform.is_xpu():\n        self.device = torch.device(f\"xpu:{local_rank}\")\n    elif current_platform.is_out_of_tree():\n        self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\")\n    else:\n        self.device = torch.device(\"cpu\")\n\n    self.use_device_communicator = use_device_communicator\n    self.device_communicator = None\n    if use_device_communicator and self.world_size > 1:\n        device_comm_cls = resolve_obj_by_qualname(\n            current_platform.get_device_communicator_cls()\n        )\n        self.device_communicator = device_comm_cls(\n            cpu_group=self.cpu_group,\n            device=self.device,\n            device_group=self.device_group,\n            unique_name=self.unique_name,\n        )\n\n    from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n    self.mq_broadcaster: MessageQueue | None = None\n    if use_message_queue_broadcaster and self.world_size > 1:\n        self.mq_broadcaster = MessageQueue.create_from_process_group(\n            self.cpu_group, 1 << 22, 6\n        )\n\n    from vllm.platforms import current_platform\n\n    self.use_custom_op_call = (\n        current_platform.is_cuda_alike() or current_platform.is_tpu()\n    )\n\n    self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr(\n        torch.ops._C, \"init_shm_manager\"\n    )",
      "language": "python"
    },
    {
      "code": "_all_gather_out_place(input_: Tensor, dim: int) -> Tensor",
      "language": "php"
    },
    {
      "code": "_all_gather_out_place(input_: Tensor, dim: int) -> Tensor",
      "language": "php"
    },
    {
      "code": "525\n526\n527\n528",
      "language": "unknown"
    },
    {
      "code": "def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor:\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.all_gather(input_, dim)",
      "language": "python"
    },
    {
      "code": "def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor:\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.all_gather(input_, dim)",
      "language": "python"
    },
    {
      "code": "_all_reduce_out_place(input_: Tensor) -> Tensor",
      "language": "php"
    },
    {
      "code": "_all_reduce_out_place(input_: Tensor) -> Tensor",
      "language": "php"
    },
    {
      "code": "504\n505\n506\n507",
      "language": "unknown"
    },
    {
      "code": "def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor:\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.all_reduce(input_)",
      "language": "python"
    },
    {
      "code": "def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor:\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.all_reduce(input_)",
      "language": "python"
    },
    {
      "code": "_reduce_scatter_out_place(\n    input_: Tensor, dim: int\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "_reduce_scatter_out_place(\n    input_: Tensor, dim: int\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "563\n564\n565\n566",
      "language": "unknown"
    },
    {
      "code": "def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor:\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.reduce_scatter(input_, dim)",
      "language": "python"
    },
    {
      "code": "def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor:\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.reduce_scatter(input_, dim)",
      "language": "python"
    },
    {
      "code": "all_gather(input_: Tensor, dim: int = -1) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "all_gather(input_: Tensor, dim: int = -1) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523",
      "language": "unknown"
    },
    {
      "code": "def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    world_size = self.world_size\n    # Bypass the function if we are using only 1 GPU.\n    if world_size == 1:\n        return input_\n    assert -input_.dim() <= dim < input_.dim(), (\n        f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n    )\n\n    if self.use_custom_op_call:\n        return torch.ops.vllm.all_gather(\n            input_, dim, world_size, group_name=self.unique_name\n        )\n    else:\n        return self._all_gather_out_place(input_, dim)",
      "language": "python"
    },
    {
      "code": "def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    world_size = self.world_size\n    # Bypass the function if we are using only 1 GPU.\n    if world_size == 1:\n        return input_\n    assert -input_.dim() <= dim < input_.dim(), (\n        f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n    )\n\n    if self.use_custom_op_call:\n        return torch.ops.vllm.all_gather(\n            input_, dim, world_size, group_name=self.unique_name\n        )\n    else:\n        return self._all_gather_out_place(input_, dim)",
      "language": "python"
    },
    {
      "code": "all_gatherv(\n    input_: Tensor | list[Tensor],\n    dim: int = 0,\n    sizes: list[int] | None = None,\n)",
      "language": "typescript"
    },
    {
      "code": "all_gatherv(\n    input_: Tensor | list[Tensor],\n    dim: int = 0,\n    sizes: list[int] | None = None,\n)",
      "language": "typescript"
    },
    {
      "code": "530\n531\n532\n533\n534\n535\n536\n537\n538",
      "language": "unknown"
    },
    {
      "code": "def all_gatherv(\n    self,\n    input_: torch.Tensor | list[torch.Tensor],\n    dim: int = 0,\n    sizes: list[int] | None = None,\n):\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.all_gatherv(input_, dim, sizes)",
      "language": "python"
    },
    {
      "code": "def all_gatherv(\n    self,\n    input_: torch.Tensor | list[torch.Tensor],\n    dim: int = 0,\n    sizes: list[int] | None = None,\n):\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.all_gatherv(input_, dim, sizes)",
      "language": "python"
    },
    {
      "code": "all_reduce(input_: Tensor) -> Tensor",
      "language": "php"
    },
    {
      "code": "all_reduce(input_: Tensor) -> Tensor",
      "language": "php"
    },
    {
      "code": "480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502",
      "language": "unknown"
    },
    {
      "code": "def all_reduce(self, input_: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    User-facing all-reduce function before we actually call the\n    all-reduce operation.\n\n    We need this because Dynamo does not support passing an arbitrary\n    object (`self` in this case) to a custom op. We need to pass the\n     group name as a string, and then look up the group coordinator from\n     the group name, dispatch the all-reduce operation to the group\n     coordinator.\n\n    In addition, PyTorch custom ops do not support mutation or returning\n    a new tensor in the same op. So we always make the all-reduce operation\n    out-of-place.\n    \"\"\"\n    # Bypass the function if we are using only 1 GPU.\n    if self.world_size == 1:\n        return input_\n\n    if self.use_custom_op_call:\n        return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name)\n    else:\n        return self._all_reduce_out_place(input_)",
      "language": "python"
    },
    {
      "code": "def all_reduce(self, input_: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    User-facing all-reduce function before we actually call the\n    all-reduce operation.\n\n    We need this because Dynamo does not support passing an arbitrary\n    object (`self` in this case) to a custom op. We need to pass the\n     group name as a string, and then look up the group coordinator from\n     the group name, dispatch the all-reduce operation to the group\n     coordinator.\n\n    In addition, PyTorch custom ops do not support mutation or returning\n    a new tensor in the same op. So we always make the all-reduce operation\n    out-of-place.\n    \"\"\"\n    # Bypass the function if we are using only 1 GPU.\n    if self.world_size == 1:\n        return input_\n\n    if self.use_custom_op_call:\n        return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name)\n    else:\n        return self._all_reduce_out_place(input_)",
      "language": "python"
    },
    {
      "code": "964\n965\n966\n967\n968\n969\n970\n971",
      "language": "unknown"
    },
    {
      "code": "def barrier(self):\n    \"\"\"Barrier synchronization among the group.\n    NOTE: don't use `device_group` here! `barrier` in NCCL is\n    terrible because it is internally a broadcast operation with\n    secretly created GPU tensors. It is easy to mess up the current\n    device. Use the CPU group instead.\n    \"\"\"\n    torch.distributed.barrier(group=self.cpu_group)",
      "language": "python"
    },
    {
      "code": "def barrier(self):\n    \"\"\"Barrier synchronization among the group.\n    NOTE: don't use `device_group` here! `barrier` in NCCL is\n    terrible because it is internally a broadcast operation with\n    secretly created GPU tensors. It is easy to mess up the current\n    device. Use the CPU group instead.\n    \"\"\"\n    torch.distributed.barrier(group=self.cpu_group)",
      "language": "python"
    },
    {
      "code": "broadcast(input_: Tensor, src: int = 0)",
      "language": "typescript"
    },
    {
      "code": "broadcast(input_: Tensor, src: int = 0)",
      "language": "typescript"
    },
    {
      "code": "584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597",
      "language": "unknown"
    },
    {
      "code": "def broadcast(self, input_: torch.Tensor, src: int = 0):\n    \"\"\"Broadcast the input tensor.\n    NOTE: `src` is the local rank of the source rank.\n    \"\"\"\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    # Bypass the function if we are using only 1 GPU.\n    if self.world_size == 1:\n        return input_\n    # Broadcast.\n    torch.distributed.broadcast(\n        input_, src=self.ranks[src], group=self.device_group\n    )\n    return input_",
      "language": "python"
    },
    {
      "code": "def broadcast(self, input_: torch.Tensor, src: int = 0):\n    \"\"\"Broadcast the input tensor.\n    NOTE: `src` is the local rank of the source rank.\n    \"\"\"\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    # Bypass the function if we are using only 1 GPU.\n    if self.world_size == 1:\n        return input_\n    # Broadcast.\n    torch.distributed.broadcast(\n        input_, src=self.ranks[src], group=self.device_group\n    )\n    return input_",
      "language": "python"
    },
    {
      "code": "broadcast_object(obj: Any | None = None, src: int = 0)",
      "language": "typescript"
    },
    {
      "code": "broadcast_object(obj: Any | None = None, src: int = 0)",
      "language": "typescript"
    },
    {
      "code": "599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621",
      "language": "unknown"
    },
    {
      "code": "def broadcast_object(self, obj: Any | None = None, src: int = 0):\n    \"\"\"Broadcast the input object.\n    NOTE: `src` is the local rank of the source rank.\n    \"\"\"\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    # Bypass the function if we are using only 1 GPU.\n    if self.world_size == 1:\n        return obj\n    if self.mq_broadcaster is not None:\n        assert src == 0, \"Message queue broadcaster only supports src=0\"\n        return self.mq_broadcaster.broadcast_object(obj)\n    if self.rank_in_group == src:\n        torch.distributed.broadcast_object_list(\n            [obj], src=self.ranks[src], group=self.cpu_group\n        )\n        return obj\n    else:\n        recv = [None]\n        torch.distributed.broadcast_object_list(\n            recv, src=self.ranks[src], group=self.cpu_group\n        )\n        return recv[0]",
      "language": "python"
    },
    {
      "code": "def broadcast_object(self, obj: Any | None = None, src: int = 0):\n    \"\"\"Broadcast the input object.\n    NOTE: `src` is the local rank of the source rank.\n    \"\"\"\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    # Bypass the function if we are using only 1 GPU.\n    if self.world_size == 1:\n        return obj\n    if self.mq_broadcaster is not None:\n        assert src == 0, \"Message queue broadcaster only supports src=0\"\n        return self.mq_broadcaster.broadcast_object(obj)\n    if self.rank_in_group == src:\n        torch.distributed.broadcast_object_list(\n            [obj], src=self.ranks[src], group=self.cpu_group\n        )\n        return obj\n    else:\n        recv = [None]\n        torch.distributed.broadcast_object_list(\n            recv, src=self.ranks[src], group=self.cpu_group\n        )\n        return recv[0]",
      "language": "python"
    },
    {
      "code": "broadcast_object_list(\n    obj_list: list[Any],\n    src: int = 0,\n    group: ProcessGroup | None = None,\n)",
      "language": "typescript"
    },
    {
      "code": "broadcast_object_list(\n    obj_list: list[Any],\n    src: int = 0,\n    group: ProcessGroup | None = None,\n)",
      "language": "typescript"
    },
    {
      "code": "623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638",
      "language": "unknown"
    },
    {
      "code": "def broadcast_object_list(\n    self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None\n):\n    \"\"\"Broadcast the input object list.\n    NOTE: `src` is the local rank of the source rank.\n    \"\"\"\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    # Bypass the function if we are using only 1 GPU.\n    if self.world_size == 1:\n        return obj_list\n    # Broadcast.\n    torch.distributed.broadcast_object_list(\n        obj_list, src=self.ranks[src], group=self.device_group\n    )\n    return obj_list",
      "language": "python"
    },
    {
      "code": "def broadcast_object_list(\n    self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None\n):\n    \"\"\"Broadcast the input object list.\n    NOTE: `src` is the local rank of the source rank.\n    \"\"\"\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    # Bypass the function if we are using only 1 GPU.\n    if self.world_size == 1:\n        return obj_list\n    # Broadcast.\n    torch.distributed.broadcast_object_list(\n        obj_list, src=self.ranks[src], group=self.device_group\n    )\n    return obj_list",
      "language": "python"
    },
    {
      "code": "broadcast_tensor_dict(\n    tensor_dict: dict[str, Tensor | Any] | None = None,\n    src: int = 0,\n    group: ProcessGroup | None = None,\n    metadata_group: ProcessGroup | None = None,\n) -> dict[str, Tensor | Any] | None",
      "language": "typescript"
    },
    {
      "code": "broadcast_tensor_dict(\n    tensor_dict: dict[str, Tensor | Any] | None = None,\n    src: int = 0,\n    group: ProcessGroup | None = None,\n    metadata_group: ProcessGroup | None = None,\n) -> dict[str, Tensor | Any] | None",
      "language": "typescript"
    },
    {
      "code": "703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741\n742\n743\n744\n745\n746\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783",
      "language": "unknown"
    },
    {
      "code": "def broadcast_tensor_dict(\n    self,\n    tensor_dict: dict[str, torch.Tensor | Any] | None = None,\n    src: int = 0,\n    group: ProcessGroup | None = None,\n    metadata_group: ProcessGroup | None = None,\n) -> dict[str, torch.Tensor | Any] | None:\n    \"\"\"Broadcast the input tensor dictionary.\n    NOTE: `src` is the local rank of the source rank.\n    \"\"\"\n    # Bypass the function if we are using only 1 GPU.\n    if not torch.distributed.is_initialized() or self.world_size == 1:\n        return tensor_dict\n\n    group = self.device_group\n    metadata_group = self.cpu_group\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    rank_in_group = self.rank_in_group\n    if rank_in_group == src:\n        metadata_list: list[tuple[Any, Any]] = []\n        assert isinstance(tensor_dict, dict), (\n            f\"Expecting a dictionary, got {type(tensor_dict)}\"\n        )\n        metadata_list, tensor_list = _split_tensor_dict(tensor_dict)\n        # `metadata_list` lives in CPU memory.\n        # `broadcast_object_list` has serialization & deserialization,\n        # all happening on CPU. Therefore, we can use the CPU group.\n        self.broadcast_object(metadata_list, src=src)\n        async_handles = []\n        for tensor in tensor_list:\n            if tensor.numel() == 0:\n                # Skip broadcasting empty tensors.\n                continue\n            if tensor.is_cpu:\n                # use metadata_group for CPU tensors\n                handle = torch.distributed.broadcast(\n                    tensor, src=self.ranks[src], group=metadata_group, async_op=True\n                )\n            else:\n                # use group for GPU tensors\n                handle = torch.distributed.broadcast(\n                    tensor, src=self.ranks[src], group=group, async_op=True\n                )\n            async_handles.append(handle)\n        for async_handle in async_handles:\n            async_handle.wait()\n\n    else:\n        metadata_list = self.broadcast_object(None, src=src)\n        tensor_dict = {}\n        async_handles = []\n        for key, value in metadata_list:\n            if isinstance(value, TensorMetadata):\n                tensor = torch.empty(\n                    value.size, dtype=value.dtype, device=value.device\n                )\n                if tensor.numel() == 0:\n                    # Skip broadcasting empty tensors.\n                    tensor_dict[key] = tensor\n                    continue\n                if tensor.is_cpu:\n                    # use metadata_group for CPU tensors\n                    handle = torch.distributed.broadcast(\n                        tensor,\n                        src=self.ranks[src],\n                        group=metadata_group,\n                        async_op=True,\n                    )\n                else:\n                    # use group for GPU tensors\n                    handle = torch.distributed.broadcast(\n                        tensor, src=self.ranks[src], group=group, async_op=True\n                    )\n                async_handles.append(handle)\n                tensor_dict[key] = tensor\n            else:\n                tensor_dict[key] = value\n        for async_handle in async_handles:\n            async_handle.wait()\n    return tensor_dict",
      "language": "python"
    },
    {
      "code": "def broadcast_tensor_dict(\n    self,\n    tensor_dict: dict[str, torch.Tensor | Any] | None = None,\n    src: int = 0,\n    group: ProcessGroup | None = None,\n    metadata_group: ProcessGroup | None = None,\n) -> dict[str, torch.Tensor | Any] | None:\n    \"\"\"Broadcast the input tensor dictionary.\n    NOTE: `src` is the local rank of the source rank.\n    \"\"\"\n    # Bypass the function if we are using only 1 GPU.\n    if not torch.distributed.is_initialized() or self.world_size == 1:\n        return tensor_dict\n\n    group = self.device_group\n    metadata_group = self.cpu_group\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    rank_in_group = self.rank_in_group\n    if rank_in_group == src:\n        metadata_list: list[tuple[Any, Any]] = []\n        assert isinstance(tensor_dict, dict), (\n            f\"Expecting a dictionary, got {type(tensor_dict)}\"\n        )\n        metadata_list, tensor_list = _split_tensor_dict(tensor_dict)\n        # `metadata_list` lives in CPU memory.\n        # `broadcast_object_list` has serialization & deserialization,\n        # all happening on CPU. Therefore, we can use the CPU group.\n        self.broadcast_object(metadata_list, src=src)\n        async_handles = []\n        for tensor in tensor_list:\n            if tensor.numel() == 0:\n                # Skip broadcasting empty tensors.\n                continue\n            if tensor.is_cpu:\n                # use metadata_group for CPU tensors\n                handle = torch.distributed.broadcast(\n                    tensor, src=self.ranks[src], group=metadata_group, async_op=True\n                )\n            else:\n                # use group for GPU tensors\n                handle = torch.distributed.broadcast(\n                    tensor, src=self.ranks[src], group=group, async_op=True\n                )\n            async_handles.append(handle)\n        for async_handle in async_handles:\n            async_handle.wait()\n\n    else:\n        metadata_list = self.broadcast_object(None, src=src)\n        tensor_dict = {}\n        async_handles = []\n        for key, value in metadata_list:\n            if isinstance(value, TensorMetadata):\n                tensor = torch.empty(\n                    value.size, dtype=value.dtype, device=value.device\n                )\n                if tensor.numel() == 0:\n                    # Skip broadcasting empty tensors.\n                    tensor_dict[key] = tensor\n                    continue\n                if tensor.is_cpu:\n                    # use metadata_group for CPU tensors\n                    handle = torch.distributed.broadcast(\n                        tensor,\n                        src=self.ranks[src],\n                        group=metadata_group,\n                        async_op=True,\n                    )\n                else:\n                    # use group for GPU tensors\n                    handle = torch.distributed.broadcast(\n                        tensor, src=self.ranks[src], group=group, async_op=True\n                    )\n                async_handles.append(handle)\n                tensor_dict[key] = tensor\n            else:\n                tensor_dict[key] = value\n        for async_handle in async_handles:\n            async_handle.wait()\n    return tensor_dict",
      "language": "python"
    },
    {
      "code": "combine(\n    hidden_states, is_sequence_parallel: bool = False\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "combine(\n    hidden_states, is_sequence_parallel: bool = False\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "1025\n1026\n1027\n1028\n1029\n1030\n1031",
      "language": "unknown"
    },
    {
      "code": "def combine(\n    self, hidden_states, is_sequence_parallel: bool = False\n) -> torch.Tensor:\n    if self.device_communicator is not None:\n        return self.device_communicator.combine(hidden_states, is_sequence_parallel)\n    else:\n        return hidden_states",
      "language": "python"
    },
    {
      "code": "def combine(\n    self, hidden_states, is_sequence_parallel: bool = False\n) -> torch.Tensor:\n    if self.device_communicator is not None:\n        return self.device_communicator.combine(hidden_states, is_sequence_parallel)\n    else:\n        return hidden_states",
      "language": "python"
    },
    {
      "code": "create_mq_broadcaster(\n    writer_rank=0,\n    external_writer_handle=None,\n    blocking=True,\n)",
      "language": "rust"
    },
    {
      "code": "create_mq_broadcaster(\n    writer_rank=0,\n    external_writer_handle=None,\n    blocking=True,\n)",
      "language": "rust"
    },
    {
      "code": "389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401",
      "language": "unknown"
    },
    {
      "code": "def create_mq_broadcaster(\n    self, writer_rank=0, external_writer_handle=None, blocking=True\n):\n    from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n    return MessageQueue.create_from_process_group(\n        self.cpu_group,\n        1 << 22,\n        6,\n        writer_rank=writer_rank,\n        external_writer_handle=external_writer_handle,\n        blocking=blocking,\n    )",
      "language": "python"
    },
    {
      "code": "def create_mq_broadcaster(\n    self, writer_rank=0, external_writer_handle=None, blocking=True\n):\n    from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n    return MessageQueue.create_from_process_group(\n        self.cpu_group,\n        1 << 22,\n        6,\n        writer_rank=writer_rank,\n        external_writer_handle=external_writer_handle,\n        blocking=blocking,\n    )",
      "language": "python"
    },
    {
      "code": "create_single_reader_mq_broadcasters(\n    reader_rank_in_group=0, blocking=False\n)",
      "language": "unknown"
    },
    {
      "code": "create_single_reader_mq_broadcasters(\n    reader_rank_in_group=0, blocking=False\n)",
      "language": "unknown"
    },
    {
      "code": "403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414",
      "language": "unknown"
    },
    {
      "code": "def create_single_reader_mq_broadcasters(\n    self, reader_rank_in_group=0, blocking=False\n):\n    from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n    return MessageQueue.create_from_process_group_single_reader(\n        self.cpu_group,\n        1 << 22,\n        6,\n        reader_rank=self.ranks[reader_rank_in_group],\n        blocking=blocking,\n    )",
      "language": "python"
    },
    {
      "code": "def create_single_reader_mq_broadcasters(\n    self, reader_rank_in_group=0, blocking=False\n):\n    from vllm.distributed.device_communicators.shm_broadcast import MessageQueue\n\n    return MessageQueue.create_from_process_group_single_reader(\n        self.cpu_group,\n        1 << 22,\n        6,\n        reader_rank=self.ranks[reader_rank_in_group],\n        blocking=blocking,\n    )",
      "language": "python"
    },
    {
      "code": "989\n990\n991\n992\n993\n994\n995\n996\n997\n998\n999",
      "language": "unknown"
    },
    {
      "code": "def destroy(self):\n    if hasattr(self, \"device_group\"):\n        torch.distributed.destroy_process_group(self.device_group)\n        del self.device_group\n    if hasattr(self, \"cpu_group\"):\n        torch.distributed.destroy_process_group(self.cpu_group)\n        del self.cpu_group\n    if self.device_communicator is not None:\n        self.device_communicator.destroy()\n    if self.mq_broadcaster is not None:\n        self.mq_broadcaster = None",
      "language": "python"
    },
    {
      "code": "def destroy(self):\n    if hasattr(self, \"device_group\"):\n        torch.distributed.destroy_process_group(self.device_group)\n        del self.device_group\n    if hasattr(self, \"cpu_group\"):\n        torch.distributed.destroy_process_group(self.cpu_group)\n        del self.cpu_group\n    if self.device_communicator is not None:\n        self.device_communicator.destroy()\n    if self.mq_broadcaster is not None:\n        self.mq_broadcaster = None",
      "language": "python"
    },
    {
      "code": "dispatch(\n    hidden_states: Tensor,\n    router_logits: Tensor,\n    is_sequence_parallel: bool = False,\n    extra_tensors: list[Tensor] | None = None,\n) -> (\n    tuple[Tensor, Tensor]\n    | tuple[Tensor, Tensor, list[Tensor]]\n)",
      "language": "typescript"
    },
    {
      "code": "dispatch(\n    hidden_states: Tensor,\n    router_logits: Tensor,\n    is_sequence_parallel: bool = False,\n    extra_tensors: list[Tensor] | None = None,\n) -> (\n    tuple[Tensor, Tensor]\n    | tuple[Tensor, Tensor, list[Tensor]]\n)",
      "language": "typescript"
    },
    {
      "code": "1005\n1006\n1007\n1008\n1009\n1010\n1011\n1012\n1013\n1014\n1015\n1016\n1017\n1018\n1019\n1020\n1021\n1022\n1023",
      "language": "unknown"
    },
    {
      "code": "def dispatch(\n    self,\n    hidden_states: torch.Tensor,\n    router_logits: torch.Tensor,\n    is_sequence_parallel: bool = False,\n    extra_tensors: list[torch.Tensor] | None = None,\n) -> (\n    tuple[torch.Tensor, torch.Tensor]\n    | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]]\n):\n    if self.device_communicator is not None:\n        return self.device_communicator.dispatch(  # type: ignore[call-arg]\n            hidden_states,\n            router_logits,\n            is_sequence_parallel,\n            extra_tensors,\n        )\n    else:\n        return hidden_states, router_logits",
      "language": "python"
    },
    {
      "code": "def dispatch(\n    self,\n    hidden_states: torch.Tensor,\n    router_logits: torch.Tensor,\n    is_sequence_parallel: bool = False,\n    extra_tensors: list[torch.Tensor] | None = None,\n) -> (\n    tuple[torch.Tensor, torch.Tensor]\n    | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]]\n):\n    if self.device_communicator is not None:\n        return self.device_communicator.dispatch(  # type: ignore[call-arg]\n            hidden_states,\n            router_logits,\n            is_sequence_parallel,\n            extra_tensors,\n        )\n    else:\n        return hidden_states, router_logits",
      "language": "python"
    },
    {
      "code": "gather(\n    input_: Tensor, dst: int = 0, dim: int = -1\n) -> Tensor | None",
      "language": "typescript"
    },
    {
      "code": "gather(\n    input_: Tensor, dst: int = 0, dim: int = -1\n) -> Tensor | None",
      "language": "typescript"
    },
    {
      "code": "568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582",
      "language": "unknown"
    },
    {
      "code": "def gather(\n    self, input_: torch.Tensor, dst: int = 0, dim: int = -1\n) -> torch.Tensor | None:\n    \"\"\"\n    NOTE: We assume that the input tensor is on the same device across\n    all the ranks.\n    NOTE: `dst` is the local rank of the destination rank.\n    \"\"\"\n    world_size = self.world_size\n    # Bypass the function if we are using only 1 GPU.\n    if world_size == 1:\n        return input_\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.gather(input_, dst, dim)",
      "language": "python"
    },
    {
      "code": "def gather(\n    self, input_: torch.Tensor, dst: int = 0, dim: int = -1\n) -> torch.Tensor | None:\n    \"\"\"\n    NOTE: We assume that the input tensor is on the same device across\n    all the ranks.\n    NOTE: `dst` is the local rank of the destination rank.\n    \"\"\"\n    world_size = self.world_size\n    # Bypass the function if we are using only 1 GPU.\n    if world_size == 1:\n        return input_\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.gather(input_, dst, dim)",
      "language": "python"
    },
    {
      "code": "graph_capture(\n    graph_capture_context: GraphCaptureContext\n    | None = None,\n)",
      "language": "rust"
    },
    {
      "code": "graph_capture(\n    graph_capture_context: GraphCaptureContext\n    | None = None,\n)",
      "language": "rust"
    },
    {
      "code": "450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478",
      "language": "unknown"
    },
    {
      "code": "@contextmanager\ndef graph_capture(self, graph_capture_context: GraphCaptureContext | None = None):\n    if graph_capture_context is None:\n        stream = torch.cuda.Stream()\n        graph_capture_context = GraphCaptureContext(stream)\n    else:\n        stream = graph_capture_context.stream\n\n    # only cuda uses this function,\n    # so we don't abstract it into the base class\n    maybe_ca_context = nullcontext()\n    from vllm.distributed.device_communicators.cuda_communicator import (\n        CudaCommunicator,\n    )\n\n    if self.device_communicator is not None:\n        assert isinstance(self.device_communicator, CudaCommunicator)\n        ca_comm = self.device_communicator.ca_comm\n        if ca_comm is not None:\n            maybe_ca_context = ca_comm.capture()  # type: ignore\n\n    # ensure all initialization operations complete before attempting to\n    # capture the graph on another stream\n    curr_stream = torch.cuda.current_stream()\n    if curr_stream != stream:\n        stream.wait_stream(curr_stream)\n\n    with torch.cuda.stream(stream), maybe_ca_context:\n        yield graph_capture_context",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef graph_capture(self, graph_capture_context: GraphCaptureContext | None = None):\n    if graph_capture_context is None:\n        stream = torch.cuda.Stream()\n        graph_capture_context = GraphCaptureContext(stream)\n    else:\n        stream = graph_capture_context.stream\n\n    # only cuda uses this function,\n    # so we don't abstract it into the base class\n    maybe_ca_context = nullcontext()\n    from vllm.distributed.device_communicators.cuda_communicator import (\n        CudaCommunicator,\n    )\n\n    if self.device_communicator is not None:\n        assert isinstance(self.device_communicator, CudaCommunicator)\n        ca_comm = self.device_communicator.ca_comm\n        if ca_comm is not None:\n            maybe_ca_context = ca_comm.capture()  # type: ignore\n\n    # ensure all initialization operations complete before attempting to\n    # capture the graph on another stream\n    curr_stream = torch.cuda.current_stream()\n    if curr_stream != stream:\n        stream.wait_stream(curr_stream)\n\n    with torch.cuda.stream(stream), maybe_ca_context:\n        yield graph_capture_context",
      "language": "python"
    },
    {
      "code": "prepare_communication_buffer_for_model(model: Module)",
      "language": "unknown"
    },
    {
      "code": "prepare_communication_buffer_for_model(model: Module)",
      "language": "unknown"
    },
    {
      "code": "1001\n1002\n1003",
      "language": "unknown"
    },
    {
      "code": "def prepare_communication_buffer_for_model(self, model: torch.nn.Module):\n    if self.device_communicator is not None:\n        self.device_communicator.prepare_communication_buffer_for_model(model)",
      "language": "python"
    },
    {
      "code": "def prepare_communication_buffer_for_model(self, model: torch.nn.Module):\n    if self.device_communicator is not None:\n        self.device_communicator.prepare_communication_buffer_for_model(model)",
      "language": "python"
    },
    {
      "code": "recv(\n    size: Size, dtype: dtype, src: int | None = None\n) -> Tensor",
      "language": "rust"
    },
    {
      "code": "recv(\n    size: Size, dtype: dtype, src: int | None = None\n) -> Tensor",
      "language": "rust"
    },
    {
      "code": "980\n981\n982\n983\n984\n985\n986\n987",
      "language": "unknown"
    },
    {
      "code": "def recv(\n    self, size: torch.Size, dtype: torch.dtype, src: int | None = None\n) -> torch.Tensor:\n    \"\"\"Receives a tensor from the source rank.\"\"\"\n    \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.recv(size, dtype, src)",
      "language": "python"
    },
    {
      "code": "def recv(\n    self, size: torch.Size, dtype: torch.dtype, src: int | None = None\n) -> torch.Tensor:\n    \"\"\"Receives a tensor from the source rank.\"\"\"\n    \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.recv(size, dtype, src)",
      "language": "python"
    },
    {
      "code": "recv_object(src: int) -> Any",
      "language": "php"
    },
    {
      "code": "recv_object(src: int) -> Any",
      "language": "php"
    },
    {
      "code": "667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701",
      "language": "unknown"
    },
    {
      "code": "def recv_object(self, src: int) -> Any:\n    \"\"\"Receive the input object list from the source rank.\"\"\"\n    \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    assert src != self.rank_in_group, (\n        \"Invalid source rank. Source rank is the same as the current rank.\"\n    )\n\n    size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\")\n\n    # Receive object size\n    rank_size = torch.distributed.recv(\n        size_tensor, src=self.ranks[src], group=self.cpu_group\n    )\n\n    # Tensor to receive serialized objects into.\n    object_tensor = torch.empty(  # type: ignore[call-overload]\n        size_tensor.item(),  # type: ignore[arg-type]\n        dtype=torch.uint8,\n        device=\"cpu\",\n    )\n\n    rank_object = torch.distributed.recv(\n        object_tensor, src=self.ranks[src], group=self.cpu_group\n    )\n\n    assert rank_object == rank_size, (\n        \"Received object sender rank does not match the size sender rank.\"\n    )\n\n    obj = pickle.loads(object_tensor.numpy().tobytes())\n\n    return obj",
      "language": "python"
    },
    {
      "code": "def recv_object(self, src: int) -> Any:\n    \"\"\"Receive the input object list from the source rank.\"\"\"\n    \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\"\n\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    assert src != self.rank_in_group, (\n        \"Invalid source rank. Source rank is the same as the current rank.\"\n    )\n\n    size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\")\n\n    # Receive object size\n    rank_size = torch.distributed.recv(\n        size_tensor, src=self.ranks[src], group=self.cpu_group\n    )\n\n    # Tensor to receive serialized objects into.\n    object_tensor = torch.empty(  # type: ignore[call-overload]\n        size_tensor.item(),  # type: ignore[arg-type]\n        dtype=torch.uint8,\n        device=\"cpu\",\n    )\n\n    rank_object = torch.distributed.recv(\n        object_tensor, src=self.ranks[src], group=self.cpu_group\n    )\n\n    assert rank_object == rank_size, (\n        \"Received object sender rank does not match the size sender rank.\"\n    )\n\n    obj = pickle.loads(object_tensor.numpy().tobytes())\n\n    return obj",
      "language": "python"
    },
    {
      "code": "recv_tensor_dict(\n    src: int | None = None,\n    all_gather_group: Optional[GroupCoordinator] = None,\n    all_gather_tensors: dict[str, bool] | None = None,\n) -> dict[str, Tensor | Any] | None",
      "language": "rust"
    },
    {
      "code": "recv_tensor_dict(\n    src: int | None = None,\n    all_gather_group: Optional[GroupCoordinator] = None,\n    all_gather_tensors: dict[str, bool] | None = None,\n) -> dict[str, Tensor | Any] | None",
      "language": "rust"
    },
    {
      "code": "873\n874\n875\n876\n877\n878\n879\n880\n881\n882\n883\n884\n885\n886\n887\n888\n889\n890\n891\n892\n893\n894\n895\n896\n897\n898\n899\n900\n901\n902\n903\n904\n905\n906\n907\n908\n909\n910\n911\n912\n913\n914\n915\n916\n917\n918\n919\n920\n921\n922\n923\n924\n925\n926\n927\n928\n929\n930\n931\n932\n933\n934\n935\n936\n937\n938\n939\n940\n941\n942\n943\n944\n945\n946\n947\n948\n949\n950\n951\n952\n953\n954\n955\n956\n957\n958\n959\n960\n961\n962",
      "language": "unknown"
    },
    {
      "code": "def recv_tensor_dict(\n    self,\n    src: int | None = None,\n    all_gather_group: Optional[\"GroupCoordinator\"] = None,\n    all_gather_tensors: dict[str, bool] | None = None,\n) -> dict[str, torch.Tensor | Any] | None:\n    \"\"\"Recv the input tensor dictionary.\n    NOTE: `src` is the local rank of the source rank.\n\n    all_gather_group: The group for the all-gather operation. If provided,\n        an optimization is enabled where each rank in the group sends a\n        slice of a tensor and the receiver reconstructs it using an\n        all-gather, which can improve performance. This is typically the\n        tensor-parallel group.\n    all_gather_tensors: A dictionary to specify which tensors should use\n        the all-gather optimization, which is only effective when\n        `all_gather_group` is provided. By default, this optimization is\n        on for any tensor whose size is divisible by the\n        `all_gather_group`'s world size. However, it should be disabled\n        for tensors that are not fully replicated across the group (e.g.,\n        the residual tensor when sequence parallelism is enabled). This\n        dictionary allows overriding the default behavior on a per-tensor\n        basis.\n    \"\"\"\n    # Bypass the function if we are using only 1 GPU.\n    if not torch.distributed.is_initialized() or self.world_size == 1:\n        return None\n    all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size\n    all_gather_rank = (\n        0 if all_gather_group is None else all_gather_group.rank_in_group\n    )\n\n    group = self.device_group\n    metadata_group = self.cpu_group\n\n    if src is None:\n        src = (self.rank_in_group - 1) % self.world_size\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    if self.use_cpu_custom_send_recv:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.recv_tensor_dict(  # type: ignore\n            src\n        )\n\n    recv_metadata_list = self.recv_object(src=src)\n    tensor_dict: dict[str, Any] = {}\n    for key, value in recv_metadata_list:\n        if isinstance(value, TensorMetadata):\n            tensor = torch.empty(value.size, dtype=value.dtype, device=value.device)\n            if tensor.numel() == 0:\n                # Skip broadcasting empty tensors.\n                tensor_dict[key] = tensor\n                continue\n\n            # send-allgather: send only a slice, then do allgather.\n            use_all_gather = (\n                all_gather_group is not None\n                and tensor.numel() % all_gather_size == 0\n            )\n            use_all_gather = (\n                all_gather_tensors.get(key, use_all_gather)\n                if all_gather_tensors\n                else use_all_gather\n            )\n\n            if use_all_gather:\n                orig_shape = tensor.shape\n                tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank]\n\n            if tensor.is_cpu:\n                # use metadata_group for CPU tensors\n                torch.distributed.recv(\n                    tensor, src=self.ranks[src], group=metadata_group\n                )\n            else:\n                # use group for GPU tensors\n                torch.distributed.recv(tensor, src=self.ranks[src], group=group)\n            if use_all_gather:\n                # do the allgather\n                tensor = all_gather_group.all_gather(  # type: ignore\n                    tensor, dim=0\n                )\n                tensor = tensor.reshape(orig_shape)\n\n            tensor_dict[key] = tensor\n        else:\n            tensor_dict[key] = value\n    return tensor_dict",
      "language": "python"
    },
    {
      "code": "def recv_tensor_dict(\n    self,\n    src: int | None = None,\n    all_gather_group: Optional[\"GroupCoordinator\"] = None,\n    all_gather_tensors: dict[str, bool] | None = None,\n) -> dict[str, torch.Tensor | Any] | None:\n    \"\"\"Recv the input tensor dictionary.\n    NOTE: `src` is the local rank of the source rank.\n\n    all_gather_group: The group for the all-gather operation. If provided,\n        an optimization is enabled where each rank in the group sends a\n        slice of a tensor and the receiver reconstructs it using an\n        all-gather, which can improve performance. This is typically the\n        tensor-parallel group.\n    all_gather_tensors: A dictionary to specify which tensors should use\n        the all-gather optimization, which is only effective when\n        `all_gather_group` is provided. By default, this optimization is\n        on for any tensor whose size is divisible by the\n        `all_gather_group`'s world size. However, it should be disabled\n        for tensors that are not fully replicated across the group (e.g.,\n        the residual tensor when sequence parallelism is enabled). This\n        dictionary allows overriding the default behavior on a per-tensor\n        basis.\n    \"\"\"\n    # Bypass the function if we are using only 1 GPU.\n    if not torch.distributed.is_initialized() or self.world_size == 1:\n        return None\n    all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size\n    all_gather_rank = (\n        0 if all_gather_group is None else all_gather_group.rank_in_group\n    )\n\n    group = self.device_group\n    metadata_group = self.cpu_group\n\n    if src is None:\n        src = (self.rank_in_group - 1) % self.world_size\n    assert src < self.world_size, f\"Invalid src rank ({src})\"\n\n    if self.use_cpu_custom_send_recv:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        return self.device_communicator.recv_tensor_dict(  # type: ignore\n            src\n        )\n\n    recv_metadata_list = self.recv_object(src=src)\n    tensor_dict: dict[str, Any] = {}\n    for key, value in recv_metadata_list:\n        if isinstance(value, TensorMetadata):\n            tensor = torch.empty(value.size, dtype=value.dtype, device=value.device)\n            if tensor.numel() == 0:\n                # Skip broadcasting empty tensors.\n                tensor_dict[key] = tensor\n                continue\n\n            # send-allgather: send only a slice, then do allgather.\n            use_all_gather = (\n                all_gather_group is not None\n                and tensor.numel() % all_gather_size == 0\n            )\n            use_all_gather = (\n                all_gather_tensors.get(key, use_all_gather)\n                if all_gather_tensors\n                else use_all_gather\n            )\n\n            if use_all_gather:\n                orig_shape = tensor.shape\n                tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank]\n\n            if tensor.is_cpu:\n                # use metadata_group for CPU tensors\n                torch.distributed.recv(\n                    tensor, src=self.ranks[src], group=metadata_group\n                )\n            else:\n                # use group for GPU tensors\n                torch.distributed.recv(tensor, src=self.ranks[src], group=group)\n            if use_all_gather:\n                # do the allgather\n                tensor = all_gather_group.all_gather(  # type: ignore\n                    tensor, dim=0\n                )\n                tensor = tensor.reshape(orig_shape)\n\n            tensor_dict[key] = tensor\n        else:\n            tensor_dict[key] = value\n    return tensor_dict",
      "language": "python"
    },
    {
      "code": "reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554",
      "language": "unknown"
    },
    {
      "code": "def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    world_size = self.world_size\n    # Bypass the function if we are using only 1 GPU.\n    if world_size == 1:\n        return input_\n    assert -input_.dim() <= dim < input_.dim(), (\n        f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n    )\n\n    if self.use_custom_op_call:\n        return torch.ops.vllm.reduce_scatter(\n            input_, dim, world_size, group_name=self.unique_name\n        )\n    else:\n        return self._reduce_scatter_out_place(input_, dim)",
      "language": "python"
    },
    {
      "code": "def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    world_size = self.world_size\n    # Bypass the function if we are using only 1 GPU.\n    if world_size == 1:\n        return input_\n    assert -input_.dim() <= dim < input_.dim(), (\n        f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\"\n    )\n\n    if self.use_custom_op_call:\n        return torch.ops.vllm.reduce_scatter(\n            input_, dim, world_size, group_name=self.unique_name\n        )\n    else:\n        return self._reduce_scatter_out_place(input_, dim)",
      "language": "python"
    },
    {
      "code": "reduce_scatterv(\n    input_: Tensor,\n    dim: int = -1,\n    sizes: list[int] | None = None,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "reduce_scatterv(\n    input_: Tensor,\n    dim: int = -1,\n    sizes: list[int] | None = None,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "556\n557\n558\n559\n560\n561",
      "language": "unknown"
    },
    {
      "code": "def reduce_scatterv(\n    self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None\n) -> torch.Tensor:\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.reduce_scatterv(input_, dim, sizes)",
      "language": "python"
    },
    {
      "code": "def reduce_scatterv(\n    self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None\n) -> torch.Tensor:\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    return self.device_communicator.reduce_scatterv(input_, dim, sizes)",
      "language": "python"
    },
    {
      "code": "send(tensor: Tensor, dst: int | None = None) -> None",
      "language": "rust"
    },
    {
      "code": "send(tensor: Tensor, dst: int | None = None) -> None",
      "language": "rust"
    },
    {
      "code": "973\n974\n975\n976\n977\n978",
      "language": "unknown"
    },
    {
      "code": "def send(self, tensor: torch.Tensor, dst: int | None = None) -> None:\n    \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\"\n    \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    self.device_communicator.send(tensor, dst)",
      "language": "python"
    },
    {
      "code": "def send(self, tensor: torch.Tensor, dst: int | None = None) -> None:\n    \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\"\n    \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n    if self.device_communicator is None:\n        raise ValueError(\"No device communicator found\")\n    self.device_communicator.send(tensor, dst)",
      "language": "python"
    },
    {
      "code": "send_object(obj: Any, dst: int) -> None",
      "language": "rust"
    },
    {
      "code": "send_object(obj: Any, dst: int) -> None",
      "language": "rust"
    },
    {
      "code": "640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665",
      "language": "unknown"
    },
    {
      "code": "def send_object(self, obj: Any, dst: int) -> None:\n    \"\"\"Send the input object list to the destination rank.\"\"\"\n    \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n\n    assert dst < self.world_size, f\"Invalid dst rank ({dst})\"\n\n    assert dst != self.rank_in_group, (\n        \"Invalid destination rank. Destination rank is the same \"\n        \"as the current rank.\"\n    )\n\n    # Serialize object to tensor and get the size as well\n    object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8)\n\n    size_tensor = torch.tensor(\n        [object_tensor.numel()], dtype=torch.long, device=\"cpu\"\n    )\n\n    # Send object size\n\n    torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group)\n\n    # Send object\n    torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group)\n\n    return None",
      "language": "python"
    },
    {
      "code": "def send_object(self, obj: Any, dst: int) -> None:\n    \"\"\"Send the input object list to the destination rank.\"\"\"\n    \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\"\n\n    assert dst < self.world_size, f\"Invalid dst rank ({dst})\"\n\n    assert dst != self.rank_in_group, (\n        \"Invalid destination rank. Destination rank is the same \"\n        \"as the current rank.\"\n    )\n\n    # Serialize object to tensor and get the size as well\n    object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8)\n\n    size_tensor = torch.tensor(\n        [object_tensor.numel()], dtype=torch.long, device=\"cpu\"\n    )\n\n    # Send object size\n\n    torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group)\n\n    # Send object\n    torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group)\n\n    return None",
      "language": "python"
    },
    {
      "code": "send_tensor_dict(\n    tensor_dict: dict[str, Tensor | Any],\n    dst: int | None = None,\n    all_gather_group: Optional[GroupCoordinator] = None,\n    all_gather_tensors: dict[str, bool] | None = None,\n) -> dict[str, Tensor | Any] | None",
      "language": "rust"
    },
    {
      "code": "send_tensor_dict(\n    tensor_dict: dict[str, Tensor | Any],\n    dst: int | None = None,\n    all_gather_group: Optional[GroupCoordinator] = None,\n    all_gather_tensors: dict[str, bool] | None = None,\n) -> dict[str, Tensor | Any] | None",
      "language": "rust"
    },
    {
      "code": "785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\n800\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816\n817\n818\n819\n820\n821\n822\n823\n824\n825\n826\n827\n828\n829\n830\n831\n832\n833\n834\n835\n836\n837\n838\n839\n840\n841\n842\n843\n844\n845\n846\n847\n848\n849\n850\n851\n852\n853\n854\n855\n856\n857\n858\n859\n860\n861\n862\n863\n864\n865\n866\n867\n868\n869\n870\n871",
      "language": "unknown"
    },
    {
      "code": "def send_tensor_dict(\n    self,\n    tensor_dict: dict[str, torch.Tensor | Any],\n    dst: int | None = None,\n    all_gather_group: Optional[\"GroupCoordinator\"] = None,\n    all_gather_tensors: dict[str, bool] | None = None,\n) -> dict[str, torch.Tensor | Any] | None:\n    \"\"\"Send the input tensor dictionary.\n    NOTE: `dst` is the local rank of the source rank.\n\n    all_gather_group: The group for the all-gather operation. If provided,\n        an optimization is enabled where each rank in the group sends a\n        slice of a tensor and the receiver reconstructs it using an\n        all-gather, which can improve performance. This is typically the\n        tensor-parallel group.\n    all_gather_tensors: A dictionary to specify which tensors should use\n        the all-gather optimization, which is only effective when\n        `all_gather_group` is provided. By default, this optimization is\n        on for any tensor whose size is divisible by the\n        `all_gather_group`'s world size. However, it should be disabled\n        for tensors that are not fully replicated across the group (e.g.,\n        the residual tensor when sequence parallelism is enabled). This\n        dictionary allows overriding the default behavior on a per-tensor\n        basis.\n    \"\"\"\n    # Bypass the function if we are using only 1 GPU.\n    if not torch.distributed.is_initialized() or self.world_size == 1:\n        return tensor_dict\n    all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size\n    all_gather_rank = (\n        0 if all_gather_group is None else all_gather_group.rank_in_group\n    )\n\n    group = self.device_group\n    metadata_group = self.cpu_group\n\n    if dst is None:\n        dst = (self.rank_in_group + 1) % self.world_size\n    assert dst < self.world_size, f\"Invalid dst rank ({dst})\"\n\n    if self.use_cpu_custom_send_recv:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        self.device_communicator.send_tensor_dict(  # type: ignore\n            tensor_dict, dst\n        )\n        return None\n\n    metadata_list: list[tuple[Any, Any]] = []\n    assert isinstance(tensor_dict, dict), (\n        f\"Expecting a dictionary, got {type(tensor_dict)}\"\n    )\n    metadata_list, tensor_list = _split_tensor_dict(tensor_dict)\n    # `metadata_list` lives in CPU memory.\n    # `send_object_list` has serialization & deserialization,\n    # all happening on CPU. Therefore, we can use the CPU group.\n    self.send_object(metadata_list, dst=dst)\n\n    tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)]\n    assert len(tensor_keys) == len(tensor_list)\n\n    for key, tensor in zip(tensor_keys, tensor_list):\n        if tensor.numel() == 0:\n            # Skip sending empty tensors.\n            continue\n\n        # send-allgather: send only a slice, then do allgather.\n        use_all_gather = (\n            all_gather_group is not None and tensor.numel() % all_gather_size == 0\n        )\n        use_all_gather = (\n            all_gather_tensors.get(key, use_all_gather)\n            if all_gather_tensors\n            else use_all_gather\n        )\n        if use_all_gather:\n            tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank]\n\n        if tensor.is_cpu:\n            # use metadata_group for CPU tensors\n            torch.distributed.send(\n                tensor, dst=self.ranks[dst], group=metadata_group\n            )\n        else:\n            # use group for GPU tensors\n            torch.distributed.send(tensor, dst=self.ranks[dst], group=group)\n    return None",
      "language": "python"
    },
    {
      "code": "def send_tensor_dict(\n    self,\n    tensor_dict: dict[str, torch.Tensor | Any],\n    dst: int | None = None,\n    all_gather_group: Optional[\"GroupCoordinator\"] = None,\n    all_gather_tensors: dict[str, bool] | None = None,\n) -> dict[str, torch.Tensor | Any] | None:\n    \"\"\"Send the input tensor dictionary.\n    NOTE: `dst` is the local rank of the source rank.\n\n    all_gather_group: The group for the all-gather operation. If provided,\n        an optimization is enabled where each rank in the group sends a\n        slice of a tensor and the receiver reconstructs it using an\n        all-gather, which can improve performance. This is typically the\n        tensor-parallel group.\n    all_gather_tensors: A dictionary to specify which tensors should use\n        the all-gather optimization, which is only effective when\n        `all_gather_group` is provided. By default, this optimization is\n        on for any tensor whose size is divisible by the\n        `all_gather_group`'s world size. However, it should be disabled\n        for tensors that are not fully replicated across the group (e.g.,\n        the residual tensor when sequence parallelism is enabled). This\n        dictionary allows overriding the default behavior on a per-tensor\n        basis.\n    \"\"\"\n    # Bypass the function if we are using only 1 GPU.\n    if not torch.distributed.is_initialized() or self.world_size == 1:\n        return tensor_dict\n    all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size\n    all_gather_rank = (\n        0 if all_gather_group is None else all_gather_group.rank_in_group\n    )\n\n    group = self.device_group\n    metadata_group = self.cpu_group\n\n    if dst is None:\n        dst = (self.rank_in_group + 1) % self.world_size\n    assert dst < self.world_size, f\"Invalid dst rank ({dst})\"\n\n    if self.use_cpu_custom_send_recv:\n        if self.device_communicator is None:\n            raise ValueError(\"No device communicator found\")\n        self.device_communicator.send_tensor_dict(  # type: ignore\n            tensor_dict, dst\n        )\n        return None\n\n    metadata_list: list[tuple[Any, Any]] = []\n    assert isinstance(tensor_dict, dict), (\n        f\"Expecting a dictionary, got {type(tensor_dict)}\"\n    )\n    metadata_list, tensor_list = _split_tensor_dict(tensor_dict)\n    # `metadata_list` lives in CPU memory.\n    # `send_object_list` has serialization & deserialization,\n    # all happening on CPU. Therefore, we can use the CPU group.\n    self.send_object(metadata_list, dst=dst)\n\n    tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)]\n    assert len(tensor_keys) == len(tensor_list)\n\n    for key, tensor in zip(tensor_keys, tensor_list):\n        if tensor.numel() == 0:\n            # Skip sending empty tensors.\n            continue\n\n        # send-allgather: send only a slice, then do allgather.\n        use_all_gather = (\n            all_gather_group is not None and tensor.numel() % all_gather_size == 0\n        )\n        use_all_gather = (\n            all_gather_tensors.get(key, use_all_gather)\n            if all_gather_tensors\n            else use_all_gather\n        )\n        if use_all_gather:\n            tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank]\n\n        if tensor.is_cpu:\n            # use metadata_group for CPU tensors\n            torch.distributed.send(\n                tensor, dst=self.ranks[dst], group=metadata_group\n            )\n        else:\n            # use group for GPU tensors\n            torch.distributed.send(tensor, dst=self.ranks[dst], group=group)\n    return None",
      "language": "python"
    },
    {
      "code": "143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418",
      "language": "unknown"
    },
    {
      "code": "@dataclasses.dataclass\nclass StatelessProcessGroup:\n    \"\"\"A dataclass to hold a metadata store, and the rank, world_size of the\n    group. Only use it to communicate metadata between processes.\n    For data-plane communication, create NCCL-related objects.\n    \"\"\"\n\n    rank: int\n    world_size: int\n    store: torch._C._distributed_c10d.Store\n\n    # stores a reference to the socket so that the file descriptor stays alive\n    socket: socket.socket | None\n\n    data_expiration_seconds: int = 3600  # 1 hour\n\n    # dst rank -> counter\n    send_dst_counter: dict[int, int] = dataclasses.field(default_factory=dict)\n    # src rank -> counter\n    recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict)\n    broadcast_send_counter: int = 0\n    broadcast_recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict)\n\n    # A deque to store the data entries, with key and timestamp.\n    entries: deque[tuple[str, float]] = dataclasses.field(default_factory=deque)\n\n    def __post_init__(self):\n        assert self.rank < self.world_size\n        self.send_dst_counter = {i: 0 for i in range(self.world_size)}\n        self.recv_src_counter = {i: 0 for i in range(self.world_size)}\n        self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)}\n\n    def send_obj(self, obj: Any, dst: int):\n        \"\"\"Send an object to a destination rank.\"\"\"\n        self.expire_data()\n        key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\"\n        self.store.set(key, pickle.dumps(obj))\n        self.send_dst_counter[dst] += 1\n        self.entries.append((key, time.time()))\n\n    def expire_data(self):\n        \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\"\n        while self.entries:\n            # check the oldest entry\n            key, timestamp = self.entries[0]\n            if time.time() - timestamp > self.data_expiration_seconds:\n                self.store.delete_key(key)\n                self.entries.popleft()\n            else:\n                break\n\n    def recv_obj(self, src: int) -> Any:\n        \"\"\"Receive an object from a source rank.\"\"\"\n        obj = pickle.loads(\n            self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\")\n        )\n        self.recv_src_counter[src] += 1\n        return obj\n\n    def broadcast_obj(self, obj: Any | None, src: int) -> Any:\n        \"\"\"Broadcast an object from a source rank to all other ranks.\n        It does not clean up after all ranks have received the object.\n        Use it for limited times, e.g., for initialization.\n        \"\"\"\n        if self.rank == src:\n            self.expire_data()\n            key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\"\n            self.store.set(key, pickle.dumps(obj))\n            self.broadcast_send_counter += 1\n            self.entries.append((key, time.time()))\n            return obj\n        else:\n            key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\"\n            recv_obj = pickle.loads(self.store.get(key))\n            self.broadcast_recv_src_counter[src] += 1\n            return recv_obj\n\n    def all_gather_obj(self, obj: Any) -> list[Any]:\n        \"\"\"All gather an object from all ranks.\"\"\"\n        gathered_objs = []\n        for i in range(self.world_size):\n            if i == self.rank:\n                gathered_objs.append(obj)\n                self.broadcast_obj(obj, src=self.rank)\n            else:\n                recv_obj = self.broadcast_obj(None, src=i)\n                gathered_objs.append(recv_obj)\n        return gathered_objs\n\n    def barrier(self, timeout: float = 30.0):\n        \"\"\"A robust barrier to synchronize all ranks.\n\n\n        Uses a multi-phase approach to ensure all processes reach the barrier\n        before proceeding:\n\n        1. Each process signals it has reached the barrier\n\n        2. Each process signals that it has confirmed the arrival of all other\n        ranks.\n\n        3. Rank 0 waits for all other ranks to signal their departure to ensure\n        that all ranks have departed the barrier first.\n\n        Args:\n            timeout: Maximum time in seconds to wait for each phase (in seconds)\n\n\n        Raises:\n            RuntimeError: If coordination fails or times out\n        \"\"\"\n        # Generate a barrier ID that is globally unique\n        try:\n            if self.rank == 0:\n                barrier_id = f\"barrier_{uuid.uuid4()}\"\n                self.broadcast_obj(barrier_id, src=0)\n            else:\n                barrier_id = self.broadcast_obj(None, src=0)\n        except Exception as e:\n            raise RuntimeError(\"Failed to broadcast barrier_id\") from e\n\n        # Phase 1: Signal arrival at barrier\n        # Wait for all processes to arrive\n        # We need all ranks to confirm the arrival of all other ranks.\n        # This is the key synchronization point.\n        arrival_key = f\"arrival_{barrier_id}_{self.rank}\"\n        try:\n            self.store.set(arrival_key, b\"1\")\n        except Exception as e:\n            raise RuntimeError(\"Failed to signal barrier arrival\") from e\n\n        start_time = time.time()\n        processes_arrived: set[int] = set()\n\n        while len(processes_arrived) < self.world_size:\n            # Check for timeout\n            cur_time = time.time()\n            if cur_time - start_time > timeout:\n                raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\")\n\n            # Check for each process\n            for i in range(self.world_size):\n                if i in processes_arrived:\n                    continue\n\n                key = f\"arrival_{barrier_id}_{i}\"\n                try:\n                    # Try to get the key - if it exists, we'll get a value\n                    # If it doesn't exist, it will throw an exception\n                    self.store.get(key)\n                    processes_arrived.add(i)\n                except KeyError:\n                    # Key doesn't exist yet\n                    pass\n                except Exception as check_e:\n                    logger.debug(\"Error checking key existence: %s\", check_e)\n                    sched_yield()\n\n            # Short sleep to avoid tight polling\n            if len(processes_arrived) < self.world_size:\n                sched_yield()\n\n        # Phase 2: Signal departure from barrier\n        # We only care to block at this stage in rank 0, which runs the\n        # server side of the TCPStore. We want to make sure that all\n        # clients have departed the barrier before rank 0 in case the\n        # next thing after the barrier is a shutdown, including tearing\n        # down the TCPStore. Other ranks can exit the barrier immediately\n        # after signaling their departure.\n        departure_key = f\"departure_{barrier_id}_{self.rank}\"\n        try:\n            self.store.set(departure_key, b\"1\")\n        except Exception as e:\n            raise RuntimeError(\"Failed to signal barrier departure\") from e\n\n        if self.rank != 0:\n            return\n\n        # Make rank 0 wait for all processes to signal departure\n        start_time = time.time()\n        processes_departed: set[int] = set()\n\n        while len(processes_departed) < self.world_size:\n            # Check for timeout\n            if time.time() - start_time > timeout:\n                raise RuntimeError(\n                    f\"Barrier departure timed out after {timeout:.2f} seconds\"\n                )\n\n            # Check for each process\n            for i in range(self.world_size):\n                if i in processes_departed:\n                    continue\n\n                key = f\"departure_{barrier_id}_{i}\"\n                try:\n                    # Try to get the key - if it exists, we'll get a value\n                    # If it doesn't exist, it will throw an exception\n                    self.store.get(key)\n                    processes_departed.add(i)\n                except KeyError:\n                    # Key doesn't exist yet\n                    pass\n                except Exception as check_e:\n                    logger.debug(\"Error checking key existence: %s\", check_e)\n                    sched_yield()\n\n            # Short sleep to avoid tight polling\n            if len(processes_departed) < self.world_size:\n                sched_yield()\n\n        # Clean up keys to avoid leaking memory in the store\n        for i in range(self.world_size):\n            try:\n                self.store.delete_key(f\"arrival_{barrier_id}_{i}\")\n            except Exception:\n                logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\")\n\n            try:\n                self.store.delete_key(f\"departure_{barrier_id}_{i}\")\n            except Exception:\n                logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\")\n\n    @staticmethod\n    def create(\n        host: str,\n        port: int,\n        rank: int,\n        world_size: int,\n        data_expiration_seconds: int = 3600,\n        store_timeout: int = 300,\n    ) -> \"StatelessProcessGroup\":\n        \"\"\"A replacement for `torch.distributed.init_process_group` that does not\n        pollute the global state.\n\n        If we have process A and process B called `torch.distributed.init_process_group`\n        to form a group, and then we want to form another group with process A, B, C,\n        D, it is not possible in PyTorch, because process A and process B have already\n        formed a group, and process C and process D cannot join that group. This\n        function is a workaround for this issue.\n\n        `torch.distributed.init_process_group` is a global call, while this function\n        is a stateless call. It will return a `StatelessProcessGroup` object that can be\n        used for exchanging metadata. With this function, process A and process B\n        can call `StatelessProcessGroup.create` to form a group, and then process A, B,\n        C, and D can call `StatelessProcessGroup.create` to form another group.\n        \"\"\"  # noqa\n        launch_server = rank == 0\n        if launch_server:\n            # listen on the specified interface (instead of 0.0.0.0)\n            listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            listen_socket.bind((host, port))\n            listen_socket.listen()\n            listen_fd = listen_socket.fileno()\n        else:\n            listen_socket = None\n            listen_fd = None\n\n        store = TCPStore(\n            host_name=host,\n            port=port,\n            world_size=world_size,\n            is_master=launch_server,\n            timeout=timedelta(seconds=store_timeout),\n            use_libuv=False,  # for now: github.com/pytorch/pytorch/pull/150215\n            master_listen_fd=listen_fd,\n        )\n\n        return StatelessProcessGroup(\n            rank=rank,\n            world_size=world_size,\n            store=store,\n            socket=listen_socket,\n            data_expiration_seconds=data_expiration_seconds,\n        )",
      "language": "python"
    },
    {
      "code": "@dataclasses.dataclass\nclass StatelessProcessGroup:\n    \"\"\"A dataclass to hold a metadata store, and the rank, world_size of the\n    group. Only use it to communicate metadata between processes.\n    For data-plane communication, create NCCL-related objects.\n    \"\"\"\n\n    rank: int\n    world_size: int\n    store: torch._C._distributed_c10d.Store\n\n    # stores a reference to the socket so that the file descriptor stays alive\n    socket: socket.socket | None\n\n    data_expiration_seconds: int = 3600  # 1 hour\n\n    # dst rank -> counter\n    send_dst_counter: dict[int, int] = dataclasses.field(default_factory=dict)\n    # src rank -> counter\n    recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict)\n    broadcast_send_counter: int = 0\n    broadcast_recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict)\n\n    # A deque to store the data entries, with key and timestamp.\n    entries: deque[tuple[str, float]] = dataclasses.field(default_factory=deque)\n\n    def __post_init__(self):\n        assert self.rank < self.world_size\n        self.send_dst_counter = {i: 0 for i in range(self.world_size)}\n        self.recv_src_counter = {i: 0 for i in range(self.world_size)}\n        self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)}\n\n    def send_obj(self, obj: Any, dst: int):\n        \"\"\"Send an object to a destination rank.\"\"\"\n        self.expire_data()\n        key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\"\n        self.store.set(key, pickle.dumps(obj))\n        self.send_dst_counter[dst] += 1\n        self.entries.append((key, time.time()))\n\n    def expire_data(self):\n        \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\"\n        while self.entries:\n            # check the oldest entry\n            key, timestamp = self.entries[0]\n            if time.time() - timestamp > self.data_expiration_seconds:\n                self.store.delete_key(key)\n                self.entries.popleft()\n            else:\n                break\n\n    def recv_obj(self, src: int) -> Any:\n        \"\"\"Receive an object from a source rank.\"\"\"\n        obj = pickle.loads(\n            self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\")\n        )\n        self.recv_src_counter[src] += 1\n        return obj\n\n    def broadcast_obj(self, obj: Any | None, src: int) -> Any:\n        \"\"\"Broadcast an object from a source rank to all other ranks.\n        It does not clean up after all ranks have received the object.\n        Use it for limited times, e.g., for initialization.\n        \"\"\"\n        if self.rank == src:\n            self.expire_data()\n            key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\"\n            self.store.set(key, pickle.dumps(obj))\n            self.broadcast_send_counter += 1\n            self.entries.append((key, time.time()))\n            return obj\n        else:\n            key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\"\n            recv_obj = pickle.loads(self.store.get(key))\n            self.broadcast_recv_src_counter[src] += 1\n            return recv_obj\n\n    def all_gather_obj(self, obj: Any) -> list[Any]:\n        \"\"\"All gather an object from all ranks.\"\"\"\n        gathered_objs = []\n        for i in range(self.world_size):\n            if i == self.rank:\n                gathered_objs.append(obj)\n                self.broadcast_obj(obj, src=self.rank)\n            else:\n                recv_obj = self.broadcast_obj(None, src=i)\n                gathered_objs.append(recv_obj)\n        return gathered_objs\n\n    def barrier(self, timeout: float = 30.0):\n        \"\"\"A robust barrier to synchronize all ranks.\n\n\n        Uses a multi-phase approach to ensure all processes reach the barrier\n        before proceeding:\n\n        1. Each process signals it has reached the barrier\n\n        2. Each process signals that it has confirmed the arrival of all other\n        ranks.\n\n        3. Rank 0 waits for all other ranks to signal their departure to ensure\n        that all ranks have departed the barrier first.\n\n        Args:\n            timeout: Maximum time in seconds to wait for each phase (in seconds)\n\n\n        Raises:\n            RuntimeError: If coordination fails or times out\n        \"\"\"\n        # Generate a barrier ID that is globally unique\n        try:\n            if self.rank == 0:\n                barrier_id = f\"barrier_{uuid.uuid4()}\"\n                self.broadcast_obj(barrier_id, src=0)\n            else:\n                barrier_id = self.broadcast_obj(None, src=0)\n        except Exception as e:\n            raise RuntimeError(\"Failed to broadcast barrier_id\") from e\n\n        # Phase 1: Signal arrival at barrier\n        # Wait for all processes to arrive\n        # We need all ranks to confirm the arrival of all other ranks.\n        # This is the key synchronization point.\n        arrival_key = f\"arrival_{barrier_id}_{self.rank}\"\n        try:\n            self.store.set(arrival_key, b\"1\")\n        except Exception as e:\n            raise RuntimeError(\"Failed to signal barrier arrival\") from e\n\n        start_time = time.time()\n        processes_arrived: set[int] = set()\n\n        while len(processes_arrived) < self.world_size:\n            # Check for timeout\n            cur_time = time.time()\n            if cur_time - start_time > timeout:\n                raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\")\n\n            # Check for each process\n            for i in range(self.world_size):\n                if i in processes_arrived:\n                    continue\n\n                key = f\"arrival_{barrier_id}_{i}\"\n                try:\n                    # Try to get the key - if it exists, we'll get a value\n                    # If it doesn't exist, it will throw an exception\n                    self.store.get(key)\n                    processes_arrived.add(i)\n                except KeyError:\n                    # Key doesn't exist yet\n                    pass\n                except Exception as check_e:\n                    logger.debug(\"Error checking key existence: %s\", check_e)\n                    sched_yield()\n\n            # Short sleep to avoid tight polling\n            if len(processes_arrived) < self.world_size:\n                sched_yield()\n\n        # Phase 2: Signal departure from barrier\n        # We only care to block at this stage in rank 0, which runs the\n        # server side of the TCPStore. We want to make sure that all\n        # clients have departed the barrier before rank 0 in case the\n        # next thing after the barrier is a shutdown, including tearing\n        # down the TCPStore. Other ranks can exit the barrier immediately\n        # after signaling their departure.\n        departure_key = f\"departure_{barrier_id}_{self.rank}\"\n        try:\n            self.store.set(departure_key, b\"1\")\n        except Exception as e:\n            raise RuntimeError(\"Failed to signal barrier departure\") from e\n\n        if self.rank != 0:\n            return\n\n        # Make rank 0 wait for all processes to signal departure\n        start_time = time.time()\n        processes_departed: set[int] = set()\n\n        while len(processes_departed) < self.world_size:\n            # Check for timeout\n            if time.time() - start_time > timeout:\n                raise RuntimeError(\n                    f\"Barrier departure timed out after {timeout:.2f} seconds\"\n                )\n\n            # Check for each process\n            for i in range(self.world_size):\n                if i in processes_departed:\n                    continue\n\n                key = f\"departure_{barrier_id}_{i}\"\n                try:\n                    # Try to get the key - if it exists, we'll get a value\n                    # If it doesn't exist, it will throw an exception\n                    self.store.get(key)\n                    processes_departed.add(i)\n                except KeyError:\n                    # Key doesn't exist yet\n                    pass\n                except Exception as check_e:\n                    logger.debug(\"Error checking key existence: %s\", check_e)\n                    sched_yield()\n\n            # Short sleep to avoid tight polling\n            if len(processes_departed) < self.world_size:\n                sched_yield()\n\n        # Clean up keys to avoid leaking memory in the store\n        for i in range(self.world_size):\n            try:\n                self.store.delete_key(f\"arrival_{barrier_id}_{i}\")\n            except Exception:\n                logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\")\n\n            try:\n                self.store.delete_key(f\"departure_{barrier_id}_{i}\")\n            except Exception:\n                logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\")\n\n    @staticmethod\n    def create(\n        host: str,\n        port: int,\n        rank: int,\n        world_size: int,\n        data_expiration_seconds: int = 3600,\n        store_timeout: int = 300,\n    ) -> \"StatelessProcessGroup\":\n        \"\"\"A replacement for `torch.distributed.init_process_group` that does not\n        pollute the global state.\n\n        If we have process A and process B called `torch.distributed.init_process_group`\n        to form a group, and then we want to form another group with process A, B, C,\n        D, it is not possible in PyTorch, because process A and process B have already\n        formed a group, and process C and process D cannot join that group. This\n        function is a workaround for this issue.\n\n        `torch.distributed.init_process_group` is a global call, while this function\n        is a stateless call. It will return a `StatelessProcessGroup` object that can be\n        used for exchanging metadata. With this function, process A and process B\n        can call `StatelessProcessGroup.create` to form a group, and then process A, B,\n        C, and D can call `StatelessProcessGroup.create` to form another group.\n        \"\"\"  # noqa\n        launch_server = rank == 0\n        if launch_server:\n            # listen on the specified interface (instead of 0.0.0.0)\n            listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            listen_socket.bind((host, port))\n            listen_socket.listen()\n            listen_fd = listen_socket.fileno()\n        else:\n            listen_socket = None\n            listen_fd = None\n\n        store = TCPStore(\n            host_name=host,\n            port=port,\n            world_size=world_size,\n            is_master=launch_server,\n            timeout=timedelta(seconds=store_timeout),\n            use_libuv=False,  # for now: github.com/pytorch/pytorch/pull/150215\n            master_listen_fd=listen_fd,\n        )\n\n        return StatelessProcessGroup(\n            rank=rank,\n            world_size=world_size,\n            store=store,\n            socket=listen_socket,\n            data_expiration_seconds=data_expiration_seconds,\n        )",
      "language": "python"
    },
    {
      "code": "broadcast_recv_src_counter: dict[int, int] = field(\n    default_factory=dict\n)",
      "language": "yaml"
    },
    {
      "code": "broadcast_recv_src_counter: dict[int, int] = field(\n    default_factory=dict\n)",
      "language": "yaml"
    },
    {
      "code": "broadcast_send_counter: int = 0",
      "language": "typescript"
    },
    {
      "code": "broadcast_send_counter: int = 0",
      "language": "typescript"
    },
    {
      "code": "data_expiration_seconds: int = 3600",
      "language": "typescript"
    },
    {
      "code": "data_expiration_seconds: int = 3600",
      "language": "typescript"
    },
    {
      "code": "entries: deque[tuple[str, float]] = field(\n    default_factory=deque\n)",
      "language": "yaml"
    },
    {
      "code": "entries: deque[tuple[str, float]] = field(\n    default_factory=deque\n)",
      "language": "yaml"
    },
    {
      "code": "recv_src_counter: dict[int, int] = field(\n    default_factory=dict\n)",
      "language": "yaml"
    },
    {
      "code": "recv_src_counter: dict[int, int] = field(\n    default_factory=dict\n)",
      "language": "yaml"
    },
    {
      "code": "send_dst_counter: dict[int, int] = field(\n    default_factory=dict\n)",
      "language": "yaml"
    },
    {
      "code": "send_dst_counter: dict[int, int] = field(\n    default_factory=dict\n)",
      "language": "yaml"
    },
    {
      "code": "socket: socket | None",
      "language": "yaml"
    },
    {
      "code": "socket: socket | None",
      "language": "yaml"
    },
    {
      "code": "store: Store",
      "language": "yaml"
    },
    {
      "code": "store: Store",
      "language": "yaml"
    },
    {
      "code": "world_size: int",
      "language": "yaml"
    },
    {
      "code": "world_size: int",
      "language": "yaml"
    },
    {
      "code": "__init__(\n    rank: int,\n    world_size: int,\n    store: Store,\n    socket: socket | None,\n    data_expiration_seconds: int = 3600,\n    send_dst_counter: dict[int, int] = dict(),\n    recv_src_counter: dict[int, int] = dict(),\n    broadcast_send_counter: int = 0,\n    broadcast_recv_src_counter: dict[int, int] = dict(),\n    entries: deque[tuple[str, float]] = deque(),\n) -> None",
      "language": "typescript"
    },
    {
      "code": "__init__(\n    rank: int,\n    world_size: int,\n    store: Store,\n    socket: socket | None,\n    data_expiration_seconds: int = 3600,\n    send_dst_counter: dict[int, int] = dict(),\n    recv_src_counter: dict[int, int] = dict(),\n    broadcast_send_counter: int = 0,\n    broadcast_recv_src_counter: dict[int, int] = dict(),\n    entries: deque[tuple[str, float]] = deque(),\n) -> None",
      "language": "typescript"
    },
    {
      "code": "__post_init__()",
      "language": "unknown"
    },
    {
      "code": "__post_init__()",
      "language": "unknown"
    },
    {
      "code": "169\n170\n171\n172\n173",
      "language": "unknown"
    },
    {
      "code": "def __post_init__(self):\n    assert self.rank < self.world_size\n    self.send_dst_counter = {i: 0 for i in range(self.world_size)}\n    self.recv_src_counter = {i: 0 for i in range(self.world_size)}\n    self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)}",
      "language": "python"
    },
    {
      "code": "def __post_init__(self):\n    assert self.rank < self.world_size\n    self.send_dst_counter = {i: 0 for i in range(self.world_size)}\n    self.recv_src_counter = {i: 0 for i in range(self.world_size)}\n    self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)}",
      "language": "python"
    },
    {
      "code": "all_gather_obj(obj: Any) -> list[Any]",
      "language": "php"
    },
    {
      "code": "all_gather_obj(obj: Any) -> list[Any]",
      "language": "php"
    },
    {
      "code": "220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230",
      "language": "unknown"
    },
    {
      "code": "def all_gather_obj(self, obj: Any) -> list[Any]:\n    \"\"\"All gather an object from all ranks.\"\"\"\n    gathered_objs = []\n    for i in range(self.world_size):\n        if i == self.rank:\n            gathered_objs.append(obj)\n            self.broadcast_obj(obj, src=self.rank)\n        else:\n            recv_obj = self.broadcast_obj(None, src=i)\n            gathered_objs.append(recv_obj)\n    return gathered_objs",
      "language": "python"
    },
    {
      "code": "def all_gather_obj(self, obj: Any) -> list[Any]:\n    \"\"\"All gather an object from all ranks.\"\"\"\n    gathered_objs = []\n    for i in range(self.world_size):\n        if i == self.rank:\n            gathered_objs.append(obj)\n            self.broadcast_obj(obj, src=self.rank)\n        else:\n            recv_obj = self.broadcast_obj(None, src=i)\n            gathered_objs.append(recv_obj)\n    return gathered_objs",
      "language": "python"
    },
    {
      "code": "barrier(timeout: float = 30.0)",
      "language": "typescript"
    },
    {
      "code": "barrier(timeout: float = 30.0)",
      "language": "typescript"
    },
    {
      "code": "232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364",
      "language": "unknown"
    },
    {
      "code": "def barrier(self, timeout: float = 30.0):\n    \"\"\"A robust barrier to synchronize all ranks.\n\n\n    Uses a multi-phase approach to ensure all processes reach the barrier\n    before proceeding:\n\n    1. Each process signals it has reached the barrier\n\n    2. Each process signals that it has confirmed the arrival of all other\n    ranks.\n\n    3. Rank 0 waits for all other ranks to signal their departure to ensure\n    that all ranks have departed the barrier first.\n\n    Args:\n        timeout: Maximum time in seconds to wait for each phase (in seconds)\n\n\n    Raises:\n        RuntimeError: If coordination fails or times out\n    \"\"\"\n    # Generate a barrier ID that is globally unique\n    try:\n        if self.rank == 0:\n            barrier_id = f\"barrier_{uuid.uuid4()}\"\n            self.broadcast_obj(barrier_id, src=0)\n        else:\n            barrier_id = self.broadcast_obj(None, src=0)\n    except Exception as e:\n        raise RuntimeError(\"Failed to broadcast barrier_id\") from e\n\n    # Phase 1: Signal arrival at barrier\n    # Wait for all processes to arrive\n    # We need all ranks to confirm the arrival of all other ranks.\n    # This is the key synchronization point.\n    arrival_key = f\"arrival_{barrier_id}_{self.rank}\"\n    try:\n        self.store.set(arrival_key, b\"1\")\n    except Exception as e:\n        raise RuntimeError(\"Failed to signal barrier arrival\") from e\n\n    start_time = time.time()\n    processes_arrived: set[int] = set()\n\n    while len(processes_arrived) < self.world_size:\n        # Check for timeout\n        cur_time = time.time()\n        if cur_time - start_time > timeout:\n            raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\")\n\n        # Check for each process\n        for i in range(self.world_size):\n            if i in processes_arrived:\n                continue\n\n            key = f\"arrival_{barrier_id}_{i}\"\n            try:\n                # Try to get the key - if it exists, we'll get a value\n                # If it doesn't exist, it will throw an exception\n                self.store.get(key)\n                processes_arrived.add(i)\n            except KeyError:\n                # Key doesn't exist yet\n                pass\n            except Exception as check_e:\n                logger.debug(\"Error checking key existence: %s\", check_e)\n                sched_yield()\n\n        # Short sleep to avoid tight polling\n        if len(processes_arrived) < self.world_size:\n            sched_yield()\n\n    # Phase 2: Signal departure from barrier\n    # We only care to block at this stage in rank 0, which runs the\n    # server side of the TCPStore. We want to make sure that all\n    # clients have departed the barrier before rank 0 in case the\n    # next thing after the barrier is a shutdown, including tearing\n    # down the TCPStore. Other ranks can exit the barrier immediately\n    # after signaling their departure.\n    departure_key = f\"departure_{barrier_id}_{self.rank}\"\n    try:\n        self.store.set(departure_key, b\"1\")\n    except Exception as e:\n        raise RuntimeError(\"Failed to signal barrier departure\") from e\n\n    if self.rank != 0:\n        return\n\n    # Make rank 0 wait for all processes to signal departure\n    start_time = time.time()\n    processes_departed: set[int] = set()\n\n    while len(processes_departed) < self.world_size:\n        # Check for timeout\n        if time.time() - start_time > timeout:\n            raise RuntimeError(\n                f\"Barrier departure timed out after {timeout:.2f} seconds\"\n            )\n\n        # Check for each process\n        for i in range(self.world_size):\n            if i in processes_departed:\n                continue\n\n            key = f\"departure_{barrier_id}_{i}\"\n            try:\n                # Try to get the key - if it exists, we'll get a value\n                # If it doesn't exist, it will throw an exception\n                self.store.get(key)\n                processes_departed.add(i)\n            except KeyError:\n                # Key doesn't exist yet\n                pass\n            except Exception as check_e:\n                logger.debug(\"Error checking key existence: %s\", check_e)\n                sched_yield()\n\n        # Short sleep to avoid tight polling\n        if len(processes_departed) < self.world_size:\n            sched_yield()\n\n    # Clean up keys to avoid leaking memory in the store\n    for i in range(self.world_size):\n        try:\n            self.store.delete_key(f\"arrival_{barrier_id}_{i}\")\n        except Exception:\n            logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\")\n\n        try:\n            self.store.delete_key(f\"departure_{barrier_id}_{i}\")\n        except Exception:\n            logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\")",
      "language": "python"
    },
    {
      "code": "def barrier(self, timeout: float = 30.0):\n    \"\"\"A robust barrier to synchronize all ranks.\n\n\n    Uses a multi-phase approach to ensure all processes reach the barrier\n    before proceeding:\n\n    1. Each process signals it has reached the barrier\n\n    2. Each process signals that it has confirmed the arrival of all other\n    ranks.\n\n    3. Rank 0 waits for all other ranks to signal their departure to ensure\n    that all ranks have departed the barrier first.\n\n    Args:\n        timeout: Maximum time in seconds to wait for each phase (in seconds)\n\n\n    Raises:\n        RuntimeError: If coordination fails or times out\n    \"\"\"\n    # Generate a barrier ID that is globally unique\n    try:\n        if self.rank == 0:\n            barrier_id = f\"barrier_{uuid.uuid4()}\"\n            self.broadcast_obj(barrier_id, src=0)\n        else:\n            barrier_id = self.broadcast_obj(None, src=0)\n    except Exception as e:\n        raise RuntimeError(\"Failed to broadcast barrier_id\") from e\n\n    # Phase 1: Signal arrival at barrier\n    # Wait for all processes to arrive\n    # We need all ranks to confirm the arrival of all other ranks.\n    # This is the key synchronization point.\n    arrival_key = f\"arrival_{barrier_id}_{self.rank}\"\n    try:\n        self.store.set(arrival_key, b\"1\")\n    except Exception as e:\n        raise RuntimeError(\"Failed to signal barrier arrival\") from e\n\n    start_time = time.time()\n    processes_arrived: set[int] = set()\n\n    while len(processes_arrived) < self.world_size:\n        # Check for timeout\n        cur_time = time.time()\n        if cur_time - start_time > timeout:\n            raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\")\n\n        # Check for each process\n        for i in range(self.world_size):\n            if i in processes_arrived:\n                continue\n\n            key = f\"arrival_{barrier_id}_{i}\"\n            try:\n                # Try to get the key - if it exists, we'll get a value\n                # If it doesn't exist, it will throw an exception\n                self.store.get(key)\n                processes_arrived.add(i)\n            except KeyError:\n                # Key doesn't exist yet\n                pass\n            except Exception as check_e:\n                logger.debug(\"Error checking key existence: %s\", check_e)\n                sched_yield()\n\n        # Short sleep to avoid tight polling\n        if len(processes_arrived) < self.world_size:\n            sched_yield()\n\n    # Phase 2: Signal departure from barrier\n    # We only care to block at this stage in rank 0, which runs the\n    # server side of the TCPStore. We want to make sure that all\n    # clients have departed the barrier before rank 0 in case the\n    # next thing after the barrier is a shutdown, including tearing\n    # down the TCPStore. Other ranks can exit the barrier immediately\n    # after signaling their departure.\n    departure_key = f\"departure_{barrier_id}_{self.rank}\"\n    try:\n        self.store.set(departure_key, b\"1\")\n    except Exception as e:\n        raise RuntimeError(\"Failed to signal barrier departure\") from e\n\n    if self.rank != 0:\n        return\n\n    # Make rank 0 wait for all processes to signal departure\n    start_time = time.time()\n    processes_departed: set[int] = set()\n\n    while len(processes_departed) < self.world_size:\n        # Check for timeout\n        if time.time() - start_time > timeout:\n            raise RuntimeError(\n                f\"Barrier departure timed out after {timeout:.2f} seconds\"\n            )\n\n        # Check for each process\n        for i in range(self.world_size):\n            if i in processes_departed:\n                continue\n\n            key = f\"departure_{barrier_id}_{i}\"\n            try:\n                # Try to get the key - if it exists, we'll get a value\n                # If it doesn't exist, it will throw an exception\n                self.store.get(key)\n                processes_departed.add(i)\n            except KeyError:\n                # Key doesn't exist yet\n                pass\n            except Exception as check_e:\n                logger.debug(\"Error checking key existence: %s\", check_e)\n                sched_yield()\n\n        # Short sleep to avoid tight polling\n        if len(processes_departed) < self.world_size:\n            sched_yield()\n\n    # Clean up keys to avoid leaking memory in the store\n    for i in range(self.world_size):\n        try:\n            self.store.delete_key(f\"arrival_{barrier_id}_{i}\")\n        except Exception:\n            logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\")\n\n        try:\n            self.store.delete_key(f\"departure_{barrier_id}_{i}\")\n        except Exception:\n            logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\")",
      "language": "python"
    },
    {
      "code": "broadcast_obj(obj: Any | None, src: int) -> Any",
      "language": "rust"
    },
    {
      "code": "broadcast_obj(obj: Any | None, src: int) -> Any",
      "language": "rust"
    },
    {
      "code": "202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218",
      "language": "unknown"
    },
    {
      "code": "def broadcast_obj(self, obj: Any | None, src: int) -> Any:\n    \"\"\"Broadcast an object from a source rank to all other ranks.\n    It does not clean up after all ranks have received the object.\n    Use it for limited times, e.g., for initialization.\n    \"\"\"\n    if self.rank == src:\n        self.expire_data()\n        key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\"\n        self.store.set(key, pickle.dumps(obj))\n        self.broadcast_send_counter += 1\n        self.entries.append((key, time.time()))\n        return obj\n    else:\n        key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\"\n        recv_obj = pickle.loads(self.store.get(key))\n        self.broadcast_recv_src_counter[src] += 1\n        return recv_obj",
      "language": "python"
    },
    {
      "code": "def broadcast_obj(self, obj: Any | None, src: int) -> Any:\n    \"\"\"Broadcast an object from a source rank to all other ranks.\n    It does not clean up after all ranks have received the object.\n    Use it for limited times, e.g., for initialization.\n    \"\"\"\n    if self.rank == src:\n        self.expire_data()\n        key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\"\n        self.store.set(key, pickle.dumps(obj))\n        self.broadcast_send_counter += 1\n        self.entries.append((key, time.time()))\n        return obj\n    else:\n        key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\"\n        recv_obj = pickle.loads(self.store.get(key))\n        self.broadcast_recv_src_counter[src] += 1\n        return recv_obj",
      "language": "python"
    },
    {
      "code": "create(\n    host: str,\n    port: int,\n    rank: int,\n    world_size: int,\n    data_expiration_seconds: int = 3600,\n    store_timeout: int = 300,\n) -> StatelessProcessGroup",
      "language": "typescript"
    },
    {
      "code": "create(\n    host: str,\n    port: int,\n    rank: int,\n    world_size: int,\n    data_expiration_seconds: int = 3600,\n    store_timeout: int = 300,\n) -> StatelessProcessGroup",
      "language": "typescript"
    },
    {
      "code": "366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418",
      "language": "unknown"
    },
    {
      "code": "@staticmethod\ndef create(\n    host: str,\n    port: int,\n    rank: int,\n    world_size: int,\n    data_expiration_seconds: int = 3600,\n    store_timeout: int = 300,\n) -> \"StatelessProcessGroup\":\n    \"\"\"A replacement for `torch.distributed.init_process_group` that does not\n    pollute the global state.\n\n    If we have process A and process B called `torch.distributed.init_process_group`\n    to form a group, and then we want to form another group with process A, B, C,\n    D, it is not possible in PyTorch, because process A and process B have already\n    formed a group, and process C and process D cannot join that group. This\n    function is a workaround for this issue.\n\n    `torch.distributed.init_process_group` is a global call, while this function\n    is a stateless call. It will return a `StatelessProcessGroup` object that can be\n    used for exchanging metadata. With this function, process A and process B\n    can call `StatelessProcessGroup.create` to form a group, and then process A, B,\n    C, and D can call `StatelessProcessGroup.create` to form another group.\n    \"\"\"  # noqa\n    launch_server = rank == 0\n    if launch_server:\n        # listen on the specified interface (instead of 0.0.0.0)\n        listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        listen_socket.bind((host, port))\n        listen_socket.listen()\n        listen_fd = listen_socket.fileno()\n    else:\n        listen_socket = None\n        listen_fd = None\n\n    store = TCPStore(\n        host_name=host,\n        port=port,\n        world_size=world_size,\n        is_master=launch_server,\n        timeout=timedelta(seconds=store_timeout),\n        use_libuv=False,  # for now: github.com/pytorch/pytorch/pull/150215\n        master_listen_fd=listen_fd,\n    )\n\n    return StatelessProcessGroup(\n        rank=rank,\n        world_size=world_size,\n        store=store,\n        socket=listen_socket,\n        data_expiration_seconds=data_expiration_seconds,\n    )",
      "language": "python"
    },
    {
      "code": "@staticmethod\ndef create(\n    host: str,\n    port: int,\n    rank: int,\n    world_size: int,\n    data_expiration_seconds: int = 3600,\n    store_timeout: int = 300,\n) -> \"StatelessProcessGroup\":\n    \"\"\"A replacement for `torch.distributed.init_process_group` that does not\n    pollute the global state.\n\n    If we have process A and process B called `torch.distributed.init_process_group`\n    to form a group, and then we want to form another group with process A, B, C,\n    D, it is not possible in PyTorch, because process A and process B have already\n    formed a group, and process C and process D cannot join that group. This\n    function is a workaround for this issue.\n\n    `torch.distributed.init_process_group` is a global call, while this function\n    is a stateless call. It will return a `StatelessProcessGroup` object that can be\n    used for exchanging metadata. With this function, process A and process B\n    can call `StatelessProcessGroup.create` to form a group, and then process A, B,\n    C, and D can call `StatelessProcessGroup.create` to form another group.\n    \"\"\"  # noqa\n    launch_server = rank == 0\n    if launch_server:\n        # listen on the specified interface (instead of 0.0.0.0)\n        listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        listen_socket.bind((host, port))\n        listen_socket.listen()\n        listen_fd = listen_socket.fileno()\n    else:\n        listen_socket = None\n        listen_fd = None\n\n    store = TCPStore(\n        host_name=host,\n        port=port,\n        world_size=world_size,\n        is_master=launch_server,\n        timeout=timedelta(seconds=store_timeout),\n        use_libuv=False,  # for now: github.com/pytorch/pytorch/pull/150215\n        master_listen_fd=listen_fd,\n    )\n\n    return StatelessProcessGroup(\n        rank=rank,\n        world_size=world_size,\n        store=store,\n        socket=listen_socket,\n        data_expiration_seconds=data_expiration_seconds,\n    )",
      "language": "python"
    },
    {
      "code": "expire_data()",
      "language": "unknown"
    },
    {
      "code": "expire_data()",
      "language": "unknown"
    },
    {
      "code": "183\n184\n185\n186\n187\n188\n189\n190\n191\n192",
      "language": "unknown"
    },
    {
      "code": "def expire_data(self):\n    \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\"\n    while self.entries:\n        # check the oldest entry\n        key, timestamp = self.entries[0]\n        if time.time() - timestamp > self.data_expiration_seconds:\n            self.store.delete_key(key)\n            self.entries.popleft()\n        else:\n            break",
      "language": "python"
    },
    {
      "code": "def expire_data(self):\n    \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\"\n    while self.entries:\n        # check the oldest entry\n        key, timestamp = self.entries[0]\n        if time.time() - timestamp > self.data_expiration_seconds:\n            self.store.delete_key(key)\n            self.entries.popleft()\n        else:\n            break",
      "language": "python"
    },
    {
      "code": "recv_obj(src: int) -> Any",
      "language": "php"
    },
    {
      "code": "recv_obj(src: int) -> Any",
      "language": "php"
    },
    {
      "code": "194\n195\n196\n197\n198\n199\n200",
      "language": "unknown"
    },
    {
      "code": "def recv_obj(self, src: int) -> Any:\n    \"\"\"Receive an object from a source rank.\"\"\"\n    obj = pickle.loads(\n        self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\")\n    )\n    self.recv_src_counter[src] += 1\n    return obj",
      "language": "python"
    },
    {
      "code": "def recv_obj(self, src: int) -> Any:\n    \"\"\"Receive an object from a source rank.\"\"\"\n    obj = pickle.loads(\n        self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\")\n    )\n    self.recv_src_counter[src] += 1\n    return obj",
      "language": "python"
    },
    {
      "code": "send_obj(obj: Any, dst: int)",
      "language": "unknown"
    },
    {
      "code": "send_obj(obj: Any, dst: int)",
      "language": "unknown"
    },
    {
      "code": "175\n176\n177\n178\n179\n180\n181",
      "language": "unknown"
    },
    {
      "code": "def send_obj(self, obj: Any, dst: int):\n    \"\"\"Send an object to a destination rank.\"\"\"\n    self.expire_data()\n    key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\"\n    self.store.set(key, pickle.dumps(obj))\n    self.send_dst_counter[dst] += 1\n    self.entries.append((key, time.time()))",
      "language": "python"
    },
    {
      "code": "def send_obj(self, obj: Any, dst: int):\n    \"\"\"Send an object to a destination rank.\"\"\"\n    self.expire_data()\n    key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\"\n    self.store.set(key, pickle.dumps(obj))\n    self.send_dst_counter[dst] += 1\n    self.entries.append((key, time.time()))",
      "language": "python"
    },
    {
      "code": "all_gather(\n    tensor: Tensor,\n    dim: int,\n    world_size: int,\n    group_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "all_gather(\n    tensor: Tensor,\n    dim: int,\n    world_size: int,\n    group_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "147\n148\n149\n150\n151\n152\n153\n154",
      "language": "unknown"
    },
    {
      "code": "def all_gather(\n    tensor: torch.Tensor, dim: int, world_size: int, group_name: str\n) -> torch.Tensor:\n    assert group_name in _groups, f\"Group {group_name} is not found.\"\n    group = _groups[group_name]()\n    if group is None:\n        raise ValueError(f\"Group {group_name} is destroyed.\")\n    return group._all_gather_out_place(tensor, dim)",
      "language": "python"
    },
    {
      "code": "def all_gather(\n    tensor: torch.Tensor, dim: int, world_size: int, group_name: str\n) -> torch.Tensor:\n    assert group_name in _groups, f\"Group {group_name} is not found.\"\n    group = _groups[group_name]()\n    if group is None:\n        raise ValueError(f\"Group {group_name} is destroyed.\")\n    return group._all_gather_out_place(tensor, dim)",
      "language": "python"
    },
    {
      "code": "all_gather_fake(\n    tensor: Tensor,\n    dim: int,\n    world_size: int,\n    group_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "all_gather_fake(\n    tensor: Tensor,\n    dim: int,\n    world_size: int,\n    group_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "157\n158\n159\n160\n161\n162",
      "language": "unknown"
    },
    {
      "code": "def all_gather_fake(\n    tensor: torch.Tensor, dim: int, world_size: int, group_name: str\n) -> torch.Tensor:\n    new_shape = list(tensor.shape)\n    new_shape[dim] = tensor.shape[dim] * world_size\n    return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device)",
      "language": "python"
    },
    {
      "code": "def all_gather_fake(\n    tensor: torch.Tensor, dim: int, world_size: int, group_name: str\n) -> torch.Tensor:\n    new_shape = list(tensor.shape)\n    new_shape[dim] = tensor.shape[dim] * world_size\n    return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device)",
      "language": "python"
    },
    {
      "code": "all_reduce(tensor: Tensor, group_name: str) -> Tensor",
      "language": "php"
    },
    {
      "code": "all_reduce(tensor: Tensor, group_name: str) -> Tensor",
      "language": "php"
    },
    {
      "code": "117\n118\n119\n120\n121\n122",
      "language": "unknown"
    },
    {
      "code": "def all_reduce(tensor: torch.Tensor, group_name: str) -> torch.Tensor:\n    assert group_name in _groups, f\"Group {group_name} is not found.\"\n    group = _groups[group_name]()\n    if group is None:\n        raise ValueError(f\"Group {group_name} is destroyed.\")\n    return group._all_reduce_out_place(tensor)",
      "language": "python"
    },
    {
      "code": "def all_reduce(tensor: torch.Tensor, group_name: str) -> torch.Tensor:\n    assert group_name in _groups, f\"Group {group_name} is not found.\"\n    group = _groups[group_name]()\n    if group is None:\n        raise ValueError(f\"Group {group_name} is destroyed.\")\n    return group._all_reduce_out_place(tensor)",
      "language": "python"
    },
    {
      "code": "all_reduce_fake(tensor: Tensor, group_name: str) -> Tensor",
      "language": "php"
    },
    {
      "code": "all_reduce_fake(tensor: Tensor, group_name: str) -> Tensor",
      "language": "php"
    },
    {
      "code": "def all_reduce_fake(tensor: torch.Tensor, group_name: str) -> torch.Tensor:\n    return torch.empty_like(tensor)",
      "language": "python"
    },
    {
      "code": "def all_reduce_fake(tensor: torch.Tensor, group_name: str) -> torch.Tensor:\n    return torch.empty_like(tensor)",
      "language": "python"
    },
    {
      "code": "broadcast_tensor_dict(\n    tensor_dict: dict[Any, Tensor | Any] | None = None,\n    src: int = 0,\n)",
      "language": "typescript"
    },
    {
      "code": "broadcast_tensor_dict(\n    tensor_dict: dict[Any, Tensor | Any] | None = None,\n    src: int = 0,\n)",
      "language": "typescript"
    },
    {
      "code": "38\n39\n40\n41\n42\n43",
      "language": "unknown"
    },
    {
      "code": "def broadcast_tensor_dict(\n    tensor_dict: dict[Any, torch.Tensor | Any] | None = None, src: int = 0\n):\n    if not torch.distributed.is_initialized():\n        return tensor_dict\n    return get_tp_group().broadcast_tensor_dict(tensor_dict, src)",
      "language": "python"
    },
    {
      "code": "def broadcast_tensor_dict(\n    tensor_dict: dict[Any, torch.Tensor | Any] | None = None, src: int = 0\n):\n    if not torch.distributed.is_initialized():\n        return tensor_dict\n    return get_tp_group().broadcast_tensor_dict(tensor_dict, src)",
      "language": "python"
    },
    {
      "code": "cleanup_dist_env_and_memory(shutdown_ray: bool = False)",
      "language": "typescript"
    },
    {
      "code": "cleanup_dist_env_and_memory(shutdown_ray: bool = False)",
      "language": "typescript"
    },
    {
      "code": "1595\n1596\n1597\n1598\n1599\n1600\n1601\n1602\n1603\n1604\n1605\n1606\n1607\n1608\n1609\n1610\n1611\n1612\n1613\n1614\n1615\n1616\n1617",
      "language": "unknown"
    },
    {
      "code": "def cleanup_dist_env_and_memory(shutdown_ray: bool = False):\n    # Reset environment variable cache\n    envs.disable_envs_cache()\n    # Ensure all objects are not frozen before cleanup\n    gc.unfreeze()\n\n    destroy_model_parallel()\n    destroy_distributed_environment()\n    if shutdown_ray:\n        import ray  # Lazy import Ray\n\n        ray.shutdown()\n    gc.collect()\n    from vllm.platforms import current_platform\n\n    empty_cache = current_platform.empty_cache\n    if empty_cache is not None:\n        empty_cache()\n    try:\n        if not current_platform.is_cpu():\n            torch._C._host_emptyCache()\n    except AttributeError:\n        logger.warning(\"torch._C._host_emptyCache() only available in Pytorch >=2.5\")",
      "language": "python"
    },
    {
      "code": "def cleanup_dist_env_and_memory(shutdown_ray: bool = False):\n    # Reset environment variable cache\n    envs.disable_envs_cache()\n    # Ensure all objects are not frozen before cleanup\n    gc.unfreeze()\n\n    destroy_model_parallel()\n    destroy_distributed_environment()\n    if shutdown_ray:\n        import ray  # Lazy import Ray\n\n        ray.shutdown()\n    gc.collect()\n    from vllm.platforms import current_platform\n\n    empty_cache = current_platform.empty_cache\n    if empty_cache is not None:\n        empty_cache()\n    try:\n        if not current_platform.is_cpu():\n            torch._C._host_emptyCache()\n    except AttributeError:\n        logger.warning(\"torch._C._host_emptyCache() only available in Pytorch >=2.5\")",
      "language": "python"
    },
    {
      "code": "destroy_distributed_environment()",
      "language": "unknown"
    },
    {
      "code": "destroy_distributed_environment()",
      "language": "unknown"
    },
    {
      "code": "1585\n1586\n1587\n1588\n1589\n1590\n1591\n1592",
      "language": "unknown"
    },
    {
      "code": "def destroy_distributed_environment():\n    global _WORLD, _NODE_COUNT\n    if _WORLD:\n        _WORLD.destroy()\n    _WORLD = None\n    _NODE_COUNT = None\n    if torch.distributed.is_initialized():\n        torch.distributed.destroy_process_group()",
      "language": "python"
    },
    {
      "code": "def destroy_distributed_environment():\n    global _WORLD, _NODE_COUNT\n    if _WORLD:\n        _WORLD.destroy()\n    _WORLD = None\n    _NODE_COUNT = None\n    if torch.distributed.is_initialized():\n        torch.distributed.destroy_process_group()",
      "language": "python"
    },
    {
      "code": "destroy_model_parallel()",
      "language": "unknown"
    },
    {
      "code": "destroy_model_parallel()",
      "language": "unknown"
    },
    {
      "code": "1551\n1552\n1553\n1554\n1555\n1556\n1557\n1558\n1559\n1560\n1561\n1562\n1563\n1564\n1565\n1566\n1567\n1568\n1569\n1570\n1571\n1572\n1573\n1574\n1575\n1576\n1577\n1578\n1579\n1580\n1581\n1582",
      "language": "unknown"
    },
    {
      "code": "def destroy_model_parallel():\n    \"\"\"Set the groups to none and destroy them.\"\"\"\n    global _TP\n\n    if _TP:\n        _TP.destroy()\n    _TP = None\n\n    global _DCP\n    if _DCP:\n        _DCP.destroy()\n    _DCP = None\n\n    global _PCP\n    if _PCP:\n        _PCP.destroy()\n    _PCP = None\n\n    global _PP\n    if _PP:\n        _PP.destroy()\n    _PP = None\n\n    global _DP\n    if _DP:\n        _DP.destroy()\n    _DP = None\n\n    global _EP\n    if _EP:\n        _EP.destroy()\n    _EP = None",
      "language": "python"
    },
    {
      "code": "def destroy_model_parallel():\n    \"\"\"Set the groups to none and destroy them.\"\"\"\n    global _TP\n\n    if _TP:\n        _TP.destroy()\n    _TP = None\n\n    global _DCP\n    if _DCP:\n        _DCP.destroy()\n    _DCP = None\n\n    global _PCP\n    if _PCP:\n        _PCP.destroy()\n    _PCP = None\n\n    global _PP\n    if _PP:\n        _PP.destroy()\n    _PP = None\n\n    global _DP\n    if _DP:\n        _DP.destroy()\n    _DP = None\n\n    global _EP\n    if _EP:\n        _EP.destroy()\n    _EP = None",
      "language": "python"
    },
    {
      "code": "direct_register_custom_op(\n    op_name: str,\n    op_func: Callable,\n    mutates_args: list[str] | None = None,\n    fake_impl: Callable | None = None,\n    target_lib: Library | None = None,\n    dispatch_key: str | None = None,\n    tags: tuple[Tag, ...] = (),\n)",
      "language": "rust"
    },
    {
      "code": "direct_register_custom_op(\n    op_name: str,\n    op_func: Callable,\n    mutates_args: list[str] | None = None,\n    fake_impl: Callable | None = None,\n    target_lib: Library | None = None,\n    dispatch_key: str | None = None,\n    tags: tuple[Tag, ...] = (),\n)",
      "language": "rust"
    },
    {
      "code": "677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727",
      "language": "unknown"
    },
    {
      "code": "def direct_register_custom_op(\n    op_name: str,\n    op_func: Callable,\n    mutates_args: list[str] | None = None,\n    fake_impl: Callable | None = None,\n    target_lib: Library | None = None,\n    dispatch_key: str | None = None,\n    tags: tuple[torch.Tag, ...] = (),\n):\n    \"\"\"\n    `torch.library.custom_op` can have significant overhead because it\n    needs to consider complicated dispatching logic. This function\n    directly registers a custom op and dispatches it to the CUDA backend.\n    See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5\n    for more details.\n\n    By default, the custom op is registered to the vLLM library. If you\n    want to register it to a different library, you can pass the library\n    object to the `target_lib` argument.\n\n    IMPORTANT: the lifetime of the operator is tied to the lifetime of the\n    library object. If you want to bind the operator to a different library,\n    make sure the library object is alive when the operator is used.\n    \"\"\"\n    if not supports_custom_op():\n        from vllm.platforms import current_platform\n\n        assert not current_platform.is_cuda_alike(), (\n            \"cuda platform needs torch>=2.4 to support custom op, \"\n            \"chances are you are using an old version of pytorch \"\n            \"or a custom build of pytorch. It is recommended to \"\n            \"use vLLM in a fresh new environment and let it install \"\n            \"the required dependencies.\"\n        )\n        return\n\n    if mutates_args is None:\n        mutates_args = []\n\n    if dispatch_key is None:\n        from vllm.platforms import current_platform\n\n        dispatch_key = current_platform.dispatch_key\n\n    schema_str = infer_schema(op_func, mutates_args=mutates_args)\n\n    my_lib = target_lib or vllm_lib\n    my_lib.define(op_name + schema_str, tags=tags)\n    my_lib.impl(op_name, op_func, dispatch_key=dispatch_key)\n    if fake_impl is not None:\n        my_lib._register_fake(op_name, fake_impl)",
      "language": "python"
    },
    {
      "code": "def direct_register_custom_op(\n    op_name: str,\n    op_func: Callable,\n    mutates_args: list[str] | None = None,\n    fake_impl: Callable | None = None,\n    target_lib: Library | None = None,\n    dispatch_key: str | None = None,\n    tags: tuple[torch.Tag, ...] = (),\n):\n    \"\"\"\n    `torch.library.custom_op` can have significant overhead because it\n    needs to consider complicated dispatching logic. This function\n    directly registers a custom op and dispatches it to the CUDA backend.\n    See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5\n    for more details.\n\n    By default, the custom op is registered to the vLLM library. If you\n    want to register it to a different library, you can pass the library\n    object to the `target_lib` argument.\n\n    IMPORTANT: the lifetime of the operator is tied to the lifetime of the\n    library object. If you want to bind the operator to a different library,\n    make sure the library object is alive when the operator is used.\n    \"\"\"\n    if not supports_custom_op():\n        from vllm.platforms import current_platform\n\n        assert not current_platform.is_cuda_alike(), (\n            \"cuda platform needs torch>=2.4 to support custom op, \"\n            \"chances are you are using an old version of pytorch \"\n            \"or a custom build of pytorch. It is recommended to \"\n            \"use vLLM in a fresh new environment and let it install \"\n            \"the required dependencies.\"\n        )\n        return\n\n    if mutates_args is None:\n        mutates_args = []\n\n    if dispatch_key is None:\n        from vllm.platforms import current_platform\n\n        dispatch_key = current_platform.dispatch_key\n\n    schema_str = infer_schema(op_func, mutates_args=mutates_args)\n\n    my_lib = target_lib or vllm_lib\n    my_lib.define(op_name + schema_str, tags=tags)\n    my_lib.impl(op_name, op_func, dispatch_key=dispatch_key)\n    if fake_impl is not None:\n        my_lib._register_fake(op_name, fake_impl)",
      "language": "python"
    },
    {
      "code": "divide(numerator, denominator)",
      "language": "unknown"
    },
    {
      "code": "divide(numerator, denominator)",
      "language": "unknown"
    },
    {
      "code": "60\n61\n62\n63\n64",
      "language": "unknown"
    },
    {
      "code": "def divide(numerator, denominator):\n    \"\"\"Ensure that numerator is divisible by the denominator and return\n    the division value.\"\"\"\n    ensure_divisibility(numerator, denominator)\n    return numerator // denominator",
      "language": "python"
    },
    {
      "code": "def divide(numerator, denominator):\n    \"\"\"Ensure that numerator is divisible by the denominator and return\n    the division value.\"\"\"\n    ensure_divisibility(numerator, denominator)\n    return numerator // denominator",
      "language": "python"
    },
    {
      "code": "ensure_divisibility(numerator, denominator)",
      "language": "unknown"
    },
    {
      "code": "ensure_divisibility(numerator, denominator)",
      "language": "unknown"
    },
    {
      "code": "53\n54\n55\n56\n57",
      "language": "unknown"
    },
    {
      "code": "def ensure_divisibility(numerator, denominator):\n    \"\"\"Ensure that numerator is divisible by the denominator.\"\"\"\n    assert numerator % denominator == 0, \"{} is not divisible by {}\".format(\n        numerator, denominator\n    )",
      "language": "python"
    },
    {
      "code": "def ensure_divisibility(numerator, denominator):\n    \"\"\"Ensure that numerator is divisible by the denominator.\"\"\"\n    assert numerator % denominator == 0, \"{} is not divisible by {}\".format(\n        numerator, denominator\n    )",
      "language": "python"
    },
    {
      "code": "ensure_model_parallel_initialized(\n    tensor_model_parallel_size: int,\n    pipeline_model_parallel_size: int,\n    prefill_context_model_parallel_size: int = 1,\n    decode_context_model_parallel_size: int | None = 1,\n    backend: str | None = None,\n) -> None",
      "language": "typescript"
    },
    {
      "code": "ensure_model_parallel_initialized(\n    tensor_model_parallel_size: int,\n    pipeline_model_parallel_size: int,\n    prefill_context_model_parallel_size: int = 1,\n    decode_context_model_parallel_size: int | None = 1,\n    backend: str | None = None,\n) -> None",
      "language": "typescript"
    },
    {
      "code": "1432\n1433\n1434\n1435\n1436\n1437\n1438\n1439\n1440\n1441\n1442\n1443\n1444\n1445\n1446\n1447\n1448\n1449\n1450\n1451\n1452\n1453\n1454\n1455\n1456\n1457\n1458\n1459\n1460\n1461\n1462\n1463\n1464\n1465\n1466\n1467\n1468\n1469\n1470",
      "language": "unknown"
    },
    {
      "code": "def ensure_model_parallel_initialized(\n    tensor_model_parallel_size: int,\n    pipeline_model_parallel_size: int,\n    prefill_context_model_parallel_size: int = 1,\n    decode_context_model_parallel_size: int | None = 1,\n    backend: str | None = None,\n) -> None:\n    \"\"\"Helper to initialize model parallel groups if they are not initialized,\n    or ensure tensor-parallel and pipeline-parallel sizes are equal to expected\n    values if the model parallel groups are initialized.\n    \"\"\"\n    backend = backend or torch.distributed.get_backend(get_world_group().device_group)\n    if not model_parallel_is_initialized():\n        initialize_model_parallel(\n            tensor_model_parallel_size,\n            pipeline_model_parallel_size,\n            prefill_context_model_parallel_size,\n            decode_context_model_parallel_size,\n            backend,\n        )\n        return\n\n    assert get_tensor_model_parallel_world_size() == tensor_model_parallel_size, (\n        \"tensor parallel group already initialized, but of unexpected size. \"\n        f\"got: {get_tensor_model_parallel_world_size()=} vs. \"\n        f\"wanted: {tensor_model_parallel_size=}\"\n    )\n    pp_world_size = get_pp_group().world_size\n    assert pp_world_size == pipeline_model_parallel_size, (\n        \"pipeline parallel group already initialized, but of unexpected size. \"\n        f\"got: {pp_world_size=} vs. \"\n        f\"wanted: {pipeline_model_parallel_size=}\"\n    )\n    pcp_world_size = get_pcp_group().world_size\n    assert pcp_world_size == prefill_context_model_parallel_size, (\n        \"prefill context parallel group already initialized, but of unexpected size: \"\n        f\"{pcp_world_size=} vs. \"\n        f\"{prefill_context_model_parallel_size=}\"\n    )",
      "language": "python"
    },
    {
      "code": "def ensure_model_parallel_initialized(\n    tensor_model_parallel_size: int,\n    pipeline_model_parallel_size: int,\n    prefill_context_model_parallel_size: int = 1,\n    decode_context_model_parallel_size: int | None = 1,\n    backend: str | None = None,\n) -> None:\n    \"\"\"Helper to initialize model parallel groups if they are not initialized,\n    or ensure tensor-parallel and pipeline-parallel sizes are equal to expected\n    values if the model parallel groups are initialized.\n    \"\"\"\n    backend = backend or torch.distributed.get_backend(get_world_group().device_group)\n    if not model_parallel_is_initialized():\n        initialize_model_parallel(\n            tensor_model_parallel_size,\n            pipeline_model_parallel_size,\n            prefill_context_model_parallel_size,\n            decode_context_model_parallel_size,\n            backend,\n        )\n        return\n\n    assert get_tensor_model_parallel_world_size() == tensor_model_parallel_size, (\n        \"tensor parallel group already initialized, but of unexpected size. \"\n        f\"got: {get_tensor_model_parallel_world_size()=} vs. \"\n        f\"wanted: {tensor_model_parallel_size=}\"\n    )\n    pp_world_size = get_pp_group().world_size\n    assert pp_world_size == pipeline_model_parallel_size, (\n        \"pipeline parallel group already initialized, but of unexpected size. \"\n        f\"got: {pp_world_size=} vs. \"\n        f\"wanted: {pipeline_model_parallel_size=}\"\n    )\n    pcp_world_size = get_pcp_group().world_size\n    assert pcp_world_size == prefill_context_model_parallel_size, (\n        \"prefill context parallel group already initialized, but of unexpected size: \"\n        f\"{pcp_world_size=} vs. \"\n        f\"{prefill_context_model_parallel_size=}\"\n    )",
      "language": "python"
    },
    {
      "code": "get_dcp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "get_dcp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1090\n1091\n1092",
      "language": "unknown"
    },
    {
      "code": "def get_dcp_group() -> GroupCoordinator:\n    assert _DCP is not None, \"decode context model parallel group is not initialized\"\n    return _DCP",
      "language": "python"
    },
    {
      "code": "def get_dcp_group() -> GroupCoordinator:\n    assert _DCP is not None, \"decode context model parallel group is not initialized\"\n    return _DCP",
      "language": "python"
    },
    {
      "code": "get_decode_context_model_parallel_rank()",
      "language": "unknown"
    },
    {
      "code": "get_decode_context_model_parallel_rank()",
      "language": "unknown"
    },
    {
      "code": "1540\n1541\n1542",
      "language": "unknown"
    },
    {
      "code": "def get_decode_context_model_parallel_rank():\n    \"\"\"Return my rank for the decode context model parallel group.\"\"\"\n    return get_dcp_group().rank_in_group",
      "language": "python"
    },
    {
      "code": "def get_decode_context_model_parallel_rank():\n    \"\"\"Return my rank for the decode context model parallel group.\"\"\"\n    return get_dcp_group().rank_in_group",
      "language": "python"
    },
    {
      "code": "get_decode_context_model_parallel_world_size()",
      "language": "unknown"
    },
    {
      "code": "get_decode_context_model_parallel_world_size()",
      "language": "unknown"
    },
    {
      "code": "1535\n1536\n1537",
      "language": "unknown"
    },
    {
      "code": "def get_decode_context_model_parallel_world_size():\n    \"\"\"Return world size for the decode context model parallel group.\"\"\"\n    return get_dcp_group().world_size",
      "language": "python"
    },
    {
      "code": "def get_decode_context_model_parallel_world_size():\n    \"\"\"Return world size for the decode context model parallel group.\"\"\"\n    return get_dcp_group().world_size",
      "language": "python"
    },
    {
      "code": "get_distributed_init_method(ip: str, port: int) -> str",
      "language": "php"
    },
    {
      "code": "get_distributed_init_method(ip: str, port: int) -> str",
      "language": "php"
    },
    {
      "code": "def get_distributed_init_method(ip: str, port: int) -> str:\n    return get_tcp_uri(ip, port)",
      "language": "python"
    },
    {
      "code": "def get_distributed_init_method(ip: str, port: int) -> str:\n    return get_tcp_uri(ip, port)",
      "language": "python"
    },
    {
      "code": "get_dp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "get_dp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1109\n1110\n1111",
      "language": "unknown"
    },
    {
      "code": "def get_dp_group() -> GroupCoordinator:\n    assert _DP is not None, \"data parallel group is not initialized\"\n    return _DP",
      "language": "python"
    },
    {
      "code": "def get_dp_group() -> GroupCoordinator:\n    assert _DP is not None, \"data parallel group is not initialized\"\n    return _DP",
      "language": "python"
    },
    {
      "code": "get_ep_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "get_ep_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1117\n1118\n1119",
      "language": "unknown"
    },
    {
      "code": "def get_ep_group() -> GroupCoordinator:\n    assert _EP is not None, \"expert parallel group is not initialized\"\n    return _EP",
      "language": "python"
    },
    {
      "code": "def get_ep_group() -> GroupCoordinator:\n    assert _EP is not None, \"expert parallel group is not initialized\"\n    return _EP",
      "language": "python"
    },
    {
      "code": "get_inner_dp_world_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "get_inner_dp_world_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1044\n1045\n1046",
      "language": "unknown"
    },
    {
      "code": "def get_inner_dp_world_group() -> GroupCoordinator:\n    assert _INNER_DP_WORLD is not None, \"inner dp world group is not initialized\"\n    return _INNER_DP_WORLD",
      "language": "python"
    },
    {
      "code": "def get_inner_dp_world_group() -> GroupCoordinator:\n    assert _INNER_DP_WORLD is not None, \"inner dp world group is not initialized\"\n    return _INNER_DP_WORLD",
      "language": "python"
    },
    {
      "code": "get_node_count() -> int",
      "language": "php"
    },
    {
      "code": "get_node_count() -> int",
      "language": "php"
    },
    {
      "code": "1545\n1546\n1547\n1548",
      "language": "unknown"
    },
    {
      "code": "def get_node_count() -> int:\n    \"\"\"Return the total number of nodes in the distributed environment.\"\"\"\n    assert _NODE_COUNT is not None, \"distributed environment is not initialized\"\n    return _NODE_COUNT",
      "language": "python"
    },
    {
      "code": "def get_node_count() -> int:\n    \"\"\"Return the total number of nodes in the distributed environment.\"\"\"\n    assert _NODE_COUNT is not None, \"distributed environment is not initialized\"\n    return _NODE_COUNT",
      "language": "python"
    },
    {
      "code": "get_pcp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "get_pcp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1125\n1126\n1127",
      "language": "unknown"
    },
    {
      "code": "def get_pcp_group() -> GroupCoordinator:\n    assert _PCP is not None, \"prefill context parallel group is not initialized\"\n    return _PCP",
      "language": "python"
    },
    {
      "code": "def get_pcp_group() -> GroupCoordinator:\n    assert _PCP is not None, \"prefill context parallel group is not initialized\"\n    return _PCP",
      "language": "python"
    },
    {
      "code": "get_pp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "get_pp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1101\n1102\n1103",
      "language": "unknown"
    },
    {
      "code": "def get_pp_group() -> GroupCoordinator:\n    assert _PP is not None, \"pipeline model parallel group is not initialized\"\n    return _PP",
      "language": "python"
    },
    {
      "code": "def get_pp_group() -> GroupCoordinator:\n    assert _PP is not None, \"pipeline model parallel group is not initialized\"\n    return _PP",
      "language": "python"
    },
    {
      "code": "get_pp_indices(\n    num_hidden_layers: int, pp_rank: int, pp_size: int\n) -> tuple[int, int]",
      "language": "php"
    },
    {
      "code": "get_pp_indices(\n    num_hidden_layers: int, pp_rank: int, pp_size: int\n) -> tuple[int, int]",
      "language": "php"
    },
    {
      "code": "95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140",
      "language": "unknown"
    },
    {
      "code": "def get_pp_indices(\n    num_hidden_layers: int, pp_rank: int, pp_size: int\n) -> tuple[int, int]:\n    \"\"\"Try to evenly distribute layers across partitions.\n\n    If the number of layers is not divisible by the number of partitions,\n    the remaining layers are evenly distributed across all but the last\n    partition. The last partition is excluded because it often contains an\n    additional norm layer and we are attempting to balance compute.\n\n    If `pp_size > 2` and the number of remaining layers is\n    `0 < x <= pp_size - 2` then the remaining layers are evenly distributed\n    across the middle partitions. The first and last partitions are excluded\n    because they contain the input and output embeddings respectively and we\n    are attempting to reduce maximum memory consumption across partitions.\n    \"\"\"\n    partition_list_str = envs.VLLM_PP_LAYER_PARTITION\n    if partition_list_str is not None:\n        try:\n            partitions = [int(layer) for layer in partition_list_str.split(\",\")]\n        except ValueError as err:\n            raise ValueError(\n                \"Invalid partition string: {}\".format(partition_list_str)\n            ) from err\n        if len(partitions) != pp_size:\n            raise ValueError(f\"{len(partitions)=} does not match {pp_size=}.\")\n        if sum(partitions) != num_hidden_layers:\n            raise ValueError(f\"{sum(partitions)=} does not match {num_hidden_layers=}.\")\n    else:\n        layers_per_partition = num_hidden_layers // pp_size\n        partitions = [layers_per_partition for _ in range(pp_size)]\n\n        if remaining_layers := num_hidden_layers % pp_size:\n            for i in range(2, remaining_layers + 2):\n                partitions[-i] += 1\n            logger.info(\n                \"Hidden layers were unevenly partitioned: [%s]. \"\n                \"This can be manually overridden using the \"\n                \"VLLM_PP_LAYER_PARTITION environment variable\",\n                \",\".join(str(p) for p in partitions),\n            )\n\n    start_layer = sum(partitions[:pp_rank])\n    end_layer = start_layer + partitions[pp_rank]\n\n    return (start_layer, end_layer)",
      "language": "typescript"
    },
    {
      "code": "def get_pp_indices(\n    num_hidden_layers: int, pp_rank: int, pp_size: int\n) -> tuple[int, int]:\n    \"\"\"Try to evenly distribute layers across partitions.\n\n    If the number of layers is not divisible by the number of partitions,\n    the remaining layers are evenly distributed across all but the last\n    partition. The last partition is excluded because it often contains an\n    additional norm layer and we are attempting to balance compute.\n\n    If `pp_size > 2` and the number of remaining layers is\n    `0 < x <= pp_size - 2` then the remaining layers are evenly distributed\n    across the middle partitions. The first and last partitions are excluded\n    because they contain the input and output embeddings respectively and we\n    are attempting to reduce maximum memory consumption across partitions.\n    \"\"\"\n    partition_list_str = envs.VLLM_PP_LAYER_PARTITION\n    if partition_list_str is not None:\n        try:\n            partitions = [int(layer) for layer in partition_list_str.split(\",\")]\n        except ValueError as err:\n            raise ValueError(\n                \"Invalid partition string: {}\".format(partition_list_str)\n            ) from err\n        if len(partitions) != pp_size:\n            raise ValueError(f\"{len(partitions)=} does not match {pp_size=}.\")\n        if sum(partitions) != num_hidden_layers:\n            raise ValueError(f\"{sum(partitions)=} does not match {num_hidden_layers=}.\")\n    else:\n        layers_per_partition = num_hidden_layers // pp_size\n        partitions = [layers_per_partition for _ in range(pp_size)]\n\n        if remaining_layers := num_hidden_layers % pp_size:\n            for i in range(2, remaining_layers + 2):\n                partitions[-i] += 1\n            logger.info(\n                \"Hidden layers were unevenly partitioned: [%s]. \"\n                \"This can be manually overridden using the \"\n                \"VLLM_PP_LAYER_PARTITION environment variable\",\n                \",\".join(str(p) for p in partitions),\n            )\n\n    start_layer = sum(partitions[:pp_rank])\n    end_layer = start_layer + partitions[pp_rank]\n\n    return (start_layer, end_layer)",
      "language": "typescript"
    },
    {
      "code": "get_tcp_uri(ip: str, port: int) -> str",
      "language": "php"
    },
    {
      "code": "get_tcp_uri(ip: str, port: int) -> str",
      "language": "php"
    },
    {
      "code": "134\n135\n136\n137\n138",
      "language": "unknown"
    },
    {
      "code": "def get_tcp_uri(ip: str, port: int) -> str:\n    if is_valid_ipv6_address(ip):\n        return f\"tcp://[{ip}]:{port}\"\n    else:\n        return f\"tcp://{ip}:{port}\"",
      "language": "python"
    },
    {
      "code": "def get_tcp_uri(ip: str, port: int) -> str:\n    if is_valid_ipv6_address(ip):\n        return f\"tcp://[{ip}]:{port}\"\n    else:\n        return f\"tcp://{ip}:{port}\"",
      "language": "python"
    },
    {
      "code": "get_tensor_model_parallel_rank()",
      "language": "unknown"
    },
    {
      "code": "get_tensor_model_parallel_rank()",
      "language": "unknown"
    },
    {
      "code": "1530\n1531\n1532",
      "language": "unknown"
    },
    {
      "code": "def get_tensor_model_parallel_rank():\n    \"\"\"Return my rank for the tensor model parallel group.\"\"\"\n    return get_tp_group().rank_in_group",
      "language": "python"
    },
    {
      "code": "def get_tensor_model_parallel_rank():\n    \"\"\"Return my rank for the tensor model parallel group.\"\"\"\n    return get_tp_group().rank_in_group",
      "language": "python"
    },
    {
      "code": "get_tensor_model_parallel_world_size()",
      "language": "unknown"
    },
    {
      "code": "get_tensor_model_parallel_world_size()",
      "language": "unknown"
    },
    {
      "code": "1525\n1526\n1527",
      "language": "unknown"
    },
    {
      "code": "def get_tensor_model_parallel_world_size():\n    \"\"\"Return world size for the tensor model parallel group.\"\"\"\n    return get_tp_group().world_size",
      "language": "python"
    },
    {
      "code": "def get_tensor_model_parallel_world_size():\n    \"\"\"Return world size for the tensor model parallel group.\"\"\"\n    return get_tp_group().world_size",
      "language": "python"
    },
    {
      "code": "get_tp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "get_tp_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1082\n1083\n1084",
      "language": "unknown"
    },
    {
      "code": "def get_tp_group() -> GroupCoordinator:\n    assert _TP is not None, \"tensor model parallel group is not initialized\"\n    return _TP",
      "language": "python"
    },
    {
      "code": "def get_tp_group() -> GroupCoordinator:\n    assert _TP is not None, \"tensor model parallel group is not initialized\"\n    return _TP",
      "language": "python"
    },
    {
      "code": "get_world_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "get_world_group() -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1039\n1040\n1041",
      "language": "unknown"
    },
    {
      "code": "def get_world_group() -> GroupCoordinator:\n    assert _WORLD is not None, \"world group is not initialized\"\n    return _WORLD",
      "language": "python"
    },
    {
      "code": "def get_world_group() -> GroupCoordinator:\n    assert _WORLD is not None, \"world group is not initialized\"\n    return _WORLD",
      "language": "python"
    },
    {
      "code": "graph_capture(device: device)",
      "language": "unknown"
    },
    {
      "code": "graph_capture(device: device)",
      "language": "unknown"
    },
    {
      "code": "1130\n1131\n1132\n1133\n1134\n1135\n1136\n1137\n1138\n1139\n1140\n1141\n1142\n1143\n1144\n1145\n1146\n1147",
      "language": "unknown"
    },
    {
      "code": "@contextmanager\ndef graph_capture(device: torch.device):\n    \"\"\"\n    `graph_capture` is a context manager which should surround the code that\n    is capturing the CUDA graph. Its main purpose is to ensure that some\n    operations will be run after the graph is captured, before the graph\n    is replayed. It returns a `GraphCaptureContext` object which contains the\n    necessary data for the graph capture. Currently, it only contains the\n    stream that the graph capture is running on. This stream is set to the\n    current CUDA stream when the context manager is entered and reset to the\n    default stream when the context manager is exited. This is to ensure that\n    the graph capture is running on a separate stream from the default stream,\n    in order to explicitly distinguish the kernels to capture\n    from other kernels possibly launched on background in the default stream.\n    \"\"\"\n    context = GraphCaptureContext(torch.cuda.Stream(device=device))\n    with get_tp_group().graph_capture(context), get_pp_group().graph_capture(context):\n        yield context",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef graph_capture(device: torch.device):\n    \"\"\"\n    `graph_capture` is a context manager which should surround the code that\n    is capturing the CUDA graph. Its main purpose is to ensure that some\n    operations will be run after the graph is captured, before the graph\n    is replayed. It returns a `GraphCaptureContext` object which contains the\n    necessary data for the graph capture. Currently, it only contains the\n    stream that the graph capture is running on. This stream is set to the\n    current CUDA stream when the context manager is entered and reset to the\n    default stream when the context manager is exited. This is to ensure that\n    the graph capture is running on a separate stream from the default stream,\n    in order to explicitly distinguish the kernels to capture\n    from other kernels possibly launched on background in the default stream.\n    \"\"\"\n    context = GraphCaptureContext(torch.cuda.Stream(device=device))\n    with get_tp_group().graph_capture(context), get_pp_group().graph_capture(context):\n        yield context",
      "language": "python"
    },
    {
      "code": "in_the_same_node_as(\n    pg: ProcessGroup | StatelessProcessGroup,\n    source_rank: int = 0,\n) -> list[bool]",
      "language": "typescript"
    },
    {
      "code": "in_the_same_node_as(\n    pg: ProcessGroup | StatelessProcessGroup,\n    source_rank: int = 0,\n) -> list[bool]",
      "language": "typescript"
    },
    {
      "code": "1620\n1621\n1622\n1623\n1624\n1625\n1626\n1627\n1628\n1629\n1630\n1631\n1632\n1633\n1634\n1635\n1636\n1637\n1638\n1639\n1640\n1641\n1642\n1643\n1644\n1645\n1646\n1647\n1648\n1649\n1650\n1651\n1652\n1653\n1654\n1655\n1656\n1657\n1658\n1659\n1660\n1661\n1662\n1663\n1664\n1665\n1666\n1667\n1668\n1669\n1670\n1671\n1672\n1673\n1674\n1675\n1676\n1677\n1678\n1679\n1680\n1681\n1682\n1683\n1684\n1685\n1686\n1687\n1688\n1689\n1690\n1691\n1692\n1693\n1694\n1695\n1696\n1697\n1698\n1699\n1700\n1701\n1702\n1703\n1704\n1705\n1706\n1707\n1708\n1709",
      "language": "unknown"
    },
    {
      "code": "def in_the_same_node_as(\n    pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0\n) -> list[bool]:\n    \"\"\"\n    This is a collective operation that returns if each rank is in the same node\n    as the source rank. It tests if processes are attached to the same\n    memory system (shared access to shared memory).\n    \"\"\"\n    if isinstance(pg, ProcessGroup):\n        assert torch.distributed.get_backend(pg) != torch.distributed.Backend.NCCL, (\n            \"in_the_same_node_as should be tested with a non-NCCL group.\"\n        )\n        # local rank inside the group\n        rank = torch.distributed.get_rank(group=pg)\n        world_size = torch.distributed.get_world_size(group=pg)\n\n        # global ranks of the processes in the group\n        ranks = torch.distributed.get_process_group_ranks(pg)\n    else:\n        rank = pg.rank\n        world_size = pg.world_size\n        ranks = list(range(world_size))\n\n    # local tensor in each process to store the result\n    is_in_the_same_node = torch.tensor(\n        [0] * world_size, dtype=torch.int32, device=\"cpu\"\n    )\n\n    magic_message = b\"magic_message\"\n    shm = None\n\n    try:\n        with contextlib.suppress(OSError):\n            if rank == source_rank:\n                # create a shared memory segment\n                shm = shared_memory.SharedMemory(create=True, size=128)\n                shm.buf[: len(magic_message)] = magic_message\n                if isinstance(pg, ProcessGroup):\n                    torch.distributed.broadcast_object_list(\n                        [shm.name], src=ranks[source_rank], group=pg\n                    )\n                else:\n                    pg.broadcast_obj(shm.name, src=source_rank)\n                is_in_the_same_node[rank] = 1\n            else:\n                # try to open the shared memory segment\n                if isinstance(pg, ProcessGroup):\n                    recv = [None]\n                    torch.distributed.broadcast_object_list(\n                        recv, src=ranks[source_rank], group=pg\n                    )\n                    name = recv[0]\n                else:\n                    name = pg.broadcast_obj(None, src=source_rank)\n                # fix to https://stackoverflow.com/q/62748654/9191338\n                # Python incorrectly tracks shared memory even if it is not\n                # created by the process. The following patch is a workaround.\n                with patch(\n                    \"multiprocessing.resource_tracker.register\",\n                    lambda *args, **kwargs: None,\n                ):\n                    shm = shared_memory.SharedMemory(name=name)\n                if shm.buf[: len(magic_message)] == magic_message:\n                    is_in_the_same_node[rank] = 1\n    except Exception as e:\n        logger.error(\"Error ignored in is_in_the_same_node: %s\", e)\n    finally:\n        if shm:\n            shm.close()\n\n    if isinstance(pg, ProcessGroup):\n        torch.distributed.barrier(group=pg)\n    else:\n        pg.barrier()\n\n    # clean up the shared memory segment\n    with contextlib.suppress(OSError):\n        if rank == source_rank and shm:\n            shm.unlink()\n\n    if isinstance(pg, ProcessGroup):\n        torch.distributed.all_reduce(is_in_the_same_node, group=pg)\n        aggregated_data = is_in_the_same_node\n    else:\n        aggregated_data = torch.zeros_like(is_in_the_same_node)\n        for i in range(world_size):\n            rank_data = pg.broadcast_obj(is_in_the_same_node, src=i)\n            aggregated_data += rank_data\n\n    return [x == 1 for x in aggregated_data.tolist()]",
      "language": "typescript"
    },
    {
      "code": "def in_the_same_node_as(\n    pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0\n) -> list[bool]:\n    \"\"\"\n    This is a collective operation that returns if each rank is in the same node\n    as the source rank. It tests if processes are attached to the same\n    memory system (shared access to shared memory).\n    \"\"\"\n    if isinstance(pg, ProcessGroup):\n        assert torch.distributed.get_backend(pg) != torch.distributed.Backend.NCCL, (\n            \"in_the_same_node_as should be tested with a non-NCCL group.\"\n        )\n        # local rank inside the group\n        rank = torch.distributed.get_rank(group=pg)\n        world_size = torch.distributed.get_world_size(group=pg)\n\n        # global ranks of the processes in the group\n        ranks = torch.distributed.get_process_group_ranks(pg)\n    else:\n        rank = pg.rank\n        world_size = pg.world_size\n        ranks = list(range(world_size))\n\n    # local tensor in each process to store the result\n    is_in_the_same_node = torch.tensor(\n        [0] * world_size, dtype=torch.int32, device=\"cpu\"\n    )\n\n    magic_message = b\"magic_message\"\n    shm = None\n\n    try:\n        with contextlib.suppress(OSError):\n            if rank == source_rank:\n                # create a shared memory segment\n                shm = shared_memory.SharedMemory(create=True, size=128)\n                shm.buf[: len(magic_message)] = magic_message\n                if isinstance(pg, ProcessGroup):\n                    torch.distributed.broadcast_object_list(\n                        [shm.name], src=ranks[source_rank], group=pg\n                    )\n                else:\n                    pg.broadcast_obj(shm.name, src=source_rank)\n                is_in_the_same_node[rank] = 1\n            else:\n                # try to open the shared memory segment\n                if isinstance(pg, ProcessGroup):\n                    recv = [None]\n                    torch.distributed.broadcast_object_list(\n                        recv, src=ranks[source_rank], group=pg\n                    )\n                    name = recv[0]\n                else:\n                    name = pg.broadcast_obj(None, src=source_rank)\n                # fix to https://stackoverflow.com/q/62748654/9191338\n                # Python incorrectly tracks shared memory even if it is not\n                # created by the process. The following patch is a workaround.\n                with patch(\n                    \"multiprocessing.resource_tracker.register\",\n                    lambda *args, **kwargs: None,\n                ):\n                    shm = shared_memory.SharedMemory(name=name)\n                if shm.buf[: len(magic_message)] == magic_message:\n                    is_in_the_same_node[rank] = 1\n    except Exception as e:\n        logger.error(\"Error ignored in is_in_the_same_node: %s\", e)\n    finally:\n        if shm:\n            shm.close()\n\n    if isinstance(pg, ProcessGroup):\n        torch.distributed.barrier(group=pg)\n    else:\n        pg.barrier()\n\n    # clean up the shared memory segment\n    with contextlib.suppress(OSError):\n        if rank == source_rank and shm:\n            shm.unlink()\n\n    if isinstance(pg, ProcessGroup):\n        torch.distributed.all_reduce(is_in_the_same_node, group=pg)\n        aggregated_data = is_in_the_same_node\n    else:\n        aggregated_data = torch.zeros_like(is_in_the_same_node)\n        for i in range(world_size):\n            rank_data = pg.broadcast_obj(is_in_the_same_node, src=i)\n            aggregated_data += rank_data\n\n    return [x == 1 for x in aggregated_data.tolist()]",
      "language": "typescript"
    },
    {
      "code": "init_distributed_environment(\n    world_size: int = -1,\n    rank: int = -1,\n    distributed_init_method: str = \"env://\",\n    local_rank: int = -1,\n    backend: str = \"nccl\",\n    timeout: timedelta | None = None,\n)",
      "language": "typescript"
    },
    {
      "code": "init_distributed_environment(\n    world_size: int = -1,\n    rank: int = -1,\n    distributed_init_method: str = \"env://\",\n    local_rank: int = -1,\n    backend: str = \"nccl\",\n    timeout: timedelta | None = None,\n)",
      "language": "typescript"
    },
    {
      "code": "1160\n1161\n1162\n1163\n1164\n1165\n1166\n1167\n1168\n1169\n1170\n1171\n1172\n1173\n1174\n1175\n1176\n1177\n1178\n1179\n1180\n1181\n1182\n1183\n1184\n1185\n1186\n1187\n1188\n1189\n1190\n1191\n1192\n1193\n1194\n1195\n1196\n1197\n1198\n1199\n1200\n1201\n1202\n1203\n1204\n1205\n1206\n1207\n1208\n1209\n1210\n1211\n1212\n1213\n1214\n1215\n1216\n1217\n1218\n1219\n1220\n1221\n1222\n1223\n1224\n1225\n1226\n1227\n1228\n1229\n1230\n1231\n1232\n1233\n1234\n1235\n1236\n1237\n1238\n1239\n1240\n1241\n1242\n1243\n1244\n1245\n1246\n1247\n1248\n1249\n1250\n1251\n1252\n1253\n1254\n1255\n1256\n1257\n1258\n1259\n1260\n1261\n1262\n1263\n1264\n1265\n1266\n1267\n1268\n1269\n1270\n1271\n1272\n1273\n1274\n1275",
      "language": "unknown"
    },
    {
      "code": "def init_distributed_environment(\n    world_size: int = -1,\n    rank: int = -1,\n    distributed_init_method: str = \"env://\",\n    local_rank: int = -1,\n    backend: str = \"nccl\",\n    timeout: timedelta | None = None,\n):\n    logger.debug(\n        \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\",\n        world_size,\n        rank,\n        local_rank,\n        distributed_init_method,\n        backend,\n    )\n    from vllm.config import get_current_vllm_config\n\n    config = get_current_vllm_config()\n    if (\n        config is not None\n        and config.parallel_config.distributed_executor_backend != \"external_launcher\"\n        and (\n            config.parallel_config.nnodes > 1\n            or config.parallel_config.data_parallel_size > 1\n        )\n    ):\n        parallel_config = config.parallel_config\n        # adjust to take into account data parallelism\n        # offset the rank by the data parallel rank\n        rank = parallel_config.data_parallel_rank * world_size + rank\n        # adjust the world size to take into account data parallelism\n        world_size = parallel_config.world_size_across_dp\n\n        # Use appropriate IP and port based on configuration\n        if parallel_config.nnodes > 1:\n            ip = parallel_config.master_addr\n            port = parallel_config.master_port\n            distributed_init_method = get_distributed_init_method(ip, port)\n        else:\n            ip = parallel_config.data_parallel_master_ip\n            port = parallel_config.get_next_dp_init_port()\n            distributed_init_method = get_distributed_init_method(ip, port)\n            logger.debug(\n                \"Adjusting world_size=%d rank=%d distributed_init_method=%s for DP\",\n                world_size,\n                rank,\n                distributed_init_method,\n            )\n    if not torch.distributed.is_initialized():\n        logger.info(\n            \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\",\n            world_size,\n            rank,\n            local_rank,\n            distributed_init_method,\n            backend,\n        )\n        assert distributed_init_method is not None, (\n            \"distributed_init_method must be provided when initializing \"\n            \"distributed environment\"\n        )\n        if not torch.distributed.is_backend_available(backend):\n            logger.warning(\n                \"Distributed backend %s is not available; falling back to gloo.\",\n                backend,\n            )\n            assert torch.distributed.is_gloo_available(), (\n                \"Fallback Gloo backend is not available.\"\n            )\n            backend = \"gloo\"\n        # this backend is used for WORLD\n        torch.distributed.init_process_group(\n            backend=backend,\n            init_method=distributed_init_method,\n            world_size=world_size,\n            rank=rank,\n            timeout=timeout,\n        )\n    # set the local rank\n    # local_rank is not available in torch ProcessGroup,\n    # see https://github.com/pytorch/pytorch/issues/122816\n    if local_rank == -1:\n        # local rank not set, this usually happens in single-node\n        # setting, where we can use rank as local rank\n        local_rank = envs.LOCAL_RANK if distributed_init_method == \"env://\" else rank\n    global _WORLD, _NODE_COUNT, _INNER_DP_WORLD\n    if _WORLD is None:\n        ranks = list(range(torch.distributed.get_world_size()))\n        _WORLD = init_world_group(ranks, local_rank, backend)\n        if config.parallel_config.nnodes > 1:\n            _NODE_COUNT = config.parallel_config.nnodes\n        else:\n            _NODE_COUNT = _node_count(_WORLD.cpu_group)\n        logger.debug(\"Detected %d nodes in the distributed environment\", _NODE_COUNT)\n    else:\n        assert _WORLD.world_size == torch.distributed.get_world_size(), (\n            \"world group already initialized with a different world size\"\n        )\n    if config.parallel_config.nnodes_within_dp > 1:\n        if parallel_config.data_parallel_size > 1:\n            world_size_inner_dp = parallel_config.world_size\n            group_ranks = [\n                [dp_rank * world_size_inner_dp + i for i in range(world_size_inner_dp)]\n                for dp_rank in range(parallel_config.data_parallel_size)\n            ]\n            _INNER_DP_WORLD = init_model_parallel_group(\n                group_ranks,\n                get_world_group().local_rank,\n                backend,\n                use_message_queue_broadcaster=True,\n                group_name=\"inner_dp_world\",\n                use_device_communicator=False,\n            )\n        else:\n            _INNER_DP_WORLD = _WORLD",
      "language": "python"
    },
    {
      "code": "def init_distributed_environment(\n    world_size: int = -1,\n    rank: int = -1,\n    distributed_init_method: str = \"env://\",\n    local_rank: int = -1,\n    backend: str = \"nccl\",\n    timeout: timedelta | None = None,\n):\n    logger.debug(\n        \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\",\n        world_size,\n        rank,\n        local_rank,\n        distributed_init_method,\n        backend,\n    )\n    from vllm.config import get_current_vllm_config\n\n    config = get_current_vllm_config()\n    if (\n        config is not None\n        and config.parallel_config.distributed_executor_backend != \"external_launcher\"\n        and (\n            config.parallel_config.nnodes > 1\n            or config.parallel_config.data_parallel_size > 1\n        )\n    ):\n        parallel_config = config.parallel_config\n        # adjust to take into account data parallelism\n        # offset the rank by the data parallel rank\n        rank = parallel_config.data_parallel_rank * world_size + rank\n        # adjust the world size to take into account data parallelism\n        world_size = parallel_config.world_size_across_dp\n\n        # Use appropriate IP and port based on configuration\n        if parallel_config.nnodes > 1:\n            ip = parallel_config.master_addr\n            port = parallel_config.master_port\n            distributed_init_method = get_distributed_init_method(ip, port)\n        else:\n            ip = parallel_config.data_parallel_master_ip\n            port = parallel_config.get_next_dp_init_port()\n            distributed_init_method = get_distributed_init_method(ip, port)\n            logger.debug(\n                \"Adjusting world_size=%d rank=%d distributed_init_method=%s for DP\",\n                world_size,\n                rank,\n                distributed_init_method,\n            )\n    if not torch.distributed.is_initialized():\n        logger.info(\n            \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\",\n            world_size,\n            rank,\n            local_rank,\n            distributed_init_method,\n            backend,\n        )\n        assert distributed_init_method is not None, (\n            \"distributed_init_method must be provided when initializing \"\n            \"distributed environment\"\n        )\n        if not torch.distributed.is_backend_available(backend):\n            logger.warning(\n                \"Distributed backend %s is not available; falling back to gloo.\",\n                backend,\n            )\n            assert torch.distributed.is_gloo_available(), (\n                \"Fallback Gloo backend is not available.\"\n            )\n            backend = \"gloo\"\n        # this backend is used for WORLD\n        torch.distributed.init_process_group(\n            backend=backend,\n            init_method=distributed_init_method,\n            world_size=world_size,\n            rank=rank,\n            timeout=timeout,\n        )\n    # set the local rank\n    # local_rank is not available in torch ProcessGroup,\n    # see https://github.com/pytorch/pytorch/issues/122816\n    if local_rank == -1:\n        # local rank not set, this usually happens in single-node\n        # setting, where we can use rank as local rank\n        local_rank = envs.LOCAL_RANK if distributed_init_method == \"env://\" else rank\n    global _WORLD, _NODE_COUNT, _INNER_DP_WORLD\n    if _WORLD is None:\n        ranks = list(range(torch.distributed.get_world_size()))\n        _WORLD = init_world_group(ranks, local_rank, backend)\n        if config.parallel_config.nnodes > 1:\n            _NODE_COUNT = config.parallel_config.nnodes\n        else:\n            _NODE_COUNT = _node_count(_WORLD.cpu_group)\n        logger.debug(\"Detected %d nodes in the distributed environment\", _NODE_COUNT)\n    else:\n        assert _WORLD.world_size == torch.distributed.get_world_size(), (\n            \"world group already initialized with a different world size\"\n        )\n    if config.parallel_config.nnodes_within_dp > 1:\n        if parallel_config.data_parallel_size > 1:\n            world_size_inner_dp = parallel_config.world_size\n            group_ranks = [\n                [dp_rank * world_size_inner_dp + i for i in range(world_size_inner_dp)]\n                for dp_rank in range(parallel_config.data_parallel_size)\n            ]\n            _INNER_DP_WORLD = init_model_parallel_group(\n                group_ranks,\n                get_world_group().local_rank,\n                backend,\n                use_message_queue_broadcaster=True,\n                group_name=\"inner_dp_world\",\n                use_device_communicator=False,\n            )\n        else:\n            _INNER_DP_WORLD = _WORLD",
      "language": "python"
    },
    {
      "code": "init_gloo_process_group(\n    prefix_store: PrefixStore,\n    group_rank: int,\n    group_size: int,\n    timeout: timedelta,\n) -> ProcessGroup",
      "language": "php"
    },
    {
      "code": "init_gloo_process_group(\n    prefix_store: PrefixStore,\n    group_rank: int,\n    group_size: int,\n    timeout: timedelta,\n) -> ProcessGroup",
      "language": "php"
    },
    {
      "code": "421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459",
      "language": "unknown"
    },
    {
      "code": "def init_gloo_process_group(\n    prefix_store: PrefixStore,\n    group_rank: int,\n    group_size: int,\n    timeout: timedelta,\n) -> ProcessGroup:\n    \"\"\"\n    Stateless init ProcessGroup with gloo backend compatible with\n    different torch versions.\n    \"\"\"\n    with suppress_stdout():\n        if is_torch_equal_or_newer(\"2.6\"):\n            pg = ProcessGroup(\n                prefix_store,\n                group_rank,\n                group_size,\n            )\n        else:\n            options = ProcessGroup.Options(backend=\"gloo\")\n            pg = ProcessGroup(\n                prefix_store,\n                group_rank,\n                group_size,\n                options,\n            )\n        from torch.distributed.distributed_c10d import ProcessGroupGloo\n\n        backend_class = ProcessGroupGloo(\n            prefix_store, group_rank, group_size, timeout=timeout\n        )\n        backend_type = ProcessGroup.BackendType.GLOO\n        device = torch.device(\"cpu\")\n        if is_torch_equal_or_newer(\"2.6\"):\n            # _set_default_backend is supported in torch >= 2.6\n            pg._set_default_backend(backend_type)\n        backend_class._set_sequence_number_for_group()\n\n        pg._register_backend(device, backend_type, backend_class)\n    return pg",
      "language": "python"
    },
    {
      "code": "def init_gloo_process_group(\n    prefix_store: PrefixStore,\n    group_rank: int,\n    group_size: int,\n    timeout: timedelta,\n) -> ProcessGroup:\n    \"\"\"\n    Stateless init ProcessGroup with gloo backend compatible with\n    different torch versions.\n    \"\"\"\n    with suppress_stdout():\n        if is_torch_equal_or_newer(\"2.6\"):\n            pg = ProcessGroup(\n                prefix_store,\n                group_rank,\n                group_size,\n            )\n        else:\n            options = ProcessGroup.Options(backend=\"gloo\")\n            pg = ProcessGroup(\n                prefix_store,\n                group_rank,\n                group_size,\n                options,\n            )\n        from torch.distributed.distributed_c10d import ProcessGroupGloo\n\n        backend_class = ProcessGroupGloo(\n            prefix_store, group_rank, group_size, timeout=timeout\n        )\n        backend_type = ProcessGroup.BackendType.GLOO\n        device = torch.device(\"cpu\")\n        if is_torch_equal_or_newer(\"2.6\"):\n            # _set_default_backend is supported in torch >= 2.6\n            pg._set_default_backend(backend_type)\n        backend_class._set_sequence_number_for_group()\n\n        pg._register_backend(device, backend_type, backend_class)\n    return pg",
      "language": "python"
    },
    {
      "code": "init_logger(name: str) -> _VllmLogger",
      "language": "php"
    },
    {
      "code": "init_logger(name: str) -> _VllmLogger",
      "language": "php"
    },
    {
      "code": "206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216",
      "language": "unknown"
    },
    {
      "code": "def init_logger(name: str) -> _VllmLogger:\n    \"\"\"The main purpose of this function is to ensure that loggers are\n    retrieved in such a way that we can be sure the root vllm logger has\n    already been configured.\"\"\"\n\n    logger = logging.getLogger(name)\n\n    for method_name, method in _METHODS_TO_PATCH.items():\n        setattr(logger, method_name, MethodType(method, logger))\n\n    return cast(_VllmLogger, logger)",
      "language": "python"
    },
    {
      "code": "def init_logger(name: str) -> _VllmLogger:\n    \"\"\"The main purpose of this function is to ensure that loggers are\n    retrieved in such a way that we can be sure the root vllm logger has\n    already been configured.\"\"\"\n\n    logger = logging.getLogger(name)\n\n    for method_name, method in _METHODS_TO_PATCH.items():\n        setattr(logger, method_name, MethodType(method, logger))\n\n    return cast(_VllmLogger, logger)",
      "language": "python"
    },
    {
      "code": "init_model_parallel_group(\n    group_ranks: list[list[int]],\n    local_rank: int,\n    backend: str,\n    use_message_queue_broadcaster: bool = False,\n    group_name: str | None = None,\n    use_device_communicator: bool = True,\n) -> GroupCoordinator",
      "language": "typescript"
    },
    {
      "code": "init_model_parallel_group(\n    group_ranks: list[list[int]],\n    local_rank: int,\n    backend: str,\n    use_message_queue_broadcaster: bool = False,\n    group_name: str | None = None,\n    use_device_communicator: bool = True,\n) -> GroupCoordinator",
      "language": "typescript"
    },
    {
      "code": "1061\n1062\n1063\n1064\n1065\n1066\n1067\n1068\n1069\n1070\n1071\n1072\n1073\n1074\n1075\n1076",
      "language": "unknown"
    },
    {
      "code": "def init_model_parallel_group(\n    group_ranks: list[list[int]],\n    local_rank: int,\n    backend: str,\n    use_message_queue_broadcaster: bool = False,\n    group_name: str | None = None,\n    use_device_communicator: bool = True,\n) -> GroupCoordinator:\n    return GroupCoordinator(\n        group_ranks=group_ranks,\n        local_rank=local_rank,\n        torch_distributed_backend=backend,\n        use_device_communicator=use_device_communicator,\n        use_message_queue_broadcaster=use_message_queue_broadcaster,\n        group_name=group_name,\n    )",
      "language": "python"
    },
    {
      "code": "def init_model_parallel_group(\n    group_ranks: list[list[int]],\n    local_rank: int,\n    backend: str,\n    use_message_queue_broadcaster: bool = False,\n    group_name: str | None = None,\n    use_device_communicator: bool = True,\n) -> GroupCoordinator:\n    return GroupCoordinator(\n        group_ranks=group_ranks,\n        local_rank=local_rank,\n        torch_distributed_backend=backend,\n        use_device_communicator=use_device_communicator,\n        use_message_queue_broadcaster=use_message_queue_broadcaster,\n        group_name=group_name,\n    )",
      "language": "python"
    },
    {
      "code": "init_world_group(\n    ranks: list[int], local_rank: int, backend: str\n) -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "init_world_group(\n    ranks: list[int], local_rank: int, backend: str\n) -> GroupCoordinator",
      "language": "php"
    },
    {
      "code": "1049\n1050\n1051\n1052\n1053\n1054\n1055\n1056\n1057\n1058",
      "language": "unknown"
    },
    {
      "code": "def init_world_group(\n    ranks: list[int], local_rank: int, backend: str\n) -> GroupCoordinator:\n    return GroupCoordinator(\n        group_ranks=[ranks],\n        local_rank=local_rank,\n        torch_distributed_backend=backend,\n        use_device_communicator=False,\n        group_name=\"world\",\n    )",
      "language": "python"
    },
    {
      "code": "def init_world_group(\n    ranks: list[int], local_rank: int, backend: str\n) -> GroupCoordinator:\n    return GroupCoordinator(\n        group_ranks=[ranks],\n        local_rank=local_rank,\n        torch_distributed_backend=backend,\n        use_device_communicator=False,\n        group_name=\"world\",\n    )",
      "language": "python"
    },
    {
      "code": "initialize_model_parallel(\n    tensor_model_parallel_size: int = 1,\n    pipeline_model_parallel_size: int = 1,\n    prefill_context_model_parallel_size: int = 1,\n    decode_context_model_parallel_size: int | None = 1,\n    backend: str | None = None,\n) -> None",
      "language": "typescript"
    },
    {
      "code": "initialize_model_parallel(\n    tensor_model_parallel_size: int = 1,\n    pipeline_model_parallel_size: int = 1,\n    prefill_context_model_parallel_size: int = 1,\n    decode_context_model_parallel_size: int | None = 1,\n    backend: str | None = None,\n) -> None",
      "language": "typescript"
    },
    {
      "code": "1278\n1279\n1280\n1281\n1282\n1283\n1284\n1285\n1286\n1287\n1288\n1289\n1290\n1291\n1292\n1293\n1294\n1295\n1296\n1297\n1298\n1299\n1300\n1301\n1302\n1303\n1304\n1305\n1306\n1307\n1308\n1309\n1310\n1311\n1312\n1313\n1314\n1315\n1316\n1317\n1318\n1319\n1320\n1321\n1322\n1323\n1324\n1325\n1326\n1327\n1328\n1329\n1330\n1331\n1332\n1333\n1334\n1335\n1336\n1337\n1338\n1339\n1340\n1341\n1342\n1343\n1344\n1345\n1346\n1347\n1348\n1349\n1350\n1351\n1352\n1353\n1354\n1355\n1356\n1357\n1358\n1359\n1360\n1361\n1362\n1363\n1364\n1365\n1366\n1367\n1368\n1369\n1370\n1371\n1372\n1373\n1374\n1375\n1376\n1377\n1378\n1379\n1380\n1381\n1382\n1383\n1384\n1385\n1386\n1387\n1388\n1389\n1390\n1391\n1392\n1393\n1394\n1395\n1396\n1397\n1398\n1399\n1400\n1401\n1402\n1403\n1404\n1405\n1406\n1407\n1408\n1409\n1410\n1411\n1412\n1413\n1414\n1415\n1416\n1417\n1418\n1419\n1420\n1421\n1422\n1423\n1424\n1425\n1426\n1427\n1428\n1429",
      "language": "unknown"
    },
    {
      "code": "def initialize_model_parallel(\n    tensor_model_parallel_size: int = 1,\n    pipeline_model_parallel_size: int = 1,\n    prefill_context_model_parallel_size: int = 1,\n    decode_context_model_parallel_size: int | None = 1,\n    backend: str | None = None,\n) -> None:\n    \"\"\"\n    Initialize model parallel groups.\n\n    Arguments:\n        tensor_model_parallel_size: number of GPUs used for tensor model\n            parallelism.\n        pipeline_model_parallel_size: number of GPUs used for pipeline model\n            parallelism.\n        backend: name of torch distributed communication backend.\n\n    Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we\n    use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize\n    the model pipeline. The present function will\n    create 4 tensor model-parallel groups and 2 pipeline model-parallel groups:\n        4 tensor model-parallel groups:\n            [g0, g1], [g2, g3], [g4, g5], [g6, g7]\n        2 pipeline model-parallel groups:\n            [g0, g2, g4, g6], [g1, g3, g5, g7]\n    Note that for efficiency, the caller should make sure adjacent ranks\n    are on the same DGX box. For example if we are using 2 DGX-1 boxes\n    with a total of 16 GPUs, rank 0 to 7 belong to the first box and\n    ranks 8 to 15 belong to the second box.\n    \"\"\"\n    # Get world size and rank. Ensure some consistencies.\n    assert torch.distributed.is_initialized()\n    world_size: int = torch.distributed.get_world_size()\n    rank = torch.distributed.get_rank()\n    backend = backend or torch.distributed.get_backend(get_world_group().device_group)\n\n    data_parallel_size = 1\n    from vllm.config import get_current_vllm_config\n\n    config = get_current_vllm_config()\n    if config is not None:\n        data_parallel_size = config.parallel_config.data_parallel_size\n\n    # the layout order is: ExternalDP x DP x PP x TP\n    # ExternalDP is the data parallel group that is not part of the model,\n    # every dp rank can generate independently (in verl integration).\n    # DP is the data parallel group that is part of the model,\n    # all the ranks in the same DP group should generate simultaneously,\n    # i.e. the `generate` call in the same DP group should be called together,\n    # otherwise it will cause deadlock.\n    # to get group_ranks for each dimension, transpose that dimension to the\n    # last dimension, then reshape to 2D, then unbind the last dimension\n    all_ranks = torch.arange(world_size).reshape(\n        -1,\n        data_parallel_size,\n        pipeline_model_parallel_size,\n        prefill_context_model_parallel_size,\n        tensor_model_parallel_size,\n    )  # noqa\n\n    # Build the tensor model-parallel groups.\n    global _TP\n    assert _TP is None, \"tensor model parallel group is already initialized\"\n    group_ranks = all_ranks.view(-1, tensor_model_parallel_size).unbind(0)\n    group_ranks = [x.tolist() for x in group_ranks]\n\n    # message queue broadcaster is only used in tensor model parallel group\n    _TP = init_model_parallel_group(\n        group_ranks,\n        get_world_group().local_rank,\n        backend,\n        use_message_queue_broadcaster=True,\n        group_name=\"tp\",\n    )\n\n    # Build the DCP model-parallel groups.\n    global _DCP\n    assert _DCP is None, \"decode context model parallel group is already initialized\"\n    # Note(hc): In the current implementation of decode context parallel,\n    # dcp_size must not exceed tp_size, because the world size does not\n    # change by DCP, it simply reuses the GPUs of TP group, and split one\n    # TP group into tp_size//dcp_size DCP groups.\n    group_ranks = all_ranks.reshape(-1, decode_context_model_parallel_size).unbind(0)\n    group_ranks = [x.tolist() for x in group_ranks]\n    _DCP = init_model_parallel_group(\n        group_ranks,\n        get_world_group().local_rank,\n        backend,\n        use_message_queue_broadcaster=True,\n        group_name=\"dcp\",\n    )\n\n    global _PCP\n    assert _PCP is None, \"prefill context parallel group is already initialized\"\n    group_ranks = (\n        all_ranks.transpose(3, 4)\n        .reshape(-1, prefill_context_model_parallel_size)\n        .unbind(0)\n    )\n    group_ranks = [x.tolist() for x in group_ranks]\n    _PCP = init_model_parallel_group(\n        group_ranks, get_world_group().local_rank, backend, group_name=\"pcp\"\n    )\n\n    # Build the pipeline model-parallel groups.\n    global _PP\n    assert _PP is None, \"pipeline model parallel group is already initialized\"\n    group_ranks = (\n        all_ranks.transpose(2, 4).reshape(-1, pipeline_model_parallel_size).unbind(0)\n    )\n    group_ranks = [x.tolist() for x in group_ranks]\n    _PP = init_model_parallel_group(\n        group_ranks, get_world_group().local_rank, backend, group_name=\"pp\"\n    )\n\n    global _DP\n    assert _DP is None, \"data parallel group is already initialized\"\n    group_ranks = all_ranks.transpose(1, 4).reshape(-1, data_parallel_size).unbind(0)\n    group_ranks = [x.tolist() for x in group_ranks]\n    _DP = init_model_parallel_group(\n        group_ranks, get_world_group().local_rank, backend, group_name=\"dp\"\n    )\n\n    global _EP\n    assert _EP is None, \"expert parallel group is already initialized\"\n    group_ranks = (\n        all_ranks.transpose(1, 2)\n        .reshape(\n            -1,\n            data_parallel_size\n            * prefill_context_model_parallel_size\n            * tensor_model_parallel_size,\n        )\n        .unbind(0)\n    )\n    group_ranks = [x.tolist() for x in group_ranks]\n    _EP = init_model_parallel_group(\n        group_ranks, get_world_group().local_rank, backend, group_name=\"ep\"\n    )\n\n    logger.info_once(\n        \"rank %s in world size %s is assigned as \"\n        \"DP rank %s, PP rank %s, PCP rank %s, \"\n        \"TP rank %s, EP rank %s\",\n        rank,\n        world_size,\n        _DP.rank_in_group,\n        _PP.rank_in_group,\n        _PCP.rank_in_group,\n        _TP.rank_in_group,\n        _EP.rank_in_group,\n    )",
      "language": "python"
    },
    {
      "code": "def initialize_model_parallel(\n    tensor_model_parallel_size: int = 1,\n    pipeline_model_parallel_size: int = 1,\n    prefill_context_model_parallel_size: int = 1,\n    decode_context_model_parallel_size: int | None = 1,\n    backend: str | None = None,\n) -> None:\n    \"\"\"\n    Initialize model parallel groups.\n\n    Arguments:\n        tensor_model_parallel_size: number of GPUs used for tensor model\n            parallelism.\n        pipeline_model_parallel_size: number of GPUs used for pipeline model\n            parallelism.\n        backend: name of torch distributed communication backend.\n\n    Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we\n    use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize\n    the model pipeline. The present function will\n    create 4 tensor model-parallel groups and 2 pipeline model-parallel groups:\n        4 tensor model-parallel groups:\n            [g0, g1], [g2, g3], [g4, g5], [g6, g7]\n        2 pipeline model-parallel groups:\n            [g0, g2, g4, g6], [g1, g3, g5, g7]\n    Note that for efficiency, the caller should make sure adjacent ranks\n    are on the same DGX box. For example if we are using 2 DGX-1 boxes\n    with a total of 16 GPUs, rank 0 to 7 belong to the first box and\n    ranks 8 to 15 belong to the second box.\n    \"\"\"\n    # Get world size and rank. Ensure some consistencies.\n    assert torch.distributed.is_initialized()\n    world_size: int = torch.distributed.get_world_size()\n    rank = torch.distributed.get_rank()\n    backend = backend or torch.distributed.get_backend(get_world_group().device_group)\n\n    data_parallel_size = 1\n    from vllm.config import get_current_vllm_config\n\n    config = get_current_vllm_config()\n    if config is not None:\n        data_parallel_size = config.parallel_config.data_parallel_size\n\n    # the layout order is: ExternalDP x DP x PP x TP\n    # ExternalDP is the data parallel group that is not part of the model,\n    # every dp rank can generate independently (in verl integration).\n    # DP is the data parallel group that is part of the model,\n    # all the ranks in the same DP group should generate simultaneously,\n    # i.e. the `generate` call in the same DP group should be called together,\n    # otherwise it will cause deadlock.\n    # to get group_ranks for each dimension, transpose that dimension to the\n    # last dimension, then reshape to 2D, then unbind the last dimension\n    all_ranks = torch.arange(world_size).reshape(\n        -1,\n        data_parallel_size,\n        pipeline_model_parallel_size,\n        prefill_context_model_parallel_size,\n        tensor_model_parallel_size,\n    )  # noqa\n\n    # Build the tensor model-parallel groups.\n    global _TP\n    assert _TP is None, \"tensor model parallel group is already initialized\"\n    group_ranks = all_ranks.view(-1, tensor_model_parallel_size).unbind(0)\n    group_ranks = [x.tolist() for x in group_ranks]\n\n    # message queue broadcaster is only used in tensor model parallel group\n    _TP = init_model_parallel_group(\n        group_ranks,\n        get_world_group().local_rank,\n        backend,\n        use_message_queue_broadcaster=True,\n        group_name=\"tp\",\n    )\n\n    # Build the DCP model-parallel groups.\n    global _DCP\n    assert _DCP is None, \"decode context model parallel group is already initialized\"\n    # Note(hc): In the current implementation of decode context parallel,\n    # dcp_size must not exceed tp_size, because the world size does not\n    # change by DCP, it simply reuses the GPUs of TP group, and split one\n    # TP group into tp_size//dcp_size DCP groups.\n    group_ranks = all_ranks.reshape(-1, decode_context_model_parallel_size).unbind(0)\n    group_ranks = [x.tolist() for x in group_ranks]\n    _DCP = init_model_parallel_group(\n        group_ranks,\n        get_world_group().local_rank,\n        backend,\n        use_message_queue_broadcaster=True,\n        group_name=\"dcp\",\n    )\n\n    global _PCP\n    assert _PCP is None, \"prefill context parallel group is already initialized\"\n    group_ranks = (\n        all_ranks.transpose(3, 4)\n        .reshape(-1, prefill_context_model_parallel_size)\n        .unbind(0)\n    )\n    group_ranks = [x.tolist() for x in group_ranks]\n    _PCP = init_model_parallel_group(\n        group_ranks, get_world_group().local_rank, backend, group_name=\"pcp\"\n    )\n\n    # Build the pipeline model-parallel groups.\n    global _PP\n    assert _PP is None, \"pipeline model parallel group is already initialized\"\n    group_ranks = (\n        all_ranks.transpose(2, 4).reshape(-1, pipeline_model_parallel_size).unbind(0)\n    )\n    group_ranks = [x.tolist() for x in group_ranks]\n    _PP = init_model_parallel_group(\n        group_ranks, get_world_group().local_rank, backend, group_name=\"pp\"\n    )\n\n    global _DP\n    assert _DP is None, \"data parallel group is already initialized\"\n    group_ranks = all_ranks.transpose(1, 4).reshape(-1, data_parallel_size).unbind(0)\n    group_ranks = [x.tolist() for x in group_ranks]\n    _DP = init_model_parallel_group(\n        group_ranks, get_world_group().local_rank, backend, group_name=\"dp\"\n    )\n\n    global _EP\n    assert _EP is None, \"expert parallel group is already initialized\"\n    group_ranks = (\n        all_ranks.transpose(1, 2)\n        .reshape(\n            -1,\n            data_parallel_size\n            * prefill_context_model_parallel_size\n            * tensor_model_parallel_size,\n        )\n        .unbind(0)\n    )\n    group_ranks = [x.tolist() for x in group_ranks]\n    _EP = init_model_parallel_group(\n        group_ranks, get_world_group().local_rank, backend, group_name=\"ep\"\n    )\n\n    logger.info_once(\n        \"rank %s in world size %s is assigned as \"\n        \"DP rank %s, PP rank %s, PCP rank %s, \"\n        \"TP rank %s, EP rank %s\",\n        rank,\n        world_size,\n        _DP.rank_in_group,\n        _PP.rank_in_group,\n        _PCP.rank_in_group,\n        _TP.rank_in_group,\n        _EP.rank_in_group,\n    )",
      "language": "python"
    },
    {
      "code": "is_global_first_rank() -> bool",
      "language": "php"
    },
    {
      "code": "is_global_first_rank() -> bool",
      "language": "php"
    },
    {
      "code": "1712\n1713\n1714\n1715\n1716\n1717\n1718\n1719\n1720\n1721\n1722\n1723\n1724\n1725\n1726\n1727\n1728\n1729\n1730\n1731\n1732\n1733\n1734\n1735\n1736\n1737\n1738\n1739\n1740",
      "language": "unknown"
    },
    {
      "code": "def is_global_first_rank() -> bool:\n    \"\"\"\n    Check if the current process is the first rank globally across all\n    parallelism strategies (PP, TP, DP, EP, etc.).\n\n    Unlike group-specific checks like `get_tensor_model_parallel_rank() == 0`\n    or `get_pp_group().is_first_rank`, this function checks the global rank\n    across all parallelism dimensions.\n\n    Returns:\n        bool: True if this is the global first rank (rank 0), False otherwise.\n              Returns True if distributed is not initialized (single process).\n    \"\"\"\n    try:\n        # If world group is available, use it for the most accurate check\n        global _WORLD\n        if _WORLD is not None:\n            return _WORLD.is_first_rank\n\n        # If torch distributed is not initialized, assume single process\n        if not torch.distributed.is_initialized():\n            return True\n\n        # Fallback to torch's global rank\n        return torch.distributed.get_rank() == 0\n\n    except Exception:\n        # If anything goes wrong, assume this is the first rank\n        return True",
      "language": "python"
    },
    {
      "code": "def is_global_first_rank() -> bool:\n    \"\"\"\n    Check if the current process is the first rank globally across all\n    parallelism strategies (PP, TP, DP, EP, etc.).\n\n    Unlike group-specific checks like `get_tensor_model_parallel_rank() == 0`\n    or `get_pp_group().is_first_rank`, this function checks the global rank\n    across all parallelism dimensions.\n\n    Returns:\n        bool: True if this is the global first rank (rank 0), False otherwise.\n              Returns True if distributed is not initialized (single process).\n    \"\"\"\n    try:\n        # If world group is available, use it for the most accurate check\n        global _WORLD\n        if _WORLD is not None:\n            return _WORLD.is_first_rank\n\n        # If torch distributed is not initialized, assume single process\n        if not torch.distributed.is_initialized():\n            return True\n\n        # Fallback to torch's global rank\n        return torch.distributed.get_rank() == 0\n\n    except Exception:\n        # If anything goes wrong, assume this is the first rank\n        return True",
      "language": "python"
    },
    {
      "code": "is_local_first_rank() -> bool",
      "language": "php"
    },
    {
      "code": "is_local_first_rank() -> bool",
      "language": "php"
    },
    {
      "code": "1743\n1744\n1745\n1746\n1747\n1748\n1749\n1750\n1751\n1752\n1753\n1754\n1755\n1756\n1757\n1758\n1759\n1760\n1761\n1762\n1763",
      "language": "unknown"
    },
    {
      "code": "def is_local_first_rank() -> bool:\n    \"\"\"\n    Check if the current process is the first local rank (rank 0 on its node).\n    \"\"\"\n    try:\n        # prefer the initialized world group if available\n        global _WORLD\n        if _WORLD is not None:\n            return _WORLD.local_rank == 0\n\n        if not torch.distributed.is_initialized():\n            return True\n\n        # fallback to environment-provided local rank if available\n        # note: envs.LOCAL_RANK is set when using env:// launchers (e.g., torchrun)\n        try:\n            return int(envs.LOCAL_RANK) == 0  # type: ignore[arg-type]\n        except Exception:\n            return torch.distributed.get_rank() == 0\n    except Exception:\n        return True",
      "language": "python"
    },
    {
      "code": "def is_local_first_rank() -> bool:\n    \"\"\"\n    Check if the current process is the first local rank (rank 0 on its node).\n    \"\"\"\n    try:\n        # prefer the initialized world group if available\n        global _WORLD\n        if _WORLD is not None:\n            return _WORLD.local_rank == 0\n\n        if not torch.distributed.is_initialized():\n            return True\n\n        # fallback to environment-provided local rank if available\n        # note: envs.LOCAL_RANK is set when using env:// launchers (e.g., torchrun)\n        try:\n            return int(envs.LOCAL_RANK) == 0  # type: ignore[arg-type]\n        except Exception:\n            return torch.distributed.get_rank() == 0\n    except Exception:\n        return True",
      "language": "python"
    },
    {
      "code": "is_torch_equal_or_newer(target: str) -> bool",
      "language": "php"
    },
    {
      "code": "is_torch_equal_or_newer(target: str) -> bool",
      "language": "php"
    },
    {
      "code": "610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623",
      "language": "unknown"
    },
    {
      "code": "def is_torch_equal_or_newer(target: str) -> bool:\n    \"\"\"Check if the installed torch version is >= the target version.\n\n    Args:\n        target: a version string, like \"2.6.0\".\n\n    Returns:\n        Whether the condition meets.\n    \"\"\"\n    try:\n        return _is_torch_equal_or_newer(str(torch.__version__), target)\n    except Exception:\n        # Fallback to PKG-INFO to load the package info, needed by the doc gen.\n        return Version(importlib.metadata.version(\"torch\")) >= Version(target)",
      "language": "go"
    },
    {
      "code": "def is_torch_equal_or_newer(target: str) -> bool:\n    \"\"\"Check if the installed torch version is >= the target version.\n\n    Args:\n        target: a version string, like \"2.6.0\".\n\n    Returns:\n        Whether the condition meets.\n    \"\"\"\n    try:\n        return _is_torch_equal_or_newer(str(torch.__version__), target)\n    except Exception:\n        # Fallback to PKG-INFO to load the package info, needed by the doc gen.\n        return Version(importlib.metadata.version(\"torch\")) >= Version(target)",
      "language": "go"
    },
    {
      "code": "model_parallel_is_initialized()",
      "language": "unknown"
    },
    {
      "code": "model_parallel_is_initialized()",
      "language": "unknown"
    },
    {
      "code": "1492\n1493\n1494",
      "language": "unknown"
    },
    {
      "code": "def model_parallel_is_initialized():\n    \"\"\"Check if tensor and pipeline parallel groups are initialized.\"\"\"\n    return _TP is not None and _PP is not None",
      "language": "python"
    },
    {
      "code": "def model_parallel_is_initialized():\n    \"\"\"Check if tensor and pipeline parallel groups are initialized.\"\"\"\n    return _TP is not None and _PP is not None",
      "language": "python"
    },
    {
      "code": "patch_tensor_parallel_group(tp_group: GroupCoordinator)",
      "language": "unknown"
    },
    {
      "code": "patch_tensor_parallel_group(tp_group: GroupCoordinator)",
      "language": "unknown"
    },
    {
      "code": "1500\n1501\n1502\n1503\n1504\n1505\n1506\n1507\n1508\n1509\n1510\n1511\n1512\n1513\n1514\n1515\n1516\n1517\n1518\n1519\n1520\n1521\n1522",
      "language": "unknown"
    },
    {
      "code": "@contextmanager\ndef patch_tensor_parallel_group(tp_group: GroupCoordinator):\n    \"\"\"Patch the tp group temporarily until this function ends.\n\n    This method is for draft workers of speculative decoding to run draft model\n    with different tp degree from that of target model workers.\n\n    Args:\n        tp_group (GroupCoordinator): the tp group coordinator\n    \"\"\"\n    global _TP_STATE_PATCHED\n    assert not _TP_STATE_PATCHED, \"Should not call when it's already patched\"\n\n    _TP_STATE_PATCHED = True\n    old_tp_group = get_tp_group()\n    global _TP\n    _TP = tp_group\n    try:\n        yield\n    finally:\n        # restore the original state\n        _TP_STATE_PATCHED = False\n        _TP = old_tp_group",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef patch_tensor_parallel_group(tp_group: GroupCoordinator):\n    \"\"\"Patch the tp group temporarily until this function ends.\n\n    This method is for draft workers of speculative decoding to run draft model\n    with different tp degree from that of target model workers.\n\n    Args:\n        tp_group (GroupCoordinator): the tp group coordinator\n    \"\"\"\n    global _TP_STATE_PATCHED\n    assert not _TP_STATE_PATCHED, \"Should not call when it's already patched\"\n\n    _TP_STATE_PATCHED = True\n    old_tp_group = get_tp_group()\n    global _TP\n    _TP = tp_group\n    try:\n        yield\n    finally:\n        # restore the original state\n        _TP_STATE_PATCHED = False\n        _TP = old_tp_group",
      "language": "python"
    },
    {
      "code": "patched_fused_scaled_matmul_reduce_scatter(\n    A: Tensor,\n    B: Tensor,\n    A_scale: Tensor,\n    B_scale: Tensor,\n    reduce_op: str,\n    orig_scatter_dim: int,\n    scatter_dim_after_maybe_reshape: int,\n    group_name: str,\n    output_shape: list[int],\n    bias: Tensor | None = None,\n    result_scale: Tensor | None = None,\n    out_dtype: dtype | None = None,\n    use_fast_accum: bool = False,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "patched_fused_scaled_matmul_reduce_scatter(\n    A: Tensor,\n    B: Tensor,\n    A_scale: Tensor,\n    B_scale: Tensor,\n    reduce_op: str,\n    orig_scatter_dim: int,\n    scatter_dim_after_maybe_reshape: int,\n    group_name: str,\n    output_shape: list[int],\n    bias: Tensor | None = None,\n    result_scale: Tensor | None = None,\n    out_dtype: dtype | None = None,\n    use_fast_accum: bool = False,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246",
      "language": "unknown"
    },
    {
      "code": "def patched_fused_scaled_matmul_reduce_scatter(\n    A: torch.Tensor,\n    B: torch.Tensor,\n    A_scale: torch.Tensor,\n    B_scale: torch.Tensor,\n    reduce_op: str,\n    orig_scatter_dim: int,\n    scatter_dim_after_maybe_reshape: int,\n    group_name: str,\n    output_shape: list[int],\n    bias: torch.Tensor | None = None,\n    result_scale: torch.Tensor | None = None,\n    out_dtype: torch.dtype | None = None,\n    use_fast_accum: bool = False,\n) -> torch.Tensor:\n    return torch.ops.symm_mem.fused_scaled_matmul_reduce_scatter(\n        A,\n        B,\n        A_scale,\n        B_scale,\n        reduce_op,\n        orig_scatter_dim,\n        scatter_dim_after_maybe_reshape,\n        group_name,\n        output_shape,\n        bias,\n        result_scale,\n        out_dtype,\n        use_fast_accum,\n    )",
      "language": "python"
    },
    {
      "code": "def patched_fused_scaled_matmul_reduce_scatter(\n    A: torch.Tensor,\n    B: torch.Tensor,\n    A_scale: torch.Tensor,\n    B_scale: torch.Tensor,\n    reduce_op: str,\n    orig_scatter_dim: int,\n    scatter_dim_after_maybe_reshape: int,\n    group_name: str,\n    output_shape: list[int],\n    bias: torch.Tensor | None = None,\n    result_scale: torch.Tensor | None = None,\n    out_dtype: torch.dtype | None = None,\n    use_fast_accum: bool = False,\n) -> torch.Tensor:\n    return torch.ops.symm_mem.fused_scaled_matmul_reduce_scatter(\n        A,\n        B,\n        A_scale,\n        B_scale,\n        reduce_op,\n        orig_scatter_dim,\n        scatter_dim_after_maybe_reshape,\n        group_name,\n        output_shape,\n        bias,\n        result_scale,\n        out_dtype,\n        use_fast_accum,\n    )",
      "language": "python"
    },
    {
      "code": "patched_fused_scaled_matmul_reduce_scatter_fake(\n    A: Tensor,\n    B: Tensor,\n    A_scale: Tensor,\n    B_scale: Tensor,\n    reduce_op: str,\n    orig_scatter_dim: int,\n    scatter_dim_after_maybe_reshape: int,\n    group_name: str,\n    output_shape: list[int],\n    bias: Tensor | None = None,\n    result_scale: Tensor | None = None,\n    out_dtype: dtype | None = None,\n    use_fast_accum: bool = False,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "patched_fused_scaled_matmul_reduce_scatter_fake(\n    A: Tensor,\n    B: Tensor,\n    A_scale: Tensor,\n    B_scale: Tensor,\n    reduce_op: str,\n    orig_scatter_dim: int,\n    scatter_dim_after_maybe_reshape: int,\n    group_name: str,\n    output_shape: list[int],\n    bias: Tensor | None = None,\n    result_scale: Tensor | None = None,\n    out_dtype: dtype | None = None,\n    use_fast_accum: bool = False,\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214",
      "language": "unknown"
    },
    {
      "code": "def patched_fused_scaled_matmul_reduce_scatter_fake(\n    A: torch.Tensor,\n    B: torch.Tensor,\n    A_scale: torch.Tensor,\n    B_scale: torch.Tensor,\n    reduce_op: str,\n    orig_scatter_dim: int,\n    scatter_dim_after_maybe_reshape: int,\n    group_name: str,\n    output_shape: list[int],\n    bias: torch.Tensor | None = None,\n    result_scale: torch.Tensor | None = None,\n    out_dtype: torch.dtype | None = None,\n    use_fast_accum: bool = False,\n) -> torch.Tensor:\n    # Copied from\n    # https://github.com/pytorch/pytorch/blob/50c338c2da905062449e4d9ac807832d1b5cd90e/torch/distributed/_symmetric_memory/__init__.py#L1189\n    if A_scale.numel() > 1:\n        if A_scale.shape[:-1] != A.shape[:-1]:\n            raise ValueError(\n                \"For row-wise scaling, the leading dims of A_scale \"\n                \"must match the leading dims of A \"\n                f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\"\n            )\n        A_scale = A_scale.flatten(0, -2).contiguous()\n    elif A_scale.numel() != 1:\n        raise ValueError(\n            \"Invalid A_scale shape \"\n            f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\"\n        )\n\n    C = torch._scaled_mm(\n        A.flatten(0, -2).contiguous(),\n        B,\n        A_scale,\n        B_scale,\n        bias,\n        result_scale,\n        out_dtype,\n        use_fast_accum,\n    )\n    C = C.view(*output_shape[:-1], B.shape[1])\n    res = funcol.reduce_scatter_tensor(\n        C,\n        reduce_op,\n        orig_scatter_dim,  # need original scatter dim for 3D+ output tensor here\n        group_name,\n    )\n    res = funcol.wait_tensor(res)\n    return res",
      "language": "python"
    },
    {
      "code": "def patched_fused_scaled_matmul_reduce_scatter_fake(\n    A: torch.Tensor,\n    B: torch.Tensor,\n    A_scale: torch.Tensor,\n    B_scale: torch.Tensor,\n    reduce_op: str,\n    orig_scatter_dim: int,\n    scatter_dim_after_maybe_reshape: int,\n    group_name: str,\n    output_shape: list[int],\n    bias: torch.Tensor | None = None,\n    result_scale: torch.Tensor | None = None,\n    out_dtype: torch.dtype | None = None,\n    use_fast_accum: bool = False,\n) -> torch.Tensor:\n    # Copied from\n    # https://github.com/pytorch/pytorch/blob/50c338c2da905062449e4d9ac807832d1b5cd90e/torch/distributed/_symmetric_memory/__init__.py#L1189\n    if A_scale.numel() > 1:\n        if A_scale.shape[:-1] != A.shape[:-1]:\n            raise ValueError(\n                \"For row-wise scaling, the leading dims of A_scale \"\n                \"must match the leading dims of A \"\n                f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\"\n            )\n        A_scale = A_scale.flatten(0, -2).contiguous()\n    elif A_scale.numel() != 1:\n        raise ValueError(\n            \"Invalid A_scale shape \"\n            f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\"\n        )\n\n    C = torch._scaled_mm(\n        A.flatten(0, -2).contiguous(),\n        B,\n        A_scale,\n        B_scale,\n        bias,\n        result_scale,\n        out_dtype,\n        use_fast_accum,\n    )\n    C = C.view(*output_shape[:-1], B.shape[1])\n    res = funcol.reduce_scatter_tensor(\n        C,\n        reduce_op,\n        orig_scatter_dim,  # need original scatter dim for 3D+ output tensor here\n        group_name,\n    )\n    res = funcol.wait_tensor(res)\n    return res",
      "language": "python"
    },
    {
      "code": "prepare_communication_buffer_for_model(model: Module)",
      "language": "unknown"
    },
    {
      "code": "prepare_communication_buffer_for_model(model: Module)",
      "language": "unknown"
    },
    {
      "code": "1473\n1474\n1475\n1476\n1477\n1478\n1479\n1480\n1481\n1482\n1483\n1484\n1485\n1486\n1487\n1488\n1489",
      "language": "unknown"
    },
    {
      "code": "def prepare_communication_buffer_for_model(model: torch.nn.Module):\n    \"\"\"Prepare the communication buffer for the model.\n    Traditional communication libraries like NCCL are almost\n    model agnostic. However, emerging new communication libraries like\n    MoE all2all (DeepEP) usually allocate the communication buffer\n    based on the model shape for optimal performance.\n    \"\"\"\n    if _TP is not None:\n        _TP.prepare_communication_buffer_for_model(model)\n    if _PCP is not None:\n        _PCP.prepare_communication_buffer_for_model(model)\n    if _PP is not None:\n        _PP.prepare_communication_buffer_for_model(model)\n    if _DP is not None:\n        _DP.prepare_communication_buffer_for_model(model)\n    if _EP is not None:\n        _EP.prepare_communication_buffer_for_model(model)",
      "language": "python"
    },
    {
      "code": "def prepare_communication_buffer_for_model(model: torch.nn.Module):\n    \"\"\"Prepare the communication buffer for the model.\n    Traditional communication libraries like NCCL are almost\n    model agnostic. However, emerging new communication libraries like\n    MoE all2all (DeepEP) usually allocate the communication buffer\n    based on the model shape for optimal performance.\n    \"\"\"\n    if _TP is not None:\n        _TP.prepare_communication_buffer_for_model(model)\n    if _PCP is not None:\n        _PCP.prepare_communication_buffer_for_model(model)\n    if _PP is not None:\n        _PP.prepare_communication_buffer_for_model(model)\n    if _DP is not None:\n        _DP.prepare_communication_buffer_for_model(model)\n    if _EP is not None:\n        _EP.prepare_communication_buffer_for_model(model)",
      "language": "python"
    },
    {
      "code": "reduce_scatter(\n    tensor: Tensor,\n    dim: int,\n    world_size: int,\n    group_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "reduce_scatter(\n    tensor: Tensor,\n    dim: int,\n    world_size: int,\n    group_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "129\n130\n131\n132\n133\n134\n135\n136",
      "language": "unknown"
    },
    {
      "code": "def reduce_scatter(\n    tensor: torch.Tensor, dim: int, world_size: int, group_name: str\n) -> torch.Tensor:\n    assert group_name in _groups, f\"Group {group_name} is not found.\"\n    group = _groups[group_name]()\n    if group is None:\n        raise ValueError(f\"Group {group_name} is destroyed.\")\n    return group._reduce_scatter_out_place(tensor, dim)",
      "language": "python"
    },
    {
      "code": "def reduce_scatter(\n    tensor: torch.Tensor, dim: int, world_size: int, group_name: str\n) -> torch.Tensor:\n    assert group_name in _groups, f\"Group {group_name} is not found.\"\n    group = _groups[group_name]()\n    if group is None:\n        raise ValueError(f\"Group {group_name} is destroyed.\")\n    return group._reduce_scatter_out_place(tensor, dim)",
      "language": "python"
    },
    {
      "code": "reduce_scatter_fake(\n    tensor: Tensor,\n    dim: int,\n    world_size: int,\n    group_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "reduce_scatter_fake(\n    tensor: Tensor,\n    dim: int,\n    world_size: int,\n    group_name: str,\n) -> Tensor",
      "language": "php"
    },
    {
      "code": "139\n140\n141\n142\n143\n144",
      "language": "unknown"
    },
    {
      "code": "def reduce_scatter_fake(\n    tensor: torch.Tensor, dim: int, world_size: int, group_name: str\n) -> torch.Tensor:\n    new_shape = list(tensor.shape)\n    new_shape[dim] = tensor.shape[dim] // world_size\n    return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device)",
      "language": "python"
    },
    {
      "code": "def reduce_scatter_fake(\n    tensor: torch.Tensor, dim: int, world_size: int, group_name: str\n) -> torch.Tensor:\n    new_shape = list(tensor.shape)\n    new_shape[dim] = tensor.shape[dim] // world_size\n    return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device)",
      "language": "python"
    },
    {
      "code": "resolve_obj_by_qualname(qualname: str) -> Any",
      "language": "php"
    },
    {
      "code": "resolve_obj_by_qualname(qualname: str) -> Any",
      "language": "php"
    },
    {
      "code": "117\n118\n119\n120\n121\n122\n123",
      "language": "unknown"
    },
    {
      "code": "def resolve_obj_by_qualname(qualname: str) -> Any:\n    \"\"\"\n    Resolve an object by its fully-qualified class name.\n    \"\"\"\n    module_name, obj_name = qualname.rsplit(\".\", 1)\n    module = importlib.import_module(module_name)\n    return getattr(module, obj_name)",
      "language": "php"
    },
    {
      "code": "def resolve_obj_by_qualname(qualname: str) -> Any:\n    \"\"\"\n    Resolve an object by its fully-qualified class name.\n    \"\"\"\n    module_name, obj_name = qualname.rsplit(\".\", 1)\n    module = importlib.import_module(module_name)\n    return getattr(module, obj_name)",
      "language": "php"
    },
    {
      "code": "sched_yield()",
      "language": "unknown"
    },
    {
      "code": "sched_yield()",
      "language": "unknown"
    },
    {
      "code": "46\n47\n48\n49\n50",
      "language": "unknown"
    },
    {
      "code": "def sched_yield():\n    if USE_SCHED_YIELD:\n        os.sched_yield()\n    else:\n        time.sleep(0)",
      "language": "python"
    },
    {
      "code": "def sched_yield():\n    if USE_SCHED_YIELD:\n        os.sched_yield()\n    else:\n        time.sleep(0)",
      "language": "python"
    },
    {
      "code": "set_custom_all_reduce(enable: bool)",
      "language": "unknown"
    },
    {
      "code": "set_custom_all_reduce(enable: bool)",
      "language": "unknown"
    },
    {
      "code": "1155\n1156\n1157",
      "language": "unknown"
    },
    {
      "code": "def set_custom_all_reduce(enable: bool):\n    global _ENABLE_CUSTOM_ALL_REDUCE\n    _ENABLE_CUSTOM_ALL_REDUCE = enable",
      "language": "python"
    },
    {
      "code": "def set_custom_all_reduce(enable: bool):\n    global _ENABLE_CUSTOM_ALL_REDUCE\n    _ENABLE_CUSTOM_ALL_REDUCE = enable",
      "language": "python"
    },
    {
      "code": "split_tensor_along_last_dim(\n    tensor: Tensor,\n    num_partitions: int,\n    contiguous_split_chunks: bool = False,\n) -> Sequence[Tensor]",
      "language": "typescript"
    },
    {
      "code": "split_tensor_along_last_dim(\n    tensor: Tensor,\n    num_partitions: int,\n    contiguous_split_chunks: bool = False,\n) -> Sequence[Tensor]",
      "language": "typescript"
    },
    {
      "code": "67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92",
      "language": "unknown"
    },
    {
      "code": "def split_tensor_along_last_dim(\n    tensor: torch.Tensor,\n    num_partitions: int,\n    contiguous_split_chunks: bool = False,\n) -> Sequence[torch.Tensor]:\n    \"\"\"Split a tensor along its last dimension.\n\n    Arguments:\n        tensor: input tensor.\n        num_partitions: number of partitions to split the tensor\n        contiguous_split_chunks: If True, make each chunk contiguous\n                                 in memory.\n\n    Returns:\n        A list of Tensors\n    \"\"\"\n    # Get the size and dimension.\n    last_dim = tensor.dim() - 1\n    last_dim_size = divide(tensor.size()[last_dim], num_partitions)\n    # Split.\n    tensor_list = torch.split(tensor, last_dim_size, dim=last_dim)\n    # NOTE: torch.split does not create contiguous tensors by default.\n    if contiguous_split_chunks:\n        return tuple(chunk.contiguous() for chunk in tensor_list)\n\n    return tensor_list",
      "language": "python"
    },
    {
      "code": "def split_tensor_along_last_dim(\n    tensor: torch.Tensor,\n    num_partitions: int,\n    contiguous_split_chunks: bool = False,\n) -> Sequence[torch.Tensor]:\n    \"\"\"Split a tensor along its last dimension.\n\n    Arguments:\n        tensor: input tensor.\n        num_partitions: number of partitions to split the tensor\n        contiguous_split_chunks: If True, make each chunk contiguous\n                                 in memory.\n\n    Returns:\n        A list of Tensors\n    \"\"\"\n    # Get the size and dimension.\n    last_dim = tensor.dim() - 1\n    last_dim_size = divide(tensor.size()[last_dim], num_partitions)\n    # Split.\n    tensor_list = torch.split(tensor, last_dim_size, dim=last_dim)\n    # NOTE: torch.split does not create contiguous tensors by default.\n    if contiguous_split_chunks:\n        return tuple(chunk.contiguous() for chunk in tensor_list)\n\n    return tensor_list",
      "language": "python"
    },
    {
      "code": "stateless_destroy_torch_distributed_process_group(\n    pg: ProcessGroup,\n) -> None",
      "language": "rust"
    },
    {
      "code": "stateless_destroy_torch_distributed_process_group(\n    pg: ProcessGroup,\n) -> None",
      "language": "rust"
    },
    {
      "code": "532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545",
      "language": "unknown"
    },
    {
      "code": "def stateless_destroy_torch_distributed_process_group(pg: ProcessGroup) -> None:\n    \"\"\"\n    Destroy ProcessGroup returned by\n        stateless_init_torch_distributed_process_group().\n    \"\"\"\n    if is_torch_equal_or_newer(\"2.7\"):\n        pg.shutdown()\n    else:\n        # Lazy import for non-CUDA backends.\n        from torch.distributed.distributed_c10d import _shutdown_backend\n\n        _shutdown_backend(pg)\n\n    _unregister_process_group(pg.group_name)",
      "language": "python"
    },
    {
      "code": "def stateless_destroy_torch_distributed_process_group(pg: ProcessGroup) -> None:\n    \"\"\"\n    Destroy ProcessGroup returned by\n        stateless_init_torch_distributed_process_group().\n    \"\"\"\n    if is_torch_equal_or_newer(\"2.7\"):\n        pg.shutdown()\n    else:\n        # Lazy import for non-CUDA backends.\n        from torch.distributed.distributed_c10d import _shutdown_backend\n\n        _shutdown_backend(pg)\n\n    _unregister_process_group(pg.group_name)",
      "language": "python"
    },
    {
      "code": "stateless_init_torch_distributed_process_group(\n    host: str,\n    port: int,\n    rank: int,\n    world_size: int,\n    backend: str,\n) -> ProcessGroup",
      "language": "php"
    },
    {
      "code": "stateless_init_torch_distributed_process_group(\n    host: str,\n    port: int,\n    rank: int,\n    world_size: int,\n    backend: str,\n) -> ProcessGroup",
      "language": "php"
    },
    {
      "code": "462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529",
      "language": "unknown"
    },
    {
      "code": "def stateless_init_torch_distributed_process_group(\n    host: str, port: int, rank: int, world_size: int, backend: str\n) -> ProcessGroup:\n    \"\"\"\n    A replacement for `torch.distributed.init_process_group` that does not\n    pollute the global state. The created ProcessGroup object can be used for\n    some operations such as `allreduce`, because it does not depend on the\n    global rank. However, some operations such as `broadcast` cannot be used\n    because it depends on the global rank.\n\n    # TODO: ask for help from PyTorch team if we need the `broadcast` operation.\n\n    This function is useful when we are not sure about the total number of\n    processes in the process group. For example, we may have process\n    1, 2, ..., 8 who want to communicate, and process 9 might be the same\n    process as process 1, or it might be a different process; process 10\n    might be the same process as process 5, or it might be a different process.\n    In this case, how can we reliably form a communication channel within\n    process 9 and 10, without affecting the communication channel within\n    process 1, 2, ..., 8?\n\n    One possible solution is to figure out if process 9 and 10 are the same\n    as process 1 and 5 beforehand, and then form a communication channel\n    based on the information, adjusting the ranks and world_size etc. However,\n    figuring out the information is not always easy, and it will interfere\n    with the main communication channel.\n\n    Our solution is to always form a communication channel with process 1, 2,\n    ..., 8, and then use this function to form another communication channel\n    with process 9 and 10. This way, regardless of whether process 9 and 10\n    are the same as process 1 and 5, the main communication channel is\n    always formed with process 1, 2, ..., 8, and the additional communication\n    channel is formed with process 9 and 10.\n    \"\"\"\n    init_method = get_tcp_uri(host, port)\n    backend = Backend(backend)  # it is basically string\n    timeout = _get_default_timeout(backend)\n\n    store, rank, world_size = next(\n        rendezvous(init_method, rank, world_size, timeout=timeout)\n    )\n    store.set_timeout(timeout)\n\n    group_rank = rank\n    group_size = world_size\n\n    # Use a PrefixStore to avoid accidental overrides of keys used by\n    # different systems (e.g. RPC) in case the store is multi-tenant.\n    prefix_store = PrefixStore(init_method, store)\n    try:\n        from vllm.platforms import current_platform\n\n        return current_platform.stateless_init_device_torch_dist_pg(\n            backend=backend,\n            prefix_store=prefix_store,\n            group_rank=group_rank,\n            group_size=group_size,\n            timeout=timeout,\n        )\n    except NotImplementedError:\n        # If platform doesn't implement stateless_init_device_torch_dist_pg, it\n        # will raise a NotImplementedError. In this case, we fall back to gloo.\n        return init_gloo_process_group(\n            prefix_store=prefix_store,\n            group_rank=group_rank,\n            group_size=group_size,\n            timeout=timeout,\n        )",
      "language": "python"
    },
    {
      "code": "def stateless_init_torch_distributed_process_group(\n    host: str, port: int, rank: int, world_size: int, backend: str\n) -> ProcessGroup:\n    \"\"\"\n    A replacement for `torch.distributed.init_process_group` that does not\n    pollute the global state. The created ProcessGroup object can be used for\n    some operations such as `allreduce`, because it does not depend on the\n    global rank. However, some operations such as `broadcast` cannot be used\n    because it depends on the global rank.\n\n    # TODO: ask for help from PyTorch team if we need the `broadcast` operation.\n\n    This function is useful when we are not sure about the total number of\n    processes in the process group. For example, we may have process\n    1, 2, ..., 8 who want to communicate, and process 9 might be the same\n    process as process 1, or it might be a different process; process 10\n    might be the same process as process 5, or it might be a different process.\n    In this case, how can we reliably form a communication channel within\n    process 9 and 10, without affecting the communication channel within\n    process 1, 2, ..., 8?\n\n    One possible solution is to figure out if process 9 and 10 are the same\n    as process 1 and 5 beforehand, and then form a communication channel\n    based on the information, adjusting the ranks and world_size etc. However,\n    figuring out the information is not always easy, and it will interfere\n    with the main communication channel.\n\n    Our solution is to always form a communication channel with process 1, 2,\n    ..., 8, and then use this function to form another communication channel\n    with process 9 and 10. This way, regardless of whether process 9 and 10\n    are the same as process 1 and 5, the main communication channel is\n    always formed with process 1, 2, ..., 8, and the additional communication\n    channel is formed with process 9 and 10.\n    \"\"\"\n    init_method = get_tcp_uri(host, port)\n    backend = Backend(backend)  # it is basically string\n    timeout = _get_default_timeout(backend)\n\n    store, rank, world_size = next(\n        rendezvous(init_method, rank, world_size, timeout=timeout)\n    )\n    store.set_timeout(timeout)\n\n    group_rank = rank\n    group_size = world_size\n\n    # Use a PrefixStore to avoid accidental overrides of keys used by\n    # different systems (e.g. RPC) in case the store is multi-tenant.\n    prefix_store = PrefixStore(init_method, store)\n    try:\n        from vllm.platforms import current_platform\n\n        return current_platform.stateless_init_device_torch_dist_pg(\n            backend=backend,\n            prefix_store=prefix_store,\n            group_rank=group_rank,\n            group_size=group_size,\n            timeout=timeout,\n        )\n    except NotImplementedError:\n        # If platform doesn't implement stateless_init_device_torch_dist_pg, it\n        # will raise a NotImplementedError. In this case, we fall back to gloo.\n        return init_gloo_process_group(\n            prefix_store=prefix_store,\n            group_rank=group_rank,\n            group_size=group_size,\n            timeout=timeout,\n        )",
      "language": "python"
    },
    {
      "code": "supports_custom_op() -> bool",
      "language": "php"
    },
    {
      "code": "supports_custom_op() -> bool",
      "language": "php"
    },
    {
      "code": "def supports_custom_op() -> bool:\n    return hasattr(torch.library, \"custom_op\")",
      "language": "python"
    },
    {
      "code": "def supports_custom_op() -> bool:\n    return hasattr(torch.library, \"custom_op\")",
      "language": "python"
    },
    {
      "code": "suppress_stdout()",
      "language": "unknown"
    },
    {
      "code": "suppress_stdout()",
      "language": "unknown"
    },
    {
      "code": "59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89",
      "language": "unknown"
    },
    {
      "code": "@contextlib.contextmanager\ndef suppress_stdout():\n    \"\"\"\n    Suppress stdout from C libraries at the file descriptor level.\n\n    Only suppresses stdout, not stderr, to preserve error messages.\n    Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG.\n\n    Example:\n        with suppress_stdout():\n            # C library calls that would normally print to stdout\n            torch.distributed.new_group(ranks, backend=\"gloo\")\n    \"\"\"\n    # Don't suppress if logging level is DEBUG\n    if envs.VLLM_LOGGING_LEVEL == \"DEBUG\":\n        yield\n        return\n\n    stdout_fd = sys.stdout.fileno()\n    stdout_dup = os.dup(stdout_fd)\n    devnull_fd = os.open(os.devnull, os.O_WRONLY)\n\n    try:\n        sys.stdout.flush()\n        os.dup2(devnull_fd, stdout_fd)\n        yield\n    finally:\n        sys.stdout.flush()\n        os.dup2(stdout_dup, stdout_fd)\n        os.close(stdout_dup)\n        os.close(devnull_fd)",
      "language": "python"
    },
    {
      "code": "@contextlib.contextmanager\ndef suppress_stdout():\n    \"\"\"\n    Suppress stdout from C libraries at the file descriptor level.\n\n    Only suppresses stdout, not stderr, to preserve error messages.\n    Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG.\n\n    Example:\n        with suppress_stdout():\n            # C library calls that would normally print to stdout\n            torch.distributed.new_group(ranks, backend=\"gloo\")\n    \"\"\"\n    # Don't suppress if logging level is DEBUG\n    if envs.VLLM_LOGGING_LEVEL == \"DEBUG\":\n        yield\n        return\n\n    stdout_fd = sys.stdout.fileno()\n    stdout_dup = os.dup(stdout_fd)\n    devnull_fd = os.open(os.devnull, os.O_WRONLY)\n\n    try:\n        sys.stdout.flush()\n        os.dup2(devnull_fd, stdout_fd)\n        yield\n    finally:\n        sys.stdout.flush()\n        os.dup2(stdout_dup, stdout_fd)\n        os.close(stdout_dup)\n        os.close(devnull_fd)",
      "language": "python"
    },
    {
      "code": "tensor_model_parallel_all_gather(\n    input_: Tensor, dim: int = -1\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "tensor_model_parallel_all_gather(\n    input_: Tensor, dim: int = -1\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "17\n18\n19\n20\n21",
      "language": "unknown"
    },
    {
      "code": "def tensor_model_parallel_all_gather(\n    input_: torch.Tensor, dim: int = -1\n) -> torch.Tensor:\n    \"\"\"All-gather the input tensor across model parallel group.\"\"\"\n    return get_tp_group().all_gather(input_, dim)",
      "language": "python"
    },
    {
      "code": "def tensor_model_parallel_all_gather(\n    input_: torch.Tensor, dim: int = -1\n) -> torch.Tensor:\n    \"\"\"All-gather the input tensor across model parallel group.\"\"\"\n    return get_tp_group().all_gather(input_, dim)",
      "language": "python"
    },
    {
      "code": "tensor_model_parallel_all_reduce(input_: Tensor) -> Tensor",
      "language": "php"
    },
    {
      "code": "tensor_model_parallel_all_reduce(input_: Tensor) -> Tensor",
      "language": "php"
    },
    {
      "code": "def tensor_model_parallel_all_reduce(input_: torch.Tensor) -> torch.Tensor:\n    \"\"\"All-reduce the input tensor across model parallel group.\"\"\"\n    return get_tp_group().all_reduce(input_)",
      "language": "python"
    },
    {
      "code": "def tensor_model_parallel_all_reduce(input_: torch.Tensor) -> torch.Tensor:\n    \"\"\"All-reduce the input tensor across model parallel group.\"\"\"\n    return get_tp_group().all_reduce(input_)",
      "language": "python"
    },
    {
      "code": "tensor_model_parallel_gather(\n    input_: Tensor, dst: int = 0, dim: int = -1\n) -> Tensor | None",
      "language": "typescript"
    },
    {
      "code": "tensor_model_parallel_gather(\n    input_: Tensor, dst: int = 0, dim: int = -1\n) -> Tensor | None",
      "language": "typescript"
    },
    {
      "code": "31\n32\n33\n34\n35",
      "language": "unknown"
    },
    {
      "code": "def tensor_model_parallel_gather(\n    input_: torch.Tensor, dst: int = 0, dim: int = -1\n) -> torch.Tensor | None:\n    \"\"\"Gather the input tensor across model parallel group.\"\"\"\n    return get_tp_group().gather(input_, dst, dim)",
      "language": "python"
    },
    {
      "code": "def tensor_model_parallel_gather(\n    input_: torch.Tensor, dst: int = 0, dim: int = -1\n) -> torch.Tensor | None:\n    \"\"\"Gather the input tensor across model parallel group.\"\"\"\n    return get_tp_group().gather(input_, dst, dim)",
      "language": "python"
    },
    {
      "code": "tensor_model_parallel_reduce_scatter(\n    input_: Tensor, dim: int = -1\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "tensor_model_parallel_reduce_scatter(\n    input_: Tensor, dim: int = -1\n) -> Tensor",
      "language": "typescript"
    },
    {
      "code": "24\n25\n26\n27\n28",
      "language": "unknown"
    },
    {
      "code": "def tensor_model_parallel_reduce_scatter(\n    input_: torch.Tensor, dim: int = -1\n) -> torch.Tensor:\n    \"\"\"Reduce-Scatter the input tensor across model parallel group.\"\"\"\n    return get_tp_group().reduce_scatter(input_, dim)",
      "language": "python"
    },
    {
      "code": "def tensor_model_parallel_reduce_scatter(\n    input_: torch.Tensor, dim: int = -1\n) -> torch.Tensor:\n    \"\"\"Reduce-Scatter the input tensor across model parallel group.\"\"\"\n    return get_tp_group().reduce_scatter(input_, dim)",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "vLLM GitHub Home User Guide User Guide Getting Started Getting Started Quickstart Installation Installation GPU CPU TPU Examples Examples Offline inference Offline inference Async LLM Streaming Audio Language Automatic Prefix Caching Basic Batch LLM Inference Chat With Tools Context Extension Data Parallel Disaggregated Prefill V1 Disaggregated Prefill Encoder Decoder Multimodal KV Load Failure Recovery Test LLM Engine Example LLM Engine Reset Kv Load Sharded State Logits Processor LoRA With Quantization Inference Metrics Mistral-Small MLPSpeculator MultiLoRA Inference Offline Inference with the OpenAI Batch file format Prefix Caching Prompt Embed Inference Qwen2.5-Omni Offline Inference Examples Qwen3 Omni Qwen 1M Reproducibility RLHF RLHF Colocate RLHF Online Quant RLHF Utils Save Sharded State Simple Profiling Skip Loading Weights In Engine Init Spec Decode Structured Outputs Torchrun Dp Example Torchrun Example Vision Language Vision Language Multi Image Online serving Online serving API Client Helm Charts Monitoring Dashboards Disaggregated Encoder Disaggregated Prefill Disaggregated Serving Disaggregated Serving P2P Nccl Xpyd Elastic Ep Gradio OpenAI Chatbot Webserver Gradio Webserver Kv Events Subscriber Multi-Node-Serving Multi Instance Data Parallel OpenAI Chat Completion Client OpenAI Chat Completion Client For Multimodal OpenAI Chat Completion Client With Tools OpenAI Chat Completion Client With Tools Required OpenAI Chat Completion Client With Tools Xlam OpenAI Chat Completion Client With Tools Xlam Streaming OpenAI Chat Completion Tool Calls With Reasoning OpenAI Chat Completion With Reasoning OpenAI Chat Completion With Reasoning Streaming OpenAI Completion Client OpenAI Responses Client OpenAI Responses Client With Mcp Tools OpenAI Responses Client With Tools OpenAI Transcription Client OpenAI Translation Client Setup OpenTelemetry POC Prometheus and Grafana Prompt Embed Inference With OpenAI Client Ray Serve Deepseek Retrieval Augmented Generation With Langchain Retrieval Augmented Generation With Llamaindex Run Cluster Sagemaker-Entrypoint Streamlit OpenAI Chatbot Webserver Structured Outputs Token Generation Client Utils Others Others LMCache Examples Logging Configuration Tensorize vLLM Model Pooling Pooling Classify Embed Plugin Pooling Score Token Classify Token Embed General General vLLM V1 Frequently Asked Questions Production Metrics Reproducibility Security Troubleshooting Usage Stats Collection Inference and Serving Inference and Serving Offline Inference OpenAI-Compatible Server Context Parallel Deployment Data Parallel Deployment Troubleshooting distributed deployments Expert Parallel Deployment Parallelism and Scaling Integrations Integrations LangChain LlamaIndex Deployment Deployment Using Docker Using Kubernetes Using Nginx Frameworks Frameworks Anyscale AnythingLLM AutoGen BentoML Cerebrium Chatbox Dify dstack Haystack Helm Hugging Face Inference Endpoints LiteLLM Lobe Chat LWS Modal Open WebUI Retrieval-Augmented Generation SkyPilot Streamlit NVIDIA Triton Integrations Integrations KAITO KServe Kthena KubeAI KubeRay Llama Stack llm-d llmaz Production stack Training Training Reinforcement Learning from Human Feedback Transformers Reinforcement Learning Configuration Configuration Conserving Memory Engine Arguments Environment Variables Model Resolution Optimization and Tuning Server Arguments TPU Models Models Supported Models Generative Models Pooling Models Extensions Extensions Loading Model weights with fastsafetensors Loading models with Run:ai Model Streamer Loading models with CoreWeave's Tensorizer Hardware Supported Models Hardware Supported Models CPU - Intel® Xeon® XPU - Intel® GPUs TPU Features Features Automatic Prefix Caching Batch Invariance Custom Arguments Custom Logits Processors Disaggregated Encoder Disaggregated Prefilling (experimental) Interleaved Thinking LoRA Adapters MooncakeConnector Usage Guide Multimodal Inputs NixlConnector Usage Guide Prompt Embedding Inputs Reasoning Outputs Sleep Mode Speculative Decoding Structured Outputs Tool Calling Quantization Quantization AutoAWQ AutoRound BitBLAS BitsAndBytes FP8 W8A8 GGUF GPTQModel FP8 INC INT4 W4A16 INT8 W8A8 NVIDIA Model Optimizer Quantized KV Cache AMD Quark TorchAO Developer Guide Developer Guide General General Deprecation Policy Dockerfile Incremental Compilation Workflow Profiling vLLM Vulnerability Management Model Implementation Model Implementation Basic Model Registering a Model Unit Testing Multi-Modal Support Speech-to-Text (Transcription/Translation) Support CI CI CI Failures Nightly Builds of vLLM Wheels Update PyTorch version on vLLM OSS CI/CD Design Documents Design Documents Plugins Plugins IO Processor Plugins LoRA Resolver Plugins Plugin System Architecture Overview CUDA Graphs Dual Batch Overlap How to debug the vLLM-torch.compile integration Fused MoE Modular Kernel Integration with Hugging Face Hybrid KV Cache Manager Logits Processors Metrics Multi-Modal Data Processing Fused MoE Kernel Features Python Multiprocessing Optimization levels P2P NCCL Connector Paged Attention Automatic Prefix Caching torch.compile integration Benchmarking Benchmarking Benchmark CLI Parameter Sweeps Performance Dashboard API Reference API Reference vllm vllm beam_search collect_env connections env_override envs forward_context logger logits_process logprobs outputs pooling_params sampling_params scalar_type scripts sequence tasks tracing version assets assets audio base image video attention attention layer selector backends backends abstract registry utils layers layers chunked_local_attention cross_attention encoder_only_attention mm_encoder_attention ops ops chunked_prefill_paged_decode common flashmla merge_attn_states paged_attn pallas_kv_cache_update prefix_prefill rocm_aiter_mla_sparse triton_decode_attention triton_merge_attn_states triton_reshape_and_cache_flash triton_unified_attention vit_attn_wrappers utils utils fa_utils kv_sharing_utils kv_transfer_utils benchmarks benchmarks datasets latency serve startup throughput lib lib endpoint_request_func ready_checker utils sweep sweep cli param_sweep plot plot_pareto serve serve_sla server sla_sweep utils compilation compilation activation_quant_fusion backends base_static_graph caching collective_fusion compiler_interface counter cuda_graph decorators fix_functionalization fusion fusion_attn fx_utils inductor_pass matcher_utils monitor noop_elimination partition_rules pass_manager piecewise_backend post_cleanup qk_norm_rope_fusion rocm_aiter_fusion sequence_parallelism torch25_custom_graph_pass vllm_inductor_pass wrapper config config attention cache compilation device ec_transfer kv_events kv_transfer load lora model multimodal observability parallel pooler profiler scheduler speculative speech_to_text structured_outputs utils vllm device_allocator device_allocator cumem distributed distributed communication_op kv_events parallel_state tpu_distributed_utils utils device_communicators device_communicators all2all all_reduce_utils base_device_communicator cpu_communicator cuda_communicator cuda_wrapper custom_all_reduce mnnvl_compat pynccl pynccl_allocator pynccl_wrapper quick_all_reduce ray_communicator shm_broadcast shm_object_storage symm_mem tpu_communicator xpu_communicator ec_transfer ec_transfer ec_transfer_state ec_connector ec_connector base example_connector factory eplb eplb async_worker eplb_state rebalance_execute policy policy abstract default kv_transfer kv_transfer kv_transfer_state kv_connector kv_connector base factory utils v1 v1 base decode_bench_connector example_connector lmcache_connector lmcache_mp_connector metrics mooncake_connector multi_connector nixl_connector offloading_connector lmcache_integration lmcache_integration multi_process_adapter utils vllm_v1_adapter p2p p2p p2p_nccl_connector p2p_nccl_engine tensor_memory_pool engine engine arg_utils async_llm_engine llm_engine protocol entrypoints entrypoints api_server chat_utils constants context launcher llm logger renderer responses_utils score_utils ssl tool tool_server utils anthropic anthropic protocol serving_messages cli cli collect_env main openai run_batch serve types benchmark benchmark base latency main serve startup sweep throughput openai openai api_server cli_args orca_metrics protocol run_batch serving_chat serving_chat_stream_harmony serving_completion serving_engine serving_models serving_responses serving_transcription speech_to_text utils parser parser harmony_utils responses_parser pooling pooling classify classify api_router protocol serving embed embed api_router conftest protocol serving pooling pooling api_router protocol serving score score api_router protocol serving sagemaker sagemaker routes serve serve cache cache api_router disagg disagg api_router protocol serving elastic_ep elastic_ep api_router middleware instrumentator instrumentator health metrics server_info lora lora api_router profile profile api_router rlhf rlhf api_router rpc rpc api_router sleep sleep api_router tokenize tokenize api_router serving inputs inputs data parse preprocess logging_utils logging_utils dump_input formatter lazy log_time lora lora lora_model lora_weights model_manager peft_helper request resolver utils worker_manager layers layers base base_linear column_parallel_linear fused_moe logits_processor replicated_linear row_parallel_linear utils vocal_parallel_embedding ops ops ipex_ops ipex_ops lora_ops torch_ops torch_ops lora_ops triton_ops triton_ops fused_moe_lora_op kernel_utils lora_expand_op lora_kernel_metadata lora_shrink_op utils xla_ops xla_ops lora_ops punica_wrapper punica_wrapper punica_base punica_cpu punica_gpu punica_selector punica_tpu punica_xpu utils model_executor model_executor custom_op parameter utils layers layers activation attention_layer_base batch_invariant conv kda layernorm lightning_attn linear logits_processor mla pooler resampler utils vocab_parallel_embedding fla fla ops ops chunk chunk_delta_h chunk_o chunk_scaled_dot_kkt cumsum fused_recurrent index kda l2norm layernorm_guard op solve_tril utils wy_fast fused_moe fused_moe all2all_utils batched_deep_gemm_moe config cpu_fused_moe cutlass_moe deep_gemm_moe deep_gemm_utils deepep_ht_prepare_finalize deepep_ll_prepare_finalize flashinfer_cutedsl_moe flashinfer_cutlass_moe flashinfer_cutlass_prepare_finalize flashinfer_trtllm_moe fused_batched_moe fused_marlin_moe fused_moe fused_moe_method_base fused_moe_modular_method gpt_oss_triton_kernels_moe layer modular_kernel moe_align_block_size moe_pallas moe_permute_unpermute moe_torch_iterative pplx_prepare_finalize prepare_finalize rocm_aiter_fused_moe routing_simulator shared_fused_moe topk_weight_and_reduce triton_deep_gemm_moe trtllm_moe unquantized_fused_moe_method utils zero_expert_fused_moe mamba mamba abstract linear_attn mamba_mixer mamba_mixer2 mamba_utils short_conv ops ops causal_conv1d layernorm_gated mamba_ssm ssd_bmm ssd_chunk_scan ssd_chunk_state ssd_combined ssd_state_passing quantization quantization auto_round awq awq_marlin awq_triton base_config bitblas bitsandbytes cpu_wna16 deepspeedfp experts_int8 fbgemm_fp8 fp8 fp_quant gguf gptq gptq_bitblas gptq_marlin gptq_marlin_24 hqq_marlin inc input_quant_fp8 ipex_quant kv_cache modelopt moe_wna16 mxfp4 petit ptpc_fp8 qutlass_utils rtn schema torchao tpu_int8 compressed_tensors compressed_tensors compressed_tensors compressed_tensors_moe triton_scaled_mm utils schemes schemes compressed_tensors_24 compressed_tensors_scheme compressed_tensors_w4a4_nvfp4 compressed_tensors_w4a8_fp8 compressed_tensors_w4a8_int compressed_tensors_w4a16_24 compressed_tensors_w4a16_nvfp4 compressed_tensors_w8a8_fp8 compressed_tensors_w8a8_int8 compressed_tensors_w8a16_fp8 compressed_tensors_wNa16 transform transform linear module utils schemes schemes linear_qutlass_nvfp4 kernels kernels mixed_precision mixed_precision allspark bitblas conch cutlass dynamic_4bit exllama MPLinearKernel machete marlin xpu scaled_mm scaled_mm aiter cpu cutlass ScaledMMLinearKernel triton xla quark quark quark quark_moe utils schemes schemes quark_ocp_mx quark_scheme quark_w8a8_fp8 quark_w8a8_int8 utils utils allspark_utils bitblas_utils flashinfer_fp4_moe flashinfer_utils fp8_utils gptq_utils int8_utils layer_utils machete_utils marlin_utils marlin_utils_fp4 marlin_utils_fp8 marlin_utils_test marlin_utils_test_24 mxfp4_utils mxfp6_utils mxfp8_utils nvfp4_emulation_utils nvfp4_moe_support ocp_mx_utils petit_utils quant_utils w8a8_utils rotary_embedding rotary_embedding base common deepseek_scaling_rope dual_chunk_rope dynamic_ntk_alpha_rope dynamic_ntk_scaling_rope ernie45_vl_rope linear_scaling_rope llama3_rope llama4_vision_rope mrope ntk_scaling_rope phi3_long_rope_scaled_rope xdrope yarn_scaling_rope model_loader model_loader base_loader bitsandbytes_loader default_loader dummy_loader gguf_loader online_quantization runai_streamer_loader sharded_state_loader tensorizer tensorizer_loader tpu utils weight_utils models models adapters afmoe aimv2 apertus arcee arctic aria audioflamingo3 aya_vision bagel baichuan bailing_moe bamba bee bert bert_with_rope blip blip2 bloom chameleon chatglm clip cohere2_vision commandr config dbrx deepencoder deepseek_eagle deepseek_mtp deepseek_ocr deepseek_v2 deepseek_vl2 dots1 dots_ocr ernie45 ernie45_moe ernie45_vl ernie45_vl_moe ernie_mtp exaone exaone4 fairseq2_llama falcon falcon_h1 flex_olmo fuyu gemma gemma2 gemma3 gemma3_mm gemma3n gemma3n_mm glm glm4 glm4_1v glm4_moe glm4_moe_mtp glm4v gpt2 gpt_bigcode gpt_j gpt_neox gpt_oss granite granite_speech granitemoe granitemoehybrid granitemoeshared gritlm grok1 h2ovl hunyuan_v1 hunyuan_vision hyperclovax_vision idefics2_vision_model idefics3 interfaces interfaces_base intern_vit internlm2 internlm2_ve interns1 interns1_vit internvl jais jais2 jamba jina_vl keye keye_vl1_5 kimi_linear kimi_vl lfm2 lfm2_moe lightonocr llama llama4 llama4_eagle llama_eagle llama_eagle3 llava llava_next llava_next_video llava_onevision longcat_flash longcat_flash_mtp mamba mamba2 medusa midashenglm mimo mimo_mtp mimo_v2_flash minicpm minicpm3 minicpm_eagle minicpmo minicpmv minimax_m2 minimax_text_01 minimax_vl_01 mistral3 mistral_large_3 mistral_large_3_eagle mixtral mllama4 mlp_speculator modernbert module_mapping molmo moonvit mpt nano_nemotron_vl nemotron nemotron_h nemotron_nas nemotron_vl nvlm_d olmo olmo2 olmoe opencua openpangu openpangu_mtp opt orion ouro ovis ovis2_5 paddleocr_vl paligemma persimmon phi phi3 phi3v phi4mm phi4mm_audio phi4mm_utils phimoe pixtral plamo2 plamo3 qwen qwen2 qwen2_5_omni_thinker qwen2_5_vl qwen2_audio qwen2_moe qwen2_rm qwen2_vl qwen3 qwen3_moe qwen3_next qwen3_next_mtp qwen3_omni_moe_thinker qwen3_vl qwen3_vl_moe qwen_vl radio registry roberta rvl seed_oss siglip siglip2navit skyworkr1v smolvlm solar stablelm starcoder2 step3_text step3_vl swin tarsier telechat2 teleflm terratorch ultravox utils vision voxtral voxtral_streaming whisper whisper_utils zamba2 transformers transformers base causal legacy moe multimodal pooling utils warmup warmup deep_gemm_warmup kernel_warmup multimodal multimodal audio base cache evs hasher image inputs parse processing profiling registry utils video platforms platforms cpu cuda interface rocm tpu xpu plugins plugins io_processors io_processors interface lora_resolvers lora_resolvers filesystem_resolver profiler profiler layerwise_profile utils wrapper ray ray lazy_utils ray_env reasoning reasoning abs_reasoning_parsers basic_parsers deepseek_r1_reasoning_parser deepseek_v3_reasoning_parser ernie45_reasoning_parser glm4_moe_reasoning_parser gptoss_reasoning_parser granite_reasoning_parser holo2_reasoning_parser hunyuan_a13b_reasoning_parser identity_reasoning_parser minimax_m2_reasoning_parser mistral_reasoning_parser olmo3_reasoning_parser qwen3_reasoning_parser seedoss_reasoning_parser step3_reasoning_parser tokenizers tokenizers deepseek_v32 deepseek_v32_encoding detokenizer_utils hf mistral protocol registry tool_parsers tool_parsers abstract_tool_parser deepseekv3_tool_parser deepseekv31_tool_parser deepseekv32_tool_parser ernie45_tool_parser functiongemma_tool_parser gigachat3_tool_parser glm4_moe_tool_parser glm47_moe_tool_parser granite_20b_fc_tool_parser granite_tool_parser hermes_tool_parser hunyuan_a13b_tool_parser internlm2_tool_parser jamba_tool_parser kimi_k2_tool_parser llama4_pythonic_tool_parser llama_tool_parser longcat_tool_parser minimax_m2_tool_parser minimax_tool_parser mistral_tool_parser olmo3_tool_parser openai_tool_parser phi4mini_tool_parser pythonic_tool_parser qwen3coder_tool_parser qwen3xml_tool_parser seed_oss_tool_parser step3_tool_parser utils xlam_tool_parser transformers_utils transformers_utils config config_parser_base dynamic_module gguf_utils processor repo_utils runai_utils s3_utils tokenizer utils chat_templates chat_templates registry configs configs afmoe arctic bagel chatglm deepseek_vl2 dotsocr eagle falcon flex_olmo hunyuan_vl jais kimi_linear kimi_vl lfm2_moe medusa midashenglm mistral mlp_speculator moonvit nemotron nemotron_h olmo3 ovis qwen3_next radio step3_vl tarsier2 ultravox speculators speculators algos base processors processors bagel deepseek_ocr deepseek_vl2 hunyuan_vl hunyuan_vl_image ovis ovis2_5 triton_utils triton_utils importing usage usage usage_lib utils utils argparse_utils async_utils cache collection_utils counter deep_gemm flashinfer func_utils gc_utils hashing import_utils jsontree math_utils mem_constants mem_utils nccl network_utils nvtx_pytorch_hooks platform_utils profiling registry serial_utils system_utils tensor_schema torch_utils v1 v1 cudagraph_dispatcher kv_cache_interface outputs request serial_utils utils attention attention backends backends cpu_attn flash_attn flashinfer flex_attention gdn_attn linear_attn mamba1_attn mamba2_attn mamba_attn pallas rocm_aiter_fa rocm_aiter_unified_attn rocm_attn short_conv_attn tree_attn triton_attn utils mla mla aiter_triton_mla common cutlass_mla flashattn_mla flashinfer_mla flashmla flashmla_sparse indexer rocm_aiter_mla rocm_aiter_mla_sparse triton_mla core core block_pool encoder_cache_manager kv_cache_coordinator kv_cache_manager kv_cache_metrics kv_cache_utils single_type_kv_cache_manager sched sched async_scheduler interface output request_queue scheduler utils engine engine async_llm coordinator core core_client detokenizer exceptions input_processor llm_engine logprobs output_processor parallel_sampling utils executor executor abstract multiproc_executor ray_distributed_executor ray_executor ray_utils uniproc_executor kv_offload kv_offload abstract arc_manager backend cpu factory lru_manager mediums spec backends backends cpu worker worker cpu_gpu worker metrics metrics loggers perf prometheus ray_wrappers reader stats pool pool metadata sample sample metadata rejection_sampler sampler logits_processor logits_processor builtin interface state ops ops bad_words logprobs penalties topk_topp_sampler tpu tpu metadata sampler spec_decode spec_decode eagle medusa metadata metrics ngram_proposer suffix_decoding utils structured_output structured_output backend_guidance backend_lm_format_enforcer backend_outlines backend_types backend_xgrammar request utils worker worker block_table cp_utils cpu_model_runner cpu_worker dp_utils ec_connector_model_runner_mixin gpu_input_batch gpu_model_runner gpu_ubatch_wrapper gpu_worker kv_connector_model_runner_mixin lora_model_runner_mixin tpu_input_batch tpu_model_runner tpu_worker ubatch_utils ubatching utils worker_base workspace xpu_model_runner xpu_worker gpu gpu async_utils attn_utils block_table cudagraph_utils dp_utils input_batch model_runner states structured_outputs metrics metrics logits sample sample gumbel logprob metadata min_p output penalties sampler spec_decode spec_decode eagle eagle_cudagraph rejection_sample CLI Reference CLI Reference vllm serve vllm chat vllm complete vllm run-batch vllm bench vllm bench vllm bench latency vllm bench serve vllm bench sweep plot vllm bench sweep plot_pareto vllm bench sweep serve vllm bench sweep serve_sla vllm bench throughput Community Community Contact Us Meetups Sponsors Governance Governance Collaboration Policy Committers Governance Process Blog Forum Slack Table of contents TensorMetadata USE_SCHED_YIELD get_context_model_parallel_group logger DeviceCommunicatorBase all2all_backend all2all_manager cpu_group device device_group global_rank global_world_size is_ep_communicator rank rank_in_group ranks unique_name use_all2all world_size __init__ all_gather all_gatherv all_reduce combine destroy dispatch gather prepare_communication_buffer_for_model recv reduce_scatter reduce_scatterv send GraphCaptureContext stream __init__ GroupCoordinator cpu_group device device_communicator device_group first_rank is_first_rank is_last_rank last_rank local_rank mq_broadcaster next_rank prev_rank rank rank_in_group ranks unique_name use_cpu_custom_send_recv use_custom_op_call use_device_communicator world_size __init__ _all_gather_out_place _all_reduce_out_place _reduce_scatter_out_place all_gather all_gatherv all_reduce barrier broadcast broadcast_object broadcast_object_list broadcast_tensor_dict combine create_mq_broadcaster create_single_reader_mq_broadcasters destroy dispatch gather graph_capture prepare_communication_buffer_for_model recv recv_object recv_tensor_dict reduce_scatter reduce_scatterv send send_object send_tensor_dict StatelessProcessGroup broadcast_recv_src_counter broadcast_send_counter data_expiration_seconds entries rank recv_src_counter send_dst_counter socket store world_size __init__ __post_init__ all_gather_obj barrier broadcast_obj create expire_data recv_obj send_obj all_gather all_gather_fake all_reduce all_reduce_fake broadcast_tensor_dict cleanup_dist_env_and_memory destroy_distributed_environment destroy_model_parallel direct_register_custom_op divide ensure_divisibility ensure_model_parallel_initialized get_dcp_group get_decode_context_model_parallel_rank get_decode_context_model_parallel_world_size get_distributed_init_method get_dp_group get_ep_group get_inner_dp_world_group get_node_count get_pcp_group get_pp_group get_pp_indices get_tcp_uri get_tensor_model_parallel_rank get_tensor_model_parallel_world_size get_tp_group get_world_group graph_capture in_the_same_node_as init_distributed_environment init_gloo_process_group init_logger init_model_parallel_group init_world_group initialize_model_parallel is_global_first_rank is_local_first_rank is_torch_equal_or_newer model_parallel_is_initialized patch_tensor_parallel_group patched_fused_scaled_matmul_reduce_scatter patched_fused_scaled_matmul_reduce_scatter_fake prepare_communication_buffer_for_model reduce_scatter reduce_scatter_fake resolve_obj_by_qualname sched_yield set_custom_all_reduce split_tensor_along_last_dim stateless_destroy_torch_distributed_process_group stateless_init_torch_distributed_process_group TODO: ask for help from PyTorch team if we need the operation. supports_custom_op suppress_stdout tensor_model_parallel_all_gather tensor_model_parallel_all_reduce tensor_model_parallel_gather tensor_model_parallel_reduce_scatter vllm.distributed ¶ Modules: Name Description communication_op device_communicators ec_transfer envs eplb Expert parallelism load balancer (EPLB). kv_events kv_transfer parallel_state vLLM distributed state. tpu_distributed_utils utils TensorMetadata module-attribute ¶ TensorMetadata = namedtuple( \"TensorMetadata\", [\"device\", \"dtype\", \"size\"] ) USE_SCHED_YIELD module-attribute ¶ USE_SCHED_YIELD = ( version_info[:3] >= (3, 11, 1) or version_info[:2] == (3, 10) and version_info[2] >= 8 ) get_context_model_parallel_group module-attribute ¶ get_context_model_parallel_group = get_dcp_group logger module-attribute ¶ logger = init_logger(__name__) DeviceCommunicatorBase ¶ Base class for device-specific communicator. It can use the cpu_group to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the device_group will also be given. Source code in vllm/distributed/device_communicators/base_device_communicator.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302class DeviceCommunicatorBase: \"\"\" Base class for device-specific communicator. It can use the `cpu_group` to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the `device_group` will also be given. \"\"\" def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor def destroy(self): pass def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states all2all_backend instance-attribute ¶ all2all_backend = all2all_backend all2all_manager instance-attribute ¶ all2all_manager: All2AllManagerBase | None = None cpu_group instance-attribute ¶ cpu_group = cpu_group device instance-attribute ¶ device = device or device('cpu') device_group instance-attribute ¶ device_group = device_group global_rank instance-attribute ¶ global_rank = get_rank() global_world_size instance-attribute ¶ global_world_size = get_world_size() is_ep_communicator instance-attribute ¶ is_ep_communicator = 'ep' in unique_name rank instance-attribute ¶ rank = get_rank(cpu_group) rank_in_group instance-attribute ¶ rank_in_group = get_group_rank(cpu_group, global_rank) ranks instance-attribute ¶ ranks = get_process_group_ranks(cpu_group) unique_name instance-attribute ¶ unique_name = unique_name use_all2all instance-attribute ¶ use_all2all = is_ep_communicator and use_ep world_size instance-attribute ¶ world_size = get_world_size(cpu_group) __init__ ¶ __init__( cpu_group: ProcessGroup, device: device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ) Source code in vllm/distributed/device_communicators/base_device_communicator.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> Tensor | list[Tensor] Source code in vllm/distributed/device_communicators/base_device_communicator.py 164 165 166 167 168 169 170def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError all_reduce ¶ all_reduce(input_: Tensor) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 135 136 137def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ combine ¶ combine( hidden_states: Tensor, is_sequence_parallel: bool = False, ) -> Tensor Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 295 296 297 298 299 300 301 302def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states destroy ¶ destroy() Source code in vllm/distributed/device_communicators/base_device_communicator.py 260 261def destroy(self): pass dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, ) -> tuple[Tensor, Tensor] Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 283 284 285 286 287 288 289 290 291 292 293def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model( model: Module, ) -> None Prepare the communication buffer for the model. Source code in vllm/distributed/device_communicators/base_device_communicator.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 248 249 250 251 252 253 254 255 256 257 258def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 205 206 207 208def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/device_communicators/base_device_communicator.py 241 242 243 244 245 246def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) GraphCaptureContext dataclass ¶ Source code in vllm/distributed/parallel_state.py 60 61 62@dataclass class GraphCaptureContext: stream: torch.cuda.Stream stream instance-attribute ¶ stream: Stream __init__ ¶ __init__(stream: Stream) -> None GroupCoordinator ¶ PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. Source code in vllm/distributed/parallel_state.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031class GroupCoordinator: \"\"\" PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. \"\"\" # available attributes: rank: int # global rank ranks: list[int] # global ranks in the group world_size: int # size of the group # difference between `local_rank` and `rank_in_group`: # if we have a group of size 4 across two nodes: # Process | Node | Rank | Local Rank | Rank in Group # 0 | 0 | 0 | 0 | 0 # 1 | 0 | 1 | 1 | 1 # 2 | 1 | 2 | 0 | 2 # 3 | 1 | 3 | 1 | 3 local_rank: int # local rank used to assign devices rank_in_group: int # rank inside the group cpu_group: ProcessGroup # group for CPU communication device_group: ProcessGroup # group for device communication # device communicator (if use_device_communicator=True) device_communicator: DeviceCommunicatorBase | None mq_broadcaster: Any | None # shared memory broadcaster def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) @property def first_rank(self): \"\"\"Return the global rank of the first process in the group\"\"\" return self.ranks[0] @property def last_rank(self): \"\"\"Return the global rank of the last process in the group\"\"\" return self.ranks[-1] @property def is_first_rank(self): \"\"\"Return whether the caller is the first process in the group\"\"\" return self.rank == self.first_rank @property def is_last_rank(self): \"\"\"Return whether the caller is the last process in the group\"\"\" return self.rank == self.last_rank @property def next_rank(self): \"\"\"Return the global rank of the process that follows the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group + 1) % world_size] @property def prev_rank(self): \"\"\"Return the global rank of the process that precedes the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group - 1) % world_size] @contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states cpu_group instance-attribute ¶ cpu_group: ProcessGroup = self_cpu_group device instance-attribute ¶ device = device(f'cuda:{local_rank}') device_communicator instance-attribute ¶ device_communicator: DeviceCommunicatorBase | None = None device_group instance-attribute ¶ device_group: ProcessGroup = self_device_group first_rank property ¶ first_rank Return the global rank of the first process in the group is_first_rank property ¶ is_first_rank Return whether the caller is the first process in the group is_last_rank property ¶ is_last_rank Return whether the caller is the last process in the group last_rank property ¶ last_rank Return the global rank of the last process in the group local_rank instance-attribute ¶ local_rank: int = local_rank mq_broadcaster instance-attribute ¶ mq_broadcaster: MessageQueue | None = None next_rank property ¶ next_rank Return the global rank of the process that follows the caller prev_rank property ¶ prev_rank Return the global rank of the process that precedes the caller rank instance-attribute ¶ rank: int = get_rank() rank_in_group instance-attribute ¶ rank_in_group: int ranks instance-attribute ¶ ranks: list[int] unique_name instance-attribute ¶ unique_name = _get_unique_name(group_name) use_cpu_custom_send_recv instance-attribute ¶ use_cpu_custom_send_recv = is_cpu() and hasattr( _C, \"init_shm_manager\" ) use_custom_op_call instance-attribute ¶ use_custom_op_call = is_cuda_alike() or is_tpu() use_device_communicator instance-attribute ¶ use_device_communicator = use_device_communicator world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, use_message_queue_broadcaster: bool = False, group_name: str | None = None, ) Source code in vllm/distributed/parallel_state.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) _all_gather_out_place ¶ _all_gather_out_place(input_: Tensor, dim: int) -> Tensor Source code in vllm/distributed/parallel_state.py 525 526 527 528def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) _all_reduce_out_place ¶ _all_reduce_out_place(input_: Tensor) -> Tensor Source code in vllm/distributed/parallel_state.py 504 505 506 507def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) _reduce_scatter_out_place ¶ _reduce_scatter_out_place( input_: Tensor, dim: int ) -> Tensor Source code in vllm/distributed/parallel_state.py 563 564 565 566def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) Source code in vllm/distributed/parallel_state.py 530 531 532 533 534 535 536 537 538def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) all_reduce ¶ all_reduce(input_: Tensor) -> Tensor User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (self in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. Source code in vllm/distributed/parallel_state.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) barrier ¶ barrier() Barrier synchronization among the group. NOTE: don't use device_group here! barrier in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. Source code in vllm/distributed/parallel_state.py 964 965 966 967 968 969 970 971def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) broadcast ¶ broadcast(input_: Tensor, src: int = 0) Broadcast the input tensor. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ broadcast_object ¶ broadcast_object(obj: Any | None = None, src: int = 0) Broadcast the input object. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] broadcast_object_list ¶ broadcast_object_list( obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None, ) Broadcast the input object list. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[str, Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, Tensor | Any] | None Broadcast the input tensor dictionary. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict combine ¶ combine( hidden_states, is_sequence_parallel: bool = False ) -> Tensor Source code in vllm/distributed/parallel_state.py 1025 1026 1027 1028 1029 1030 1031def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states create_mq_broadcaster ¶ create_mq_broadcaster( writer_rank=0, external_writer_handle=None, blocking=True, ) Source code in vllm/distributed/parallel_state.py 389 390 391 392 393 394 395 396 397 398 399 400 401def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) create_single_reader_mq_broadcasters ¶ create_single_reader_mq_broadcasters( reader_rank_in_group=0, blocking=False ) Source code in vllm/distributed/parallel_state.py 403 404 405 406 407 408 409 410 411 412 413 414def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) destroy ¶ destroy() Source code in vllm/distributed/parallel_state.py 989 990 991 992 993 994 995 996 997 998 999def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, extra_tensors: list[Tensor] | None = None, ) -> ( tuple[Tensor, Tensor] | tuple[Tensor, Tensor, list[Tensor]] ) Source code in vllm/distributed/parallel_state.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/parallel_state.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) graph_capture ¶ graph_capture( graph_capture_context: GraphCaptureContext | None = None, ) Source code in vllm/distributed/parallel_state.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478@contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Source code in vllm/distributed/parallel_state.py 1001 1002 1003def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/parallel_state.py 980 981 982 983 984 985 986 987def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) recv_object ¶ recv_object(src: int) -> Any Receive the input object list from the source rank. Source code in vllm/distributed/parallel_state.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj recv_tensor_dict ¶ recv_tensor_dict( src: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Recv the input tensor dictionary. NOTE: src is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/parallel_state.py 556 557 558 559 560 561def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/parallel_state.py 973 974 975 976 977 978def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) send_object ¶ send_object(obj: Any, dst: int) -> None Send the input object list to the destination rank. Source code in vllm/distributed/parallel_state.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None send_tensor_dict ¶ send_tensor_dict( tensor_dict: dict[str, Tensor | Any], dst: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Send the input tensor dictionary. NOTE: dst is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None StatelessProcessGroup dataclass ¶ A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. Source code in vllm/distributed/utils.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@dataclasses.dataclass class StatelessProcessGroup: \"\"\"A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. \"\"\" rank: int world_size: int store: torch._C._distributed_c10d.Store # stores a reference to the socket so that the file descriptor stays alive socket: socket.socket | None data_expiration_seconds: int = 3600 # 1 hour # dst rank -> counter send_dst_counter: dict[int, int] = dataclasses.field(default_factory=dict) # src rank -> counter recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) broadcast_send_counter: int = 0 broadcast_recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) # A deque to store the data entries, with key and timestamp. entries: deque[tuple[str, float]] = dataclasses.field(default_factory=deque) def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") @staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) broadcast_recv_src_counter class-attribute instance-attribute ¶ broadcast_recv_src_counter: dict[int, int] = field( default_factory=dict ) broadcast_send_counter class-attribute instance-attribute ¶ broadcast_send_counter: int = 0 data_expiration_seconds class-attribute instance-attribute ¶ data_expiration_seconds: int = 3600 entries class-attribute instance-attribute ¶ entries: deque[tuple[str, float]] = field( default_factory=deque ) rank instance-attribute ¶ rank: int recv_src_counter class-attribute instance-attribute ¶ recv_src_counter: dict[int, int] = field( default_factory=dict ) send_dst_counter class-attribute instance-attribute ¶ send_dst_counter: dict[int, int] = field( default_factory=dict ) socket instance-attribute ¶ socket: socket | None store instance-attribute ¶ store: Store world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( rank: int, world_size: int, store: Store, socket: socket | None, data_expiration_seconds: int = 3600, send_dst_counter: dict[int, int] = dict(), recv_src_counter: dict[int, int] = dict(), broadcast_send_counter: int = 0, broadcast_recv_src_counter: dict[int, int] = dict(), entries: deque[tuple[str, float]] = deque(), ) -> None __post_init__ ¶ __post_init__() Source code in vllm/distributed/utils.py 169 170 171 172 173def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} all_gather_obj ¶ all_gather_obj(obj: Any) -> list[Any] All gather an object from all ranks. Source code in vllm/distributed/utils.py 220 221 222 223 224 225 226 227 228 229 230def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs barrier ¶ barrier(timeout: float = 30.0) A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: Each process signals it has reached the barrier Each process signals that it has confirmed the arrival of all other ranks. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Parameters: Name Type Description Default timeout float Maximum time in seconds to wait for each phase (in seconds) 30.0 Raises: Type Description RuntimeError If coordination fails or times out Source code in vllm/distributed/utils.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") broadcast_obj ¶ broadcast_obj(obj: Any | None, src: int) -> Any Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. Source code in vllm/distributed/utils.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj create staticmethod ¶ create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> StatelessProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. If we have process A and process B called torch.distributed.init_process_group to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. torch.distributed.init_process_group is a global call, while this function is a stateless call. It will return a StatelessProcessGroup object that can be used for exchanging metadata. With this function, process A and process B can call StatelessProcessGroup.create to form a group, and then process A, B, C, and D can call StatelessProcessGroup.create to form another group. Source code in vllm/distributed/utils.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) expire_data ¶ expire_data() Expire data that is older than data_expiration_seconds seconds. Source code in vllm/distributed/utils.py 183 184 185 186 187 188 189 190 191 192def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break recv_obj ¶ recv_obj(src: int) -> Any Receive an object from a source rank. Source code in vllm/distributed/utils.py 194 195 196 197 198 199 200def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj send_obj ¶ send_obj(obj: Any, dst: int) Send an object to a destination rank. Source code in vllm/distributed/utils.py 175 176 177 178 179 180 181def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) all_gather ¶ all_gather( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 147 148 149 150 151 152 153 154def all_gather( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_gather_out_place(tensor, dim) all_gather_fake ¶ all_gather_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 157 158 159 160 161 162def all_gather_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] * world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) all_reduce ¶ all_reduce(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 117 118 119 120 121 122def all_reduce(tensor: torch.Tensor, group_name: str) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_reduce_out_place(tensor) all_reduce_fake ¶ all_reduce_fake(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 125 126def all_reduce_fake(tensor: torch.Tensor, group_name: str) -> torch.Tensor: return torch.empty_like(tensor) broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[Any, Tensor | Any] | None = None, src: int = 0, ) Source code in vllm/distributed/communication_op.py 38 39 40 41 42 43def broadcast_tensor_dict( tensor_dict: dict[Any, torch.Tensor | Any] | None = None, src: int = 0 ): if not torch.distributed.is_initialized(): return tensor_dict return get_tp_group().broadcast_tensor_dict(tensor_dict, src) cleanup_dist_env_and_memory ¶ cleanup_dist_env_and_memory(shutdown_ray: bool = False) Source code in vllm/distributed/parallel_state.py 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617def cleanup_dist_env_and_memory(shutdown_ray: bool = False): # Reset environment variable cache envs.disable_envs_cache() # Ensure all objects are not frozen before cleanup gc.unfreeze() destroy_model_parallel() destroy_distributed_environment() if shutdown_ray: import ray # Lazy import Ray ray.shutdown() gc.collect() from vllm.platforms import current_platform empty_cache = current_platform.empty_cache if empty_cache is not None: empty_cache() try: if not current_platform.is_cpu(): torch._C._host_emptyCache() except AttributeError: logger.warning(\"torch._C._host_emptyCache() only available in Pytorch >=2.5\") destroy_distributed_environment ¶ destroy_distributed_environment() Source code in vllm/distributed/parallel_state.py 1585 1586 1587 1588 1589 1590 1591 1592def destroy_distributed_environment(): global _WORLD, _NODE_COUNT if _WORLD: _WORLD.destroy() _WORLD = None _NODE_COUNT = None if torch.distributed.is_initialized(): torch.distributed.destroy_process_group() destroy_model_parallel ¶ destroy_model_parallel() Set the groups to none and destroy them. Source code in vllm/distributed/parallel_state.py 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582def destroy_model_parallel(): \"\"\"Set the groups to none and destroy them.\"\"\" global _TP if _TP: _TP.destroy() _TP = None global _DCP if _DCP: _DCP.destroy() _DCP = None global _PCP if _PCP: _PCP.destroy() _PCP = None global _PP if _PP: _PP.destroy() _PP = None global _DP if _DP: _DP.destroy() _DP = None global _EP if _EP: _EP.destroy() _EP = None direct_register_custom_op ¶ direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[Tag, ...] = (), ) torch.library.custom_op can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the target_lib argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. Source code in vllm/utils/torch_utils.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727def direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[torch.Tag, ...] = (), ): \"\"\" `torch.library.custom_op` can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the `target_lib` argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. \"\"\" if not supports_custom_op(): from vllm.platforms import current_platform assert not current_platform.is_cuda_alike(), ( \"cuda platform needs torch>=2.4 to support custom op, \" \"chances are you are using an old version of pytorch \" \"or a custom build of pytorch. It is recommended to \" \"use vLLM in a fresh new environment and let it install \" \"the required dependencies.\" ) return if mutates_args is None: mutates_args = [] if dispatch_key is None: from vllm.platforms import current_platform dispatch_key = current_platform.dispatch_key schema_str = infer_schema(op_func, mutates_args=mutates_args) my_lib = target_lib or vllm_lib my_lib.define(op_name + schema_str, tags=tags) my_lib.impl(op_name, op_func, dispatch_key=dispatch_key) if fake_impl is not None: my_lib._register_fake(op_name, fake_impl) divide ¶ divide(numerator, denominator) Ensure that numerator is divisible by the denominator and return the division value. Source code in vllm/distributed/utils.py 60 61 62 63 64def divide(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator and return the division value.\"\"\" ensure_divisibility(numerator, denominator) return numerator // denominator ensure_divisibility ¶ ensure_divisibility(numerator, denominator) Ensure that numerator is divisible by the denominator. Source code in vllm/distributed/utils.py 53 54 55 56 57def ensure_divisibility(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator.\"\"\" assert numerator % denominator == 0, \"{} is not divisible by {}\".format( numerator, denominator ) ensure_model_parallel_initialized ¶ ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470def ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\"Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. \"\"\" backend = backend or torch.distributed.get_backend(get_world_group().device_group) if not model_parallel_is_initialized(): initialize_model_parallel( tensor_model_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, decode_context_model_parallel_size, backend, ) return assert get_tensor_model_parallel_world_size() == tensor_model_parallel_size, ( \"tensor parallel group already initialized, but of unexpected size. \" f\"got: {get_tensor_model_parallel_world_size()=} vs. \" f\"wanted: {tensor_model_parallel_size=}\" ) pp_world_size = get_pp_group().world_size assert pp_world_size == pipeline_model_parallel_size, ( \"pipeline parallel group already initialized, but of unexpected size. \" f\"got: {pp_world_size=} vs. \" f\"wanted: {pipeline_model_parallel_size=}\" ) pcp_world_size = get_pcp_group().world_size assert pcp_world_size == prefill_context_model_parallel_size, ( \"prefill context parallel group already initialized, but of unexpected size: \" f\"{pcp_world_size=} vs. \" f\"{prefill_context_model_parallel_size=}\" ) get_dcp_group ¶ get_dcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1090 1091 1092def get_dcp_group() -> GroupCoordinator: assert _DCP is not None, \"decode context model parallel group is not initialized\" return _DCP get_decode_context_model_parallel_rank ¶ get_decode_context_model_parallel_rank() Return my rank for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1540 1541 1542def get_decode_context_model_parallel_rank(): \"\"\"Return my rank for the decode context model parallel group.\"\"\" return get_dcp_group().rank_in_group get_decode_context_model_parallel_world_size ¶ get_decode_context_model_parallel_world_size() Return world size for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1535 1536 1537def get_decode_context_model_parallel_world_size(): \"\"\"Return world size for the decode context model parallel group.\"\"\" return get_dcp_group().world_size get_distributed_init_method ¶ get_distributed_init_method(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 130 131def get_distributed_init_method(ip: str, port: int) -> str: return get_tcp_uri(ip, port) get_dp_group ¶ get_dp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1109 1110 1111def get_dp_group() -> GroupCoordinator: assert _DP is not None, \"data parallel group is not initialized\" return _DP get_ep_group ¶ get_ep_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1117 1118 1119def get_ep_group() -> GroupCoordinator: assert _EP is not None, \"expert parallel group is not initialized\" return _EP get_inner_dp_world_group ¶ get_inner_dp_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1044 1045 1046def get_inner_dp_world_group() -> GroupCoordinator: assert _INNER_DP_WORLD is not None, \"inner dp world group is not initialized\" return _INNER_DP_WORLD get_node_count ¶ get_node_count() -> int Return the total number of nodes in the distributed environment. Source code in vllm/distributed/parallel_state.py 1545 1546 1547 1548def get_node_count() -> int: \"\"\"Return the total number of nodes in the distributed environment.\"\"\" assert _NODE_COUNT is not None, \"distributed environment is not initialized\" return _NODE_COUNT get_pcp_group ¶ get_pcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1125 1126 1127def get_pcp_group() -> GroupCoordinator: assert _PCP is not None, \"prefill context parallel group is not initialized\" return _PCP get_pp_group ¶ get_pp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1101 1102 1103def get_pp_group() -> GroupCoordinator: assert _PP is not None, \"pipeline model parallel group is not initialized\" return _PP get_pp_indices ¶ get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int] Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If pp_size > 2 and the number of remaining layers is 0 < x <= pp_size - 2 then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. Source code in vllm/distributed/utils.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140def get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int]: \"\"\"Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If `pp_size > 2` and the number of remaining layers is `0 < x <= pp_size - 2` then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. \"\"\" partition_list_str = envs.VLLM_PP_LAYER_PARTITION if partition_list_str is not None: try: partitions = [int(layer) for layer in partition_list_str.split(\",\")] except ValueError as err: raise ValueError( \"Invalid partition string: {}\".format(partition_list_str) ) from err if len(partitions) != pp_size: raise ValueError(f\"{len(partitions)=} does not match {pp_size=}.\") if sum(partitions) != num_hidden_layers: raise ValueError(f\"{sum(partitions)=} does not match {num_hidden_layers=}.\") else: layers_per_partition = num_hidden_layers // pp_size partitions = [layers_per_partition for _ in range(pp_size)] if remaining_layers := num_hidden_layers % pp_size: for i in range(2, remaining_layers + 2): partitions[-i] += 1 logger.info( \"Hidden layers were unevenly partitioned: [%s]. \" \"This can be manually overridden using the \" \"VLLM_PP_LAYER_PARTITION environment variable\", \",\".join(str(p) for p in partitions), ) start_layer = sum(partitions[:pp_rank]) end_layer = start_layer + partitions[pp_rank] return (start_layer, end_layer) get_tcp_uri ¶ get_tcp_uri(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 134 135 136 137 138def get_tcp_uri(ip: str, port: int) -> str: if is_valid_ipv6_address(ip): return f\"tcp://[{ip}]:{port}\" else: return f\"tcp://{ip}:{port}\" get_tensor_model_parallel_rank ¶ get_tensor_model_parallel_rank() Return my rank for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1530 1531 1532def get_tensor_model_parallel_rank(): \"\"\"Return my rank for the tensor model parallel group.\"\"\" return get_tp_group().rank_in_group get_tensor_model_parallel_world_size ¶ get_tensor_model_parallel_world_size() Return world size for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1525 1526 1527def get_tensor_model_parallel_world_size(): \"\"\"Return world size for the tensor model parallel group.\"\"\" return get_tp_group().world_size get_tp_group ¶ get_tp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1082 1083 1084def get_tp_group() -> GroupCoordinator: assert _TP is not None, \"tensor model parallel group is not initialized\" return _TP get_world_group ¶ get_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1039 1040 1041def get_world_group() -> GroupCoordinator: assert _WORLD is not None, \"world group is not initialized\" return _WORLD graph_capture ¶ graph_capture(device: device) graph_capture is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a GraphCaptureContext object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. Source code in vllm/distributed/parallel_state.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147@contextmanager def graph_capture(device: torch.device): \"\"\" `graph_capture` is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a `GraphCaptureContext` object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. \"\"\" context = GraphCaptureContext(torch.cuda.Stream(device=device)) with get_tp_group().graph_capture(context), get_pp_group().graph_capture(context): yield context in_the_same_node_as ¶ in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0, ) -> list[bool] This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). Source code in vllm/distributed/parallel_state.py 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709def in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0 ) -> list[bool]: \"\"\" This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). \"\"\" if isinstance(pg, ProcessGroup): assert torch.distributed.get_backend(pg) != torch.distributed.Backend.NCCL, ( \"in_the_same_node_as should be tested with a non-NCCL group.\" ) # local rank inside the group rank = torch.distributed.get_rank(group=pg) world_size = torch.distributed.get_world_size(group=pg) # global ranks of the processes in the group ranks = torch.distributed.get_process_group_ranks(pg) else: rank = pg.rank world_size = pg.world_size ranks = list(range(world_size)) # local tensor in each process to store the result is_in_the_same_node = torch.tensor( [0] * world_size, dtype=torch.int32, device=\"cpu\" ) magic_message = b\"magic_message\" shm = None try: with contextlib.suppress(OSError): if rank == source_rank: # create a shared memory segment shm = shared_memory.SharedMemory(create=True, size=128) shm.buf[: len(magic_message)] = magic_message if isinstance(pg, ProcessGroup): torch.distributed.broadcast_object_list( [shm.name], src=ranks[source_rank], group=pg ) else: pg.broadcast_obj(shm.name, src=source_rank) is_in_the_same_node[rank] = 1 else: # try to open the shared memory segment if isinstance(pg, ProcessGroup): recv = [None] torch.distributed.broadcast_object_list( recv, src=ranks[source_rank], group=pg ) name = recv[0] else: name = pg.broadcast_obj(None, src=source_rank) # fix to https://stackoverflow.com/q/62748654/9191338 # Python incorrectly tracks shared memory even if it is not # created by the process. The following patch is a workaround. with patch( \"multiprocessing.resource_tracker.register\", lambda *args, **kwargs: None, ): shm = shared_memory.SharedMemory(name=name) if shm.buf[: len(magic_message)] == magic_message: is_in_the_same_node[rank] = 1 except Exception as e: logger.error(\"Error ignored in is_in_the_same_node: %s\", e) finally: if shm: shm.close() if isinstance(pg, ProcessGroup): torch.distributed.barrier(group=pg) else: pg.barrier() # clean up the shared memory segment with contextlib.suppress(OSError): if rank == source_rank and shm: shm.unlink() if isinstance(pg, ProcessGroup): torch.distributed.all_reduce(is_in_the_same_node, group=pg) aggregated_data = is_in_the_same_node else: aggregated_data = torch.zeros_like(is_in_the_same_node) for i in range(world_size): rank_data = pg.broadcast_obj(is_in_the_same_node, src=i) aggregated_data += rank_data return [x == 1 for x in aggregated_data.tolist()] init_distributed_environment ¶ init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ) Source code in vllm/distributed/parallel_state.py 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275def init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ): logger.debug( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) from vllm.config import get_current_vllm_config config = get_current_vllm_config() if ( config is not None and config.parallel_config.distributed_executor_backend != \"external_launcher\" and ( config.parallel_config.nnodes > 1 or config.parallel_config.data_parallel_size > 1 ) ): parallel_config = config.parallel_config # adjust to take into account data parallelism # offset the rank by the data parallel rank rank = parallel_config.data_parallel_rank * world_size + rank # adjust the world size to take into account data parallelism world_size = parallel_config.world_size_across_dp # Use appropriate IP and port based on configuration if parallel_config.nnodes > 1: ip = parallel_config.master_addr port = parallel_config.master_port distributed_init_method = get_distributed_init_method(ip, port) else: ip = parallel_config.data_parallel_master_ip port = parallel_config.get_next_dp_init_port() distributed_init_method = get_distributed_init_method(ip, port) logger.debug( \"Adjusting world_size=%d rank=%d distributed_init_method=%s for DP\", world_size, rank, distributed_init_method, ) if not torch.distributed.is_initialized(): logger.info( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) assert distributed_init_method is not None, ( \"distributed_init_method must be provided when initializing \" \"distributed environment\" ) if not torch.distributed.is_backend_available(backend): logger.warning( \"Distributed backend %s is not available; falling back to gloo.\", backend, ) assert torch.distributed.is_gloo_available(), ( \"Fallback Gloo backend is not available.\" ) backend = \"gloo\" # this backend is used for WORLD torch.distributed.init_process_group( backend=backend, init_method=distributed_init_method, world_size=world_size, rank=rank, timeout=timeout, ) # set the local rank # local_rank is not available in torch ProcessGroup, # see https://github.com/pytorch/pytorch/issues/122816 if local_rank == -1: # local rank not set, this usually happens in single-node # setting, where we can use rank as local rank local_rank = envs.LOCAL_RANK if distributed_init_method == \"env://\" else rank global _WORLD, _NODE_COUNT, _INNER_DP_WORLD if _WORLD is None: ranks = list(range(torch.distributed.get_world_size())) _WORLD = init_world_group(ranks, local_rank, backend) if config.parallel_config.nnodes > 1: _NODE_COUNT = config.parallel_config.nnodes else: _NODE_COUNT = _node_count(_WORLD.cpu_group) logger.debug(\"Detected %d nodes in the distributed environment\", _NODE_COUNT) else: assert _WORLD.world_size == torch.distributed.get_world_size(), ( \"world group already initialized with a different world size\" ) if config.parallel_config.nnodes_within_dp > 1: if parallel_config.data_parallel_size > 1: world_size_inner_dp = parallel_config.world_size group_ranks = [ [dp_rank * world_size_inner_dp + i for i in range(world_size_inner_dp)] for dp_rank in range(parallel_config.data_parallel_size) ] _INNER_DP_WORLD = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"inner_dp_world\", use_device_communicator=False, ) else: _INNER_DP_WORLD = _WORLD init_gloo_process_group ¶ init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup Stateless init ProcessGroup with gloo backend compatible with different torch versions. Source code in vllm/distributed/utils.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459def init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup: \"\"\" Stateless init ProcessGroup with gloo backend compatible with different torch versions. \"\"\" with suppress_stdout(): if is_torch_equal_or_newer(\"2.6\"): pg = ProcessGroup( prefix_store, group_rank, group_size, ) else: options = ProcessGroup.Options(backend=\"gloo\") pg = ProcessGroup( prefix_store, group_rank, group_size, options, ) from torch.distributed.distributed_c10d import ProcessGroupGloo backend_class = ProcessGroupGloo( prefix_store, group_rank, group_size, timeout=timeout ) backend_type = ProcessGroup.BackendType.GLOO device = torch.device(\"cpu\") if is_torch_equal_or_newer(\"2.6\"): # _set_default_backend is supported in torch >= 2.6 pg._set_default_backend(backend_type) backend_class._set_sequence_number_for_group() pg._register_backend(device, backend_type, backend_class) return pg init_logger ¶ init_logger(name: str) -> _VllmLogger The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured. Source code in vllm/logger.py 206 207 208 209 210 211 212 213 214 215 216def init_logger(name: str) -> _VllmLogger: \"\"\"The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured.\"\"\" logger = logging.getLogger(name) for method_name, method in _METHODS_TO_PATCH.items(): setattr(logger, method_name, MethodType(method, logger)) return cast(_VllmLogger, logger) init_model_parallel_group ¶ init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076def init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator: return GroupCoordinator( group_ranks=group_ranks, local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=use_device_communicator, use_message_queue_broadcaster=use_message_queue_broadcaster, group_name=group_name, ) init_world_group ¶ init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058def init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator: return GroupCoordinator( group_ranks=[ranks], local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=False, group_name=\"world\", ) initialize_model_parallel ¶ initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Initialize model parallel groups. Parameters: Name Type Description Default tensor_model_parallel_size int number of GPUs used for tensor model parallelism. 1 pipeline_model_parallel_size int number of GPUs used for pipeline model parallelism. 1 backend str | None name of torch distributed communication backend. None Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. Source code in vllm/distributed/parallel_state.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429def initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\" Initialize model parallel groups. Arguments: tensor_model_parallel_size: number of GPUs used for tensor model parallelism. pipeline_model_parallel_size: number of GPUs used for pipeline model parallelism. backend: name of torch distributed communication backend. Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. \"\"\" # Get world size and rank. Ensure some consistencies. assert torch.distributed.is_initialized() world_size: int = torch.distributed.get_world_size() rank = torch.distributed.get_rank() backend = backend or torch.distributed.get_backend(get_world_group().device_group) data_parallel_size = 1 from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: data_parallel_size = config.parallel_config.data_parallel_size # the layout order is: ExternalDP x DP x PP x TP # ExternalDP is the data parallel group that is not part of the model, # every dp rank can generate independently (in verl integration). # DP is the data parallel group that is part of the model, # all the ranks in the same DP group should generate simultaneously, # i.e. the `generate` call in the same DP group should be called together, # otherwise it will cause deadlock. # to get group_ranks for each dimension, transpose that dimension to the # last dimension, then reshape to 2D, then unbind the last dimension all_ranks = torch.arange(world_size).reshape( -1, data_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, tensor_model_parallel_size, ) # noqa # Build the tensor model-parallel groups. global _TP assert _TP is None, \"tensor model parallel group is already initialized\" group_ranks = all_ranks.view(-1, tensor_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] # message queue broadcaster is only used in tensor model parallel group _TP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"tp\", ) # Build the DCP model-parallel groups. global _DCP assert _DCP is None, \"decode context model parallel group is already initialized\" # Note(hc): In the current implementation of decode context parallel, # dcp_size must not exceed tp_size, because the world size does not # change by DCP, it simply reuses the GPUs of TP group, and split one # TP group into tp_size//dcp_size DCP groups. group_ranks = all_ranks.reshape(-1, decode_context_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"dcp\", ) global _PCP assert _PCP is None, \"prefill context parallel group is already initialized\" group_ranks = ( all_ranks.transpose(3, 4) .reshape(-1, prefill_context_model_parallel_size) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pcp\" ) # Build the pipeline model-parallel groups. global _PP assert _PP is None, \"pipeline model parallel group is already initialized\" group_ranks = ( all_ranks.transpose(2, 4).reshape(-1, pipeline_model_parallel_size).unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pp\" ) global _DP assert _DP is None, \"data parallel group is already initialized\" group_ranks = all_ranks.transpose(1, 4).reshape(-1, data_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"dp\" ) global _EP assert _EP is None, \"expert parallel group is already initialized\" group_ranks = ( all_ranks.transpose(1, 2) .reshape( -1, data_parallel_size * prefill_context_model_parallel_size * tensor_model_parallel_size, ) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _EP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"ep\" ) logger.info_once( \"rank %s in world size %s is assigned as \" \"DP rank %s, PP rank %s, PCP rank %s, \" \"TP rank %s, EP rank %s\", rank, world_size, _DP.rank_in_group, _PP.rank_in_group, _PCP.rank_in_group, _TP.rank_in_group, _EP.rank_in_group, ) is_global_first_rank ¶ is_global_first_rank() -> bool Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like get_tensor_model_parallel_rank() == 0 or get_pp_group().is_first_rank, this function checks the global rank across all parallelism dimensions. Returns: Name Type Description bool bool True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). Source code in vllm/distributed/parallel_state.py 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740def is_global_first_rank() -> bool: \"\"\" Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like `get_tensor_model_parallel_rank() == 0` or `get_pp_group().is_first_rank`, this function checks the global rank across all parallelism dimensions. Returns: bool: True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). \"\"\" try: # If world group is available, use it for the most accurate check global _WORLD if _WORLD is not None: return _WORLD.is_first_rank # If torch distributed is not initialized, assume single process if not torch.distributed.is_initialized(): return True # Fallback to torch's global rank return torch.distributed.get_rank() == 0 except Exception: # If anything goes wrong, assume this is the first rank return True is_local_first_rank ¶ is_local_first_rank() -> bool Check if the current process is the first local rank (rank 0 on its node). Source code in vllm/distributed/parallel_state.py 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763def is_local_first_rank() -> bool: \"\"\" Check if the current process is the first local rank (rank 0 on its node). \"\"\" try: # prefer the initialized world group if available global _WORLD if _WORLD is not None: return _WORLD.local_rank == 0 if not torch.distributed.is_initialized(): return True # fallback to environment-provided local rank if available # note: envs.LOCAL_RANK is set when using env:// launchers (e.g., torchrun) try: return int(envs.LOCAL_RANK) == 0 # type: ignore[arg-type] except Exception: return torch.distributed.get_rank() == 0 except Exception: return True is_torch_equal_or_newer ¶ is_torch_equal_or_newer(target: str) -> bool Check if the installed torch version is >= the target version. Parameters: Name Type Description Default target str a version string, like \"2.6.0\". required Returns: Type Description bool Whether the condition meets. Source code in vllm/utils/torch_utils.py 610 611 612 613 614 615 616 617 618 619 620 621 622 623def is_torch_equal_or_newer(target: str) -> bool: \"\"\"Check if the installed torch version is >= the target version. Args: target: a version string, like \"2.6.0\". Returns: Whether the condition meets. \"\"\" try: return _is_torch_equal_or_newer(str(torch.__version__), target) except Exception: # Fallback to PKG-INFO to load the package info, needed by the doc gen. return Version(importlib.metadata.version(\"torch\")) >= Version(target) model_parallel_is_initialized ¶ model_parallel_is_initialized() Check if tensor and pipeline parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1492 1493 1494def model_parallel_is_initialized(): \"\"\"Check if tensor and pipeline parallel groups are initialized.\"\"\" return _TP is not None and _PP is not None patch_tensor_parallel_group ¶ patch_tensor_parallel_group(tp_group: GroupCoordinator) Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Parameters: Name Type Description Default tp_group GroupCoordinator the tp group coordinator required Source code in vllm/distributed/parallel_state.py 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522@contextmanager def patch_tensor_parallel_group(tp_group: GroupCoordinator): \"\"\"Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Args: tp_group (GroupCoordinator): the tp group coordinator \"\"\" global _TP_STATE_PATCHED assert not _TP_STATE_PATCHED, \"Should not call when it's already patched\" _TP_STATE_PATCHED = True old_tp_group = get_tp_group() global _TP _TP = tp_group try: yield finally: # restore the original state _TP_STATE_PATCHED = False _TP = old_tp_group patched_fused_scaled_matmul_reduce_scatter ¶ patched_fused_scaled_matmul_reduce_scatter( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246def patched_fused_scaled_matmul_reduce_scatter( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: return torch.ops.symm_mem.fused_scaled_matmul_reduce_scatter( A, B, A_scale, B_scale, reduce_op, orig_scatter_dim, scatter_dim_after_maybe_reshape, group_name, output_shape, bias, result_scale, out_dtype, use_fast_accum, ) patched_fused_scaled_matmul_reduce_scatter_fake ¶ patched_fused_scaled_matmul_reduce_scatter_fake( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214def patched_fused_scaled_matmul_reduce_scatter_fake( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: # Copied from # https://github.com/pytorch/pytorch/blob/50c338c2da905062449e4d9ac807832d1b5cd90e/torch/distributed/_symmetric_memory/__init__.py#L1189 if A_scale.numel() > 1: if A_scale.shape[:-1] != A.shape[:-1]: raise ValueError( \"For row-wise scaling, the leading dims of A_scale \" \"must match the leading dims of A \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) A_scale = A_scale.flatten(0, -2).contiguous() elif A_scale.numel() != 1: raise ValueError( \"Invalid A_scale shape \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) C = torch._scaled_mm( A.flatten(0, -2).contiguous(), B, A_scale, B_scale, bias, result_scale, out_dtype, use_fast_accum, ) C = C.view(*output_shape[:-1], B.shape[1]) res = funcol.reduce_scatter_tensor( C, reduce_op, orig_scatter_dim, # need original scatter dim for 3D+ output tensor here group_name, ) res = funcol.wait_tensor(res) return res prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. Source code in vllm/distributed/parallel_state.py 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489def prepare_communication_buffer_for_model(model: torch.nn.Module): \"\"\"Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. \"\"\" if _TP is not None: _TP.prepare_communication_buffer_for_model(model) if _PCP is not None: _PCP.prepare_communication_buffer_for_model(model) if _PP is not None: _PP.prepare_communication_buffer_for_model(model) if _DP is not None: _DP.prepare_communication_buffer_for_model(model) if _EP is not None: _EP.prepare_communication_buffer_for_model(model) reduce_scatter ¶ reduce_scatter( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 129 130 131 132 133 134 135 136def reduce_scatter( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._reduce_scatter_out_place(tensor, dim) reduce_scatter_fake ¶ reduce_scatter_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 139 140 141 142 143 144def reduce_scatter_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] // world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) resolve_obj_by_qualname ¶ resolve_obj_by_qualname(qualname: str) -> Any Resolve an object by its fully-qualified class name. Source code in vllm/utils/import_utils.py 117 118 119 120 121 122 123def resolve_obj_by_qualname(qualname: str) -> Any: \"\"\" Resolve an object by its fully-qualified class name. \"\"\" module_name, obj_name = qualname.rsplit(\".\", 1) module = importlib.import_module(module_name) return getattr(module, obj_name) sched_yield ¶ sched_yield() Source code in vllm/distributed/utils.py 46 47 48 49 50def sched_yield(): if USE_SCHED_YIELD: os.sched_yield() else: time.sleep(0) set_custom_all_reduce ¶ set_custom_all_reduce(enable: bool) Source code in vllm/distributed/parallel_state.py 1155 1156 1157def set_custom_all_reduce(enable: bool): global _ENABLE_CUSTOM_ALL_REDUCE _ENABLE_CUSTOM_ALL_REDUCE = enable split_tensor_along_last_dim ¶ split_tensor_along_last_dim( tensor: Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[Tensor] Split a tensor along its last dimension. Parameters: Name Type Description Default tensor Tensor input tensor. required num_partitions int number of partitions to split the tensor required contiguous_split_chunks bool If True, make each chunk contiguous in memory. False Returns: Type Description Sequence[Tensor] A list of Tensors Source code in vllm/distributed/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92def split_tensor_along_last_dim( tensor: torch.Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[torch.Tensor]: \"\"\"Split a tensor along its last dimension. Arguments: tensor: input tensor. num_partitions: number of partitions to split the tensor contiguous_split_chunks: If True, make each chunk contiguous in memory. Returns: A list of Tensors \"\"\" # Get the size and dimension. last_dim = tensor.dim() - 1 last_dim_size = divide(tensor.size()[last_dim], num_partitions) # Split. tensor_list = torch.split(tensor, last_dim_size, dim=last_dim) # NOTE: torch.split does not create contiguous tensors by default. if contiguous_split_chunks: return tuple(chunk.contiguous() for chunk in tensor_list) return tensor_list stateless_destroy_torch_distributed_process_group ¶ stateless_destroy_torch_distributed_process_group( pg: ProcessGroup, ) -> None Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). Source code in vllm/distributed/utils.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545def stateless_destroy_torch_distributed_process_group(pg: ProcessGroup) -> None: \"\"\" Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). \"\"\" if is_torch_equal_or_newer(\"2.7\"): pg.shutdown() else: # Lazy import for non-CUDA backends. from torch.distributed.distributed_c10d import _shutdown_backend _shutdown_backend(pg) _unregister_process_group(pg.group_name) stateless_init_torch_distributed_process_group ¶ stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str, ) -> ProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. The created ProcessGroup object can be used for some operations such as allreduce, because it does not depend on the global rank. However, some operations such as broadcast cannot be used because it depends on the global rank. TODO: ask for help from PyTorch team if we need the broadcast operation.¶ This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. Source code in vllm/distributed/utils.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529def stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str ) -> ProcessGroup: \"\"\" A replacement for `torch.distributed.init_process_group` that does not pollute the global state. The created ProcessGroup object can be used for some operations such as `allreduce`, because it does not depend on the global rank. However, some operations such as `broadcast` cannot be used because it depends on the global rank. # TODO: ask for help from PyTorch team if we need the `broadcast` operation. This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. \"\"\" init_method = get_tcp_uri(host, port) backend = Backend(backend) # it is basically string timeout = _get_default_timeout(backend) store, rank, world_size = next( rendezvous(init_method, rank, world_size, timeout=timeout) ) store.set_timeout(timeout) group_rank = rank group_size = world_size # Use a PrefixStore to avoid accidental overrides of keys used by # different systems (e.g. RPC) in case the store is multi-tenant. prefix_store = PrefixStore(init_method, store) try: from vllm.platforms import current_platform return current_platform.stateless_init_device_torch_dist_pg( backend=backend, prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) except NotImplementedError: # If platform doesn't implement stateless_init_device_torch_dist_pg, it # will raise a NotImplementedError. In this case, we fall back to gloo. return init_gloo_process_group( prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) supports_custom_op ¶ supports_custom_op() -> bool Source code in vllm/utils/torch_utils.py 669 670def supports_custom_op() -> bool: return hasattr(torch.library, \"custom_op\") suppress_stdout ¶ suppress_stdout() Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") Source code in vllm/utils/system_utils.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89@contextlib.contextmanager def suppress_stdout(): \"\"\" Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example: with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") \"\"\" # Don't suppress if logging level is DEBUG if envs.VLLM_LOGGING_LEVEL == \"DEBUG\": yield return stdout_fd = sys.stdout.fileno() stdout_dup = os.dup(stdout_fd) devnull_fd = os.open(os.devnull, os.O_WRONLY) try: sys.stdout.flush() os.dup2(devnull_fd, stdout_fd) yield finally: sys.stdout.flush() os.dup2(stdout_dup, stdout_fd) os.close(stdout_dup) os.close(devnull_fd) tensor_model_parallel_all_gather ¶ tensor_model_parallel_all_gather( input_: Tensor, dim: int = -1 ) -> Tensor All-gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 17 18 19 20 21def tensor_model_parallel_all_gather( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"All-gather the input tensor across model parallel group.\"\"\" return get_tp_group().all_gather(input_, dim) tensor_model_parallel_all_reduce ¶ tensor_model_parallel_all_reduce(input_: Tensor) -> Tensor All-reduce the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 12 13 14def tensor_model_parallel_all_reduce(input_: torch.Tensor) -> torch.Tensor: \"\"\"All-reduce the input tensor across model parallel group.\"\"\" return get_tp_group().all_reduce(input_) tensor_model_parallel_gather ¶ tensor_model_parallel_gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None Gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 31 32 33 34 35def tensor_model_parallel_gather( input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\"Gather the input tensor across model parallel group.\"\"\" return get_tp_group().gather(input_, dst, dim) tensor_model_parallel_reduce_scatter ¶ tensor_model_parallel_reduce_scatter( input_: Tensor, dim: int = -1 ) -> Tensor Reduce-Scatter the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 24 25 26 27 28def tensor_model_parallel_reduce_scatter( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"Reduce-Scatter the input tensor across model parallel group.\"\"\" return get_tp_group().reduce_scatter(input_, dim) December 25, 2025",
      "code": ""
    },
    {
      "description": "vllm.distributed ¶ Modules: Name Description communication_op device_communicators ec_transfer envs eplb Expert parallelism load balancer (EPLB). kv_events kv_transfer parallel_state vLLM distributed state. tpu_distributed_utils utils TensorMetadata module-attribute ¶ TensorMetadata = namedtuple( \"TensorMetadata\", [\"device\", \"dtype\", \"size\"] ) USE_SCHED_YIELD module-attribute ¶ USE_SCHED_YIELD = ( version_info[:3] >= (3, 11, 1) or version_info[:2] == (3, 10) and version_info[2] >= 8 ) get_context_model_parallel_group module-attribute ¶ get_context_model_parallel_group = get_dcp_group logger module-attribute ¶ logger = init_logger(__name__) DeviceCommunicatorBase ¶ Base class for device-specific communicator. It can use the cpu_group to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the device_group will also be given. Source code in vllm/distributed/device_communicators/base_device_communicator.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302class DeviceCommunicatorBase: \"\"\" Base class for device-specific communicator. It can use the `cpu_group` to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the `device_group` will also be given. \"\"\" def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor def destroy(self): pass def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states all2all_backend instance-attribute ¶ all2all_backend = all2all_backend all2all_manager instance-attribute ¶ all2all_manager: All2AllManagerBase | None = None cpu_group instance-attribute ¶ cpu_group = cpu_group device instance-attribute ¶ device = device or device('cpu') device_group instance-attribute ¶ device_group = device_group global_rank instance-attribute ¶ global_rank = get_rank() global_world_size instance-attribute ¶ global_world_size = get_world_size() is_ep_communicator instance-attribute ¶ is_ep_communicator = 'ep' in unique_name rank instance-attribute ¶ rank = get_rank(cpu_group) rank_in_group instance-attribute ¶ rank_in_group = get_group_rank(cpu_group, global_rank) ranks instance-attribute ¶ ranks = get_process_group_ranks(cpu_group) unique_name instance-attribute ¶ unique_name = unique_name use_all2all instance-attribute ¶ use_all2all = is_ep_communicator and use_ep world_size instance-attribute ¶ world_size = get_world_size(cpu_group) __init__ ¶ __init__( cpu_group: ProcessGroup, device: device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ) Source code in vllm/distributed/device_communicators/base_device_communicator.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> Tensor | list[Tensor] Source code in vllm/distributed/device_communicators/base_device_communicator.py 164 165 166 167 168 169 170def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError all_reduce ¶ all_reduce(input_: Tensor) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 135 136 137def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ combine ¶ combine( hidden_states: Tensor, is_sequence_parallel: bool = False, ) -> Tensor Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 295 296 297 298 299 300 301 302def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states destroy ¶ destroy() Source code in vllm/distributed/device_communicators/base_device_communicator.py 260 261def destroy(self): pass dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, ) -> tuple[Tensor, Tensor] Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 283 284 285 286 287 288 289 290 291 292 293def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model( model: Module, ) -> None Prepare the communication buffer for the model. Source code in vllm/distributed/device_communicators/base_device_communicator.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 248 249 250 251 252 253 254 255 256 257 258def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 205 206 207 208def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/device_communicators/base_device_communicator.py 241 242 243 244 245 246def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) GraphCaptureContext dataclass ¶ Source code in vllm/distributed/parallel_state.py 60 61 62@dataclass class GraphCaptureContext: stream: torch.cuda.Stream stream instance-attribute ¶ stream: Stream __init__ ¶ __init__(stream: Stream) -> None GroupCoordinator ¶ PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. Source code in vllm/distributed/parallel_state.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031class GroupCoordinator: \"\"\" PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. \"\"\" # available attributes: rank: int # global rank ranks: list[int] # global ranks in the group world_size: int # size of the group # difference between `local_rank` and `rank_in_group`: # if we have a group of size 4 across two nodes: # Process | Node | Rank | Local Rank | Rank in Group # 0 | 0 | 0 | 0 | 0 # 1 | 0 | 1 | 1 | 1 # 2 | 1 | 2 | 0 | 2 # 3 | 1 | 3 | 1 | 3 local_rank: int # local rank used to assign devices rank_in_group: int # rank inside the group cpu_group: ProcessGroup # group for CPU communication device_group: ProcessGroup # group for device communication # device communicator (if use_device_communicator=True) device_communicator: DeviceCommunicatorBase | None mq_broadcaster: Any | None # shared memory broadcaster def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) @property def first_rank(self): \"\"\"Return the global rank of the first process in the group\"\"\" return self.ranks[0] @property def last_rank(self): \"\"\"Return the global rank of the last process in the group\"\"\" return self.ranks[-1] @property def is_first_rank(self): \"\"\"Return whether the caller is the first process in the group\"\"\" return self.rank == self.first_rank @property def is_last_rank(self): \"\"\"Return whether the caller is the last process in the group\"\"\" return self.rank == self.last_rank @property def next_rank(self): \"\"\"Return the global rank of the process that follows the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group + 1) % world_size] @property def prev_rank(self): \"\"\"Return the global rank of the process that precedes the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group - 1) % world_size] @contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states cpu_group instance-attribute ¶ cpu_group: ProcessGroup = self_cpu_group device instance-attribute ¶ device = device(f'cuda:{local_rank}') device_communicator instance-attribute ¶ device_communicator: DeviceCommunicatorBase | None = None device_group instance-attribute ¶ device_group: ProcessGroup = self_device_group first_rank property ¶ first_rank Return the global rank of the first process in the group is_first_rank property ¶ is_first_rank Return whether the caller is the first process in the group is_last_rank property ¶ is_last_rank Return whether the caller is the last process in the group last_rank property ¶ last_rank Return the global rank of the last process in the group local_rank instance-attribute ¶ local_rank: int = local_rank mq_broadcaster instance-attribute ¶ mq_broadcaster: MessageQueue | None = None next_rank property ¶ next_rank Return the global rank of the process that follows the caller prev_rank property ¶ prev_rank Return the global rank of the process that precedes the caller rank instance-attribute ¶ rank: int = get_rank() rank_in_group instance-attribute ¶ rank_in_group: int ranks instance-attribute ¶ ranks: list[int] unique_name instance-attribute ¶ unique_name = _get_unique_name(group_name) use_cpu_custom_send_recv instance-attribute ¶ use_cpu_custom_send_recv = is_cpu() and hasattr( _C, \"init_shm_manager\" ) use_custom_op_call instance-attribute ¶ use_custom_op_call = is_cuda_alike() or is_tpu() use_device_communicator instance-attribute ¶ use_device_communicator = use_device_communicator world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, use_message_queue_broadcaster: bool = False, group_name: str | None = None, ) Source code in vllm/distributed/parallel_state.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) _all_gather_out_place ¶ _all_gather_out_place(input_: Tensor, dim: int) -> Tensor Source code in vllm/distributed/parallel_state.py 525 526 527 528def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) _all_reduce_out_place ¶ _all_reduce_out_place(input_: Tensor) -> Tensor Source code in vllm/distributed/parallel_state.py 504 505 506 507def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) _reduce_scatter_out_place ¶ _reduce_scatter_out_place( input_: Tensor, dim: int ) -> Tensor Source code in vllm/distributed/parallel_state.py 563 564 565 566def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) Source code in vllm/distributed/parallel_state.py 530 531 532 533 534 535 536 537 538def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) all_reduce ¶ all_reduce(input_: Tensor) -> Tensor User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (self in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. Source code in vllm/distributed/parallel_state.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) barrier ¶ barrier() Barrier synchronization among the group. NOTE: don't use device_group here! barrier in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. Source code in vllm/distributed/parallel_state.py 964 965 966 967 968 969 970 971def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) broadcast ¶ broadcast(input_: Tensor, src: int = 0) Broadcast the input tensor. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ broadcast_object ¶ broadcast_object(obj: Any | None = None, src: int = 0) Broadcast the input object. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] broadcast_object_list ¶ broadcast_object_list( obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None, ) Broadcast the input object list. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[str, Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, Tensor | Any] | None Broadcast the input tensor dictionary. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict combine ¶ combine( hidden_states, is_sequence_parallel: bool = False ) -> Tensor Source code in vllm/distributed/parallel_state.py 1025 1026 1027 1028 1029 1030 1031def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states create_mq_broadcaster ¶ create_mq_broadcaster( writer_rank=0, external_writer_handle=None, blocking=True, ) Source code in vllm/distributed/parallel_state.py 389 390 391 392 393 394 395 396 397 398 399 400 401def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) create_single_reader_mq_broadcasters ¶ create_single_reader_mq_broadcasters( reader_rank_in_group=0, blocking=False ) Source code in vllm/distributed/parallel_state.py 403 404 405 406 407 408 409 410 411 412 413 414def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) destroy ¶ destroy() Source code in vllm/distributed/parallel_state.py 989 990 991 992 993 994 995 996 997 998 999def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, extra_tensors: list[Tensor] | None = None, ) -> ( tuple[Tensor, Tensor] | tuple[Tensor, Tensor, list[Tensor]] ) Source code in vllm/distributed/parallel_state.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/parallel_state.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) graph_capture ¶ graph_capture( graph_capture_context: GraphCaptureContext | None = None, ) Source code in vllm/distributed/parallel_state.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478@contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Source code in vllm/distributed/parallel_state.py 1001 1002 1003def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/parallel_state.py 980 981 982 983 984 985 986 987def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) recv_object ¶ recv_object(src: int) -> Any Receive the input object list from the source rank. Source code in vllm/distributed/parallel_state.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj recv_tensor_dict ¶ recv_tensor_dict( src: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Recv the input tensor dictionary. NOTE: src is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/parallel_state.py 556 557 558 559 560 561def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/parallel_state.py 973 974 975 976 977 978def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) send_object ¶ send_object(obj: Any, dst: int) -> None Send the input object list to the destination rank. Source code in vllm/distributed/parallel_state.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None send_tensor_dict ¶ send_tensor_dict( tensor_dict: dict[str, Tensor | Any], dst: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Send the input tensor dictionary. NOTE: dst is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None StatelessProcessGroup dataclass ¶ A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. Source code in vllm/distributed/utils.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@dataclasses.dataclass class StatelessProcessGroup: \"\"\"A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. \"\"\" rank: int world_size: int store: torch._C._distributed_c10d.Store # stores a reference to the socket so that the file descriptor stays alive socket: socket.socket | None data_expiration_seconds: int = 3600 # 1 hour # dst rank -> counter send_dst_counter: dict[int, int] = dataclasses.field(default_factory=dict) # src rank -> counter recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) broadcast_send_counter: int = 0 broadcast_recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) # A deque to store the data entries, with key and timestamp. entries: deque[tuple[str, float]] = dataclasses.field(default_factory=deque) def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") @staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) broadcast_recv_src_counter class-attribute instance-attribute ¶ broadcast_recv_src_counter: dict[int, int] = field( default_factory=dict ) broadcast_send_counter class-attribute instance-attribute ¶ broadcast_send_counter: int = 0 data_expiration_seconds class-attribute instance-attribute ¶ data_expiration_seconds: int = 3600 entries class-attribute instance-attribute ¶ entries: deque[tuple[str, float]] = field( default_factory=deque ) rank instance-attribute ¶ rank: int recv_src_counter class-attribute instance-attribute ¶ recv_src_counter: dict[int, int] = field( default_factory=dict ) send_dst_counter class-attribute instance-attribute ¶ send_dst_counter: dict[int, int] = field( default_factory=dict ) socket instance-attribute ¶ socket: socket | None store instance-attribute ¶ store: Store world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( rank: int, world_size: int, store: Store, socket: socket | None, data_expiration_seconds: int = 3600, send_dst_counter: dict[int, int] = dict(), recv_src_counter: dict[int, int] = dict(), broadcast_send_counter: int = 0, broadcast_recv_src_counter: dict[int, int] = dict(), entries: deque[tuple[str, float]] = deque(), ) -> None __post_init__ ¶ __post_init__() Source code in vllm/distributed/utils.py 169 170 171 172 173def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} all_gather_obj ¶ all_gather_obj(obj: Any) -> list[Any] All gather an object from all ranks. Source code in vllm/distributed/utils.py 220 221 222 223 224 225 226 227 228 229 230def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs barrier ¶ barrier(timeout: float = 30.0) A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: Each process signals it has reached the barrier Each process signals that it has confirmed the arrival of all other ranks. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Parameters: Name Type Description Default timeout float Maximum time in seconds to wait for each phase (in seconds) 30.0 Raises: Type Description RuntimeError If coordination fails or times out Source code in vllm/distributed/utils.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") broadcast_obj ¶ broadcast_obj(obj: Any | None, src: int) -> Any Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. Source code in vllm/distributed/utils.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj create staticmethod ¶ create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> StatelessProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. If we have process A and process B called torch.distributed.init_process_group to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. torch.distributed.init_process_group is a global call, while this function is a stateless call. It will return a StatelessProcessGroup object that can be used for exchanging metadata. With this function, process A and process B can call StatelessProcessGroup.create to form a group, and then process A, B, C, and D can call StatelessProcessGroup.create to form another group. Source code in vllm/distributed/utils.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) expire_data ¶ expire_data() Expire data that is older than data_expiration_seconds seconds. Source code in vllm/distributed/utils.py 183 184 185 186 187 188 189 190 191 192def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break recv_obj ¶ recv_obj(src: int) -> Any Receive an object from a source rank. Source code in vllm/distributed/utils.py 194 195 196 197 198 199 200def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj send_obj ¶ send_obj(obj: Any, dst: int) Send an object to a destination rank. Source code in vllm/distributed/utils.py 175 176 177 178 179 180 181def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) all_gather ¶ all_gather( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 147 148 149 150 151 152 153 154def all_gather( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_gather_out_place(tensor, dim) all_gather_fake ¶ all_gather_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 157 158 159 160 161 162def all_gather_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] * world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) all_reduce ¶ all_reduce(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 117 118 119 120 121 122def all_reduce(tensor: torch.Tensor, group_name: str) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_reduce_out_place(tensor) all_reduce_fake ¶ all_reduce_fake(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 125 126def all_reduce_fake(tensor: torch.Tensor, group_name: str) -> torch.Tensor: return torch.empty_like(tensor) broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[Any, Tensor | Any] | None = None, src: int = 0, ) Source code in vllm/distributed/communication_op.py 38 39 40 41 42 43def broadcast_tensor_dict( tensor_dict: dict[Any, torch.Tensor | Any] | None = None, src: int = 0 ): if not torch.distributed.is_initialized(): return tensor_dict return get_tp_group().broadcast_tensor_dict(tensor_dict, src) cleanup_dist_env_and_memory ¶ cleanup_dist_env_and_memory(shutdown_ray: bool = False) Source code in vllm/distributed/parallel_state.py 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617def cleanup_dist_env_and_memory(shutdown_ray: bool = False): # Reset environment variable cache envs.disable_envs_cache() # Ensure all objects are not frozen before cleanup gc.unfreeze() destroy_model_parallel() destroy_distributed_environment() if shutdown_ray: import ray # Lazy import Ray ray.shutdown() gc.collect() from vllm.platforms import current_platform empty_cache = current_platform.empty_cache if empty_cache is not None: empty_cache() try: if not current_platform.is_cpu(): torch._C._host_emptyCache() except AttributeError: logger.warning(\"torch._C._host_emptyCache() only available in Pytorch >=2.5\") destroy_distributed_environment ¶ destroy_distributed_environment() Source code in vllm/distributed/parallel_state.py 1585 1586 1587 1588 1589 1590 1591 1592def destroy_distributed_environment(): global _WORLD, _NODE_COUNT if _WORLD: _WORLD.destroy() _WORLD = None _NODE_COUNT = None if torch.distributed.is_initialized(): torch.distributed.destroy_process_group() destroy_model_parallel ¶ destroy_model_parallel() Set the groups to none and destroy them. Source code in vllm/distributed/parallel_state.py 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582def destroy_model_parallel(): \"\"\"Set the groups to none and destroy them.\"\"\" global _TP if _TP: _TP.destroy() _TP = None global _DCP if _DCP: _DCP.destroy() _DCP = None global _PCP if _PCP: _PCP.destroy() _PCP = None global _PP if _PP: _PP.destroy() _PP = None global _DP if _DP: _DP.destroy() _DP = None global _EP if _EP: _EP.destroy() _EP = None direct_register_custom_op ¶ direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[Tag, ...] = (), ) torch.library.custom_op can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the target_lib argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. Source code in vllm/utils/torch_utils.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727def direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[torch.Tag, ...] = (), ): \"\"\" `torch.library.custom_op` can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the `target_lib` argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. \"\"\" if not supports_custom_op(): from vllm.platforms import current_platform assert not current_platform.is_cuda_alike(), ( \"cuda platform needs torch>=2.4 to support custom op, \" \"chances are you are using an old version of pytorch \" \"or a custom build of pytorch. It is recommended to \" \"use vLLM in a fresh new environment and let it install \" \"the required dependencies.\" ) return if mutates_args is None: mutates_args = [] if dispatch_key is None: from vllm.platforms import current_platform dispatch_key = current_platform.dispatch_key schema_str = infer_schema(op_func, mutates_args=mutates_args) my_lib = target_lib or vllm_lib my_lib.define(op_name + schema_str, tags=tags) my_lib.impl(op_name, op_func, dispatch_key=dispatch_key) if fake_impl is not None: my_lib._register_fake(op_name, fake_impl) divide ¶ divide(numerator, denominator) Ensure that numerator is divisible by the denominator and return the division value. Source code in vllm/distributed/utils.py 60 61 62 63 64def divide(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator and return the division value.\"\"\" ensure_divisibility(numerator, denominator) return numerator // denominator ensure_divisibility ¶ ensure_divisibility(numerator, denominator) Ensure that numerator is divisible by the denominator. Source code in vllm/distributed/utils.py 53 54 55 56 57def ensure_divisibility(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator.\"\"\" assert numerator % denominator == 0, \"{} is not divisible by {}\".format( numerator, denominator ) ensure_model_parallel_initialized ¶ ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470def ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\"Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. \"\"\" backend = backend or torch.distributed.get_backend(get_world_group().device_group) if not model_parallel_is_initialized(): initialize_model_parallel( tensor_model_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, decode_context_model_parallel_size, backend, ) return assert get_tensor_model_parallel_world_size() == tensor_model_parallel_size, ( \"tensor parallel group already initialized, but of unexpected size. \" f\"got: {get_tensor_model_parallel_world_size()=} vs. \" f\"wanted: {tensor_model_parallel_size=}\" ) pp_world_size = get_pp_group().world_size assert pp_world_size == pipeline_model_parallel_size, ( \"pipeline parallel group already initialized, but of unexpected size. \" f\"got: {pp_world_size=} vs. \" f\"wanted: {pipeline_model_parallel_size=}\" ) pcp_world_size = get_pcp_group().world_size assert pcp_world_size == prefill_context_model_parallel_size, ( \"prefill context parallel group already initialized, but of unexpected size: \" f\"{pcp_world_size=} vs. \" f\"{prefill_context_model_parallel_size=}\" ) get_dcp_group ¶ get_dcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1090 1091 1092def get_dcp_group() -> GroupCoordinator: assert _DCP is not None, \"decode context model parallel group is not initialized\" return _DCP get_decode_context_model_parallel_rank ¶ get_decode_context_model_parallel_rank() Return my rank for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1540 1541 1542def get_decode_context_model_parallel_rank(): \"\"\"Return my rank for the decode context model parallel group.\"\"\" return get_dcp_group().rank_in_group get_decode_context_model_parallel_world_size ¶ get_decode_context_model_parallel_world_size() Return world size for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1535 1536 1537def get_decode_context_model_parallel_world_size(): \"\"\"Return world size for the decode context model parallel group.\"\"\" return get_dcp_group().world_size get_distributed_init_method ¶ get_distributed_init_method(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 130 131def get_distributed_init_method(ip: str, port: int) -> str: return get_tcp_uri(ip, port) get_dp_group ¶ get_dp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1109 1110 1111def get_dp_group() -> GroupCoordinator: assert _DP is not None, \"data parallel group is not initialized\" return _DP get_ep_group ¶ get_ep_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1117 1118 1119def get_ep_group() -> GroupCoordinator: assert _EP is not None, \"expert parallel group is not initialized\" return _EP get_inner_dp_world_group ¶ get_inner_dp_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1044 1045 1046def get_inner_dp_world_group() -> GroupCoordinator: assert _INNER_DP_WORLD is not None, \"inner dp world group is not initialized\" return _INNER_DP_WORLD get_node_count ¶ get_node_count() -> int Return the total number of nodes in the distributed environment. Source code in vllm/distributed/parallel_state.py 1545 1546 1547 1548def get_node_count() -> int: \"\"\"Return the total number of nodes in the distributed environment.\"\"\" assert _NODE_COUNT is not None, \"distributed environment is not initialized\" return _NODE_COUNT get_pcp_group ¶ get_pcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1125 1126 1127def get_pcp_group() -> GroupCoordinator: assert _PCP is not None, \"prefill context parallel group is not initialized\" return _PCP get_pp_group ¶ get_pp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1101 1102 1103def get_pp_group() -> GroupCoordinator: assert _PP is not None, \"pipeline model parallel group is not initialized\" return _PP get_pp_indices ¶ get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int] Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If pp_size > 2 and the number of remaining layers is 0 < x <= pp_size - 2 then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. Source code in vllm/distributed/utils.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140def get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int]: \"\"\"Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If `pp_size > 2` and the number of remaining layers is `0 < x <= pp_size - 2` then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. \"\"\" partition_list_str = envs.VLLM_PP_LAYER_PARTITION if partition_list_str is not None: try: partitions = [int(layer) for layer in partition_list_str.split(\",\")] except ValueError as err: raise ValueError( \"Invalid partition string: {}\".format(partition_list_str) ) from err if len(partitions) != pp_size: raise ValueError(f\"{len(partitions)=} does not match {pp_size=}.\") if sum(partitions) != num_hidden_layers: raise ValueError(f\"{sum(partitions)=} does not match {num_hidden_layers=}.\") else: layers_per_partition = num_hidden_layers // pp_size partitions = [layers_per_partition for _ in range(pp_size)] if remaining_layers := num_hidden_layers % pp_size: for i in range(2, remaining_layers + 2): partitions[-i] += 1 logger.info( \"Hidden layers were unevenly partitioned: [%s]. \" \"This can be manually overridden using the \" \"VLLM_PP_LAYER_PARTITION environment variable\", \",\".join(str(p) for p in partitions), ) start_layer = sum(partitions[:pp_rank]) end_layer = start_layer + partitions[pp_rank] return (start_layer, end_layer) get_tcp_uri ¶ get_tcp_uri(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 134 135 136 137 138def get_tcp_uri(ip: str, port: int) -> str: if is_valid_ipv6_address(ip): return f\"tcp://[{ip}]:{port}\" else: return f\"tcp://{ip}:{port}\" get_tensor_model_parallel_rank ¶ get_tensor_model_parallel_rank() Return my rank for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1530 1531 1532def get_tensor_model_parallel_rank(): \"\"\"Return my rank for the tensor model parallel group.\"\"\" return get_tp_group().rank_in_group get_tensor_model_parallel_world_size ¶ get_tensor_model_parallel_world_size() Return world size for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1525 1526 1527def get_tensor_model_parallel_world_size(): \"\"\"Return world size for the tensor model parallel group.\"\"\" return get_tp_group().world_size get_tp_group ¶ get_tp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1082 1083 1084def get_tp_group() -> GroupCoordinator: assert _TP is not None, \"tensor model parallel group is not initialized\" return _TP get_world_group ¶ get_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1039 1040 1041def get_world_group() -> GroupCoordinator: assert _WORLD is not None, \"world group is not initialized\" return _WORLD graph_capture ¶ graph_capture(device: device) graph_capture is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a GraphCaptureContext object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. Source code in vllm/distributed/parallel_state.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147@contextmanager def graph_capture(device: torch.device): \"\"\" `graph_capture` is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a `GraphCaptureContext` object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. \"\"\" context = GraphCaptureContext(torch.cuda.Stream(device=device)) with get_tp_group().graph_capture(context), get_pp_group().graph_capture(context): yield context in_the_same_node_as ¶ in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0, ) -> list[bool] This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). Source code in vllm/distributed/parallel_state.py 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709def in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0 ) -> list[bool]: \"\"\" This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). \"\"\" if isinstance(pg, ProcessGroup): assert torch.distributed.get_backend(pg) != torch.distributed.Backend.NCCL, ( \"in_the_same_node_as should be tested with a non-NCCL group.\" ) # local rank inside the group rank = torch.distributed.get_rank(group=pg) world_size = torch.distributed.get_world_size(group=pg) # global ranks of the processes in the group ranks = torch.distributed.get_process_group_ranks(pg) else: rank = pg.rank world_size = pg.world_size ranks = list(range(world_size)) # local tensor in each process to store the result is_in_the_same_node = torch.tensor( [0] * world_size, dtype=torch.int32, device=\"cpu\" ) magic_message = b\"magic_message\" shm = None try: with contextlib.suppress(OSError): if rank == source_rank: # create a shared memory segment shm = shared_memory.SharedMemory(create=True, size=128) shm.buf[: len(magic_message)] = magic_message if isinstance(pg, ProcessGroup): torch.distributed.broadcast_object_list( [shm.name], src=ranks[source_rank], group=pg ) else: pg.broadcast_obj(shm.name, src=source_rank) is_in_the_same_node[rank] = 1 else: # try to open the shared memory segment if isinstance(pg, ProcessGroup): recv = [None] torch.distributed.broadcast_object_list( recv, src=ranks[source_rank], group=pg ) name = recv[0] else: name = pg.broadcast_obj(None, src=source_rank) # fix to https://stackoverflow.com/q/62748654/9191338 # Python incorrectly tracks shared memory even if it is not # created by the process. The following patch is a workaround. with patch( \"multiprocessing.resource_tracker.register\", lambda *args, **kwargs: None, ): shm = shared_memory.SharedMemory(name=name) if shm.buf[: len(magic_message)] == magic_message: is_in_the_same_node[rank] = 1 except Exception as e: logger.error(\"Error ignored in is_in_the_same_node: %s\", e) finally: if shm: shm.close() if isinstance(pg, ProcessGroup): torch.distributed.barrier(group=pg) else: pg.barrier() # clean up the shared memory segment with contextlib.suppress(OSError): if rank == source_rank and shm: shm.unlink() if isinstance(pg, ProcessGroup): torch.distributed.all_reduce(is_in_the_same_node, group=pg) aggregated_data = is_in_the_same_node else: aggregated_data = torch.zeros_like(is_in_the_same_node) for i in range(world_size): rank_data = pg.broadcast_obj(is_in_the_same_node, src=i) aggregated_data += rank_data return [x == 1 for x in aggregated_data.tolist()] init_distributed_environment ¶ init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ) Source code in vllm/distributed/parallel_state.py 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275def init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ): logger.debug( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) from vllm.config import get_current_vllm_config config = get_current_vllm_config() if ( config is not None and config.parallel_config.distributed_executor_backend != \"external_launcher\" and ( config.parallel_config.nnodes > 1 or config.parallel_config.data_parallel_size > 1 ) ): parallel_config = config.parallel_config # adjust to take into account data parallelism # offset the rank by the data parallel rank rank = parallel_config.data_parallel_rank * world_size + rank # adjust the world size to take into account data parallelism world_size = parallel_config.world_size_across_dp # Use appropriate IP and port based on configuration if parallel_config.nnodes > 1: ip = parallel_config.master_addr port = parallel_config.master_port distributed_init_method = get_distributed_init_method(ip, port) else: ip = parallel_config.data_parallel_master_ip port = parallel_config.get_next_dp_init_port() distributed_init_method = get_distributed_init_method(ip, port) logger.debug( \"Adjusting world_size=%d rank=%d distributed_init_method=%s for DP\", world_size, rank, distributed_init_method, ) if not torch.distributed.is_initialized(): logger.info( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) assert distributed_init_method is not None, ( \"distributed_init_method must be provided when initializing \" \"distributed environment\" ) if not torch.distributed.is_backend_available(backend): logger.warning( \"Distributed backend %s is not available; falling back to gloo.\", backend, ) assert torch.distributed.is_gloo_available(), ( \"Fallback Gloo backend is not available.\" ) backend = \"gloo\" # this backend is used for WORLD torch.distributed.init_process_group( backend=backend, init_method=distributed_init_method, world_size=world_size, rank=rank, timeout=timeout, ) # set the local rank # local_rank is not available in torch ProcessGroup, # see https://github.com/pytorch/pytorch/issues/122816 if local_rank == -1: # local rank not set, this usually happens in single-node # setting, where we can use rank as local rank local_rank = envs.LOCAL_RANK if distributed_init_method == \"env://\" else rank global _WORLD, _NODE_COUNT, _INNER_DP_WORLD if _WORLD is None: ranks = list(range(torch.distributed.get_world_size())) _WORLD = init_world_group(ranks, local_rank, backend) if config.parallel_config.nnodes > 1: _NODE_COUNT = config.parallel_config.nnodes else: _NODE_COUNT = _node_count(_WORLD.cpu_group) logger.debug(\"Detected %d nodes in the distributed environment\", _NODE_COUNT) else: assert _WORLD.world_size == torch.distributed.get_world_size(), ( \"world group already initialized with a different world size\" ) if config.parallel_config.nnodes_within_dp > 1: if parallel_config.data_parallel_size > 1: world_size_inner_dp = parallel_config.world_size group_ranks = [ [dp_rank * world_size_inner_dp + i for i in range(world_size_inner_dp)] for dp_rank in range(parallel_config.data_parallel_size) ] _INNER_DP_WORLD = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"inner_dp_world\", use_device_communicator=False, ) else: _INNER_DP_WORLD = _WORLD init_gloo_process_group ¶ init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup Stateless init ProcessGroup with gloo backend compatible with different torch versions. Source code in vllm/distributed/utils.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459def init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup: \"\"\" Stateless init ProcessGroup with gloo backend compatible with different torch versions. \"\"\" with suppress_stdout(): if is_torch_equal_or_newer(\"2.6\"): pg = ProcessGroup( prefix_store, group_rank, group_size, ) else: options = ProcessGroup.Options(backend=\"gloo\") pg = ProcessGroup( prefix_store, group_rank, group_size, options, ) from torch.distributed.distributed_c10d import ProcessGroupGloo backend_class = ProcessGroupGloo( prefix_store, group_rank, group_size, timeout=timeout ) backend_type = ProcessGroup.BackendType.GLOO device = torch.device(\"cpu\") if is_torch_equal_or_newer(\"2.6\"): # _set_default_backend is supported in torch >= 2.6 pg._set_default_backend(backend_type) backend_class._set_sequence_number_for_group() pg._register_backend(device, backend_type, backend_class) return pg init_logger ¶ init_logger(name: str) -> _VllmLogger The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured. Source code in vllm/logger.py 206 207 208 209 210 211 212 213 214 215 216def init_logger(name: str) -> _VllmLogger: \"\"\"The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured.\"\"\" logger = logging.getLogger(name) for method_name, method in _METHODS_TO_PATCH.items(): setattr(logger, method_name, MethodType(method, logger)) return cast(_VllmLogger, logger) init_model_parallel_group ¶ init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076def init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator: return GroupCoordinator( group_ranks=group_ranks, local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=use_device_communicator, use_message_queue_broadcaster=use_message_queue_broadcaster, group_name=group_name, ) init_world_group ¶ init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058def init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator: return GroupCoordinator( group_ranks=[ranks], local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=False, group_name=\"world\", ) initialize_model_parallel ¶ initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Initialize model parallel groups. Parameters: Name Type Description Default tensor_model_parallel_size int number of GPUs used for tensor model parallelism. 1 pipeline_model_parallel_size int number of GPUs used for pipeline model parallelism. 1 backend str | None name of torch distributed communication backend. None Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. Source code in vllm/distributed/parallel_state.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429def initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\" Initialize model parallel groups. Arguments: tensor_model_parallel_size: number of GPUs used for tensor model parallelism. pipeline_model_parallel_size: number of GPUs used for pipeline model parallelism. backend: name of torch distributed communication backend. Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. \"\"\" # Get world size and rank. Ensure some consistencies. assert torch.distributed.is_initialized() world_size: int = torch.distributed.get_world_size() rank = torch.distributed.get_rank() backend = backend or torch.distributed.get_backend(get_world_group().device_group) data_parallel_size = 1 from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: data_parallel_size = config.parallel_config.data_parallel_size # the layout order is: ExternalDP x DP x PP x TP # ExternalDP is the data parallel group that is not part of the model, # every dp rank can generate independently (in verl integration). # DP is the data parallel group that is part of the model, # all the ranks in the same DP group should generate simultaneously, # i.e. the `generate` call in the same DP group should be called together, # otherwise it will cause deadlock. # to get group_ranks for each dimension, transpose that dimension to the # last dimension, then reshape to 2D, then unbind the last dimension all_ranks = torch.arange(world_size).reshape( -1, data_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, tensor_model_parallel_size, ) # noqa # Build the tensor model-parallel groups. global _TP assert _TP is None, \"tensor model parallel group is already initialized\" group_ranks = all_ranks.view(-1, tensor_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] # message queue broadcaster is only used in tensor model parallel group _TP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"tp\", ) # Build the DCP model-parallel groups. global _DCP assert _DCP is None, \"decode context model parallel group is already initialized\" # Note(hc): In the current implementation of decode context parallel, # dcp_size must not exceed tp_size, because the world size does not # change by DCP, it simply reuses the GPUs of TP group, and split one # TP group into tp_size//dcp_size DCP groups. group_ranks = all_ranks.reshape(-1, decode_context_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"dcp\", ) global _PCP assert _PCP is None, \"prefill context parallel group is already initialized\" group_ranks = ( all_ranks.transpose(3, 4) .reshape(-1, prefill_context_model_parallel_size) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pcp\" ) # Build the pipeline model-parallel groups. global _PP assert _PP is None, \"pipeline model parallel group is already initialized\" group_ranks = ( all_ranks.transpose(2, 4).reshape(-1, pipeline_model_parallel_size).unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pp\" ) global _DP assert _DP is None, \"data parallel group is already initialized\" group_ranks = all_ranks.transpose(1, 4).reshape(-1, data_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"dp\" ) global _EP assert _EP is None, \"expert parallel group is already initialized\" group_ranks = ( all_ranks.transpose(1, 2) .reshape( -1, data_parallel_size * prefill_context_model_parallel_size * tensor_model_parallel_size, ) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _EP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"ep\" ) logger.info_once( \"rank %s in world size %s is assigned as \" \"DP rank %s, PP rank %s, PCP rank %s, \" \"TP rank %s, EP rank %s\", rank, world_size, _DP.rank_in_group, _PP.rank_in_group, _PCP.rank_in_group, _TP.rank_in_group, _EP.rank_in_group, ) is_global_first_rank ¶ is_global_first_rank() -> bool Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like get_tensor_model_parallel_rank() == 0 or get_pp_group().is_first_rank, this function checks the global rank across all parallelism dimensions. Returns: Name Type Description bool bool True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). Source code in vllm/distributed/parallel_state.py 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740def is_global_first_rank() -> bool: \"\"\" Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like `get_tensor_model_parallel_rank() == 0` or `get_pp_group().is_first_rank`, this function checks the global rank across all parallelism dimensions. Returns: bool: True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). \"\"\" try: # If world group is available, use it for the most accurate check global _WORLD if _WORLD is not None: return _WORLD.is_first_rank # If torch distributed is not initialized, assume single process if not torch.distributed.is_initialized(): return True # Fallback to torch's global rank return torch.distributed.get_rank() == 0 except Exception: # If anything goes wrong, assume this is the first rank return True is_local_first_rank ¶ is_local_first_rank() -> bool Check if the current process is the first local rank (rank 0 on its node). Source code in vllm/distributed/parallel_state.py 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763def is_local_first_rank() -> bool: \"\"\" Check if the current process is the first local rank (rank 0 on its node). \"\"\" try: # prefer the initialized world group if available global _WORLD if _WORLD is not None: return _WORLD.local_rank == 0 if not torch.distributed.is_initialized(): return True # fallback to environment-provided local rank if available # note: envs.LOCAL_RANK is set when using env:// launchers (e.g., torchrun) try: return int(envs.LOCAL_RANK) == 0 # type: ignore[arg-type] except Exception: return torch.distributed.get_rank() == 0 except Exception: return True is_torch_equal_or_newer ¶ is_torch_equal_or_newer(target: str) -> bool Check if the installed torch version is >= the target version. Parameters: Name Type Description Default target str a version string, like \"2.6.0\". required Returns: Type Description bool Whether the condition meets. Source code in vllm/utils/torch_utils.py 610 611 612 613 614 615 616 617 618 619 620 621 622 623def is_torch_equal_or_newer(target: str) -> bool: \"\"\"Check if the installed torch version is >= the target version. Args: target: a version string, like \"2.6.0\". Returns: Whether the condition meets. \"\"\" try: return _is_torch_equal_or_newer(str(torch.__version__), target) except Exception: # Fallback to PKG-INFO to load the package info, needed by the doc gen. return Version(importlib.metadata.version(\"torch\")) >= Version(target) model_parallel_is_initialized ¶ model_parallel_is_initialized() Check if tensor and pipeline parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1492 1493 1494def model_parallel_is_initialized(): \"\"\"Check if tensor and pipeline parallel groups are initialized.\"\"\" return _TP is not None and _PP is not None patch_tensor_parallel_group ¶ patch_tensor_parallel_group(tp_group: GroupCoordinator) Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Parameters: Name Type Description Default tp_group GroupCoordinator the tp group coordinator required Source code in vllm/distributed/parallel_state.py 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522@contextmanager def patch_tensor_parallel_group(tp_group: GroupCoordinator): \"\"\"Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Args: tp_group (GroupCoordinator): the tp group coordinator \"\"\" global _TP_STATE_PATCHED assert not _TP_STATE_PATCHED, \"Should not call when it's already patched\" _TP_STATE_PATCHED = True old_tp_group = get_tp_group() global _TP _TP = tp_group try: yield finally: # restore the original state _TP_STATE_PATCHED = False _TP = old_tp_group patched_fused_scaled_matmul_reduce_scatter ¶ patched_fused_scaled_matmul_reduce_scatter( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246def patched_fused_scaled_matmul_reduce_scatter( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: return torch.ops.symm_mem.fused_scaled_matmul_reduce_scatter( A, B, A_scale, B_scale, reduce_op, orig_scatter_dim, scatter_dim_after_maybe_reshape, group_name, output_shape, bias, result_scale, out_dtype, use_fast_accum, ) patched_fused_scaled_matmul_reduce_scatter_fake ¶ patched_fused_scaled_matmul_reduce_scatter_fake( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214def patched_fused_scaled_matmul_reduce_scatter_fake( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: # Copied from # https://github.com/pytorch/pytorch/blob/50c338c2da905062449e4d9ac807832d1b5cd90e/torch/distributed/_symmetric_memory/__init__.py#L1189 if A_scale.numel() > 1: if A_scale.shape[:-1] != A.shape[:-1]: raise ValueError( \"For row-wise scaling, the leading dims of A_scale \" \"must match the leading dims of A \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) A_scale = A_scale.flatten(0, -2).contiguous() elif A_scale.numel() != 1: raise ValueError( \"Invalid A_scale shape \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) C = torch._scaled_mm( A.flatten(0, -2).contiguous(), B, A_scale, B_scale, bias, result_scale, out_dtype, use_fast_accum, ) C = C.view(*output_shape[:-1], B.shape[1]) res = funcol.reduce_scatter_tensor( C, reduce_op, orig_scatter_dim, # need original scatter dim for 3D+ output tensor here group_name, ) res = funcol.wait_tensor(res) return res prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. Source code in vllm/distributed/parallel_state.py 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489def prepare_communication_buffer_for_model(model: torch.nn.Module): \"\"\"Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. \"\"\" if _TP is not None: _TP.prepare_communication_buffer_for_model(model) if _PCP is not None: _PCP.prepare_communication_buffer_for_model(model) if _PP is not None: _PP.prepare_communication_buffer_for_model(model) if _DP is not None: _DP.prepare_communication_buffer_for_model(model) if _EP is not None: _EP.prepare_communication_buffer_for_model(model) reduce_scatter ¶ reduce_scatter( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 129 130 131 132 133 134 135 136def reduce_scatter( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._reduce_scatter_out_place(tensor, dim) reduce_scatter_fake ¶ reduce_scatter_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 139 140 141 142 143 144def reduce_scatter_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] // world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) resolve_obj_by_qualname ¶ resolve_obj_by_qualname(qualname: str) -> Any Resolve an object by its fully-qualified class name. Source code in vllm/utils/import_utils.py 117 118 119 120 121 122 123def resolve_obj_by_qualname(qualname: str) -> Any: \"\"\" Resolve an object by its fully-qualified class name. \"\"\" module_name, obj_name = qualname.rsplit(\".\", 1) module = importlib.import_module(module_name) return getattr(module, obj_name) sched_yield ¶ sched_yield() Source code in vllm/distributed/utils.py 46 47 48 49 50def sched_yield(): if USE_SCHED_YIELD: os.sched_yield() else: time.sleep(0) set_custom_all_reduce ¶ set_custom_all_reduce(enable: bool) Source code in vllm/distributed/parallel_state.py 1155 1156 1157def set_custom_all_reduce(enable: bool): global _ENABLE_CUSTOM_ALL_REDUCE _ENABLE_CUSTOM_ALL_REDUCE = enable split_tensor_along_last_dim ¶ split_tensor_along_last_dim( tensor: Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[Tensor] Split a tensor along its last dimension. Parameters: Name Type Description Default tensor Tensor input tensor. required num_partitions int number of partitions to split the tensor required contiguous_split_chunks bool If True, make each chunk contiguous in memory. False Returns: Type Description Sequence[Tensor] A list of Tensors Source code in vllm/distributed/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92def split_tensor_along_last_dim( tensor: torch.Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[torch.Tensor]: \"\"\"Split a tensor along its last dimension. Arguments: tensor: input tensor. num_partitions: number of partitions to split the tensor contiguous_split_chunks: If True, make each chunk contiguous in memory. Returns: A list of Tensors \"\"\" # Get the size and dimension. last_dim = tensor.dim() - 1 last_dim_size = divide(tensor.size()[last_dim], num_partitions) # Split. tensor_list = torch.split(tensor, last_dim_size, dim=last_dim) # NOTE: torch.split does not create contiguous tensors by default. if contiguous_split_chunks: return tuple(chunk.contiguous() for chunk in tensor_list) return tensor_list stateless_destroy_torch_distributed_process_group ¶ stateless_destroy_torch_distributed_process_group( pg: ProcessGroup, ) -> None Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). Source code in vllm/distributed/utils.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545def stateless_destroy_torch_distributed_process_group(pg: ProcessGroup) -> None: \"\"\" Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). \"\"\" if is_torch_equal_or_newer(\"2.7\"): pg.shutdown() else: # Lazy import for non-CUDA backends. from torch.distributed.distributed_c10d import _shutdown_backend _shutdown_backend(pg) _unregister_process_group(pg.group_name) stateless_init_torch_distributed_process_group ¶ stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str, ) -> ProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. The created ProcessGroup object can be used for some operations such as allreduce, because it does not depend on the global rank. However, some operations such as broadcast cannot be used because it depends on the global rank. TODO: ask for help from PyTorch team if we need the broadcast operation.¶ This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. Source code in vllm/distributed/utils.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529def stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str ) -> ProcessGroup: \"\"\" A replacement for `torch.distributed.init_process_group` that does not pollute the global state. The created ProcessGroup object can be used for some operations such as `allreduce`, because it does not depend on the global rank. However, some operations such as `broadcast` cannot be used because it depends on the global rank. # TODO: ask for help from PyTorch team if we need the `broadcast` operation. This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. \"\"\" init_method = get_tcp_uri(host, port) backend = Backend(backend) # it is basically string timeout = _get_default_timeout(backend) store, rank, world_size = next( rendezvous(init_method, rank, world_size, timeout=timeout) ) store.set_timeout(timeout) group_rank = rank group_size = world_size # Use a PrefixStore to avoid accidental overrides of keys used by # different systems (e.g. RPC) in case the store is multi-tenant. prefix_store = PrefixStore(init_method, store) try: from vllm.platforms import current_platform return current_platform.stateless_init_device_torch_dist_pg( backend=backend, prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) except NotImplementedError: # If platform doesn't implement stateless_init_device_torch_dist_pg, it # will raise a NotImplementedError. In this case, we fall back to gloo. return init_gloo_process_group( prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) supports_custom_op ¶ supports_custom_op() -> bool Source code in vllm/utils/torch_utils.py 669 670def supports_custom_op() -> bool: return hasattr(torch.library, \"custom_op\") suppress_stdout ¶ suppress_stdout() Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") Source code in vllm/utils/system_utils.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89@contextlib.contextmanager def suppress_stdout(): \"\"\" Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example: with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") \"\"\" # Don't suppress if logging level is DEBUG if envs.VLLM_LOGGING_LEVEL == \"DEBUG\": yield return stdout_fd = sys.stdout.fileno() stdout_dup = os.dup(stdout_fd) devnull_fd = os.open(os.devnull, os.O_WRONLY) try: sys.stdout.flush() os.dup2(devnull_fd, stdout_fd) yield finally: sys.stdout.flush() os.dup2(stdout_dup, stdout_fd) os.close(stdout_dup) os.close(devnull_fd) tensor_model_parallel_all_gather ¶ tensor_model_parallel_all_gather( input_: Tensor, dim: int = -1 ) -> Tensor All-gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 17 18 19 20 21def tensor_model_parallel_all_gather( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"All-gather the input tensor across model parallel group.\"\"\" return get_tp_group().all_gather(input_, dim) tensor_model_parallel_all_reduce ¶ tensor_model_parallel_all_reduce(input_: Tensor) -> Tensor All-reduce the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 12 13 14def tensor_model_parallel_all_reduce(input_: torch.Tensor) -> torch.Tensor: \"\"\"All-reduce the input tensor across model parallel group.\"\"\" return get_tp_group().all_reduce(input_) tensor_model_parallel_gather ¶ tensor_model_parallel_gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None Gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 31 32 33 34 35def tensor_model_parallel_gather( input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\"Gather the input tensor across model parallel group.\"\"\" return get_tp_group().gather(input_, dst, dim) tensor_model_parallel_reduce_scatter ¶ tensor_model_parallel_reduce_scatter( input_: Tensor, dim: int = -1 ) -> Tensor Reduce-Scatter the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 24 25 26 27 28def tensor_model_parallel_reduce_scatter( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"Reduce-Scatter the input tensor across model parallel group.\"\"\" return get_tp_group().reduce_scatter(input_, dim) December 25, 2025",
      "code": ""
    },
    {
      "description": "vllm.distributed ¶ Modules: Name Description communication_op device_communicators ec_transfer envs eplb Expert parallelism load balancer (EPLB). kv_events kv_transfer parallel_state vLLM distributed state. tpu_distributed_utils utils TensorMetadata module-attribute ¶ TensorMetadata = namedtuple( \"TensorMetadata\", [\"device\", \"dtype\", \"size\"] ) USE_SCHED_YIELD module-attribute ¶ USE_SCHED_YIELD = ( version_info[:3] >= (3, 11, 1) or version_info[:2] == (3, 10) and version_info[2] >= 8 ) get_context_model_parallel_group module-attribute ¶ get_context_model_parallel_group = get_dcp_group logger module-attribute ¶ logger = init_logger(__name__) DeviceCommunicatorBase ¶ Base class for device-specific communicator. It can use the cpu_group to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the device_group will also be given. Source code in vllm/distributed/device_communicators/base_device_communicator.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302class DeviceCommunicatorBase: \"\"\" Base class for device-specific communicator. It can use the `cpu_group` to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the `device_group` will also be given. \"\"\" def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor def destroy(self): pass def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states all2all_backend instance-attribute ¶ all2all_backend = all2all_backend all2all_manager instance-attribute ¶ all2all_manager: All2AllManagerBase | None = None cpu_group instance-attribute ¶ cpu_group = cpu_group device instance-attribute ¶ device = device or device('cpu') device_group instance-attribute ¶ device_group = device_group global_rank instance-attribute ¶ global_rank = get_rank() global_world_size instance-attribute ¶ global_world_size = get_world_size() is_ep_communicator instance-attribute ¶ is_ep_communicator = 'ep' in unique_name rank instance-attribute ¶ rank = get_rank(cpu_group) rank_in_group instance-attribute ¶ rank_in_group = get_group_rank(cpu_group, global_rank) ranks instance-attribute ¶ ranks = get_process_group_ranks(cpu_group) unique_name instance-attribute ¶ unique_name = unique_name use_all2all instance-attribute ¶ use_all2all = is_ep_communicator and use_ep world_size instance-attribute ¶ world_size = get_world_size(cpu_group) __init__ ¶ __init__( cpu_group: ProcessGroup, device: device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ) Source code in vllm/distributed/device_communicators/base_device_communicator.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> Tensor | list[Tensor] Source code in vllm/distributed/device_communicators/base_device_communicator.py 164 165 166 167 168 169 170def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError all_reduce ¶ all_reduce(input_: Tensor) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 135 136 137def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ combine ¶ combine( hidden_states: Tensor, is_sequence_parallel: bool = False, ) -> Tensor Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 295 296 297 298 299 300 301 302def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states destroy ¶ destroy() Source code in vllm/distributed/device_communicators/base_device_communicator.py 260 261def destroy(self): pass dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, ) -> tuple[Tensor, Tensor] Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 283 284 285 286 287 288 289 290 291 292 293def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model( model: Module, ) -> None Prepare the communication buffer for the model. Source code in vllm/distributed/device_communicators/base_device_communicator.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 248 249 250 251 252 253 254 255 256 257 258def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 205 206 207 208def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/device_communicators/base_device_communicator.py 241 242 243 244 245 246def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) GraphCaptureContext dataclass ¶ Source code in vllm/distributed/parallel_state.py 60 61 62@dataclass class GraphCaptureContext: stream: torch.cuda.Stream stream instance-attribute ¶ stream: Stream __init__ ¶ __init__(stream: Stream) -> None GroupCoordinator ¶ PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. Source code in vllm/distributed/parallel_state.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031class GroupCoordinator: \"\"\" PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. \"\"\" # available attributes: rank: int # global rank ranks: list[int] # global ranks in the group world_size: int # size of the group # difference between `local_rank` and `rank_in_group`: # if we have a group of size 4 across two nodes: # Process | Node | Rank | Local Rank | Rank in Group # 0 | 0 | 0 | 0 | 0 # 1 | 0 | 1 | 1 | 1 # 2 | 1 | 2 | 0 | 2 # 3 | 1 | 3 | 1 | 3 local_rank: int # local rank used to assign devices rank_in_group: int # rank inside the group cpu_group: ProcessGroup # group for CPU communication device_group: ProcessGroup # group for device communication # device communicator (if use_device_communicator=True) device_communicator: DeviceCommunicatorBase | None mq_broadcaster: Any | None # shared memory broadcaster def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) @property def first_rank(self): \"\"\"Return the global rank of the first process in the group\"\"\" return self.ranks[0] @property def last_rank(self): \"\"\"Return the global rank of the last process in the group\"\"\" return self.ranks[-1] @property def is_first_rank(self): \"\"\"Return whether the caller is the first process in the group\"\"\" return self.rank == self.first_rank @property def is_last_rank(self): \"\"\"Return whether the caller is the last process in the group\"\"\" return self.rank == self.last_rank @property def next_rank(self): \"\"\"Return the global rank of the process that follows the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group + 1) % world_size] @property def prev_rank(self): \"\"\"Return the global rank of the process that precedes the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group - 1) % world_size] @contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states cpu_group instance-attribute ¶ cpu_group: ProcessGroup = self_cpu_group device instance-attribute ¶ device = device(f'cuda:{local_rank}') device_communicator instance-attribute ¶ device_communicator: DeviceCommunicatorBase | None = None device_group instance-attribute ¶ device_group: ProcessGroup = self_device_group first_rank property ¶ first_rank Return the global rank of the first process in the group is_first_rank property ¶ is_first_rank Return whether the caller is the first process in the group is_last_rank property ¶ is_last_rank Return whether the caller is the last process in the group last_rank property ¶ last_rank Return the global rank of the last process in the group local_rank instance-attribute ¶ local_rank: int = local_rank mq_broadcaster instance-attribute ¶ mq_broadcaster: MessageQueue | None = None next_rank property ¶ next_rank Return the global rank of the process that follows the caller prev_rank property ¶ prev_rank Return the global rank of the process that precedes the caller rank instance-attribute ¶ rank: int = get_rank() rank_in_group instance-attribute ¶ rank_in_group: int ranks instance-attribute ¶ ranks: list[int] unique_name instance-attribute ¶ unique_name = _get_unique_name(group_name) use_cpu_custom_send_recv instance-attribute ¶ use_cpu_custom_send_recv = is_cpu() and hasattr( _C, \"init_shm_manager\" ) use_custom_op_call instance-attribute ¶ use_custom_op_call = is_cuda_alike() or is_tpu() use_device_communicator instance-attribute ¶ use_device_communicator = use_device_communicator world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, use_message_queue_broadcaster: bool = False, group_name: str | None = None, ) Source code in vllm/distributed/parallel_state.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) _all_gather_out_place ¶ _all_gather_out_place(input_: Tensor, dim: int) -> Tensor Source code in vllm/distributed/parallel_state.py 525 526 527 528def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) _all_reduce_out_place ¶ _all_reduce_out_place(input_: Tensor) -> Tensor Source code in vllm/distributed/parallel_state.py 504 505 506 507def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) _reduce_scatter_out_place ¶ _reduce_scatter_out_place( input_: Tensor, dim: int ) -> Tensor Source code in vllm/distributed/parallel_state.py 563 564 565 566def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) Source code in vllm/distributed/parallel_state.py 530 531 532 533 534 535 536 537 538def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) all_reduce ¶ all_reduce(input_: Tensor) -> Tensor User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (self in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. Source code in vllm/distributed/parallel_state.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) barrier ¶ barrier() Barrier synchronization among the group. NOTE: don't use device_group here! barrier in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. Source code in vllm/distributed/parallel_state.py 964 965 966 967 968 969 970 971def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) broadcast ¶ broadcast(input_: Tensor, src: int = 0) Broadcast the input tensor. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ broadcast_object ¶ broadcast_object(obj: Any | None = None, src: int = 0) Broadcast the input object. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] broadcast_object_list ¶ broadcast_object_list( obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None, ) Broadcast the input object list. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[str, Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, Tensor | Any] | None Broadcast the input tensor dictionary. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict combine ¶ combine( hidden_states, is_sequence_parallel: bool = False ) -> Tensor Source code in vllm/distributed/parallel_state.py 1025 1026 1027 1028 1029 1030 1031def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states create_mq_broadcaster ¶ create_mq_broadcaster( writer_rank=0, external_writer_handle=None, blocking=True, ) Source code in vllm/distributed/parallel_state.py 389 390 391 392 393 394 395 396 397 398 399 400 401def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) create_single_reader_mq_broadcasters ¶ create_single_reader_mq_broadcasters( reader_rank_in_group=0, blocking=False ) Source code in vllm/distributed/parallel_state.py 403 404 405 406 407 408 409 410 411 412 413 414def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) destroy ¶ destroy() Source code in vllm/distributed/parallel_state.py 989 990 991 992 993 994 995 996 997 998 999def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, extra_tensors: list[Tensor] | None = None, ) -> ( tuple[Tensor, Tensor] | tuple[Tensor, Tensor, list[Tensor]] ) Source code in vllm/distributed/parallel_state.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/parallel_state.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) graph_capture ¶ graph_capture( graph_capture_context: GraphCaptureContext | None = None, ) Source code in vllm/distributed/parallel_state.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478@contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Source code in vllm/distributed/parallel_state.py 1001 1002 1003def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/parallel_state.py 980 981 982 983 984 985 986 987def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) recv_object ¶ recv_object(src: int) -> Any Receive the input object list from the source rank. Source code in vllm/distributed/parallel_state.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj recv_tensor_dict ¶ recv_tensor_dict( src: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Recv the input tensor dictionary. NOTE: src is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/parallel_state.py 556 557 558 559 560 561def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/parallel_state.py 973 974 975 976 977 978def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) send_object ¶ send_object(obj: Any, dst: int) -> None Send the input object list to the destination rank. Source code in vllm/distributed/parallel_state.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None send_tensor_dict ¶ send_tensor_dict( tensor_dict: dict[str, Tensor | Any], dst: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Send the input tensor dictionary. NOTE: dst is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None StatelessProcessGroup dataclass ¶ A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. Source code in vllm/distributed/utils.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@dataclasses.dataclass class StatelessProcessGroup: \"\"\"A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. \"\"\" rank: int world_size: int store: torch._C._distributed_c10d.Store # stores a reference to the socket so that the file descriptor stays alive socket: socket.socket | None data_expiration_seconds: int = 3600 # 1 hour # dst rank -> counter send_dst_counter: dict[int, int] = dataclasses.field(default_factory=dict) # src rank -> counter recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) broadcast_send_counter: int = 0 broadcast_recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) # A deque to store the data entries, with key and timestamp. entries: deque[tuple[str, float]] = dataclasses.field(default_factory=deque) def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") @staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) broadcast_recv_src_counter class-attribute instance-attribute ¶ broadcast_recv_src_counter: dict[int, int] = field( default_factory=dict ) broadcast_send_counter class-attribute instance-attribute ¶ broadcast_send_counter: int = 0 data_expiration_seconds class-attribute instance-attribute ¶ data_expiration_seconds: int = 3600 entries class-attribute instance-attribute ¶ entries: deque[tuple[str, float]] = field( default_factory=deque ) rank instance-attribute ¶ rank: int recv_src_counter class-attribute instance-attribute ¶ recv_src_counter: dict[int, int] = field( default_factory=dict ) send_dst_counter class-attribute instance-attribute ¶ send_dst_counter: dict[int, int] = field( default_factory=dict ) socket instance-attribute ¶ socket: socket | None store instance-attribute ¶ store: Store world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( rank: int, world_size: int, store: Store, socket: socket | None, data_expiration_seconds: int = 3600, send_dst_counter: dict[int, int] = dict(), recv_src_counter: dict[int, int] = dict(), broadcast_send_counter: int = 0, broadcast_recv_src_counter: dict[int, int] = dict(), entries: deque[tuple[str, float]] = deque(), ) -> None __post_init__ ¶ __post_init__() Source code in vllm/distributed/utils.py 169 170 171 172 173def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} all_gather_obj ¶ all_gather_obj(obj: Any) -> list[Any] All gather an object from all ranks. Source code in vllm/distributed/utils.py 220 221 222 223 224 225 226 227 228 229 230def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs barrier ¶ barrier(timeout: float = 30.0) A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: Each process signals it has reached the barrier Each process signals that it has confirmed the arrival of all other ranks. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Parameters: Name Type Description Default timeout float Maximum time in seconds to wait for each phase (in seconds) 30.0 Raises: Type Description RuntimeError If coordination fails or times out Source code in vllm/distributed/utils.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") broadcast_obj ¶ broadcast_obj(obj: Any | None, src: int) -> Any Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. Source code in vllm/distributed/utils.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj create staticmethod ¶ create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> StatelessProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. If we have process A and process B called torch.distributed.init_process_group to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. torch.distributed.init_process_group is a global call, while this function is a stateless call. It will return a StatelessProcessGroup object that can be used for exchanging metadata. With this function, process A and process B can call StatelessProcessGroup.create to form a group, and then process A, B, C, and D can call StatelessProcessGroup.create to form another group. Source code in vllm/distributed/utils.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) expire_data ¶ expire_data() Expire data that is older than data_expiration_seconds seconds. Source code in vllm/distributed/utils.py 183 184 185 186 187 188 189 190 191 192def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break recv_obj ¶ recv_obj(src: int) -> Any Receive an object from a source rank. Source code in vllm/distributed/utils.py 194 195 196 197 198 199 200def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj send_obj ¶ send_obj(obj: Any, dst: int) Send an object to a destination rank. Source code in vllm/distributed/utils.py 175 176 177 178 179 180 181def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) all_gather ¶ all_gather( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 147 148 149 150 151 152 153 154def all_gather( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_gather_out_place(tensor, dim) all_gather_fake ¶ all_gather_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 157 158 159 160 161 162def all_gather_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] * world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) all_reduce ¶ all_reduce(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 117 118 119 120 121 122def all_reduce(tensor: torch.Tensor, group_name: str) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_reduce_out_place(tensor) all_reduce_fake ¶ all_reduce_fake(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 125 126def all_reduce_fake(tensor: torch.Tensor, group_name: str) -> torch.Tensor: return torch.empty_like(tensor) broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[Any, Tensor | Any] | None = None, src: int = 0, ) Source code in vllm/distributed/communication_op.py 38 39 40 41 42 43def broadcast_tensor_dict( tensor_dict: dict[Any, torch.Tensor | Any] | None = None, src: int = 0 ): if not torch.distributed.is_initialized(): return tensor_dict return get_tp_group().broadcast_tensor_dict(tensor_dict, src) cleanup_dist_env_and_memory ¶ cleanup_dist_env_and_memory(shutdown_ray: bool = False) Source code in vllm/distributed/parallel_state.py 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617def cleanup_dist_env_and_memory(shutdown_ray: bool = False): # Reset environment variable cache envs.disable_envs_cache() # Ensure all objects are not frozen before cleanup gc.unfreeze() destroy_model_parallel() destroy_distributed_environment() if shutdown_ray: import ray # Lazy import Ray ray.shutdown() gc.collect() from vllm.platforms import current_platform empty_cache = current_platform.empty_cache if empty_cache is not None: empty_cache() try: if not current_platform.is_cpu(): torch._C._host_emptyCache() except AttributeError: logger.warning(\"torch._C._host_emptyCache() only available in Pytorch >=2.5\") destroy_distributed_environment ¶ destroy_distributed_environment() Source code in vllm/distributed/parallel_state.py 1585 1586 1587 1588 1589 1590 1591 1592def destroy_distributed_environment(): global _WORLD, _NODE_COUNT if _WORLD: _WORLD.destroy() _WORLD = None _NODE_COUNT = None if torch.distributed.is_initialized(): torch.distributed.destroy_process_group() destroy_model_parallel ¶ destroy_model_parallel() Set the groups to none and destroy them. Source code in vllm/distributed/parallel_state.py 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582def destroy_model_parallel(): \"\"\"Set the groups to none and destroy them.\"\"\" global _TP if _TP: _TP.destroy() _TP = None global _DCP if _DCP: _DCP.destroy() _DCP = None global _PCP if _PCP: _PCP.destroy() _PCP = None global _PP if _PP: _PP.destroy() _PP = None global _DP if _DP: _DP.destroy() _DP = None global _EP if _EP: _EP.destroy() _EP = None direct_register_custom_op ¶ direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[Tag, ...] = (), ) torch.library.custom_op can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the target_lib argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. Source code in vllm/utils/torch_utils.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727def direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[torch.Tag, ...] = (), ): \"\"\" `torch.library.custom_op` can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the `target_lib` argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. \"\"\" if not supports_custom_op(): from vllm.platforms import current_platform assert not current_platform.is_cuda_alike(), ( \"cuda platform needs torch>=2.4 to support custom op, \" \"chances are you are using an old version of pytorch \" \"or a custom build of pytorch. It is recommended to \" \"use vLLM in a fresh new environment and let it install \" \"the required dependencies.\" ) return if mutates_args is None: mutates_args = [] if dispatch_key is None: from vllm.platforms import current_platform dispatch_key = current_platform.dispatch_key schema_str = infer_schema(op_func, mutates_args=mutates_args) my_lib = target_lib or vllm_lib my_lib.define(op_name + schema_str, tags=tags) my_lib.impl(op_name, op_func, dispatch_key=dispatch_key) if fake_impl is not None: my_lib._register_fake(op_name, fake_impl) divide ¶ divide(numerator, denominator) Ensure that numerator is divisible by the denominator and return the division value. Source code in vllm/distributed/utils.py 60 61 62 63 64def divide(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator and return the division value.\"\"\" ensure_divisibility(numerator, denominator) return numerator // denominator ensure_divisibility ¶ ensure_divisibility(numerator, denominator) Ensure that numerator is divisible by the denominator. Source code in vllm/distributed/utils.py 53 54 55 56 57def ensure_divisibility(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator.\"\"\" assert numerator % denominator == 0, \"{} is not divisible by {}\".format( numerator, denominator ) ensure_model_parallel_initialized ¶ ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470def ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\"Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. \"\"\" backend = backend or torch.distributed.get_backend(get_world_group().device_group) if not model_parallel_is_initialized(): initialize_model_parallel( tensor_model_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, decode_context_model_parallel_size, backend, ) return assert get_tensor_model_parallel_world_size() == tensor_model_parallel_size, ( \"tensor parallel group already initialized, but of unexpected size. \" f\"got: {get_tensor_model_parallel_world_size()=} vs. \" f\"wanted: {tensor_model_parallel_size=}\" ) pp_world_size = get_pp_group().world_size assert pp_world_size == pipeline_model_parallel_size, ( \"pipeline parallel group already initialized, but of unexpected size. \" f\"got: {pp_world_size=} vs. \" f\"wanted: {pipeline_model_parallel_size=}\" ) pcp_world_size = get_pcp_group().world_size assert pcp_world_size == prefill_context_model_parallel_size, ( \"prefill context parallel group already initialized, but of unexpected size: \" f\"{pcp_world_size=} vs. \" f\"{prefill_context_model_parallel_size=}\" ) get_dcp_group ¶ get_dcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1090 1091 1092def get_dcp_group() -> GroupCoordinator: assert _DCP is not None, \"decode context model parallel group is not initialized\" return _DCP get_decode_context_model_parallel_rank ¶ get_decode_context_model_parallel_rank() Return my rank for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1540 1541 1542def get_decode_context_model_parallel_rank(): \"\"\"Return my rank for the decode context model parallel group.\"\"\" return get_dcp_group().rank_in_group get_decode_context_model_parallel_world_size ¶ get_decode_context_model_parallel_world_size() Return world size for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1535 1536 1537def get_decode_context_model_parallel_world_size(): \"\"\"Return world size for the decode context model parallel group.\"\"\" return get_dcp_group().world_size get_distributed_init_method ¶ get_distributed_init_method(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 130 131def get_distributed_init_method(ip: str, port: int) -> str: return get_tcp_uri(ip, port) get_dp_group ¶ get_dp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1109 1110 1111def get_dp_group() -> GroupCoordinator: assert _DP is not None, \"data parallel group is not initialized\" return _DP get_ep_group ¶ get_ep_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1117 1118 1119def get_ep_group() -> GroupCoordinator: assert _EP is not None, \"expert parallel group is not initialized\" return _EP get_inner_dp_world_group ¶ get_inner_dp_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1044 1045 1046def get_inner_dp_world_group() -> GroupCoordinator: assert _INNER_DP_WORLD is not None, \"inner dp world group is not initialized\" return _INNER_DP_WORLD get_node_count ¶ get_node_count() -> int Return the total number of nodes in the distributed environment. Source code in vllm/distributed/parallel_state.py 1545 1546 1547 1548def get_node_count() -> int: \"\"\"Return the total number of nodes in the distributed environment.\"\"\" assert _NODE_COUNT is not None, \"distributed environment is not initialized\" return _NODE_COUNT get_pcp_group ¶ get_pcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1125 1126 1127def get_pcp_group() -> GroupCoordinator: assert _PCP is not None, \"prefill context parallel group is not initialized\" return _PCP get_pp_group ¶ get_pp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1101 1102 1103def get_pp_group() -> GroupCoordinator: assert _PP is not None, \"pipeline model parallel group is not initialized\" return _PP get_pp_indices ¶ get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int] Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If pp_size > 2 and the number of remaining layers is 0 < x <= pp_size - 2 then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. Source code in vllm/distributed/utils.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140def get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int]: \"\"\"Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If `pp_size > 2` and the number of remaining layers is `0 < x <= pp_size - 2` then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. \"\"\" partition_list_str = envs.VLLM_PP_LAYER_PARTITION if partition_list_str is not None: try: partitions = [int(layer) for layer in partition_list_str.split(\",\")] except ValueError as err: raise ValueError( \"Invalid partition string: {}\".format(partition_list_str) ) from err if len(partitions) != pp_size: raise ValueError(f\"{len(partitions)=} does not match {pp_size=}.\") if sum(partitions) != num_hidden_layers: raise ValueError(f\"{sum(partitions)=} does not match {num_hidden_layers=}.\") else: layers_per_partition = num_hidden_layers // pp_size partitions = [layers_per_partition for _ in range(pp_size)] if remaining_layers := num_hidden_layers % pp_size: for i in range(2, remaining_layers + 2): partitions[-i] += 1 logger.info( \"Hidden layers were unevenly partitioned: [%s]. \" \"This can be manually overridden using the \" \"VLLM_PP_LAYER_PARTITION environment variable\", \",\".join(str(p) for p in partitions), ) start_layer = sum(partitions[:pp_rank]) end_layer = start_layer + partitions[pp_rank] return (start_layer, end_layer) get_tcp_uri ¶ get_tcp_uri(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 134 135 136 137 138def get_tcp_uri(ip: str, port: int) -> str: if is_valid_ipv6_address(ip): return f\"tcp://[{ip}]:{port}\" else: return f\"tcp://{ip}:{port}\" get_tensor_model_parallel_rank ¶ get_tensor_model_parallel_rank() Return my rank for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1530 1531 1532def get_tensor_model_parallel_rank(): \"\"\"Return my rank for the tensor model parallel group.\"\"\" return get_tp_group().rank_in_group get_tensor_model_parallel_world_size ¶ get_tensor_model_parallel_world_size() Return world size for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1525 1526 1527def get_tensor_model_parallel_world_size(): \"\"\"Return world size for the tensor model parallel group.\"\"\" return get_tp_group().world_size get_tp_group ¶ get_tp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1082 1083 1084def get_tp_group() -> GroupCoordinator: assert _TP is not None, \"tensor model parallel group is not initialized\" return _TP get_world_group ¶ get_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1039 1040 1041def get_world_group() -> GroupCoordinator: assert _WORLD is not None, \"world group is not initialized\" return _WORLD graph_capture ¶ graph_capture(device: device) graph_capture is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a GraphCaptureContext object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. Source code in vllm/distributed/parallel_state.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147@contextmanager def graph_capture(device: torch.device): \"\"\" `graph_capture` is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a `GraphCaptureContext` object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. \"\"\" context = GraphCaptureContext(torch.cuda.Stream(device=device)) with get_tp_group().graph_capture(context), get_pp_group().graph_capture(context): yield context in_the_same_node_as ¶ in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0, ) -> list[bool] This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). Source code in vllm/distributed/parallel_state.py 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709def in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0 ) -> list[bool]: \"\"\" This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). \"\"\" if isinstance(pg, ProcessGroup): assert torch.distributed.get_backend(pg) != torch.distributed.Backend.NCCL, ( \"in_the_same_node_as should be tested with a non-NCCL group.\" ) # local rank inside the group rank = torch.distributed.get_rank(group=pg) world_size = torch.distributed.get_world_size(group=pg) # global ranks of the processes in the group ranks = torch.distributed.get_process_group_ranks(pg) else: rank = pg.rank world_size = pg.world_size ranks = list(range(world_size)) # local tensor in each process to store the result is_in_the_same_node = torch.tensor( [0] * world_size, dtype=torch.int32, device=\"cpu\" ) magic_message = b\"magic_message\" shm = None try: with contextlib.suppress(OSError): if rank == source_rank: # create a shared memory segment shm = shared_memory.SharedMemory(create=True, size=128) shm.buf[: len(magic_message)] = magic_message if isinstance(pg, ProcessGroup): torch.distributed.broadcast_object_list( [shm.name], src=ranks[source_rank], group=pg ) else: pg.broadcast_obj(shm.name, src=source_rank) is_in_the_same_node[rank] = 1 else: # try to open the shared memory segment if isinstance(pg, ProcessGroup): recv = [None] torch.distributed.broadcast_object_list( recv, src=ranks[source_rank], group=pg ) name = recv[0] else: name = pg.broadcast_obj(None, src=source_rank) # fix to https://stackoverflow.com/q/62748654/9191338 # Python incorrectly tracks shared memory even if it is not # created by the process. The following patch is a workaround. with patch( \"multiprocessing.resource_tracker.register\", lambda *args, **kwargs: None, ): shm = shared_memory.SharedMemory(name=name) if shm.buf[: len(magic_message)] == magic_message: is_in_the_same_node[rank] = 1 except Exception as e: logger.error(\"Error ignored in is_in_the_same_node: %s\", e) finally: if shm: shm.close() if isinstance(pg, ProcessGroup): torch.distributed.barrier(group=pg) else: pg.barrier() # clean up the shared memory segment with contextlib.suppress(OSError): if rank == source_rank and shm: shm.unlink() if isinstance(pg, ProcessGroup): torch.distributed.all_reduce(is_in_the_same_node, group=pg) aggregated_data = is_in_the_same_node else: aggregated_data = torch.zeros_like(is_in_the_same_node) for i in range(world_size): rank_data = pg.broadcast_obj(is_in_the_same_node, src=i) aggregated_data += rank_data return [x == 1 for x in aggregated_data.tolist()] init_distributed_environment ¶ init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ) Source code in vllm/distributed/parallel_state.py 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275def init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ): logger.debug( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) from vllm.config import get_current_vllm_config config = get_current_vllm_config() if ( config is not None and config.parallel_config.distributed_executor_backend != \"external_launcher\" and ( config.parallel_config.nnodes > 1 or config.parallel_config.data_parallel_size > 1 ) ): parallel_config = config.parallel_config # adjust to take into account data parallelism # offset the rank by the data parallel rank rank = parallel_config.data_parallel_rank * world_size + rank # adjust the world size to take into account data parallelism world_size = parallel_config.world_size_across_dp # Use appropriate IP and port based on configuration if parallel_config.nnodes > 1: ip = parallel_config.master_addr port = parallel_config.master_port distributed_init_method = get_distributed_init_method(ip, port) else: ip = parallel_config.data_parallel_master_ip port = parallel_config.get_next_dp_init_port() distributed_init_method = get_distributed_init_method(ip, port) logger.debug( \"Adjusting world_size=%d rank=%d distributed_init_method=%s for DP\", world_size, rank, distributed_init_method, ) if not torch.distributed.is_initialized(): logger.info( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) assert distributed_init_method is not None, ( \"distributed_init_method must be provided when initializing \" \"distributed environment\" ) if not torch.distributed.is_backend_available(backend): logger.warning( \"Distributed backend %s is not available; falling back to gloo.\", backend, ) assert torch.distributed.is_gloo_available(), ( \"Fallback Gloo backend is not available.\" ) backend = \"gloo\" # this backend is used for WORLD torch.distributed.init_process_group( backend=backend, init_method=distributed_init_method, world_size=world_size, rank=rank, timeout=timeout, ) # set the local rank # local_rank is not available in torch ProcessGroup, # see https://github.com/pytorch/pytorch/issues/122816 if local_rank == -1: # local rank not set, this usually happens in single-node # setting, where we can use rank as local rank local_rank = envs.LOCAL_RANK if distributed_init_method == \"env://\" else rank global _WORLD, _NODE_COUNT, _INNER_DP_WORLD if _WORLD is None: ranks = list(range(torch.distributed.get_world_size())) _WORLD = init_world_group(ranks, local_rank, backend) if config.parallel_config.nnodes > 1: _NODE_COUNT = config.parallel_config.nnodes else: _NODE_COUNT = _node_count(_WORLD.cpu_group) logger.debug(\"Detected %d nodes in the distributed environment\", _NODE_COUNT) else: assert _WORLD.world_size == torch.distributed.get_world_size(), ( \"world group already initialized with a different world size\" ) if config.parallel_config.nnodes_within_dp > 1: if parallel_config.data_parallel_size > 1: world_size_inner_dp = parallel_config.world_size group_ranks = [ [dp_rank * world_size_inner_dp + i for i in range(world_size_inner_dp)] for dp_rank in range(parallel_config.data_parallel_size) ] _INNER_DP_WORLD = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"inner_dp_world\", use_device_communicator=False, ) else: _INNER_DP_WORLD = _WORLD init_gloo_process_group ¶ init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup Stateless init ProcessGroup with gloo backend compatible with different torch versions. Source code in vllm/distributed/utils.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459def init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup: \"\"\" Stateless init ProcessGroup with gloo backend compatible with different torch versions. \"\"\" with suppress_stdout(): if is_torch_equal_or_newer(\"2.6\"): pg = ProcessGroup( prefix_store, group_rank, group_size, ) else: options = ProcessGroup.Options(backend=\"gloo\") pg = ProcessGroup( prefix_store, group_rank, group_size, options, ) from torch.distributed.distributed_c10d import ProcessGroupGloo backend_class = ProcessGroupGloo( prefix_store, group_rank, group_size, timeout=timeout ) backend_type = ProcessGroup.BackendType.GLOO device = torch.device(\"cpu\") if is_torch_equal_or_newer(\"2.6\"): # _set_default_backend is supported in torch >= 2.6 pg._set_default_backend(backend_type) backend_class._set_sequence_number_for_group() pg._register_backend(device, backend_type, backend_class) return pg init_logger ¶ init_logger(name: str) -> _VllmLogger The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured. Source code in vllm/logger.py 206 207 208 209 210 211 212 213 214 215 216def init_logger(name: str) -> _VllmLogger: \"\"\"The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured.\"\"\" logger = logging.getLogger(name) for method_name, method in _METHODS_TO_PATCH.items(): setattr(logger, method_name, MethodType(method, logger)) return cast(_VllmLogger, logger) init_model_parallel_group ¶ init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076def init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator: return GroupCoordinator( group_ranks=group_ranks, local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=use_device_communicator, use_message_queue_broadcaster=use_message_queue_broadcaster, group_name=group_name, ) init_world_group ¶ init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058def init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator: return GroupCoordinator( group_ranks=[ranks], local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=False, group_name=\"world\", ) initialize_model_parallel ¶ initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Initialize model parallel groups. Parameters: Name Type Description Default tensor_model_parallel_size int number of GPUs used for tensor model parallelism. 1 pipeline_model_parallel_size int number of GPUs used for pipeline model parallelism. 1 backend str | None name of torch distributed communication backend. None Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. Source code in vllm/distributed/parallel_state.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429def initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\" Initialize model parallel groups. Arguments: tensor_model_parallel_size: number of GPUs used for tensor model parallelism. pipeline_model_parallel_size: number of GPUs used for pipeline model parallelism. backend: name of torch distributed communication backend. Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. \"\"\" # Get world size and rank. Ensure some consistencies. assert torch.distributed.is_initialized() world_size: int = torch.distributed.get_world_size() rank = torch.distributed.get_rank() backend = backend or torch.distributed.get_backend(get_world_group().device_group) data_parallel_size = 1 from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: data_parallel_size = config.parallel_config.data_parallel_size # the layout order is: ExternalDP x DP x PP x TP # ExternalDP is the data parallel group that is not part of the model, # every dp rank can generate independently (in verl integration). # DP is the data parallel group that is part of the model, # all the ranks in the same DP group should generate simultaneously, # i.e. the `generate` call in the same DP group should be called together, # otherwise it will cause deadlock. # to get group_ranks for each dimension, transpose that dimension to the # last dimension, then reshape to 2D, then unbind the last dimension all_ranks = torch.arange(world_size).reshape( -1, data_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, tensor_model_parallel_size, ) # noqa # Build the tensor model-parallel groups. global _TP assert _TP is None, \"tensor model parallel group is already initialized\" group_ranks = all_ranks.view(-1, tensor_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] # message queue broadcaster is only used in tensor model parallel group _TP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"tp\", ) # Build the DCP model-parallel groups. global _DCP assert _DCP is None, \"decode context model parallel group is already initialized\" # Note(hc): In the current implementation of decode context parallel, # dcp_size must not exceed tp_size, because the world size does not # change by DCP, it simply reuses the GPUs of TP group, and split one # TP group into tp_size//dcp_size DCP groups. group_ranks = all_ranks.reshape(-1, decode_context_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"dcp\", ) global _PCP assert _PCP is None, \"prefill context parallel group is already initialized\" group_ranks = ( all_ranks.transpose(3, 4) .reshape(-1, prefill_context_model_parallel_size) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pcp\" ) # Build the pipeline model-parallel groups. global _PP assert _PP is None, \"pipeline model parallel group is already initialized\" group_ranks = ( all_ranks.transpose(2, 4).reshape(-1, pipeline_model_parallel_size).unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pp\" ) global _DP assert _DP is None, \"data parallel group is already initialized\" group_ranks = all_ranks.transpose(1, 4).reshape(-1, data_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"dp\" ) global _EP assert _EP is None, \"expert parallel group is already initialized\" group_ranks = ( all_ranks.transpose(1, 2) .reshape( -1, data_parallel_size * prefill_context_model_parallel_size * tensor_model_parallel_size, ) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _EP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"ep\" ) logger.info_once( \"rank %s in world size %s is assigned as \" \"DP rank %s, PP rank %s, PCP rank %s, \" \"TP rank %s, EP rank %s\", rank, world_size, _DP.rank_in_group, _PP.rank_in_group, _PCP.rank_in_group, _TP.rank_in_group, _EP.rank_in_group, ) is_global_first_rank ¶ is_global_first_rank() -> bool Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like get_tensor_model_parallel_rank() == 0 or get_pp_group().is_first_rank, this function checks the global rank across all parallelism dimensions. Returns: Name Type Description bool bool True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). Source code in vllm/distributed/parallel_state.py 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740def is_global_first_rank() -> bool: \"\"\" Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like `get_tensor_model_parallel_rank() == 0` or `get_pp_group().is_first_rank`, this function checks the global rank across all parallelism dimensions. Returns: bool: True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). \"\"\" try: # If world group is available, use it for the most accurate check global _WORLD if _WORLD is not None: return _WORLD.is_first_rank # If torch distributed is not initialized, assume single process if not torch.distributed.is_initialized(): return True # Fallback to torch's global rank return torch.distributed.get_rank() == 0 except Exception: # If anything goes wrong, assume this is the first rank return True is_local_first_rank ¶ is_local_first_rank() -> bool Check if the current process is the first local rank (rank 0 on its node). Source code in vllm/distributed/parallel_state.py 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763def is_local_first_rank() -> bool: \"\"\" Check if the current process is the first local rank (rank 0 on its node). \"\"\" try: # prefer the initialized world group if available global _WORLD if _WORLD is not None: return _WORLD.local_rank == 0 if not torch.distributed.is_initialized(): return True # fallback to environment-provided local rank if available # note: envs.LOCAL_RANK is set when using env:// launchers (e.g., torchrun) try: return int(envs.LOCAL_RANK) == 0 # type: ignore[arg-type] except Exception: return torch.distributed.get_rank() == 0 except Exception: return True is_torch_equal_or_newer ¶ is_torch_equal_or_newer(target: str) -> bool Check if the installed torch version is >= the target version. Parameters: Name Type Description Default target str a version string, like \"2.6.0\". required Returns: Type Description bool Whether the condition meets. Source code in vllm/utils/torch_utils.py 610 611 612 613 614 615 616 617 618 619 620 621 622 623def is_torch_equal_or_newer(target: str) -> bool: \"\"\"Check if the installed torch version is >= the target version. Args: target: a version string, like \"2.6.0\". Returns: Whether the condition meets. \"\"\" try: return _is_torch_equal_or_newer(str(torch.__version__), target) except Exception: # Fallback to PKG-INFO to load the package info, needed by the doc gen. return Version(importlib.metadata.version(\"torch\")) >= Version(target) model_parallel_is_initialized ¶ model_parallel_is_initialized() Check if tensor and pipeline parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1492 1493 1494def model_parallel_is_initialized(): \"\"\"Check if tensor and pipeline parallel groups are initialized.\"\"\" return _TP is not None and _PP is not None patch_tensor_parallel_group ¶ patch_tensor_parallel_group(tp_group: GroupCoordinator) Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Parameters: Name Type Description Default tp_group GroupCoordinator the tp group coordinator required Source code in vllm/distributed/parallel_state.py 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522@contextmanager def patch_tensor_parallel_group(tp_group: GroupCoordinator): \"\"\"Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Args: tp_group (GroupCoordinator): the tp group coordinator \"\"\" global _TP_STATE_PATCHED assert not _TP_STATE_PATCHED, \"Should not call when it's already patched\" _TP_STATE_PATCHED = True old_tp_group = get_tp_group() global _TP _TP = tp_group try: yield finally: # restore the original state _TP_STATE_PATCHED = False _TP = old_tp_group patched_fused_scaled_matmul_reduce_scatter ¶ patched_fused_scaled_matmul_reduce_scatter( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246def patched_fused_scaled_matmul_reduce_scatter( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: return torch.ops.symm_mem.fused_scaled_matmul_reduce_scatter( A, B, A_scale, B_scale, reduce_op, orig_scatter_dim, scatter_dim_after_maybe_reshape, group_name, output_shape, bias, result_scale, out_dtype, use_fast_accum, ) patched_fused_scaled_matmul_reduce_scatter_fake ¶ patched_fused_scaled_matmul_reduce_scatter_fake( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214def patched_fused_scaled_matmul_reduce_scatter_fake( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: # Copied from # https://github.com/pytorch/pytorch/blob/50c338c2da905062449e4d9ac807832d1b5cd90e/torch/distributed/_symmetric_memory/__init__.py#L1189 if A_scale.numel() > 1: if A_scale.shape[:-1] != A.shape[:-1]: raise ValueError( \"For row-wise scaling, the leading dims of A_scale \" \"must match the leading dims of A \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) A_scale = A_scale.flatten(0, -2).contiguous() elif A_scale.numel() != 1: raise ValueError( \"Invalid A_scale shape \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) C = torch._scaled_mm( A.flatten(0, -2).contiguous(), B, A_scale, B_scale, bias, result_scale, out_dtype, use_fast_accum, ) C = C.view(*output_shape[:-1], B.shape[1]) res = funcol.reduce_scatter_tensor( C, reduce_op, orig_scatter_dim, # need original scatter dim for 3D+ output tensor here group_name, ) res = funcol.wait_tensor(res) return res prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. Source code in vllm/distributed/parallel_state.py 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489def prepare_communication_buffer_for_model(model: torch.nn.Module): \"\"\"Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. \"\"\" if _TP is not None: _TP.prepare_communication_buffer_for_model(model) if _PCP is not None: _PCP.prepare_communication_buffer_for_model(model) if _PP is not None: _PP.prepare_communication_buffer_for_model(model) if _DP is not None: _DP.prepare_communication_buffer_for_model(model) if _EP is not None: _EP.prepare_communication_buffer_for_model(model) reduce_scatter ¶ reduce_scatter( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 129 130 131 132 133 134 135 136def reduce_scatter( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._reduce_scatter_out_place(tensor, dim) reduce_scatter_fake ¶ reduce_scatter_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 139 140 141 142 143 144def reduce_scatter_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] // world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) resolve_obj_by_qualname ¶ resolve_obj_by_qualname(qualname: str) -> Any Resolve an object by its fully-qualified class name. Source code in vllm/utils/import_utils.py 117 118 119 120 121 122 123def resolve_obj_by_qualname(qualname: str) -> Any: \"\"\" Resolve an object by its fully-qualified class name. \"\"\" module_name, obj_name = qualname.rsplit(\".\", 1) module = importlib.import_module(module_name) return getattr(module, obj_name) sched_yield ¶ sched_yield() Source code in vllm/distributed/utils.py 46 47 48 49 50def sched_yield(): if USE_SCHED_YIELD: os.sched_yield() else: time.sleep(0) set_custom_all_reduce ¶ set_custom_all_reduce(enable: bool) Source code in vllm/distributed/parallel_state.py 1155 1156 1157def set_custom_all_reduce(enable: bool): global _ENABLE_CUSTOM_ALL_REDUCE _ENABLE_CUSTOM_ALL_REDUCE = enable split_tensor_along_last_dim ¶ split_tensor_along_last_dim( tensor: Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[Tensor] Split a tensor along its last dimension. Parameters: Name Type Description Default tensor Tensor input tensor. required num_partitions int number of partitions to split the tensor required contiguous_split_chunks bool If True, make each chunk contiguous in memory. False Returns: Type Description Sequence[Tensor] A list of Tensors Source code in vllm/distributed/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92def split_tensor_along_last_dim( tensor: torch.Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[torch.Tensor]: \"\"\"Split a tensor along its last dimension. Arguments: tensor: input tensor. num_partitions: number of partitions to split the tensor contiguous_split_chunks: If True, make each chunk contiguous in memory. Returns: A list of Tensors \"\"\" # Get the size and dimension. last_dim = tensor.dim() - 1 last_dim_size = divide(tensor.size()[last_dim], num_partitions) # Split. tensor_list = torch.split(tensor, last_dim_size, dim=last_dim) # NOTE: torch.split does not create contiguous tensors by default. if contiguous_split_chunks: return tuple(chunk.contiguous() for chunk in tensor_list) return tensor_list stateless_destroy_torch_distributed_process_group ¶ stateless_destroy_torch_distributed_process_group( pg: ProcessGroup, ) -> None Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). Source code in vllm/distributed/utils.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545def stateless_destroy_torch_distributed_process_group(pg: ProcessGroup) -> None: \"\"\" Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). \"\"\" if is_torch_equal_or_newer(\"2.7\"): pg.shutdown() else: # Lazy import for non-CUDA backends. from torch.distributed.distributed_c10d import _shutdown_backend _shutdown_backend(pg) _unregister_process_group(pg.group_name) stateless_init_torch_distributed_process_group ¶ stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str, ) -> ProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. The created ProcessGroup object can be used for some operations such as allreduce, because it does not depend on the global rank. However, some operations such as broadcast cannot be used because it depends on the global rank. TODO: ask for help from PyTorch team if we need the broadcast operation.¶ This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. Source code in vllm/distributed/utils.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529def stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str ) -> ProcessGroup: \"\"\" A replacement for `torch.distributed.init_process_group` that does not pollute the global state. The created ProcessGroup object can be used for some operations such as `allreduce`, because it does not depend on the global rank. However, some operations such as `broadcast` cannot be used because it depends on the global rank. # TODO: ask for help from PyTorch team if we need the `broadcast` operation. This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. \"\"\" init_method = get_tcp_uri(host, port) backend = Backend(backend) # it is basically string timeout = _get_default_timeout(backend) store, rank, world_size = next( rendezvous(init_method, rank, world_size, timeout=timeout) ) store.set_timeout(timeout) group_rank = rank group_size = world_size # Use a PrefixStore to avoid accidental overrides of keys used by # different systems (e.g. RPC) in case the store is multi-tenant. prefix_store = PrefixStore(init_method, store) try: from vllm.platforms import current_platform return current_platform.stateless_init_device_torch_dist_pg( backend=backend, prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) except NotImplementedError: # If platform doesn't implement stateless_init_device_torch_dist_pg, it # will raise a NotImplementedError. In this case, we fall back to gloo. return init_gloo_process_group( prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) supports_custom_op ¶ supports_custom_op() -> bool Source code in vllm/utils/torch_utils.py 669 670def supports_custom_op() -> bool: return hasattr(torch.library, \"custom_op\") suppress_stdout ¶ suppress_stdout() Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") Source code in vllm/utils/system_utils.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89@contextlib.contextmanager def suppress_stdout(): \"\"\" Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example: with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") \"\"\" # Don't suppress if logging level is DEBUG if envs.VLLM_LOGGING_LEVEL == \"DEBUG\": yield return stdout_fd = sys.stdout.fileno() stdout_dup = os.dup(stdout_fd) devnull_fd = os.open(os.devnull, os.O_WRONLY) try: sys.stdout.flush() os.dup2(devnull_fd, stdout_fd) yield finally: sys.stdout.flush() os.dup2(stdout_dup, stdout_fd) os.close(stdout_dup) os.close(devnull_fd) tensor_model_parallel_all_gather ¶ tensor_model_parallel_all_gather( input_: Tensor, dim: int = -1 ) -> Tensor All-gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 17 18 19 20 21def tensor_model_parallel_all_gather( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"All-gather the input tensor across model parallel group.\"\"\" return get_tp_group().all_gather(input_, dim) tensor_model_parallel_all_reduce ¶ tensor_model_parallel_all_reduce(input_: Tensor) -> Tensor All-reduce the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 12 13 14def tensor_model_parallel_all_reduce(input_: torch.Tensor) -> torch.Tensor: \"\"\"All-reduce the input tensor across model parallel group.\"\"\" return get_tp_group().all_reduce(input_) tensor_model_parallel_gather ¶ tensor_model_parallel_gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None Gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 31 32 33 34 35def tensor_model_parallel_gather( input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\"Gather the input tensor across model parallel group.\"\"\" return get_tp_group().gather(input_, dst, dim) tensor_model_parallel_reduce_scatter ¶ tensor_model_parallel_reduce_scatter( input_: Tensor, dim: int = -1 ) -> Tensor Reduce-Scatter the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 24 25 26 27 28def tensor_model_parallel_reduce_scatter( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"Reduce-Scatter the input tensor across model parallel group.\"\"\" return get_tp_group().reduce_scatter(input_, dim)",
      "code": ""
    },
    {
      "description": "Modules: Name Description communication_op device_communicators ec_transfer envs eplb Expert parallelism load balancer (EPLB). kv_events kv_transfer parallel_state vLLM distributed state. tpu_distributed_utils utils TensorMetadata module-attribute ¶ TensorMetadata = namedtuple( \"TensorMetadata\", [\"device\", \"dtype\", \"size\"] ) USE_SCHED_YIELD module-attribute ¶ USE_SCHED_YIELD = ( version_info[:3] >= (3, 11, 1) or version_info[:2] == (3, 10) and version_info[2] >= 8 ) get_context_model_parallel_group module-attribute ¶ get_context_model_parallel_group = get_dcp_group logger module-attribute ¶ logger = init_logger(__name__) DeviceCommunicatorBase ¶ Base class for device-specific communicator. It can use the cpu_group to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the device_group will also be given. Source code in vllm/distributed/device_communicators/base_device_communicator.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302class DeviceCommunicatorBase: \"\"\" Base class for device-specific communicator. It can use the `cpu_group` to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the `device_group` will also be given. \"\"\" def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor def destroy(self): pass def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states all2all_backend instance-attribute ¶ all2all_backend = all2all_backend all2all_manager instance-attribute ¶ all2all_manager: All2AllManagerBase | None = None cpu_group instance-attribute ¶ cpu_group = cpu_group device instance-attribute ¶ device = device or device('cpu') device_group instance-attribute ¶ device_group = device_group global_rank instance-attribute ¶ global_rank = get_rank() global_world_size instance-attribute ¶ global_world_size = get_world_size() is_ep_communicator instance-attribute ¶ is_ep_communicator = 'ep' in unique_name rank instance-attribute ¶ rank = get_rank(cpu_group) rank_in_group instance-attribute ¶ rank_in_group = get_group_rank(cpu_group, global_rank) ranks instance-attribute ¶ ranks = get_process_group_ranks(cpu_group) unique_name instance-attribute ¶ unique_name = unique_name use_all2all instance-attribute ¶ use_all2all = is_ep_communicator and use_ep world_size instance-attribute ¶ world_size = get_world_size(cpu_group) __init__ ¶ __init__( cpu_group: ProcessGroup, device: device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ) Source code in vllm/distributed/device_communicators/base_device_communicator.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> Tensor | list[Tensor] Source code in vllm/distributed/device_communicators/base_device_communicator.py 164 165 166 167 168 169 170def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError all_reduce ¶ all_reduce(input_: Tensor) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 135 136 137def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ combine ¶ combine( hidden_states: Tensor, is_sequence_parallel: bool = False, ) -> Tensor Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 295 296 297 298 299 300 301 302def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states destroy ¶ destroy() Source code in vllm/distributed/device_communicators/base_device_communicator.py 260 261def destroy(self): pass dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, ) -> tuple[Tensor, Tensor] Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 283 284 285 286 287 288 289 290 291 292 293def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model( model: Module, ) -> None Prepare the communication buffer for the model. Source code in vllm/distributed/device_communicators/base_device_communicator.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 248 249 250 251 252 253 254 255 256 257 258def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 205 206 207 208def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/device_communicators/base_device_communicator.py 241 242 243 244 245 246def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) GraphCaptureContext dataclass ¶ Source code in vllm/distributed/parallel_state.py 60 61 62@dataclass class GraphCaptureContext: stream: torch.cuda.Stream stream instance-attribute ¶ stream: Stream __init__ ¶ __init__(stream: Stream) -> None GroupCoordinator ¶ PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. Source code in vllm/distributed/parallel_state.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031class GroupCoordinator: \"\"\" PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. \"\"\" # available attributes: rank: int # global rank ranks: list[int] # global ranks in the group world_size: int # size of the group # difference between `local_rank` and `rank_in_group`: # if we have a group of size 4 across two nodes: # Process | Node | Rank | Local Rank | Rank in Group # 0 | 0 | 0 | 0 | 0 # 1 | 0 | 1 | 1 | 1 # 2 | 1 | 2 | 0 | 2 # 3 | 1 | 3 | 1 | 3 local_rank: int # local rank used to assign devices rank_in_group: int # rank inside the group cpu_group: ProcessGroup # group for CPU communication device_group: ProcessGroup # group for device communication # device communicator (if use_device_communicator=True) device_communicator: DeviceCommunicatorBase | None mq_broadcaster: Any | None # shared memory broadcaster def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) @property def first_rank(self): \"\"\"Return the global rank of the first process in the group\"\"\" return self.ranks[0] @property def last_rank(self): \"\"\"Return the global rank of the last process in the group\"\"\" return self.ranks[-1] @property def is_first_rank(self): \"\"\"Return whether the caller is the first process in the group\"\"\" return self.rank == self.first_rank @property def is_last_rank(self): \"\"\"Return whether the caller is the last process in the group\"\"\" return self.rank == self.last_rank @property def next_rank(self): \"\"\"Return the global rank of the process that follows the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group + 1) % world_size] @property def prev_rank(self): \"\"\"Return the global rank of the process that precedes the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group - 1) % world_size] @contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states cpu_group instance-attribute ¶ cpu_group: ProcessGroup = self_cpu_group device instance-attribute ¶ device = device(f'cuda:{local_rank}') device_communicator instance-attribute ¶ device_communicator: DeviceCommunicatorBase | None = None device_group instance-attribute ¶ device_group: ProcessGroup = self_device_group first_rank property ¶ first_rank Return the global rank of the first process in the group is_first_rank property ¶ is_first_rank Return whether the caller is the first process in the group is_last_rank property ¶ is_last_rank Return whether the caller is the last process in the group last_rank property ¶ last_rank Return the global rank of the last process in the group local_rank instance-attribute ¶ local_rank: int = local_rank mq_broadcaster instance-attribute ¶ mq_broadcaster: MessageQueue | None = None next_rank property ¶ next_rank Return the global rank of the process that follows the caller prev_rank property ¶ prev_rank Return the global rank of the process that precedes the caller rank instance-attribute ¶ rank: int = get_rank() rank_in_group instance-attribute ¶ rank_in_group: int ranks instance-attribute ¶ ranks: list[int] unique_name instance-attribute ¶ unique_name = _get_unique_name(group_name) use_cpu_custom_send_recv instance-attribute ¶ use_cpu_custom_send_recv = is_cpu() and hasattr( _C, \"init_shm_manager\" ) use_custom_op_call instance-attribute ¶ use_custom_op_call = is_cuda_alike() or is_tpu() use_device_communicator instance-attribute ¶ use_device_communicator = use_device_communicator world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, use_message_queue_broadcaster: bool = False, group_name: str | None = None, ) Source code in vllm/distributed/parallel_state.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) _all_gather_out_place ¶ _all_gather_out_place(input_: Tensor, dim: int) -> Tensor Source code in vllm/distributed/parallel_state.py 525 526 527 528def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) _all_reduce_out_place ¶ _all_reduce_out_place(input_: Tensor) -> Tensor Source code in vllm/distributed/parallel_state.py 504 505 506 507def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) _reduce_scatter_out_place ¶ _reduce_scatter_out_place( input_: Tensor, dim: int ) -> Tensor Source code in vllm/distributed/parallel_state.py 563 564 565 566def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) Source code in vllm/distributed/parallel_state.py 530 531 532 533 534 535 536 537 538def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) all_reduce ¶ all_reduce(input_: Tensor) -> Tensor User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (self in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. Source code in vllm/distributed/parallel_state.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) barrier ¶ barrier() Barrier synchronization among the group. NOTE: don't use device_group here! barrier in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. Source code in vllm/distributed/parallel_state.py 964 965 966 967 968 969 970 971def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) broadcast ¶ broadcast(input_: Tensor, src: int = 0) Broadcast the input tensor. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ broadcast_object ¶ broadcast_object(obj: Any | None = None, src: int = 0) Broadcast the input object. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] broadcast_object_list ¶ broadcast_object_list( obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None, ) Broadcast the input object list. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[str, Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, Tensor | Any] | None Broadcast the input tensor dictionary. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict combine ¶ combine( hidden_states, is_sequence_parallel: bool = False ) -> Tensor Source code in vllm/distributed/parallel_state.py 1025 1026 1027 1028 1029 1030 1031def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states create_mq_broadcaster ¶ create_mq_broadcaster( writer_rank=0, external_writer_handle=None, blocking=True, ) Source code in vllm/distributed/parallel_state.py 389 390 391 392 393 394 395 396 397 398 399 400 401def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) create_single_reader_mq_broadcasters ¶ create_single_reader_mq_broadcasters( reader_rank_in_group=0, blocking=False ) Source code in vllm/distributed/parallel_state.py 403 404 405 406 407 408 409 410 411 412 413 414def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) destroy ¶ destroy() Source code in vllm/distributed/parallel_state.py 989 990 991 992 993 994 995 996 997 998 999def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, extra_tensors: list[Tensor] | None = None, ) -> ( tuple[Tensor, Tensor] | tuple[Tensor, Tensor, list[Tensor]] ) Source code in vllm/distributed/parallel_state.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/parallel_state.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) graph_capture ¶ graph_capture( graph_capture_context: GraphCaptureContext | None = None, ) Source code in vllm/distributed/parallel_state.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478@contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Source code in vllm/distributed/parallel_state.py 1001 1002 1003def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/parallel_state.py 980 981 982 983 984 985 986 987def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) recv_object ¶ recv_object(src: int) -> Any Receive the input object list from the source rank. Source code in vllm/distributed/parallel_state.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj recv_tensor_dict ¶ recv_tensor_dict( src: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Recv the input tensor dictionary. NOTE: src is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/parallel_state.py 556 557 558 559 560 561def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/parallel_state.py 973 974 975 976 977 978def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) send_object ¶ send_object(obj: Any, dst: int) -> None Send the input object list to the destination rank. Source code in vllm/distributed/parallel_state.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None send_tensor_dict ¶ send_tensor_dict( tensor_dict: dict[str, Tensor | Any], dst: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Send the input tensor dictionary. NOTE: dst is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None StatelessProcessGroup dataclass ¶ A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. Source code in vllm/distributed/utils.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@dataclasses.dataclass class StatelessProcessGroup: \"\"\"A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. \"\"\" rank: int world_size: int store: torch._C._distributed_c10d.Store # stores a reference to the socket so that the file descriptor stays alive socket: socket.socket | None data_expiration_seconds: int = 3600 # 1 hour # dst rank -> counter send_dst_counter: dict[int, int] = dataclasses.field(default_factory=dict) # src rank -> counter recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) broadcast_send_counter: int = 0 broadcast_recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) # A deque to store the data entries, with key and timestamp. entries: deque[tuple[str, float]] = dataclasses.field(default_factory=deque) def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") @staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) broadcast_recv_src_counter class-attribute instance-attribute ¶ broadcast_recv_src_counter: dict[int, int] = field( default_factory=dict ) broadcast_send_counter class-attribute instance-attribute ¶ broadcast_send_counter: int = 0 data_expiration_seconds class-attribute instance-attribute ¶ data_expiration_seconds: int = 3600 entries class-attribute instance-attribute ¶ entries: deque[tuple[str, float]] = field( default_factory=deque ) rank instance-attribute ¶ rank: int recv_src_counter class-attribute instance-attribute ¶ recv_src_counter: dict[int, int] = field( default_factory=dict ) send_dst_counter class-attribute instance-attribute ¶ send_dst_counter: dict[int, int] = field( default_factory=dict ) socket instance-attribute ¶ socket: socket | None store instance-attribute ¶ store: Store world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( rank: int, world_size: int, store: Store, socket: socket | None, data_expiration_seconds: int = 3600, send_dst_counter: dict[int, int] = dict(), recv_src_counter: dict[int, int] = dict(), broadcast_send_counter: int = 0, broadcast_recv_src_counter: dict[int, int] = dict(), entries: deque[tuple[str, float]] = deque(), ) -> None __post_init__ ¶ __post_init__() Source code in vllm/distributed/utils.py 169 170 171 172 173def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} all_gather_obj ¶ all_gather_obj(obj: Any) -> list[Any] All gather an object from all ranks. Source code in vllm/distributed/utils.py 220 221 222 223 224 225 226 227 228 229 230def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs barrier ¶ barrier(timeout: float = 30.0) A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: Each process signals it has reached the barrier Each process signals that it has confirmed the arrival of all other ranks. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Parameters: Name Type Description Default timeout float Maximum time in seconds to wait for each phase (in seconds) 30.0 Raises: Type Description RuntimeError If coordination fails or times out Source code in vllm/distributed/utils.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") broadcast_obj ¶ broadcast_obj(obj: Any | None, src: int) -> Any Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. Source code in vllm/distributed/utils.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj create staticmethod ¶ create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> StatelessProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. If we have process A and process B called torch.distributed.init_process_group to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. torch.distributed.init_process_group is a global call, while this function is a stateless call. It will return a StatelessProcessGroup object that can be used for exchanging metadata. With this function, process A and process B can call StatelessProcessGroup.create to form a group, and then process A, B, C, and D can call StatelessProcessGroup.create to form another group. Source code in vllm/distributed/utils.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) expire_data ¶ expire_data() Expire data that is older than data_expiration_seconds seconds. Source code in vllm/distributed/utils.py 183 184 185 186 187 188 189 190 191 192def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break recv_obj ¶ recv_obj(src: int) -> Any Receive an object from a source rank. Source code in vllm/distributed/utils.py 194 195 196 197 198 199 200def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj send_obj ¶ send_obj(obj: Any, dst: int) Send an object to a destination rank. Source code in vllm/distributed/utils.py 175 176 177 178 179 180 181def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) all_gather ¶ all_gather( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 147 148 149 150 151 152 153 154def all_gather( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_gather_out_place(tensor, dim) all_gather_fake ¶ all_gather_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 157 158 159 160 161 162def all_gather_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] * world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) all_reduce ¶ all_reduce(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 117 118 119 120 121 122def all_reduce(tensor: torch.Tensor, group_name: str) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_reduce_out_place(tensor) all_reduce_fake ¶ all_reduce_fake(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 125 126def all_reduce_fake(tensor: torch.Tensor, group_name: str) -> torch.Tensor: return torch.empty_like(tensor) broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[Any, Tensor | Any] | None = None, src: int = 0, ) Source code in vllm/distributed/communication_op.py 38 39 40 41 42 43def broadcast_tensor_dict( tensor_dict: dict[Any, torch.Tensor | Any] | None = None, src: int = 0 ): if not torch.distributed.is_initialized(): return tensor_dict return get_tp_group().broadcast_tensor_dict(tensor_dict, src) cleanup_dist_env_and_memory ¶ cleanup_dist_env_and_memory(shutdown_ray: bool = False) Source code in vllm/distributed/parallel_state.py 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617def cleanup_dist_env_and_memory(shutdown_ray: bool = False): # Reset environment variable cache envs.disable_envs_cache() # Ensure all objects are not frozen before cleanup gc.unfreeze() destroy_model_parallel() destroy_distributed_environment() if shutdown_ray: import ray # Lazy import Ray ray.shutdown() gc.collect() from vllm.platforms import current_platform empty_cache = current_platform.empty_cache if empty_cache is not None: empty_cache() try: if not current_platform.is_cpu(): torch._C._host_emptyCache() except AttributeError: logger.warning(\"torch._C._host_emptyCache() only available in Pytorch >=2.5\") destroy_distributed_environment ¶ destroy_distributed_environment() Source code in vllm/distributed/parallel_state.py 1585 1586 1587 1588 1589 1590 1591 1592def destroy_distributed_environment(): global _WORLD, _NODE_COUNT if _WORLD: _WORLD.destroy() _WORLD = None _NODE_COUNT = None if torch.distributed.is_initialized(): torch.distributed.destroy_process_group() destroy_model_parallel ¶ destroy_model_parallel() Set the groups to none and destroy them. Source code in vllm/distributed/parallel_state.py 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582def destroy_model_parallel(): \"\"\"Set the groups to none and destroy them.\"\"\" global _TP if _TP: _TP.destroy() _TP = None global _DCP if _DCP: _DCP.destroy() _DCP = None global _PCP if _PCP: _PCP.destroy() _PCP = None global _PP if _PP: _PP.destroy() _PP = None global _DP if _DP: _DP.destroy() _DP = None global _EP if _EP: _EP.destroy() _EP = None direct_register_custom_op ¶ direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[Tag, ...] = (), ) torch.library.custom_op can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the target_lib argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. Source code in vllm/utils/torch_utils.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727def direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[torch.Tag, ...] = (), ): \"\"\" `torch.library.custom_op` can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the `target_lib` argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. \"\"\" if not supports_custom_op(): from vllm.platforms import current_platform assert not current_platform.is_cuda_alike(), ( \"cuda platform needs torch>=2.4 to support custom op, \" \"chances are you are using an old version of pytorch \" \"or a custom build of pytorch. It is recommended to \" \"use vLLM in a fresh new environment and let it install \" \"the required dependencies.\" ) return if mutates_args is None: mutates_args = [] if dispatch_key is None: from vllm.platforms import current_platform dispatch_key = current_platform.dispatch_key schema_str = infer_schema(op_func, mutates_args=mutates_args) my_lib = target_lib or vllm_lib my_lib.define(op_name + schema_str, tags=tags) my_lib.impl(op_name, op_func, dispatch_key=dispatch_key) if fake_impl is not None: my_lib._register_fake(op_name, fake_impl) divide ¶ divide(numerator, denominator) Ensure that numerator is divisible by the denominator and return the division value. Source code in vllm/distributed/utils.py 60 61 62 63 64def divide(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator and return the division value.\"\"\" ensure_divisibility(numerator, denominator) return numerator // denominator ensure_divisibility ¶ ensure_divisibility(numerator, denominator) Ensure that numerator is divisible by the denominator. Source code in vllm/distributed/utils.py 53 54 55 56 57def ensure_divisibility(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator.\"\"\" assert numerator % denominator == 0, \"{} is not divisible by {}\".format( numerator, denominator ) ensure_model_parallel_initialized ¶ ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470def ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\"Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. \"\"\" backend = backend or torch.distributed.get_backend(get_world_group().device_group) if not model_parallel_is_initialized(): initialize_model_parallel( tensor_model_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, decode_context_model_parallel_size, backend, ) return assert get_tensor_model_parallel_world_size() == tensor_model_parallel_size, ( \"tensor parallel group already initialized, but of unexpected size. \" f\"got: {get_tensor_model_parallel_world_size()=} vs. \" f\"wanted: {tensor_model_parallel_size=}\" ) pp_world_size = get_pp_group().world_size assert pp_world_size == pipeline_model_parallel_size, ( \"pipeline parallel group already initialized, but of unexpected size. \" f\"got: {pp_world_size=} vs. \" f\"wanted: {pipeline_model_parallel_size=}\" ) pcp_world_size = get_pcp_group().world_size assert pcp_world_size == prefill_context_model_parallel_size, ( \"prefill context parallel group already initialized, but of unexpected size: \" f\"{pcp_world_size=} vs. \" f\"{prefill_context_model_parallel_size=}\" ) get_dcp_group ¶ get_dcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1090 1091 1092def get_dcp_group() -> GroupCoordinator: assert _DCP is not None, \"decode context model parallel group is not initialized\" return _DCP get_decode_context_model_parallel_rank ¶ get_decode_context_model_parallel_rank() Return my rank for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1540 1541 1542def get_decode_context_model_parallel_rank(): \"\"\"Return my rank for the decode context model parallel group.\"\"\" return get_dcp_group().rank_in_group get_decode_context_model_parallel_world_size ¶ get_decode_context_model_parallel_world_size() Return world size for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1535 1536 1537def get_decode_context_model_parallel_world_size(): \"\"\"Return world size for the decode context model parallel group.\"\"\" return get_dcp_group().world_size get_distributed_init_method ¶ get_distributed_init_method(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 130 131def get_distributed_init_method(ip: str, port: int) -> str: return get_tcp_uri(ip, port) get_dp_group ¶ get_dp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1109 1110 1111def get_dp_group() -> GroupCoordinator: assert _DP is not None, \"data parallel group is not initialized\" return _DP get_ep_group ¶ get_ep_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1117 1118 1119def get_ep_group() -> GroupCoordinator: assert _EP is not None, \"expert parallel group is not initialized\" return _EP get_inner_dp_world_group ¶ get_inner_dp_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1044 1045 1046def get_inner_dp_world_group() -> GroupCoordinator: assert _INNER_DP_WORLD is not None, \"inner dp world group is not initialized\" return _INNER_DP_WORLD get_node_count ¶ get_node_count() -> int Return the total number of nodes in the distributed environment. Source code in vllm/distributed/parallel_state.py 1545 1546 1547 1548def get_node_count() -> int: \"\"\"Return the total number of nodes in the distributed environment.\"\"\" assert _NODE_COUNT is not None, \"distributed environment is not initialized\" return _NODE_COUNT get_pcp_group ¶ get_pcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1125 1126 1127def get_pcp_group() -> GroupCoordinator: assert _PCP is not None, \"prefill context parallel group is not initialized\" return _PCP get_pp_group ¶ get_pp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1101 1102 1103def get_pp_group() -> GroupCoordinator: assert _PP is not None, \"pipeline model parallel group is not initialized\" return _PP get_pp_indices ¶ get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int] Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If pp_size > 2 and the number of remaining layers is 0 < x <= pp_size - 2 then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. Source code in vllm/distributed/utils.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140def get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int]: \"\"\"Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If `pp_size > 2` and the number of remaining layers is `0 < x <= pp_size - 2` then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. \"\"\" partition_list_str = envs.VLLM_PP_LAYER_PARTITION if partition_list_str is not None: try: partitions = [int(layer) for layer in partition_list_str.split(\",\")] except ValueError as err: raise ValueError( \"Invalid partition string: {}\".format(partition_list_str) ) from err if len(partitions) != pp_size: raise ValueError(f\"{len(partitions)=} does not match {pp_size=}.\") if sum(partitions) != num_hidden_layers: raise ValueError(f\"{sum(partitions)=} does not match {num_hidden_layers=}.\") else: layers_per_partition = num_hidden_layers // pp_size partitions = [layers_per_partition for _ in range(pp_size)] if remaining_layers := num_hidden_layers % pp_size: for i in range(2, remaining_layers + 2): partitions[-i] += 1 logger.info( \"Hidden layers were unevenly partitioned: [%s]. \" \"This can be manually overridden using the \" \"VLLM_PP_LAYER_PARTITION environment variable\", \",\".join(str(p) for p in partitions), ) start_layer = sum(partitions[:pp_rank]) end_layer = start_layer + partitions[pp_rank] return (start_layer, end_layer) get_tcp_uri ¶ get_tcp_uri(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 134 135 136 137 138def get_tcp_uri(ip: str, port: int) -> str: if is_valid_ipv6_address(ip): return f\"tcp://[{ip}]:{port}\" else: return f\"tcp://{ip}:{port}\" get_tensor_model_parallel_rank ¶ get_tensor_model_parallel_rank() Return my rank for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1530 1531 1532def get_tensor_model_parallel_rank(): \"\"\"Return my rank for the tensor model parallel group.\"\"\" return get_tp_group().rank_in_group get_tensor_model_parallel_world_size ¶ get_tensor_model_parallel_world_size() Return world size for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1525 1526 1527def get_tensor_model_parallel_world_size(): \"\"\"Return world size for the tensor model parallel group.\"\"\" return get_tp_group().world_size get_tp_group ¶ get_tp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1082 1083 1084def get_tp_group() -> GroupCoordinator: assert _TP is not None, \"tensor model parallel group is not initialized\" return _TP get_world_group ¶ get_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1039 1040 1041def get_world_group() -> GroupCoordinator: assert _WORLD is not None, \"world group is not initialized\" return _WORLD graph_capture ¶ graph_capture(device: device) graph_capture is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a GraphCaptureContext object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. Source code in vllm/distributed/parallel_state.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147@contextmanager def graph_capture(device: torch.device): \"\"\" `graph_capture` is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a `GraphCaptureContext` object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. \"\"\" context = GraphCaptureContext(torch.cuda.Stream(device=device)) with get_tp_group().graph_capture(context), get_pp_group().graph_capture(context): yield context in_the_same_node_as ¶ in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0, ) -> list[bool] This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). Source code in vllm/distributed/parallel_state.py 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709def in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0 ) -> list[bool]: \"\"\" This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). \"\"\" if isinstance(pg, ProcessGroup): assert torch.distributed.get_backend(pg) != torch.distributed.Backend.NCCL, ( \"in_the_same_node_as should be tested with a non-NCCL group.\" ) # local rank inside the group rank = torch.distributed.get_rank(group=pg) world_size = torch.distributed.get_world_size(group=pg) # global ranks of the processes in the group ranks = torch.distributed.get_process_group_ranks(pg) else: rank = pg.rank world_size = pg.world_size ranks = list(range(world_size)) # local tensor in each process to store the result is_in_the_same_node = torch.tensor( [0] * world_size, dtype=torch.int32, device=\"cpu\" ) magic_message = b\"magic_message\" shm = None try: with contextlib.suppress(OSError): if rank == source_rank: # create a shared memory segment shm = shared_memory.SharedMemory(create=True, size=128) shm.buf[: len(magic_message)] = magic_message if isinstance(pg, ProcessGroup): torch.distributed.broadcast_object_list( [shm.name], src=ranks[source_rank], group=pg ) else: pg.broadcast_obj(shm.name, src=source_rank) is_in_the_same_node[rank] = 1 else: # try to open the shared memory segment if isinstance(pg, ProcessGroup): recv = [None] torch.distributed.broadcast_object_list( recv, src=ranks[source_rank], group=pg ) name = recv[0] else: name = pg.broadcast_obj(None, src=source_rank) # fix to https://stackoverflow.com/q/62748654/9191338 # Python incorrectly tracks shared memory even if it is not # created by the process. The following patch is a workaround. with patch( \"multiprocessing.resource_tracker.register\", lambda *args, **kwargs: None, ): shm = shared_memory.SharedMemory(name=name) if shm.buf[: len(magic_message)] == magic_message: is_in_the_same_node[rank] = 1 except Exception as e: logger.error(\"Error ignored in is_in_the_same_node: %s\", e) finally: if shm: shm.close() if isinstance(pg, ProcessGroup): torch.distributed.barrier(group=pg) else: pg.barrier() # clean up the shared memory segment with contextlib.suppress(OSError): if rank == source_rank and shm: shm.unlink() if isinstance(pg, ProcessGroup): torch.distributed.all_reduce(is_in_the_same_node, group=pg) aggregated_data = is_in_the_same_node else: aggregated_data = torch.zeros_like(is_in_the_same_node) for i in range(world_size): rank_data = pg.broadcast_obj(is_in_the_same_node, src=i) aggregated_data += rank_data return [x == 1 for x in aggregated_data.tolist()] init_distributed_environment ¶ init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ) Source code in vllm/distributed/parallel_state.py 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275def init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ): logger.debug( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) from vllm.config import get_current_vllm_config config = get_current_vllm_config() if ( config is not None and config.parallel_config.distributed_executor_backend != \"external_launcher\" and ( config.parallel_config.nnodes > 1 or config.parallel_config.data_parallel_size > 1 ) ): parallel_config = config.parallel_config # adjust to take into account data parallelism # offset the rank by the data parallel rank rank = parallel_config.data_parallel_rank * world_size + rank # adjust the world size to take into account data parallelism world_size = parallel_config.world_size_across_dp # Use appropriate IP and port based on configuration if parallel_config.nnodes > 1: ip = parallel_config.master_addr port = parallel_config.master_port distributed_init_method = get_distributed_init_method(ip, port) else: ip = parallel_config.data_parallel_master_ip port = parallel_config.get_next_dp_init_port() distributed_init_method = get_distributed_init_method(ip, port) logger.debug( \"Adjusting world_size=%d rank=%d distributed_init_method=%s for DP\", world_size, rank, distributed_init_method, ) if not torch.distributed.is_initialized(): logger.info( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) assert distributed_init_method is not None, ( \"distributed_init_method must be provided when initializing \" \"distributed environment\" ) if not torch.distributed.is_backend_available(backend): logger.warning( \"Distributed backend %s is not available; falling back to gloo.\", backend, ) assert torch.distributed.is_gloo_available(), ( \"Fallback Gloo backend is not available.\" ) backend = \"gloo\" # this backend is used for WORLD torch.distributed.init_process_group( backend=backend, init_method=distributed_init_method, world_size=world_size, rank=rank, timeout=timeout, ) # set the local rank # local_rank is not available in torch ProcessGroup, # see https://github.com/pytorch/pytorch/issues/122816 if local_rank == -1: # local rank not set, this usually happens in single-node # setting, where we can use rank as local rank local_rank = envs.LOCAL_RANK if distributed_init_method == \"env://\" else rank global _WORLD, _NODE_COUNT, _INNER_DP_WORLD if _WORLD is None: ranks = list(range(torch.distributed.get_world_size())) _WORLD = init_world_group(ranks, local_rank, backend) if config.parallel_config.nnodes > 1: _NODE_COUNT = config.parallel_config.nnodes else: _NODE_COUNT = _node_count(_WORLD.cpu_group) logger.debug(\"Detected %d nodes in the distributed environment\", _NODE_COUNT) else: assert _WORLD.world_size == torch.distributed.get_world_size(), ( \"world group already initialized with a different world size\" ) if config.parallel_config.nnodes_within_dp > 1: if parallel_config.data_parallel_size > 1: world_size_inner_dp = parallel_config.world_size group_ranks = [ [dp_rank * world_size_inner_dp + i for i in range(world_size_inner_dp)] for dp_rank in range(parallel_config.data_parallel_size) ] _INNER_DP_WORLD = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"inner_dp_world\", use_device_communicator=False, ) else: _INNER_DP_WORLD = _WORLD init_gloo_process_group ¶ init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup Stateless init ProcessGroup with gloo backend compatible with different torch versions. Source code in vllm/distributed/utils.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459def init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup: \"\"\" Stateless init ProcessGroup with gloo backend compatible with different torch versions. \"\"\" with suppress_stdout(): if is_torch_equal_or_newer(\"2.6\"): pg = ProcessGroup( prefix_store, group_rank, group_size, ) else: options = ProcessGroup.Options(backend=\"gloo\") pg = ProcessGroup( prefix_store, group_rank, group_size, options, ) from torch.distributed.distributed_c10d import ProcessGroupGloo backend_class = ProcessGroupGloo( prefix_store, group_rank, group_size, timeout=timeout ) backend_type = ProcessGroup.BackendType.GLOO device = torch.device(\"cpu\") if is_torch_equal_or_newer(\"2.6\"): # _set_default_backend is supported in torch >= 2.6 pg._set_default_backend(backend_type) backend_class._set_sequence_number_for_group() pg._register_backend(device, backend_type, backend_class) return pg init_logger ¶ init_logger(name: str) -> _VllmLogger The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured. Source code in vllm/logger.py 206 207 208 209 210 211 212 213 214 215 216def init_logger(name: str) -> _VllmLogger: \"\"\"The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured.\"\"\" logger = logging.getLogger(name) for method_name, method in _METHODS_TO_PATCH.items(): setattr(logger, method_name, MethodType(method, logger)) return cast(_VllmLogger, logger) init_model_parallel_group ¶ init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076def init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator: return GroupCoordinator( group_ranks=group_ranks, local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=use_device_communicator, use_message_queue_broadcaster=use_message_queue_broadcaster, group_name=group_name, ) init_world_group ¶ init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058def init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator: return GroupCoordinator( group_ranks=[ranks], local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=False, group_name=\"world\", ) initialize_model_parallel ¶ initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Initialize model parallel groups. Parameters: Name Type Description Default tensor_model_parallel_size int number of GPUs used for tensor model parallelism. 1 pipeline_model_parallel_size int number of GPUs used for pipeline model parallelism. 1 backend str | None name of torch distributed communication backend. None Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. Source code in vllm/distributed/parallel_state.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429def initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\" Initialize model parallel groups. Arguments: tensor_model_parallel_size: number of GPUs used for tensor model parallelism. pipeline_model_parallel_size: number of GPUs used for pipeline model parallelism. backend: name of torch distributed communication backend. Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. \"\"\" # Get world size and rank. Ensure some consistencies. assert torch.distributed.is_initialized() world_size: int = torch.distributed.get_world_size() rank = torch.distributed.get_rank() backend = backend or torch.distributed.get_backend(get_world_group().device_group) data_parallel_size = 1 from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: data_parallel_size = config.parallel_config.data_parallel_size # the layout order is: ExternalDP x DP x PP x TP # ExternalDP is the data parallel group that is not part of the model, # every dp rank can generate independently (in verl integration). # DP is the data parallel group that is part of the model, # all the ranks in the same DP group should generate simultaneously, # i.e. the `generate` call in the same DP group should be called together, # otherwise it will cause deadlock. # to get group_ranks for each dimension, transpose that dimension to the # last dimension, then reshape to 2D, then unbind the last dimension all_ranks = torch.arange(world_size).reshape( -1, data_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, tensor_model_parallel_size, ) # noqa # Build the tensor model-parallel groups. global _TP assert _TP is None, \"tensor model parallel group is already initialized\" group_ranks = all_ranks.view(-1, tensor_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] # message queue broadcaster is only used in tensor model parallel group _TP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"tp\", ) # Build the DCP model-parallel groups. global _DCP assert _DCP is None, \"decode context model parallel group is already initialized\" # Note(hc): In the current implementation of decode context parallel, # dcp_size must not exceed tp_size, because the world size does not # change by DCP, it simply reuses the GPUs of TP group, and split one # TP group into tp_size//dcp_size DCP groups. group_ranks = all_ranks.reshape(-1, decode_context_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"dcp\", ) global _PCP assert _PCP is None, \"prefill context parallel group is already initialized\" group_ranks = ( all_ranks.transpose(3, 4) .reshape(-1, prefill_context_model_parallel_size) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pcp\" ) # Build the pipeline model-parallel groups. global _PP assert _PP is None, \"pipeline model parallel group is already initialized\" group_ranks = ( all_ranks.transpose(2, 4).reshape(-1, pipeline_model_parallel_size).unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pp\" ) global _DP assert _DP is None, \"data parallel group is already initialized\" group_ranks = all_ranks.transpose(1, 4).reshape(-1, data_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"dp\" ) global _EP assert _EP is None, \"expert parallel group is already initialized\" group_ranks = ( all_ranks.transpose(1, 2) .reshape( -1, data_parallel_size * prefill_context_model_parallel_size * tensor_model_parallel_size, ) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _EP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"ep\" ) logger.info_once( \"rank %s in world size %s is assigned as \" \"DP rank %s, PP rank %s, PCP rank %s, \" \"TP rank %s, EP rank %s\", rank, world_size, _DP.rank_in_group, _PP.rank_in_group, _PCP.rank_in_group, _TP.rank_in_group, _EP.rank_in_group, ) is_global_first_rank ¶ is_global_first_rank() -> bool Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like get_tensor_model_parallel_rank() == 0 or get_pp_group().is_first_rank, this function checks the global rank across all parallelism dimensions. Returns: Name Type Description bool bool True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). Source code in vllm/distributed/parallel_state.py 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740def is_global_first_rank() -> bool: \"\"\" Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like `get_tensor_model_parallel_rank() == 0` or `get_pp_group().is_first_rank`, this function checks the global rank across all parallelism dimensions. Returns: bool: True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). \"\"\" try: # If world group is available, use it for the most accurate check global _WORLD if _WORLD is not None: return _WORLD.is_first_rank # If torch distributed is not initialized, assume single process if not torch.distributed.is_initialized(): return True # Fallback to torch's global rank return torch.distributed.get_rank() == 0 except Exception: # If anything goes wrong, assume this is the first rank return True is_local_first_rank ¶ is_local_first_rank() -> bool Check if the current process is the first local rank (rank 0 on its node). Source code in vllm/distributed/parallel_state.py 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763def is_local_first_rank() -> bool: \"\"\" Check if the current process is the first local rank (rank 0 on its node). \"\"\" try: # prefer the initialized world group if available global _WORLD if _WORLD is not None: return _WORLD.local_rank == 0 if not torch.distributed.is_initialized(): return True # fallback to environment-provided local rank if available # note: envs.LOCAL_RANK is set when using env:// launchers (e.g., torchrun) try: return int(envs.LOCAL_RANK) == 0 # type: ignore[arg-type] except Exception: return torch.distributed.get_rank() == 0 except Exception: return True is_torch_equal_or_newer ¶ is_torch_equal_or_newer(target: str) -> bool Check if the installed torch version is >= the target version. Parameters: Name Type Description Default target str a version string, like \"2.6.0\". required Returns: Type Description bool Whether the condition meets. Source code in vllm/utils/torch_utils.py 610 611 612 613 614 615 616 617 618 619 620 621 622 623def is_torch_equal_or_newer(target: str) -> bool: \"\"\"Check if the installed torch version is >= the target version. Args: target: a version string, like \"2.6.0\". Returns: Whether the condition meets. \"\"\" try: return _is_torch_equal_or_newer(str(torch.__version__), target) except Exception: # Fallback to PKG-INFO to load the package info, needed by the doc gen. return Version(importlib.metadata.version(\"torch\")) >= Version(target) model_parallel_is_initialized ¶ model_parallel_is_initialized() Check if tensor and pipeline parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1492 1493 1494def model_parallel_is_initialized(): \"\"\"Check if tensor and pipeline parallel groups are initialized.\"\"\" return _TP is not None and _PP is not None patch_tensor_parallel_group ¶ patch_tensor_parallel_group(tp_group: GroupCoordinator) Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Parameters: Name Type Description Default tp_group GroupCoordinator the tp group coordinator required Source code in vllm/distributed/parallel_state.py 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522@contextmanager def patch_tensor_parallel_group(tp_group: GroupCoordinator): \"\"\"Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Args: tp_group (GroupCoordinator): the tp group coordinator \"\"\" global _TP_STATE_PATCHED assert not _TP_STATE_PATCHED, \"Should not call when it's already patched\" _TP_STATE_PATCHED = True old_tp_group = get_tp_group() global _TP _TP = tp_group try: yield finally: # restore the original state _TP_STATE_PATCHED = False _TP = old_tp_group patched_fused_scaled_matmul_reduce_scatter ¶ patched_fused_scaled_matmul_reduce_scatter( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246def patched_fused_scaled_matmul_reduce_scatter( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: return torch.ops.symm_mem.fused_scaled_matmul_reduce_scatter( A, B, A_scale, B_scale, reduce_op, orig_scatter_dim, scatter_dim_after_maybe_reshape, group_name, output_shape, bias, result_scale, out_dtype, use_fast_accum, ) patched_fused_scaled_matmul_reduce_scatter_fake ¶ patched_fused_scaled_matmul_reduce_scatter_fake( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214def patched_fused_scaled_matmul_reduce_scatter_fake( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: # Copied from # https://github.com/pytorch/pytorch/blob/50c338c2da905062449e4d9ac807832d1b5cd90e/torch/distributed/_symmetric_memory/__init__.py#L1189 if A_scale.numel() > 1: if A_scale.shape[:-1] != A.shape[:-1]: raise ValueError( \"For row-wise scaling, the leading dims of A_scale \" \"must match the leading dims of A \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) A_scale = A_scale.flatten(0, -2).contiguous() elif A_scale.numel() != 1: raise ValueError( \"Invalid A_scale shape \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) C = torch._scaled_mm( A.flatten(0, -2).contiguous(), B, A_scale, B_scale, bias, result_scale, out_dtype, use_fast_accum, ) C = C.view(*output_shape[:-1], B.shape[1]) res = funcol.reduce_scatter_tensor( C, reduce_op, orig_scatter_dim, # need original scatter dim for 3D+ output tensor here group_name, ) res = funcol.wait_tensor(res) return res prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. Source code in vllm/distributed/parallel_state.py 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489def prepare_communication_buffer_for_model(model: torch.nn.Module): \"\"\"Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. \"\"\" if _TP is not None: _TP.prepare_communication_buffer_for_model(model) if _PCP is not None: _PCP.prepare_communication_buffer_for_model(model) if _PP is not None: _PP.prepare_communication_buffer_for_model(model) if _DP is not None: _DP.prepare_communication_buffer_for_model(model) if _EP is not None: _EP.prepare_communication_buffer_for_model(model) reduce_scatter ¶ reduce_scatter( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 129 130 131 132 133 134 135 136def reduce_scatter( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._reduce_scatter_out_place(tensor, dim) reduce_scatter_fake ¶ reduce_scatter_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 139 140 141 142 143 144def reduce_scatter_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] // world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) resolve_obj_by_qualname ¶ resolve_obj_by_qualname(qualname: str) -> Any Resolve an object by its fully-qualified class name. Source code in vllm/utils/import_utils.py 117 118 119 120 121 122 123def resolve_obj_by_qualname(qualname: str) -> Any: \"\"\" Resolve an object by its fully-qualified class name. \"\"\" module_name, obj_name = qualname.rsplit(\".\", 1) module = importlib.import_module(module_name) return getattr(module, obj_name) sched_yield ¶ sched_yield() Source code in vllm/distributed/utils.py 46 47 48 49 50def sched_yield(): if USE_SCHED_YIELD: os.sched_yield() else: time.sleep(0) set_custom_all_reduce ¶ set_custom_all_reduce(enable: bool) Source code in vllm/distributed/parallel_state.py 1155 1156 1157def set_custom_all_reduce(enable: bool): global _ENABLE_CUSTOM_ALL_REDUCE _ENABLE_CUSTOM_ALL_REDUCE = enable split_tensor_along_last_dim ¶ split_tensor_along_last_dim( tensor: Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[Tensor] Split a tensor along its last dimension. Parameters: Name Type Description Default tensor Tensor input tensor. required num_partitions int number of partitions to split the tensor required contiguous_split_chunks bool If True, make each chunk contiguous in memory. False Returns: Type Description Sequence[Tensor] A list of Tensors Source code in vllm/distributed/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92def split_tensor_along_last_dim( tensor: torch.Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[torch.Tensor]: \"\"\"Split a tensor along its last dimension. Arguments: tensor: input tensor. num_partitions: number of partitions to split the tensor contiguous_split_chunks: If True, make each chunk contiguous in memory. Returns: A list of Tensors \"\"\" # Get the size and dimension. last_dim = tensor.dim() - 1 last_dim_size = divide(tensor.size()[last_dim], num_partitions) # Split. tensor_list = torch.split(tensor, last_dim_size, dim=last_dim) # NOTE: torch.split does not create contiguous tensors by default. if contiguous_split_chunks: return tuple(chunk.contiguous() for chunk in tensor_list) return tensor_list stateless_destroy_torch_distributed_process_group ¶ stateless_destroy_torch_distributed_process_group( pg: ProcessGroup, ) -> None Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). Source code in vllm/distributed/utils.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545def stateless_destroy_torch_distributed_process_group(pg: ProcessGroup) -> None: \"\"\" Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). \"\"\" if is_torch_equal_or_newer(\"2.7\"): pg.shutdown() else: # Lazy import for non-CUDA backends. from torch.distributed.distributed_c10d import _shutdown_backend _shutdown_backend(pg) _unregister_process_group(pg.group_name) stateless_init_torch_distributed_process_group ¶ stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str, ) -> ProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. The created ProcessGroup object can be used for some operations such as allreduce, because it does not depend on the global rank. However, some operations such as broadcast cannot be used because it depends on the global rank. TODO: ask for help from PyTorch team if we need the broadcast operation.¶ This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. Source code in vllm/distributed/utils.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529def stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str ) -> ProcessGroup: \"\"\" A replacement for `torch.distributed.init_process_group` that does not pollute the global state. The created ProcessGroup object can be used for some operations such as `allreduce`, because it does not depend on the global rank. However, some operations such as `broadcast` cannot be used because it depends on the global rank. # TODO: ask for help from PyTorch team if we need the `broadcast` operation. This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. \"\"\" init_method = get_tcp_uri(host, port) backend = Backend(backend) # it is basically string timeout = _get_default_timeout(backend) store, rank, world_size = next( rendezvous(init_method, rank, world_size, timeout=timeout) ) store.set_timeout(timeout) group_rank = rank group_size = world_size # Use a PrefixStore to avoid accidental overrides of keys used by # different systems (e.g. RPC) in case the store is multi-tenant. prefix_store = PrefixStore(init_method, store) try: from vllm.platforms import current_platform return current_platform.stateless_init_device_torch_dist_pg( backend=backend, prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) except NotImplementedError: # If platform doesn't implement stateless_init_device_torch_dist_pg, it # will raise a NotImplementedError. In this case, we fall back to gloo. return init_gloo_process_group( prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) supports_custom_op ¶ supports_custom_op() -> bool Source code in vllm/utils/torch_utils.py 669 670def supports_custom_op() -> bool: return hasattr(torch.library, \"custom_op\") suppress_stdout ¶ suppress_stdout() Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") Source code in vllm/utils/system_utils.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89@contextlib.contextmanager def suppress_stdout(): \"\"\" Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example: with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") \"\"\" # Don't suppress if logging level is DEBUG if envs.VLLM_LOGGING_LEVEL == \"DEBUG\": yield return stdout_fd = sys.stdout.fileno() stdout_dup = os.dup(stdout_fd) devnull_fd = os.open(os.devnull, os.O_WRONLY) try: sys.stdout.flush() os.dup2(devnull_fd, stdout_fd) yield finally: sys.stdout.flush() os.dup2(stdout_dup, stdout_fd) os.close(stdout_dup) os.close(devnull_fd) tensor_model_parallel_all_gather ¶ tensor_model_parallel_all_gather( input_: Tensor, dim: int = -1 ) -> Tensor All-gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 17 18 19 20 21def tensor_model_parallel_all_gather( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"All-gather the input tensor across model parallel group.\"\"\" return get_tp_group().all_gather(input_, dim) tensor_model_parallel_all_reduce ¶ tensor_model_parallel_all_reduce(input_: Tensor) -> Tensor All-reduce the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 12 13 14def tensor_model_parallel_all_reduce(input_: torch.Tensor) -> torch.Tensor: \"\"\"All-reduce the input tensor across model parallel group.\"\"\" return get_tp_group().all_reduce(input_) tensor_model_parallel_gather ¶ tensor_model_parallel_gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None Gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 31 32 33 34 35def tensor_model_parallel_gather( input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\"Gather the input tensor across model parallel group.\"\"\" return get_tp_group().gather(input_, dst, dim) tensor_model_parallel_reduce_scatter ¶ tensor_model_parallel_reduce_scatter( input_: Tensor, dim: int = -1 ) -> Tensor Reduce-Scatter the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 24 25 26 27 28def tensor_model_parallel_reduce_scatter( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"Reduce-Scatter the input tensor across model parallel group.\"\"\" return get_tp_group().reduce_scatter(input_, dim)",
      "code": "communication_op"
    },
    {
      "description": "TensorMetadata module-attribute ¶ TensorMetadata = namedtuple( \"TensorMetadata\", [\"device\", \"dtype\", \"size\"] ) USE_SCHED_YIELD module-attribute ¶ USE_SCHED_YIELD = ( version_info[:3] >= (3, 11, 1) or version_info[:2] == (3, 10) and version_info[2] >= 8 ) get_context_model_parallel_group module-attribute ¶ get_context_model_parallel_group = get_dcp_group logger module-attribute ¶ logger = init_logger(__name__) DeviceCommunicatorBase ¶ Base class for device-specific communicator. It can use the cpu_group to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the device_group will also be given. Source code in vllm/distributed/device_communicators/base_device_communicator.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302class DeviceCommunicatorBase: \"\"\" Base class for device-specific communicator. It can use the `cpu_group` to initialize the communicator. If the device has PyTorch integration (PyTorch can recognize its communication backend), the `device_group` will also be given. \"\"\" def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor def destroy(self): pass def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states all2all_backend instance-attribute ¶ all2all_backend = all2all_backend all2all_manager instance-attribute ¶ all2all_manager: All2AllManagerBase | None = None cpu_group instance-attribute ¶ cpu_group = cpu_group device instance-attribute ¶ device = device or device('cpu') device_group instance-attribute ¶ device_group = device_group global_rank instance-attribute ¶ global_rank = get_rank() global_world_size instance-attribute ¶ global_world_size = get_world_size() is_ep_communicator instance-attribute ¶ is_ep_communicator = 'ep' in unique_name rank instance-attribute ¶ rank = get_rank(cpu_group) rank_in_group instance-attribute ¶ rank_in_group = get_group_rank(cpu_group, global_rank) ranks instance-attribute ¶ ranks = get_process_group_ranks(cpu_group) unique_name instance-attribute ¶ unique_name = unique_name use_all2all instance-attribute ¶ use_all2all = is_ep_communicator and use_ep world_size instance-attribute ¶ world_size = get_world_size(cpu_group) __init__ ¶ __init__( cpu_group: ProcessGroup, device: device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ) Source code in vllm/distributed/device_communicators/base_device_communicator.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133def __init__( self, cpu_group: ProcessGroup, device: torch.device | None = None, device_group: ProcessGroup | None = None, unique_name: str = \"\", ): self.device = device or torch.device(\"cpu\") self.cpu_group = cpu_group self.device_group = device_group self.unique_name = unique_name self.rank = dist.get_rank(cpu_group) self.world_size = dist.get_world_size(cpu_group) self.ranks = dist.get_process_group_ranks(cpu_group) self.global_rank = dist.get_rank() self.global_world_size = dist.get_world_size() self.rank_in_group = dist.get_group_rank(self.cpu_group, self.global_rank) use_ep = False all2all_backend = None from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: # as long as we use data parallel (coupled data parallel # where all data parallel ranks execute forward together), # we initialize the all2all manager used in expert parallel. use_ep = config.parallel_config.data_parallel_size > 1 all2all_backend = config.parallel_config.all2all_backend self.is_ep_communicator = \"ep\" in unique_name self.use_all2all = self.is_ep_communicator and use_ep self.all2all_backend = all2all_backend self.all2all_manager: All2AllManagerBase | None = None all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: if dim < 0: # Convert negative dim to positive. dim += input_.dim() input_size = input_.size() # NOTE: we have to use concat-style all-gather here, # stack-style all-gather has compatibility issues with # torch.compile . see https://github.com/pytorch/pytorch/issues/138795 output_size = (input_size[0] * self.world_size,) + input_size[1:] # Allocate output tensor. output_tensor = torch.empty( output_size, dtype=input_.dtype, device=input_.device ) # All-gather. dist.all_gather_into_tensor(output_tensor, input_, group=self.device_group) # Reshape output_tensor = output_tensor.reshape((self.world_size,) + input_size) output_tensor = output_tensor.movedim(0, dim) output_tensor = output_tensor.reshape( input_size[:dim] + (self.world_size * input_size[dim],) + input_size[dim + 1 :] ) return output_tensor all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> Tensor | list[Tensor] Source code in vllm/distributed/device_communicators/base_device_communicator.py 164 165 166 167 168 169 170def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ) -> torch.Tensor | list[torch.Tensor]: raise NotImplementedError all_reduce ¶ all_reduce(input_: Tensor) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 135 136 137def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: dist.all_reduce(input_, group=self.device_group) return input_ combine ¶ combine( hidden_states: Tensor, is_sequence_parallel: bool = False, ) -> Tensor Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 295 296 297 298 299 300 301 302def combine( self, hidden_states: torch.Tensor, is_sequence_parallel: bool = False ) -> torch.Tensor: \"\"\" Combine the hidden states and router logits from the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states destroy ¶ destroy() Source code in vllm/distributed/device_communicators/base_device_communicator.py 260 261def destroy(self): pass dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, ) -> tuple[Tensor, Tensor] Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. Source code in vllm/distributed/device_communicators/base_device_communicator.py 283 284 285 286 287 288 289 290 291 292 293def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, ) -> tuple[torch.Tensor, torch.Tensor]: \"\"\" Dispatch the hidden states and router logits to the appropriate device. This is a no-op in the base class. \"\"\" return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Allocate output tensor. if self.rank_in_group == dst: gather_list = [torch.empty_like(input_) for _ in range(world_size)] else: gather_list = None # Gather. torch.distributed.gather( input_, gather_list, dst=self.ranks[dst], group=self.device_group ) if self.rank_in_group == dst: output_tensor = torch.cat(gather_list, dim=dim) else: output_tensor = None return output_tensor prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model( model: Module, ) -> None Prepare the communication buffer for the model. Source code in vllm/distributed/device_communicators/base_device_communicator.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281def prepare_communication_buffer_for_model(self, model: torch.nn.Module) -> None: \"\"\" Prepare the communication buffer for the model. \"\"\" if not self.is_ep_communicator: return moe_modules = [ module for module in model.modules() # TODO(bnell): Should use isinstance but can't. Maybe search for # presence of quant_method.maybe_init_modular_kernel? if ( module.__class__.__name__ == \"FusedMoE\" or module.__class__.__name__ == \"SharedFusedMoE\" ) ] for module in moe_modules: module.maybe_init_modular_kernel() recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/device_communicators/base_device_communicator.py 248 249 250 251 252 253 254 255 256 257 258def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if src is None: src = (self.rank_in_group - 1) % self.world_size tensor = torch.empty(size, dtype=dtype, device=self.device) torch.distributed.recv(tensor, self.ranks[src], self.device_group) return tensor reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if dim < 0: # Convert negative dim to positive. dim += input_.dim() # Note: This will produce an incorrect answer if we don't make # the input_tensor contiguous. Possible bug in reduce_scatter_tensor? input_tensor = input_.movedim(0, dim).contiguous() assert input_tensor.shape[0] % world_size == 0 chunk_size = input_tensor.shape[0] // world_size output_shape = (chunk_size,) + input_tensor.shape[1:] output_tensor = torch.empty( output_shape, dtype=input_tensor.dtype, device=input_tensor.device ) # Perform reduce-scatter operation torch.distributed.reduce_scatter_tensor( output_tensor, input_tensor, group=self.device_group ) # Reshape before returning return output_tensor.movedim(0, dim).contiguous() reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/device_communicators/base_device_communicator.py 205 206 207 208def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: raise NotImplementedError send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/device_communicators/base_device_communicator.py 241 242 243 244 245 246def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if dst is None: dst = (self.rank_in_group + 1) % self.world_size torch.distributed.send(tensor, self.ranks[dst], self.device_group) GraphCaptureContext dataclass ¶ Source code in vllm/distributed/parallel_state.py 60 61 62@dataclass class GraphCaptureContext: stream: torch.cuda.Stream stream instance-attribute ¶ stream: Stream __init__ ¶ __init__(stream: Stream) -> None GroupCoordinator ¶ PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. Source code in vllm/distributed/parallel_state.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031class GroupCoordinator: \"\"\" PyTorch ProcessGroup wrapper for a group of processes. PyTorch ProcessGroup is bound to one specific communication backend, e.g. NCCL, Gloo, MPI, etc. GroupCoordinator takes charge of all the communication operations among the processes in the group. It manages both CPU and device communication. \"\"\" # available attributes: rank: int # global rank ranks: list[int] # global ranks in the group world_size: int # size of the group # difference between `local_rank` and `rank_in_group`: # if we have a group of size 4 across two nodes: # Process | Node | Rank | Local Rank | Rank in Group # 0 | 0 | 0 | 0 | 0 # 1 | 0 | 1 | 1 | 1 # 2 | 1 | 2 | 0 | 2 # 3 | 1 | 3 | 1 | 3 local_rank: int # local rank used to assign devices rank_in_group: int # rank inside the group cpu_group: ProcessGroup # group for CPU communication device_group: ProcessGroup # group for device communication # device communicator (if use_device_communicator=True) device_communicator: DeviceCommunicatorBase | None mq_broadcaster: Any | None # shared memory broadcaster def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) @property def first_rank(self): \"\"\"Return the global rank of the first process in the group\"\"\" return self.ranks[0] @property def last_rank(self): \"\"\"Return the global rank of the last process in the group\"\"\" return self.ranks[-1] @property def is_first_rank(self): \"\"\"Return whether the caller is the first process in the group\"\"\" return self.rank == self.first_rank @property def is_last_rank(self): \"\"\"Return whether the caller is the last process in the group\"\"\" return self.rank == self.last_rank @property def next_rank(self): \"\"\"Return the global rank of the process that follows the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group + 1) % world_size] @property def prev_rank(self): \"\"\"Return the global rank of the process that precedes the caller\"\"\" rank_in_group = self.rank_in_group world_size = self.world_size return self.ranks[(rank_in_group - 1) % world_size] @contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states cpu_group instance-attribute ¶ cpu_group: ProcessGroup = self_cpu_group device instance-attribute ¶ device = device(f'cuda:{local_rank}') device_communicator instance-attribute ¶ device_communicator: DeviceCommunicatorBase | None = None device_group instance-attribute ¶ device_group: ProcessGroup = self_device_group first_rank property ¶ first_rank Return the global rank of the first process in the group is_first_rank property ¶ is_first_rank Return whether the caller is the first process in the group is_last_rank property ¶ is_last_rank Return whether the caller is the last process in the group last_rank property ¶ last_rank Return the global rank of the last process in the group local_rank instance-attribute ¶ local_rank: int = local_rank mq_broadcaster instance-attribute ¶ mq_broadcaster: MessageQueue | None = None next_rank property ¶ next_rank Return the global rank of the process that follows the caller prev_rank property ¶ prev_rank Return the global rank of the process that precedes the caller rank instance-attribute ¶ rank: int = get_rank() rank_in_group instance-attribute ¶ rank_in_group: int ranks instance-attribute ¶ ranks: list[int] unique_name instance-attribute ¶ unique_name = _get_unique_name(group_name) use_cpu_custom_send_recv instance-attribute ¶ use_cpu_custom_send_recv = is_cpu() and hasattr( _C, \"init_shm_manager\" ) use_custom_op_call instance-attribute ¶ use_custom_op_call = is_cuda_alike() or is_tpu() use_device_communicator instance-attribute ¶ use_device_communicator = use_device_communicator world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, use_message_queue_broadcaster: bool = False, group_name: str | None = None, ) Source code in vllm/distributed/parallel_state.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387def __init__( self, group_ranks: list[list[int]], local_rank: int, torch_distributed_backend: str | Backend, use_device_communicator: bool, # whether to use device communicator use_message_queue_broadcaster: bool = False, group_name: str | None = None, ): group_name = group_name or \"anonymous\" self.unique_name = _get_unique_name(group_name) _register_group(self) self.rank = torch.distributed.get_rank() self.local_rank = local_rank self_device_group = None self_cpu_group = None for ranks in group_ranks: device_group = torch.distributed.new_group( ranks, backend=torch_distributed_backend ) # a group with `gloo` backend, to allow direct coordination between # processes through the CPU. with suppress_stdout(): cpu_group = torch.distributed.new_group(ranks, backend=\"gloo\") if self.rank in ranks: self.ranks = ranks self.world_size = len(ranks) self.rank_in_group = ranks.index(self.rank) self_device_group = device_group self_cpu_group = cpu_group assert self_cpu_group is not None assert self_device_group is not None self.cpu_group = self_cpu_group self.device_group = self_device_group from vllm.platforms import current_platform if current_platform.is_cuda_alike(): self.device = torch.device(f\"cuda:{local_rank}\") elif current_platform.is_xpu(): self.device = torch.device(f\"xpu:{local_rank}\") elif current_platform.is_out_of_tree(): self.device = torch.device(f\"{current_platform.device_name}:{local_rank}\") else: self.device = torch.device(\"cpu\") self.use_device_communicator = use_device_communicator self.device_communicator = None if use_device_communicator and self.world_size > 1: device_comm_cls = resolve_obj_by_qualname( current_platform.get_device_communicator_cls() ) self.device_communicator = device_comm_cls( cpu_group=self.cpu_group, device=self.device, device_group=self.device_group, unique_name=self.unique_name, ) from vllm.distributed.device_communicators.shm_broadcast import MessageQueue self.mq_broadcaster: MessageQueue | None = None if use_message_queue_broadcaster and self.world_size > 1: self.mq_broadcaster = MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6 ) from vllm.platforms import current_platform self.use_custom_op_call = ( current_platform.is_cuda_alike() or current_platform.is_tpu() ) self.use_cpu_custom_send_recv = current_platform.is_cpu() and hasattr( torch.ops._C, \"init_shm_manager\" ) _all_gather_out_place ¶ _all_gather_out_place(input_: Tensor, dim: int) -> Tensor Source code in vllm/distributed/parallel_state.py 525 526 527 528def _all_gather_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gather(input_, dim) _all_reduce_out_place ¶ _all_reduce_out_place(input_: Tensor) -> Tensor Source code in vllm/distributed/parallel_state.py 504 505 506 507def _all_reduce_out_place(self, input_: torch.Tensor) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_reduce(input_) _reduce_scatter_out_place ¶ _reduce_scatter_out_place( input_: Tensor, dim: int ) -> Tensor Source code in vllm/distributed/parallel_state.py 563 564 565 566def _reduce_scatter_out_place(self, input_: torch.Tensor, dim: int) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatter(input_, dim) all_gather ¶ all_gather(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523def all_gather(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.all_gather( input_, dim, world_size, group_name=self.unique_name ) else: return self._all_gather_out_place(input_, dim) all_gatherv ¶ all_gatherv( input_: Tensor | list[Tensor], dim: int = 0, sizes: list[int] | None = None, ) Source code in vllm/distributed/parallel_state.py 530 531 532 533 534 535 536 537 538def all_gatherv( self, input_: torch.Tensor | list[torch.Tensor], dim: int = 0, sizes: list[int] | None = None, ): if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.all_gatherv(input_, dim, sizes) all_reduce ¶ all_reduce(input_: Tensor) -> Tensor User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (self in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. Source code in vllm/distributed/parallel_state.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502def all_reduce(self, input_: torch.Tensor) -> torch.Tensor: \"\"\" User-facing all-reduce function before we actually call the all-reduce operation. We need this because Dynamo does not support passing an arbitrary object (`self` in this case) to a custom op. We need to pass the group name as a string, and then look up the group coordinator from the group name, dispatch the all-reduce operation to the group coordinator. In addition, PyTorch custom ops do not support mutation or returning a new tensor in the same op. So we always make the all-reduce operation out-of-place. \"\"\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ if self.use_custom_op_call: return torch.ops.vllm.all_reduce(input_, group_name=self.unique_name) else: return self._all_reduce_out_place(input_) barrier ¶ barrier() Barrier synchronization among the group. NOTE: don't use device_group here! barrier in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. Source code in vllm/distributed/parallel_state.py 964 965 966 967 968 969 970 971def barrier(self): \"\"\"Barrier synchronization among the group. NOTE: don't use `device_group` here! `barrier` in NCCL is terrible because it is internally a broadcast operation with secretly created GPU tensors. It is easy to mess up the current device. Use the CPU group instead. \"\"\" torch.distributed.barrier(group=self.cpu_group) broadcast ¶ broadcast(input_: Tensor, src: int = 0) Broadcast the input tensor. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597def broadcast(self, input_: torch.Tensor, src: int = 0): \"\"\"Broadcast the input tensor. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return input_ # Broadcast. torch.distributed.broadcast( input_, src=self.ranks[src], group=self.device_group ) return input_ broadcast_object ¶ broadcast_object(obj: Any | None = None, src: int = 0) Broadcast the input object. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621def broadcast_object(self, obj: Any | None = None, src: int = 0): \"\"\"Broadcast the input object. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj if self.mq_broadcaster is not None: assert src == 0, \"Message queue broadcaster only supports src=0\" return self.mq_broadcaster.broadcast_object(obj) if self.rank_in_group == src: torch.distributed.broadcast_object_list( [obj], src=self.ranks[src], group=self.cpu_group ) return obj else: recv = [None] torch.distributed.broadcast_object_list( recv, src=self.ranks[src], group=self.cpu_group ) return recv[0] broadcast_object_list ¶ broadcast_object_list( obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None, ) Broadcast the input object list. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638def broadcast_object_list( self, obj_list: list[Any], src: int = 0, group: ProcessGroup | None = None ): \"\"\"Broadcast the input object list. NOTE: `src` is the local rank of the source rank. \"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" # Bypass the function if we are using only 1 GPU. if self.world_size == 1: return obj_list # Broadcast. torch.distributed.broadcast_object_list( obj_list, src=self.ranks[src], group=self.device_group ) return obj_list broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[str, Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, Tensor | Any] | None Broadcast the input tensor dictionary. NOTE: src is the local rank of the source rank. Source code in vllm/distributed/parallel_state.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783def broadcast_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any] | None = None, src: int = 0, group: ProcessGroup | None = None, metadata_group: ProcessGroup | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Broadcast the input tensor dictionary. NOTE: `src` is the local rank of the source rank. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict group = self.device_group metadata_group = self.cpu_group assert src < self.world_size, f\"Invalid src rank ({src})\" rank_in_group = self.rank_in_group if rank_in_group == src: metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `broadcast_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.broadcast_object(metadata_list, src=src) async_handles = [] for tensor in tensor_list: if tensor.numel() == 0: # Skip broadcasting empty tensors. continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) for async_handle in async_handles: async_handle.wait() else: metadata_list = self.broadcast_object(None, src=src) tensor_dict = {} async_handles = [] for key, value in metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty( value.size, dtype=value.dtype, device=value.device ) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue if tensor.is_cpu: # use metadata_group for CPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=metadata_group, async_op=True, ) else: # use group for GPU tensors handle = torch.distributed.broadcast( tensor, src=self.ranks[src], group=group, async_op=True ) async_handles.append(handle) tensor_dict[key] = tensor else: tensor_dict[key] = value for async_handle in async_handles: async_handle.wait() return tensor_dict combine ¶ combine( hidden_states, is_sequence_parallel: bool = False ) -> Tensor Source code in vllm/distributed/parallel_state.py 1025 1026 1027 1028 1029 1030 1031def combine( self, hidden_states, is_sequence_parallel: bool = False ) -> torch.Tensor: if self.device_communicator is not None: return self.device_communicator.combine(hidden_states, is_sequence_parallel) else: return hidden_states create_mq_broadcaster ¶ create_mq_broadcaster( writer_rank=0, external_writer_handle=None, blocking=True, ) Source code in vllm/distributed/parallel_state.py 389 390 391 392 393 394 395 396 397 398 399 400 401def create_mq_broadcaster( self, writer_rank=0, external_writer_handle=None, blocking=True ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group( self.cpu_group, 1 << 22, 6, writer_rank=writer_rank, external_writer_handle=external_writer_handle, blocking=blocking, ) create_single_reader_mq_broadcasters ¶ create_single_reader_mq_broadcasters( reader_rank_in_group=0, blocking=False ) Source code in vllm/distributed/parallel_state.py 403 404 405 406 407 408 409 410 411 412 413 414def create_single_reader_mq_broadcasters( self, reader_rank_in_group=0, blocking=False ): from vllm.distributed.device_communicators.shm_broadcast import MessageQueue return MessageQueue.create_from_process_group_single_reader( self.cpu_group, 1 << 22, 6, reader_rank=self.ranks[reader_rank_in_group], blocking=blocking, ) destroy ¶ destroy() Source code in vllm/distributed/parallel_state.py 989 990 991 992 993 994 995 996 997 998 999def destroy(self): if hasattr(self, \"device_group\"): torch.distributed.destroy_process_group(self.device_group) del self.device_group if hasattr(self, \"cpu_group\"): torch.distributed.destroy_process_group(self.cpu_group) del self.cpu_group if self.device_communicator is not None: self.device_communicator.destroy() if self.mq_broadcaster is not None: self.mq_broadcaster = None dispatch ¶ dispatch( hidden_states: Tensor, router_logits: Tensor, is_sequence_parallel: bool = False, extra_tensors: list[Tensor] | None = None, ) -> ( tuple[Tensor, Tensor] | tuple[Tensor, Tensor, list[Tensor]] ) Source code in vllm/distributed/parallel_state.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023def dispatch( self, hidden_states: torch.Tensor, router_logits: torch.Tensor, is_sequence_parallel: bool = False, extra_tensors: list[torch.Tensor] | None = None, ) -> ( tuple[torch.Tensor, torch.Tensor] | tuple[torch.Tensor, torch.Tensor, list[torch.Tensor]] ): if self.device_communicator is not None: return self.device_communicator.dispatch( # type: ignore[call-arg] hidden_states, router_logits, is_sequence_parallel, extra_tensors, ) else: return hidden_states, router_logits gather ¶ gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: dst is the local rank of the destination rank. Source code in vllm/distributed/parallel_state.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582def gather( self, input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\" NOTE: We assume that the input tensor is on the same device across all the ranks. NOTE: `dst` is the local rank of the destination rank. \"\"\" world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.gather(input_, dst, dim) graph_capture ¶ graph_capture( graph_capture_context: GraphCaptureContext | None = None, ) Source code in vllm/distributed/parallel_state.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478@contextmanager def graph_capture(self, graph_capture_context: GraphCaptureContext | None = None): if graph_capture_context is None: stream = torch.cuda.Stream() graph_capture_context = GraphCaptureContext(stream) else: stream = graph_capture_context.stream # only cuda uses this function, # so we don't abstract it into the base class maybe_ca_context = nullcontext() from vllm.distributed.device_communicators.cuda_communicator import ( CudaCommunicator, ) if self.device_communicator is not None: assert isinstance(self.device_communicator, CudaCommunicator) ca_comm = self.device_communicator.ca_comm if ca_comm is not None: maybe_ca_context = ca_comm.capture() # type: ignore # ensure all initialization operations complete before attempting to # capture the graph on another stream curr_stream = torch.cuda.current_stream() if curr_stream != stream: stream.wait_stream(curr_stream) with torch.cuda.stream(stream), maybe_ca_context: yield graph_capture_context prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Source code in vllm/distributed/parallel_state.py 1001 1002 1003def prepare_communication_buffer_for_model(self, model: torch.nn.Module): if self.device_communicator is not None: self.device_communicator.prepare_communication_buffer_for_model(model) recv ¶ recv( size: Size, dtype: dtype, src: int | None = None ) -> Tensor Receives a tensor from the source rank. Source code in vllm/distributed/parallel_state.py 980 981 982 983 984 985 986 987def recv( self, size: torch.Size, dtype: torch.dtype, src: int | None = None ) -> torch.Tensor: \"\"\"Receives a tensor from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv(size, dtype, src) recv_object ¶ recv_object(src: int) -> Any Receive the input object list from the source rank. Source code in vllm/distributed/parallel_state.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701def recv_object(self, src: int) -> Any: \"\"\"Receive the input object list from the source rank.\"\"\" \"\"\"NOTE: `src` is the local rank of the source rank.\"\"\" assert src < self.world_size, f\"Invalid src rank ({src})\" assert src != self.rank_in_group, ( \"Invalid source rank. Source rank is the same as the current rank.\" ) size_tensor = torch.empty(1, dtype=torch.long, device=\"cpu\") # Receive object size rank_size = torch.distributed.recv( size_tensor, src=self.ranks[src], group=self.cpu_group ) # Tensor to receive serialized objects into. object_tensor = torch.empty( # type: ignore[call-overload] size_tensor.item(), # type: ignore[arg-type] dtype=torch.uint8, device=\"cpu\", ) rank_object = torch.distributed.recv( object_tensor, src=self.ranks[src], group=self.cpu_group ) assert rank_object == rank_size, ( \"Received object sender rank does not match the size sender rank.\" ) obj = pickle.loads(object_tensor.numpy().tobytes()) return obj recv_tensor_dict ¶ recv_tensor_dict( src: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Recv the input tensor dictionary. NOTE: src is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962def recv_tensor_dict( self, src: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Recv the input tensor dictionary. NOTE: `src` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return None all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if src is None: src = (self.rank_in_group - 1) % self.world_size assert src < self.world_size, f\"Invalid src rank ({src})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.recv_tensor_dict( # type: ignore src ) recv_metadata_list = self.recv_object(src=src) tensor_dict: dict[str, Any] = {} for key, value in recv_metadata_list: if isinstance(value, TensorMetadata): tensor = torch.empty(value.size, dtype=value.dtype, device=value.device) if tensor.numel() == 0: # Skip broadcasting empty tensors. tensor_dict[key] = tensor continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: orig_shape = tensor.shape tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.recv( tensor, src=self.ranks[src], group=metadata_group ) else: # use group for GPU tensors torch.distributed.recv(tensor, src=self.ranks[src], group=group) if use_all_gather: # do the allgather tensor = all_gather_group.all_gather( # type: ignore tensor, dim=0 ) tensor = tensor.reshape(orig_shape) tensor_dict[key] = tensor else: tensor_dict[key] = value return tensor_dict reduce_scatter ¶ reduce_scatter(input_: Tensor, dim: int = -1) -> Tensor Source code in vllm/distributed/parallel_state.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554def reduce_scatter(self, input_: torch.Tensor, dim: int = -1) -> torch.Tensor: world_size = self.world_size # Bypass the function if we are using only 1 GPU. if world_size == 1: return input_ assert -input_.dim() <= dim < input_.dim(), ( f\"Invalid dim ({dim}) for input tensor with shape {input_.size()}\" ) if self.use_custom_op_call: return torch.ops.vllm.reduce_scatter( input_, dim, world_size, group_name=self.unique_name ) else: return self._reduce_scatter_out_place(input_, dim) reduce_scatterv ¶ reduce_scatterv( input_: Tensor, dim: int = -1, sizes: list[int] | None = None, ) -> Tensor Source code in vllm/distributed/parallel_state.py 556 557 558 559 560 561def reduce_scatterv( self, input_: torch.Tensor, dim: int = -1, sizes: list[int] | None = None ) -> torch.Tensor: if self.device_communicator is None: raise ValueError(\"No device communicator found\") return self.device_communicator.reduce_scatterv(input_, dim, sizes) send ¶ send(tensor: Tensor, dst: int | None = None) -> None Sends a tensor to the destination rank in a blocking way Source code in vllm/distributed/parallel_state.py 973 974 975 976 977 978def send(self, tensor: torch.Tensor, dst: int | None = None) -> None: \"\"\"Sends a tensor to the destination rank in a blocking way\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send(tensor, dst) send_object ¶ send_object(obj: Any, dst: int) -> None Send the input object list to the destination rank. Source code in vllm/distributed/parallel_state.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665def send_object(self, obj: Any, dst: int) -> None: \"\"\"Send the input object list to the destination rank.\"\"\" \"\"\"NOTE: `dst` is the local rank of the destination rank.\"\"\" assert dst < self.world_size, f\"Invalid dst rank ({dst})\" assert dst != self.rank_in_group, ( \"Invalid destination rank. Destination rank is the same \" \"as the current rank.\" ) # Serialize object to tensor and get the size as well object_tensor = torch.frombuffer(pickle.dumps(obj), dtype=torch.uint8) size_tensor = torch.tensor( [object_tensor.numel()], dtype=torch.long, device=\"cpu\" ) # Send object size torch.distributed.send(size_tensor, dst=self.ranks[dst], group=self.cpu_group) # Send object torch.distributed.send(object_tensor, dst=self.ranks[dst], group=self.cpu_group) return None send_tensor_dict ¶ send_tensor_dict( tensor_dict: dict[str, Tensor | Any], dst: int | None = None, all_gather_group: Optional[GroupCoordinator] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, Tensor | Any] | None Send the input tensor dictionary. NOTE: dst is the local rank of the source rank. The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when all_gather_group is provided. By default, this optimization is on for any tensor whose size is divisible by the all_gather_group's world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. Source code in vllm/distributed/parallel_state.py 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871def send_tensor_dict( self, tensor_dict: dict[str, torch.Tensor | Any], dst: int | None = None, all_gather_group: Optional[\"GroupCoordinator\"] = None, all_gather_tensors: dict[str, bool] | None = None, ) -> dict[str, torch.Tensor | Any] | None: \"\"\"Send the input tensor dictionary. NOTE: `dst` is the local rank of the source rank. all_gather_group: The group for the all-gather operation. If provided, an optimization is enabled where each rank in the group sends a slice of a tensor and the receiver reconstructs it using an all-gather, which can improve performance. This is typically the tensor-parallel group. all_gather_tensors: A dictionary to specify which tensors should use the all-gather optimization, which is only effective when `all_gather_group` is provided. By default, this optimization is on for any tensor whose size is divisible by the `all_gather_group`'s world size. However, it should be disabled for tensors that are not fully replicated across the group (e.g., the residual tensor when sequence parallelism is enabled). This dictionary allows overriding the default behavior on a per-tensor basis. \"\"\" # Bypass the function if we are using only 1 GPU. if not torch.distributed.is_initialized() or self.world_size == 1: return tensor_dict all_gather_size = 1 if all_gather_group is None else all_gather_group.world_size all_gather_rank = ( 0 if all_gather_group is None else all_gather_group.rank_in_group ) group = self.device_group metadata_group = self.cpu_group if dst is None: dst = (self.rank_in_group + 1) % self.world_size assert dst < self.world_size, f\"Invalid dst rank ({dst})\" if self.use_cpu_custom_send_recv: if self.device_communicator is None: raise ValueError(\"No device communicator found\") self.device_communicator.send_tensor_dict( # type: ignore tensor_dict, dst ) return None metadata_list: list[tuple[Any, Any]] = [] assert isinstance(tensor_dict, dict), ( f\"Expecting a dictionary, got {type(tensor_dict)}\" ) metadata_list, tensor_list = _split_tensor_dict(tensor_dict) # `metadata_list` lives in CPU memory. # `send_object_list` has serialization & deserialization, # all happening on CPU. Therefore, we can use the CPU group. self.send_object(metadata_list, dst=dst) tensor_keys = [k for k, v in tensor_dict.items() if isinstance(v, torch.Tensor)] assert len(tensor_keys) == len(tensor_list) for key, tensor in zip(tensor_keys, tensor_list): if tensor.numel() == 0: # Skip sending empty tensors. continue # send-allgather: send only a slice, then do allgather. use_all_gather = ( all_gather_group is not None and tensor.numel() % all_gather_size == 0 ) use_all_gather = ( all_gather_tensors.get(key, use_all_gather) if all_gather_tensors else use_all_gather ) if use_all_gather: tensor = tensor.reshape(all_gather_size, -1)[all_gather_rank] if tensor.is_cpu: # use metadata_group for CPU tensors torch.distributed.send( tensor, dst=self.ranks[dst], group=metadata_group ) else: # use group for GPU tensors torch.distributed.send(tensor, dst=self.ranks[dst], group=group) return None StatelessProcessGroup dataclass ¶ A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. Source code in vllm/distributed/utils.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@dataclasses.dataclass class StatelessProcessGroup: \"\"\"A dataclass to hold a metadata store, and the rank, world_size of the group. Only use it to communicate metadata between processes. For data-plane communication, create NCCL-related objects. \"\"\" rank: int world_size: int store: torch._C._distributed_c10d.Store # stores a reference to the socket so that the file descriptor stays alive socket: socket.socket | None data_expiration_seconds: int = 3600 # 1 hour # dst rank -> counter send_dst_counter: dict[int, int] = dataclasses.field(default_factory=dict) # src rank -> counter recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) broadcast_send_counter: int = 0 broadcast_recv_src_counter: dict[int, int] = dataclasses.field(default_factory=dict) # A deque to store the data entries, with key and timestamp. entries: deque[tuple[str, float]] = dataclasses.field(default_factory=deque) def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") @staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) broadcast_recv_src_counter class-attribute instance-attribute ¶ broadcast_recv_src_counter: dict[int, int] = field( default_factory=dict ) broadcast_send_counter class-attribute instance-attribute ¶ broadcast_send_counter: int = 0 data_expiration_seconds class-attribute instance-attribute ¶ data_expiration_seconds: int = 3600 entries class-attribute instance-attribute ¶ entries: deque[tuple[str, float]] = field( default_factory=deque ) rank instance-attribute ¶ rank: int recv_src_counter class-attribute instance-attribute ¶ recv_src_counter: dict[int, int] = field( default_factory=dict ) send_dst_counter class-attribute instance-attribute ¶ send_dst_counter: dict[int, int] = field( default_factory=dict ) socket instance-attribute ¶ socket: socket | None store instance-attribute ¶ store: Store world_size instance-attribute ¶ world_size: int __init__ ¶ __init__( rank: int, world_size: int, store: Store, socket: socket | None, data_expiration_seconds: int = 3600, send_dst_counter: dict[int, int] = dict(), recv_src_counter: dict[int, int] = dict(), broadcast_send_counter: int = 0, broadcast_recv_src_counter: dict[int, int] = dict(), entries: deque[tuple[str, float]] = deque(), ) -> None __post_init__ ¶ __post_init__() Source code in vllm/distributed/utils.py 169 170 171 172 173def __post_init__(self): assert self.rank < self.world_size self.send_dst_counter = {i: 0 for i in range(self.world_size)} self.recv_src_counter = {i: 0 for i in range(self.world_size)} self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)} all_gather_obj ¶ all_gather_obj(obj: Any) -> list[Any] All gather an object from all ranks. Source code in vllm/distributed/utils.py 220 221 222 223 224 225 226 227 228 229 230def all_gather_obj(self, obj: Any) -> list[Any]: \"\"\"All gather an object from all ranks.\"\"\" gathered_objs = [] for i in range(self.world_size): if i == self.rank: gathered_objs.append(obj) self.broadcast_obj(obj, src=self.rank) else: recv_obj = self.broadcast_obj(None, src=i) gathered_objs.append(recv_obj) return gathered_objs barrier ¶ barrier(timeout: float = 30.0) A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: Each process signals it has reached the barrier Each process signals that it has confirmed the arrival of all other ranks. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Parameters: Name Type Description Default timeout float Maximum time in seconds to wait for each phase (in seconds) 30.0 Raises: Type Description RuntimeError If coordination fails or times out Source code in vllm/distributed/utils.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364def barrier(self, timeout: float = 30.0): \"\"\"A robust barrier to synchronize all ranks. Uses a multi-phase approach to ensure all processes reach the barrier before proceeding: 1. Each process signals it has reached the barrier 2. Each process signals that it has confirmed the arrival of all other ranks. 3. Rank 0 waits for all other ranks to signal their departure to ensure that all ranks have departed the barrier first. Args: timeout: Maximum time in seconds to wait for each phase (in seconds) Raises: RuntimeError: If coordination fails or times out \"\"\" # Generate a barrier ID that is globally unique try: if self.rank == 0: barrier_id = f\"barrier_{uuid.uuid4()}\" self.broadcast_obj(barrier_id, src=0) else: barrier_id = self.broadcast_obj(None, src=0) except Exception as e: raise RuntimeError(\"Failed to broadcast barrier_id\") from e # Phase 1: Signal arrival at barrier # Wait for all processes to arrive # We need all ranks to confirm the arrival of all other ranks. # This is the key synchronization point. arrival_key = f\"arrival_{barrier_id}_{self.rank}\" try: self.store.set(arrival_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier arrival\") from e start_time = time.time() processes_arrived: set[int] = set() while len(processes_arrived) < self.world_size: # Check for timeout cur_time = time.time() if cur_time - start_time > timeout: raise RuntimeError(f\"Barrier timed out after {timeout:.2f} seconds\") # Check for each process for i in range(self.world_size): if i in processes_arrived: continue key = f\"arrival_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_arrived.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_arrived) < self.world_size: sched_yield() # Phase 2: Signal departure from barrier # We only care to block at this stage in rank 0, which runs the # server side of the TCPStore. We want to make sure that all # clients have departed the barrier before rank 0 in case the # next thing after the barrier is a shutdown, including tearing # down the TCPStore. Other ranks can exit the barrier immediately # after signaling their departure. departure_key = f\"departure_{barrier_id}_{self.rank}\" try: self.store.set(departure_key, b\"1\") except Exception as e: raise RuntimeError(\"Failed to signal barrier departure\") from e if self.rank != 0: return # Make rank 0 wait for all processes to signal departure start_time = time.time() processes_departed: set[int] = set() while len(processes_departed) < self.world_size: # Check for timeout if time.time() - start_time > timeout: raise RuntimeError( f\"Barrier departure timed out after {timeout:.2f} seconds\" ) # Check for each process for i in range(self.world_size): if i in processes_departed: continue key = f\"departure_{barrier_id}_{i}\" try: # Try to get the key - if it exists, we'll get a value # If it doesn't exist, it will throw an exception self.store.get(key) processes_departed.add(i) except KeyError: # Key doesn't exist yet pass except Exception as check_e: logger.debug(\"Error checking key existence: %s\", check_e) sched_yield() # Short sleep to avoid tight polling if len(processes_departed) < self.world_size: sched_yield() # Clean up keys to avoid leaking memory in the store for i in range(self.world_size): try: self.store.delete_key(f\"arrival_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"arrival_{barrier_id}_{i}\") try: self.store.delete_key(f\"departure_{barrier_id}_{i}\") except Exception: logger.debug(\"Error deleting key: %s\", f\"departure_{barrier_id}_{i}\") broadcast_obj ¶ broadcast_obj(obj: Any | None, src: int) -> Any Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. Source code in vllm/distributed/utils.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218def broadcast_obj(self, obj: Any | None, src: int) -> Any: \"\"\"Broadcast an object from a source rank to all other ranks. It does not clean up after all ranks have received the object. Use it for limited times, e.g., for initialization. \"\"\" if self.rank == src: self.expire_data() key = f\"broadcast_from/{src}/{self.broadcast_send_counter}\" self.store.set(key, pickle.dumps(obj)) self.broadcast_send_counter += 1 self.entries.append((key, time.time())) return obj else: key = f\"broadcast_from/{src}/{self.broadcast_recv_src_counter[src]}\" recv_obj = pickle.loads(self.store.get(key)) self.broadcast_recv_src_counter[src] += 1 return recv_obj create staticmethod ¶ create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> StatelessProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. If we have process A and process B called torch.distributed.init_process_group to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. torch.distributed.init_process_group is a global call, while this function is a stateless call. It will return a StatelessProcessGroup object that can be used for exchanging metadata. With this function, process A and process B can call StatelessProcessGroup.create to form a group, and then process A, B, C, and D can call StatelessProcessGroup.create to form another group. Source code in vllm/distributed/utils.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418@staticmethod def create( host: str, port: int, rank: int, world_size: int, data_expiration_seconds: int = 3600, store_timeout: int = 300, ) -> \"StatelessProcessGroup\": \"\"\"A replacement for `torch.distributed.init_process_group` that does not pollute the global state. If we have process A and process B called `torch.distributed.init_process_group` to form a group, and then we want to form another group with process A, B, C, D, it is not possible in PyTorch, because process A and process B have already formed a group, and process C and process D cannot join that group. This function is a workaround for this issue. `torch.distributed.init_process_group` is a global call, while this function is a stateless call. It will return a `StatelessProcessGroup` object that can be used for exchanging metadata. With this function, process A and process B can call `StatelessProcessGroup.create` to form a group, and then process A, B, C, and D can call `StatelessProcessGroup.create` to form another group. \"\"\" # noqa launch_server = rank == 0 if launch_server: # listen on the specified interface (instead of 0.0.0.0) listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind((host, port)) listen_socket.listen() listen_fd = listen_socket.fileno() else: listen_socket = None listen_fd = None store = TCPStore( host_name=host, port=port, world_size=world_size, is_master=launch_server, timeout=timedelta(seconds=store_timeout), use_libuv=False, # for now: github.com/pytorch/pytorch/pull/150215 master_listen_fd=listen_fd, ) return StatelessProcessGroup( rank=rank, world_size=world_size, store=store, socket=listen_socket, data_expiration_seconds=data_expiration_seconds, ) expire_data ¶ expire_data() Expire data that is older than data_expiration_seconds seconds. Source code in vllm/distributed/utils.py 183 184 185 186 187 188 189 190 191 192def expire_data(self): \"\"\"Expire data that is older than `data_expiration_seconds` seconds.\"\"\" while self.entries: # check the oldest entry key, timestamp = self.entries[0] if time.time() - timestamp > self.data_expiration_seconds: self.store.delete_key(key) self.entries.popleft() else: break recv_obj ¶ recv_obj(src: int) -> Any Receive an object from a source rank. Source code in vllm/distributed/utils.py 194 195 196 197 198 199 200def recv_obj(self, src: int) -> Any: \"\"\"Receive an object from a source rank.\"\"\" obj = pickle.loads( self.store.get(f\"send_to/{self.rank}/{self.recv_src_counter[src]}\") ) self.recv_src_counter[src] += 1 return obj send_obj ¶ send_obj(obj: Any, dst: int) Send an object to a destination rank. Source code in vllm/distributed/utils.py 175 176 177 178 179 180 181def send_obj(self, obj: Any, dst: int): \"\"\"Send an object to a destination rank.\"\"\" self.expire_data() key = f\"send_to/{dst}/{self.send_dst_counter[dst]}\" self.store.set(key, pickle.dumps(obj)) self.send_dst_counter[dst] += 1 self.entries.append((key, time.time())) all_gather ¶ all_gather( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 147 148 149 150 151 152 153 154def all_gather( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_gather_out_place(tensor, dim) all_gather_fake ¶ all_gather_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 157 158 159 160 161 162def all_gather_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] * world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) all_reduce ¶ all_reduce(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 117 118 119 120 121 122def all_reduce(tensor: torch.Tensor, group_name: str) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._all_reduce_out_place(tensor) all_reduce_fake ¶ all_reduce_fake(tensor: Tensor, group_name: str) -> Tensor Source code in vllm/distributed/parallel_state.py 125 126def all_reduce_fake(tensor: torch.Tensor, group_name: str) -> torch.Tensor: return torch.empty_like(tensor) broadcast_tensor_dict ¶ broadcast_tensor_dict( tensor_dict: dict[Any, Tensor | Any] | None = None, src: int = 0, ) Source code in vllm/distributed/communication_op.py 38 39 40 41 42 43def broadcast_tensor_dict( tensor_dict: dict[Any, torch.Tensor | Any] | None = None, src: int = 0 ): if not torch.distributed.is_initialized(): return tensor_dict return get_tp_group().broadcast_tensor_dict(tensor_dict, src) cleanup_dist_env_and_memory ¶ cleanup_dist_env_and_memory(shutdown_ray: bool = False) Source code in vllm/distributed/parallel_state.py 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617def cleanup_dist_env_and_memory(shutdown_ray: bool = False): # Reset environment variable cache envs.disable_envs_cache() # Ensure all objects are not frozen before cleanup gc.unfreeze() destroy_model_parallel() destroy_distributed_environment() if shutdown_ray: import ray # Lazy import Ray ray.shutdown() gc.collect() from vllm.platforms import current_platform empty_cache = current_platform.empty_cache if empty_cache is not None: empty_cache() try: if not current_platform.is_cpu(): torch._C._host_emptyCache() except AttributeError: logger.warning(\"torch._C._host_emptyCache() only available in Pytorch >=2.5\") destroy_distributed_environment ¶ destroy_distributed_environment() Source code in vllm/distributed/parallel_state.py 1585 1586 1587 1588 1589 1590 1591 1592def destroy_distributed_environment(): global _WORLD, _NODE_COUNT if _WORLD: _WORLD.destroy() _WORLD = None _NODE_COUNT = None if torch.distributed.is_initialized(): torch.distributed.destroy_process_group() destroy_model_parallel ¶ destroy_model_parallel() Set the groups to none and destroy them. Source code in vllm/distributed/parallel_state.py 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582def destroy_model_parallel(): \"\"\"Set the groups to none and destroy them.\"\"\" global _TP if _TP: _TP.destroy() _TP = None global _DCP if _DCP: _DCP.destroy() _DCP = None global _PCP if _PCP: _PCP.destroy() _PCP = None global _PP if _PP: _PP.destroy() _PP = None global _DP if _DP: _DP.destroy() _DP = None global _EP if _EP: _EP.destroy() _EP = None direct_register_custom_op ¶ direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[Tag, ...] = (), ) torch.library.custom_op can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the target_lib argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. Source code in vllm/utils/torch_utils.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727def direct_register_custom_op( op_name: str, op_func: Callable, mutates_args: list[str] | None = None, fake_impl: Callable | None = None, target_lib: Library | None = None, dispatch_key: str | None = None, tags: tuple[torch.Tag, ...] = (), ): \"\"\" `torch.library.custom_op` can have significant overhead because it needs to consider complicated dispatching logic. This function directly registers a custom op and dispatches it to the CUDA backend. See https://gist.github.com/youkaichao/ecbea9ec9fc79a45d2adce1784d7a9a5 for more details. By default, the custom op is registered to the vLLM library. If you want to register it to a different library, you can pass the library object to the `target_lib` argument. IMPORTANT: the lifetime of the operator is tied to the lifetime of the library object. If you want to bind the operator to a different library, make sure the library object is alive when the operator is used. \"\"\" if not supports_custom_op(): from vllm.platforms import current_platform assert not current_platform.is_cuda_alike(), ( \"cuda platform needs torch>=2.4 to support custom op, \" \"chances are you are using an old version of pytorch \" \"or a custom build of pytorch. It is recommended to \" \"use vLLM in a fresh new environment and let it install \" \"the required dependencies.\" ) return if mutates_args is None: mutates_args = [] if dispatch_key is None: from vllm.platforms import current_platform dispatch_key = current_platform.dispatch_key schema_str = infer_schema(op_func, mutates_args=mutates_args) my_lib = target_lib or vllm_lib my_lib.define(op_name + schema_str, tags=tags) my_lib.impl(op_name, op_func, dispatch_key=dispatch_key) if fake_impl is not None: my_lib._register_fake(op_name, fake_impl) divide ¶ divide(numerator, denominator) Ensure that numerator is divisible by the denominator and return the division value. Source code in vllm/distributed/utils.py 60 61 62 63 64def divide(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator and return the division value.\"\"\" ensure_divisibility(numerator, denominator) return numerator // denominator ensure_divisibility ¶ ensure_divisibility(numerator, denominator) Ensure that numerator is divisible by the denominator. Source code in vllm/distributed/utils.py 53 54 55 56 57def ensure_divisibility(numerator, denominator): \"\"\"Ensure that numerator is divisible by the denominator.\"\"\" assert numerator % denominator == 0, \"{} is not divisible by {}\".format( numerator, denominator ) ensure_model_parallel_initialized ¶ ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470def ensure_model_parallel_initialized( tensor_model_parallel_size: int, pipeline_model_parallel_size: int, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\"Helper to initialize model parallel groups if they are not initialized, or ensure tensor-parallel and pipeline-parallel sizes are equal to expected values if the model parallel groups are initialized. \"\"\" backend = backend or torch.distributed.get_backend(get_world_group().device_group) if not model_parallel_is_initialized(): initialize_model_parallel( tensor_model_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, decode_context_model_parallel_size, backend, ) return assert get_tensor_model_parallel_world_size() == tensor_model_parallel_size, ( \"tensor parallel group already initialized, but of unexpected size. \" f\"got: {get_tensor_model_parallel_world_size()=} vs. \" f\"wanted: {tensor_model_parallel_size=}\" ) pp_world_size = get_pp_group().world_size assert pp_world_size == pipeline_model_parallel_size, ( \"pipeline parallel group already initialized, but of unexpected size. \" f\"got: {pp_world_size=} vs. \" f\"wanted: {pipeline_model_parallel_size=}\" ) pcp_world_size = get_pcp_group().world_size assert pcp_world_size == prefill_context_model_parallel_size, ( \"prefill context parallel group already initialized, but of unexpected size: \" f\"{pcp_world_size=} vs. \" f\"{prefill_context_model_parallel_size=}\" ) get_dcp_group ¶ get_dcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1090 1091 1092def get_dcp_group() -> GroupCoordinator: assert _DCP is not None, \"decode context model parallel group is not initialized\" return _DCP get_decode_context_model_parallel_rank ¶ get_decode_context_model_parallel_rank() Return my rank for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1540 1541 1542def get_decode_context_model_parallel_rank(): \"\"\"Return my rank for the decode context model parallel group.\"\"\" return get_dcp_group().rank_in_group get_decode_context_model_parallel_world_size ¶ get_decode_context_model_parallel_world_size() Return world size for the decode context model parallel group. Source code in vllm/distributed/parallel_state.py 1535 1536 1537def get_decode_context_model_parallel_world_size(): \"\"\"Return world size for the decode context model parallel group.\"\"\" return get_dcp_group().world_size get_distributed_init_method ¶ get_distributed_init_method(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 130 131def get_distributed_init_method(ip: str, port: int) -> str: return get_tcp_uri(ip, port) get_dp_group ¶ get_dp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1109 1110 1111def get_dp_group() -> GroupCoordinator: assert _DP is not None, \"data parallel group is not initialized\" return _DP get_ep_group ¶ get_ep_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1117 1118 1119def get_ep_group() -> GroupCoordinator: assert _EP is not None, \"expert parallel group is not initialized\" return _EP get_inner_dp_world_group ¶ get_inner_dp_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1044 1045 1046def get_inner_dp_world_group() -> GroupCoordinator: assert _INNER_DP_WORLD is not None, \"inner dp world group is not initialized\" return _INNER_DP_WORLD get_node_count ¶ get_node_count() -> int Return the total number of nodes in the distributed environment. Source code in vllm/distributed/parallel_state.py 1545 1546 1547 1548def get_node_count() -> int: \"\"\"Return the total number of nodes in the distributed environment.\"\"\" assert _NODE_COUNT is not None, \"distributed environment is not initialized\" return _NODE_COUNT get_pcp_group ¶ get_pcp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1125 1126 1127def get_pcp_group() -> GroupCoordinator: assert _PCP is not None, \"prefill context parallel group is not initialized\" return _PCP get_pp_group ¶ get_pp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1101 1102 1103def get_pp_group() -> GroupCoordinator: assert _PP is not None, \"pipeline model parallel group is not initialized\" return _PP get_pp_indices ¶ get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int] Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If pp_size > 2 and the number of remaining layers is 0 < x <= pp_size - 2 then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. Source code in vllm/distributed/utils.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140def get_pp_indices( num_hidden_layers: int, pp_rank: int, pp_size: int ) -> tuple[int, int]: \"\"\"Try to evenly distribute layers across partitions. If the number of layers is not divisible by the number of partitions, the remaining layers are evenly distributed across all but the last partition. The last partition is excluded because it often contains an additional norm layer and we are attempting to balance compute. If `pp_size > 2` and the number of remaining layers is `0 < x <= pp_size - 2` then the remaining layers are evenly distributed across the middle partitions. The first and last partitions are excluded because they contain the input and output embeddings respectively and we are attempting to reduce maximum memory consumption across partitions. \"\"\" partition_list_str = envs.VLLM_PP_LAYER_PARTITION if partition_list_str is not None: try: partitions = [int(layer) for layer in partition_list_str.split(\",\")] except ValueError as err: raise ValueError( \"Invalid partition string: {}\".format(partition_list_str) ) from err if len(partitions) != pp_size: raise ValueError(f\"{len(partitions)=} does not match {pp_size=}.\") if sum(partitions) != num_hidden_layers: raise ValueError(f\"{sum(partitions)=} does not match {num_hidden_layers=}.\") else: layers_per_partition = num_hidden_layers // pp_size partitions = [layers_per_partition for _ in range(pp_size)] if remaining_layers := num_hidden_layers % pp_size: for i in range(2, remaining_layers + 2): partitions[-i] += 1 logger.info( \"Hidden layers were unevenly partitioned: [%s]. \" \"This can be manually overridden using the \" \"VLLM_PP_LAYER_PARTITION environment variable\", \",\".join(str(p) for p in partitions), ) start_layer = sum(partitions[:pp_rank]) end_layer = start_layer + partitions[pp_rank] return (start_layer, end_layer) get_tcp_uri ¶ get_tcp_uri(ip: str, port: int) -> str Source code in vllm/utils/network_utils.py 134 135 136 137 138def get_tcp_uri(ip: str, port: int) -> str: if is_valid_ipv6_address(ip): return f\"tcp://[{ip}]:{port}\" else: return f\"tcp://{ip}:{port}\" get_tensor_model_parallel_rank ¶ get_tensor_model_parallel_rank() Return my rank for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1530 1531 1532def get_tensor_model_parallel_rank(): \"\"\"Return my rank for the tensor model parallel group.\"\"\" return get_tp_group().rank_in_group get_tensor_model_parallel_world_size ¶ get_tensor_model_parallel_world_size() Return world size for the tensor model parallel group. Source code in vllm/distributed/parallel_state.py 1525 1526 1527def get_tensor_model_parallel_world_size(): \"\"\"Return world size for the tensor model parallel group.\"\"\" return get_tp_group().world_size get_tp_group ¶ get_tp_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1082 1083 1084def get_tp_group() -> GroupCoordinator: assert _TP is not None, \"tensor model parallel group is not initialized\" return _TP get_world_group ¶ get_world_group() -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1039 1040 1041def get_world_group() -> GroupCoordinator: assert _WORLD is not None, \"world group is not initialized\" return _WORLD graph_capture ¶ graph_capture(device: device) graph_capture is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a GraphCaptureContext object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. Source code in vllm/distributed/parallel_state.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147@contextmanager def graph_capture(device: torch.device): \"\"\" `graph_capture` is a context manager which should surround the code that is capturing the CUDA graph. Its main purpose is to ensure that some operations will be run after the graph is captured, before the graph is replayed. It returns a `GraphCaptureContext` object which contains the necessary data for the graph capture. Currently, it only contains the stream that the graph capture is running on. This stream is set to the current CUDA stream when the context manager is entered and reset to the default stream when the context manager is exited. This is to ensure that the graph capture is running on a separate stream from the default stream, in order to explicitly distinguish the kernels to capture from other kernels possibly launched on background in the default stream. \"\"\" context = GraphCaptureContext(torch.cuda.Stream(device=device)) with get_tp_group().graph_capture(context), get_pp_group().graph_capture(context): yield context in_the_same_node_as ¶ in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0, ) -> list[bool] This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). Source code in vllm/distributed/parallel_state.py 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709def in_the_same_node_as( pg: ProcessGroup | StatelessProcessGroup, source_rank: int = 0 ) -> list[bool]: \"\"\" This is a collective operation that returns if each rank is in the same node as the source rank. It tests if processes are attached to the same memory system (shared access to shared memory). \"\"\" if isinstance(pg, ProcessGroup): assert torch.distributed.get_backend(pg) != torch.distributed.Backend.NCCL, ( \"in_the_same_node_as should be tested with a non-NCCL group.\" ) # local rank inside the group rank = torch.distributed.get_rank(group=pg) world_size = torch.distributed.get_world_size(group=pg) # global ranks of the processes in the group ranks = torch.distributed.get_process_group_ranks(pg) else: rank = pg.rank world_size = pg.world_size ranks = list(range(world_size)) # local tensor in each process to store the result is_in_the_same_node = torch.tensor( [0] * world_size, dtype=torch.int32, device=\"cpu\" ) magic_message = b\"magic_message\" shm = None try: with contextlib.suppress(OSError): if rank == source_rank: # create a shared memory segment shm = shared_memory.SharedMemory(create=True, size=128) shm.buf[: len(magic_message)] = magic_message if isinstance(pg, ProcessGroup): torch.distributed.broadcast_object_list( [shm.name], src=ranks[source_rank], group=pg ) else: pg.broadcast_obj(shm.name, src=source_rank) is_in_the_same_node[rank] = 1 else: # try to open the shared memory segment if isinstance(pg, ProcessGroup): recv = [None] torch.distributed.broadcast_object_list( recv, src=ranks[source_rank], group=pg ) name = recv[0] else: name = pg.broadcast_obj(None, src=source_rank) # fix to https://stackoverflow.com/q/62748654/9191338 # Python incorrectly tracks shared memory even if it is not # created by the process. The following patch is a workaround. with patch( \"multiprocessing.resource_tracker.register\", lambda *args, **kwargs: None, ): shm = shared_memory.SharedMemory(name=name) if shm.buf[: len(magic_message)] == magic_message: is_in_the_same_node[rank] = 1 except Exception as e: logger.error(\"Error ignored in is_in_the_same_node: %s\", e) finally: if shm: shm.close() if isinstance(pg, ProcessGroup): torch.distributed.barrier(group=pg) else: pg.barrier() # clean up the shared memory segment with contextlib.suppress(OSError): if rank == source_rank and shm: shm.unlink() if isinstance(pg, ProcessGroup): torch.distributed.all_reduce(is_in_the_same_node, group=pg) aggregated_data = is_in_the_same_node else: aggregated_data = torch.zeros_like(is_in_the_same_node) for i in range(world_size): rank_data = pg.broadcast_obj(is_in_the_same_node, src=i) aggregated_data += rank_data return [x == 1 for x in aggregated_data.tolist()] init_distributed_environment ¶ init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ) Source code in vllm/distributed/parallel_state.py 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275def init_distributed_environment( world_size: int = -1, rank: int = -1, distributed_init_method: str = \"env://\", local_rank: int = -1, backend: str = \"nccl\", timeout: timedelta | None = None, ): logger.debug( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) from vllm.config import get_current_vllm_config config = get_current_vllm_config() if ( config is not None and config.parallel_config.distributed_executor_backend != \"external_launcher\" and ( config.parallel_config.nnodes > 1 or config.parallel_config.data_parallel_size > 1 ) ): parallel_config = config.parallel_config # adjust to take into account data parallelism # offset the rank by the data parallel rank rank = parallel_config.data_parallel_rank * world_size + rank # adjust the world size to take into account data parallelism world_size = parallel_config.world_size_across_dp # Use appropriate IP and port based on configuration if parallel_config.nnodes > 1: ip = parallel_config.master_addr port = parallel_config.master_port distributed_init_method = get_distributed_init_method(ip, port) else: ip = parallel_config.data_parallel_master_ip port = parallel_config.get_next_dp_init_port() distributed_init_method = get_distributed_init_method(ip, port) logger.debug( \"Adjusting world_size=%d rank=%d distributed_init_method=%s for DP\", world_size, rank, distributed_init_method, ) if not torch.distributed.is_initialized(): logger.info( \"world_size=%d rank=%d local_rank=%d distributed_init_method=%s backend=%s\", world_size, rank, local_rank, distributed_init_method, backend, ) assert distributed_init_method is not None, ( \"distributed_init_method must be provided when initializing \" \"distributed environment\" ) if not torch.distributed.is_backend_available(backend): logger.warning( \"Distributed backend %s is not available; falling back to gloo.\", backend, ) assert torch.distributed.is_gloo_available(), ( \"Fallback Gloo backend is not available.\" ) backend = \"gloo\" # this backend is used for WORLD torch.distributed.init_process_group( backend=backend, init_method=distributed_init_method, world_size=world_size, rank=rank, timeout=timeout, ) # set the local rank # local_rank is not available in torch ProcessGroup, # see https://github.com/pytorch/pytorch/issues/122816 if local_rank == -1: # local rank not set, this usually happens in single-node # setting, where we can use rank as local rank local_rank = envs.LOCAL_RANK if distributed_init_method == \"env://\" else rank global _WORLD, _NODE_COUNT, _INNER_DP_WORLD if _WORLD is None: ranks = list(range(torch.distributed.get_world_size())) _WORLD = init_world_group(ranks, local_rank, backend) if config.parallel_config.nnodes > 1: _NODE_COUNT = config.parallel_config.nnodes else: _NODE_COUNT = _node_count(_WORLD.cpu_group) logger.debug(\"Detected %d nodes in the distributed environment\", _NODE_COUNT) else: assert _WORLD.world_size == torch.distributed.get_world_size(), ( \"world group already initialized with a different world size\" ) if config.parallel_config.nnodes_within_dp > 1: if parallel_config.data_parallel_size > 1: world_size_inner_dp = parallel_config.world_size group_ranks = [ [dp_rank * world_size_inner_dp + i for i in range(world_size_inner_dp)] for dp_rank in range(parallel_config.data_parallel_size) ] _INNER_DP_WORLD = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"inner_dp_world\", use_device_communicator=False, ) else: _INNER_DP_WORLD = _WORLD init_gloo_process_group ¶ init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup Stateless init ProcessGroup with gloo backend compatible with different torch versions. Source code in vllm/distributed/utils.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459def init_gloo_process_group( prefix_store: PrefixStore, group_rank: int, group_size: int, timeout: timedelta, ) -> ProcessGroup: \"\"\" Stateless init ProcessGroup with gloo backend compatible with different torch versions. \"\"\" with suppress_stdout(): if is_torch_equal_or_newer(\"2.6\"): pg = ProcessGroup( prefix_store, group_rank, group_size, ) else: options = ProcessGroup.Options(backend=\"gloo\") pg = ProcessGroup( prefix_store, group_rank, group_size, options, ) from torch.distributed.distributed_c10d import ProcessGroupGloo backend_class = ProcessGroupGloo( prefix_store, group_rank, group_size, timeout=timeout ) backend_type = ProcessGroup.BackendType.GLOO device = torch.device(\"cpu\") if is_torch_equal_or_newer(\"2.6\"): # _set_default_backend is supported in torch >= 2.6 pg._set_default_backend(backend_type) backend_class._set_sequence_number_for_group() pg._register_backend(device, backend_type, backend_class) return pg init_logger ¶ init_logger(name: str) -> _VllmLogger The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured. Source code in vllm/logger.py 206 207 208 209 210 211 212 213 214 215 216def init_logger(name: str) -> _VllmLogger: \"\"\"The main purpose of this function is to ensure that loggers are retrieved in such a way that we can be sure the root vllm logger has already been configured.\"\"\" logger = logging.getLogger(name) for method_name, method in _METHODS_TO_PATCH.items(): setattr(logger, method_name, MethodType(method, logger)) return cast(_VllmLogger, logger) init_model_parallel_group ¶ init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076def init_model_parallel_group( group_ranks: list[list[int]], local_rank: int, backend: str, use_message_queue_broadcaster: bool = False, group_name: str | None = None, use_device_communicator: bool = True, ) -> GroupCoordinator: return GroupCoordinator( group_ranks=group_ranks, local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=use_device_communicator, use_message_queue_broadcaster=use_message_queue_broadcaster, group_name=group_name, ) init_world_group ¶ init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator Source code in vllm/distributed/parallel_state.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058def init_world_group( ranks: list[int], local_rank: int, backend: str ) -> GroupCoordinator: return GroupCoordinator( group_ranks=[ranks], local_rank=local_rank, torch_distributed_backend=backend, use_device_communicator=False, group_name=\"world\", ) initialize_model_parallel ¶ initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None Initialize model parallel groups. Parameters: Name Type Description Default tensor_model_parallel_size int number of GPUs used for tensor model parallelism. 1 pipeline_model_parallel_size int number of GPUs used for pipeline model parallelism. 1 backend str | None name of torch distributed communication backend. None Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. Source code in vllm/distributed/parallel_state.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429def initialize_model_parallel( tensor_model_parallel_size: int = 1, pipeline_model_parallel_size: int = 1, prefill_context_model_parallel_size: int = 1, decode_context_model_parallel_size: int | None = 1, backend: str | None = None, ) -> None: \"\"\" Initialize model parallel groups. Arguments: tensor_model_parallel_size: number of GPUs used for tensor model parallelism. pipeline_model_parallel_size: number of GPUs used for pipeline model parallelism. backend: name of torch distributed communication backend. Let's say we have a total of 8 GPUs denoted by g0 ... g7 and we use 2 GPUs to parallelize the model tensor, and 4 GPUs to parallelize the model pipeline. The present function will create 4 tensor model-parallel groups and 2 pipeline model-parallel groups: 4 tensor model-parallel groups: [g0, g1], [g2, g3], [g4, g5], [g6, g7] 2 pipeline model-parallel groups: [g0, g2, g4, g6], [g1, g3, g5, g7] Note that for efficiency, the caller should make sure adjacent ranks are on the same DGX box. For example if we are using 2 DGX-1 boxes with a total of 16 GPUs, rank 0 to 7 belong to the first box and ranks 8 to 15 belong to the second box. \"\"\" # Get world size and rank. Ensure some consistencies. assert torch.distributed.is_initialized() world_size: int = torch.distributed.get_world_size() rank = torch.distributed.get_rank() backend = backend or torch.distributed.get_backend(get_world_group().device_group) data_parallel_size = 1 from vllm.config import get_current_vllm_config config = get_current_vllm_config() if config is not None: data_parallel_size = config.parallel_config.data_parallel_size # the layout order is: ExternalDP x DP x PP x TP # ExternalDP is the data parallel group that is not part of the model, # every dp rank can generate independently (in verl integration). # DP is the data parallel group that is part of the model, # all the ranks in the same DP group should generate simultaneously, # i.e. the `generate` call in the same DP group should be called together, # otherwise it will cause deadlock. # to get group_ranks for each dimension, transpose that dimension to the # last dimension, then reshape to 2D, then unbind the last dimension all_ranks = torch.arange(world_size).reshape( -1, data_parallel_size, pipeline_model_parallel_size, prefill_context_model_parallel_size, tensor_model_parallel_size, ) # noqa # Build the tensor model-parallel groups. global _TP assert _TP is None, \"tensor model parallel group is already initialized\" group_ranks = all_ranks.view(-1, tensor_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] # message queue broadcaster is only used in tensor model parallel group _TP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"tp\", ) # Build the DCP model-parallel groups. global _DCP assert _DCP is None, \"decode context model parallel group is already initialized\" # Note(hc): In the current implementation of decode context parallel, # dcp_size must not exceed tp_size, because the world size does not # change by DCP, it simply reuses the GPUs of TP group, and split one # TP group into tp_size//dcp_size DCP groups. group_ranks = all_ranks.reshape(-1, decode_context_model_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, use_message_queue_broadcaster=True, group_name=\"dcp\", ) global _PCP assert _PCP is None, \"prefill context parallel group is already initialized\" group_ranks = ( all_ranks.transpose(3, 4) .reshape(-1, prefill_context_model_parallel_size) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PCP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pcp\" ) # Build the pipeline model-parallel groups. global _PP assert _PP is None, \"pipeline model parallel group is already initialized\" group_ranks = ( all_ranks.transpose(2, 4).reshape(-1, pipeline_model_parallel_size).unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _PP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"pp\" ) global _DP assert _DP is None, \"data parallel group is already initialized\" group_ranks = all_ranks.transpose(1, 4).reshape(-1, data_parallel_size).unbind(0) group_ranks = [x.tolist() for x in group_ranks] _DP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"dp\" ) global _EP assert _EP is None, \"expert parallel group is already initialized\" group_ranks = ( all_ranks.transpose(1, 2) .reshape( -1, data_parallel_size * prefill_context_model_parallel_size * tensor_model_parallel_size, ) .unbind(0) ) group_ranks = [x.tolist() for x in group_ranks] _EP = init_model_parallel_group( group_ranks, get_world_group().local_rank, backend, group_name=\"ep\" ) logger.info_once( \"rank %s in world size %s is assigned as \" \"DP rank %s, PP rank %s, PCP rank %s, \" \"TP rank %s, EP rank %s\", rank, world_size, _DP.rank_in_group, _PP.rank_in_group, _PCP.rank_in_group, _TP.rank_in_group, _EP.rank_in_group, ) is_global_first_rank ¶ is_global_first_rank() -> bool Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like get_tensor_model_parallel_rank() == 0 or get_pp_group().is_first_rank, this function checks the global rank across all parallelism dimensions. Returns: Name Type Description bool bool True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). Source code in vllm/distributed/parallel_state.py 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740def is_global_first_rank() -> bool: \"\"\" Check if the current process is the first rank globally across all parallelism strategies (PP, TP, DP, EP, etc.). Unlike group-specific checks like `get_tensor_model_parallel_rank() == 0` or `get_pp_group().is_first_rank`, this function checks the global rank across all parallelism dimensions. Returns: bool: True if this is the global first rank (rank 0), False otherwise. Returns True if distributed is not initialized (single process). \"\"\" try: # If world group is available, use it for the most accurate check global _WORLD if _WORLD is not None: return _WORLD.is_first_rank # If torch distributed is not initialized, assume single process if not torch.distributed.is_initialized(): return True # Fallback to torch's global rank return torch.distributed.get_rank() == 0 except Exception: # If anything goes wrong, assume this is the first rank return True is_local_first_rank ¶ is_local_first_rank() -> bool Check if the current process is the first local rank (rank 0 on its node). Source code in vllm/distributed/parallel_state.py 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763def is_local_first_rank() -> bool: \"\"\" Check if the current process is the first local rank (rank 0 on its node). \"\"\" try: # prefer the initialized world group if available global _WORLD if _WORLD is not None: return _WORLD.local_rank == 0 if not torch.distributed.is_initialized(): return True # fallback to environment-provided local rank if available # note: envs.LOCAL_RANK is set when using env:// launchers (e.g., torchrun) try: return int(envs.LOCAL_RANK) == 0 # type: ignore[arg-type] except Exception: return torch.distributed.get_rank() == 0 except Exception: return True is_torch_equal_or_newer ¶ is_torch_equal_or_newer(target: str) -> bool Check if the installed torch version is >= the target version. Parameters: Name Type Description Default target str a version string, like \"2.6.0\". required Returns: Type Description bool Whether the condition meets. Source code in vllm/utils/torch_utils.py 610 611 612 613 614 615 616 617 618 619 620 621 622 623def is_torch_equal_or_newer(target: str) -> bool: \"\"\"Check if the installed torch version is >= the target version. Args: target: a version string, like \"2.6.0\". Returns: Whether the condition meets. \"\"\" try: return _is_torch_equal_or_newer(str(torch.__version__), target) except Exception: # Fallback to PKG-INFO to load the package info, needed by the doc gen. return Version(importlib.metadata.version(\"torch\")) >= Version(target) model_parallel_is_initialized ¶ model_parallel_is_initialized() Check if tensor and pipeline parallel groups are initialized. Source code in vllm/distributed/parallel_state.py 1492 1493 1494def model_parallel_is_initialized(): \"\"\"Check if tensor and pipeline parallel groups are initialized.\"\"\" return _TP is not None and _PP is not None patch_tensor_parallel_group ¶ patch_tensor_parallel_group(tp_group: GroupCoordinator) Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Parameters: Name Type Description Default tp_group GroupCoordinator the tp group coordinator required Source code in vllm/distributed/parallel_state.py 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522@contextmanager def patch_tensor_parallel_group(tp_group: GroupCoordinator): \"\"\"Patch the tp group temporarily until this function ends. This method is for draft workers of speculative decoding to run draft model with different tp degree from that of target model workers. Args: tp_group (GroupCoordinator): the tp group coordinator \"\"\" global _TP_STATE_PATCHED assert not _TP_STATE_PATCHED, \"Should not call when it's already patched\" _TP_STATE_PATCHED = True old_tp_group = get_tp_group() global _TP _TP = tp_group try: yield finally: # restore the original state _TP_STATE_PATCHED = False _TP = old_tp_group patched_fused_scaled_matmul_reduce_scatter ¶ patched_fused_scaled_matmul_reduce_scatter( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246def patched_fused_scaled_matmul_reduce_scatter( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: return torch.ops.symm_mem.fused_scaled_matmul_reduce_scatter( A, B, A_scale, B_scale, reduce_op, orig_scatter_dim, scatter_dim_after_maybe_reshape, group_name, output_shape, bias, result_scale, out_dtype, use_fast_accum, ) patched_fused_scaled_matmul_reduce_scatter_fake ¶ patched_fused_scaled_matmul_reduce_scatter_fake( A: Tensor, B: Tensor, A_scale: Tensor, B_scale: Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: Tensor | None = None, result_scale: Tensor | None = None, out_dtype: dtype | None = None, use_fast_accum: bool = False, ) -> Tensor Source code in vllm/distributed/parallel_state.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214def patched_fused_scaled_matmul_reduce_scatter_fake( A: torch.Tensor, B: torch.Tensor, A_scale: torch.Tensor, B_scale: torch.Tensor, reduce_op: str, orig_scatter_dim: int, scatter_dim_after_maybe_reshape: int, group_name: str, output_shape: list[int], bias: torch.Tensor | None = None, result_scale: torch.Tensor | None = None, out_dtype: torch.dtype | None = None, use_fast_accum: bool = False, ) -> torch.Tensor: # Copied from # https://github.com/pytorch/pytorch/blob/50c338c2da905062449e4d9ac807832d1b5cd90e/torch/distributed/_symmetric_memory/__init__.py#L1189 if A_scale.numel() > 1: if A_scale.shape[:-1] != A.shape[:-1]: raise ValueError( \"For row-wise scaling, the leading dims of A_scale \" \"must match the leading dims of A \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) A_scale = A_scale.flatten(0, -2).contiguous() elif A_scale.numel() != 1: raise ValueError( \"Invalid A_scale shape \" f\"(A shape: {A.shape}, A_scale shape: {A_scale.shape})\" ) C = torch._scaled_mm( A.flatten(0, -2).contiguous(), B, A_scale, B_scale, bias, result_scale, out_dtype, use_fast_accum, ) C = C.view(*output_shape[:-1], B.shape[1]) res = funcol.reduce_scatter_tensor( C, reduce_op, orig_scatter_dim, # need original scatter dim for 3D+ output tensor here group_name, ) res = funcol.wait_tensor(res) return res prepare_communication_buffer_for_model ¶ prepare_communication_buffer_for_model(model: Module) Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. Source code in vllm/distributed/parallel_state.py 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489def prepare_communication_buffer_for_model(model: torch.nn.Module): \"\"\"Prepare the communication buffer for the model. Traditional communication libraries like NCCL are almost model agnostic. However, emerging new communication libraries like MoE all2all (DeepEP) usually allocate the communication buffer based on the model shape for optimal performance. \"\"\" if _TP is not None: _TP.prepare_communication_buffer_for_model(model) if _PCP is not None: _PCP.prepare_communication_buffer_for_model(model) if _PP is not None: _PP.prepare_communication_buffer_for_model(model) if _DP is not None: _DP.prepare_communication_buffer_for_model(model) if _EP is not None: _EP.prepare_communication_buffer_for_model(model) reduce_scatter ¶ reduce_scatter( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 129 130 131 132 133 134 135 136def reduce_scatter( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: assert group_name in _groups, f\"Group {group_name} is not found.\" group = _groups[group_name]() if group is None: raise ValueError(f\"Group {group_name} is destroyed.\") return group._reduce_scatter_out_place(tensor, dim) reduce_scatter_fake ¶ reduce_scatter_fake( tensor: Tensor, dim: int, world_size: int, group_name: str, ) -> Tensor Source code in vllm/distributed/parallel_state.py 139 140 141 142 143 144def reduce_scatter_fake( tensor: torch.Tensor, dim: int, world_size: int, group_name: str ) -> torch.Tensor: new_shape = list(tensor.shape) new_shape[dim] = tensor.shape[dim] // world_size return torch.empty(new_shape, dtype=tensor.dtype, device=tensor.device) resolve_obj_by_qualname ¶ resolve_obj_by_qualname(qualname: str) -> Any Resolve an object by its fully-qualified class name. Source code in vllm/utils/import_utils.py 117 118 119 120 121 122 123def resolve_obj_by_qualname(qualname: str) -> Any: \"\"\" Resolve an object by its fully-qualified class name. \"\"\" module_name, obj_name = qualname.rsplit(\".\", 1) module = importlib.import_module(module_name) return getattr(module, obj_name) sched_yield ¶ sched_yield() Source code in vllm/distributed/utils.py 46 47 48 49 50def sched_yield(): if USE_SCHED_YIELD: os.sched_yield() else: time.sleep(0) set_custom_all_reduce ¶ set_custom_all_reduce(enable: bool) Source code in vllm/distributed/parallel_state.py 1155 1156 1157def set_custom_all_reduce(enable: bool): global _ENABLE_CUSTOM_ALL_REDUCE _ENABLE_CUSTOM_ALL_REDUCE = enable split_tensor_along_last_dim ¶ split_tensor_along_last_dim( tensor: Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[Tensor] Split a tensor along its last dimension. Parameters: Name Type Description Default tensor Tensor input tensor. required num_partitions int number of partitions to split the tensor required contiguous_split_chunks bool If True, make each chunk contiguous in memory. False Returns: Type Description Sequence[Tensor] A list of Tensors Source code in vllm/distributed/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92def split_tensor_along_last_dim( tensor: torch.Tensor, num_partitions: int, contiguous_split_chunks: bool = False, ) -> Sequence[torch.Tensor]: \"\"\"Split a tensor along its last dimension. Arguments: tensor: input tensor. num_partitions: number of partitions to split the tensor contiguous_split_chunks: If True, make each chunk contiguous in memory. Returns: A list of Tensors \"\"\" # Get the size and dimension. last_dim = tensor.dim() - 1 last_dim_size = divide(tensor.size()[last_dim], num_partitions) # Split. tensor_list = torch.split(tensor, last_dim_size, dim=last_dim) # NOTE: torch.split does not create contiguous tensors by default. if contiguous_split_chunks: return tuple(chunk.contiguous() for chunk in tensor_list) return tensor_list stateless_destroy_torch_distributed_process_group ¶ stateless_destroy_torch_distributed_process_group( pg: ProcessGroup, ) -> None Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). Source code in vllm/distributed/utils.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545def stateless_destroy_torch_distributed_process_group(pg: ProcessGroup) -> None: \"\"\" Destroy ProcessGroup returned by stateless_init_torch_distributed_process_group(). \"\"\" if is_torch_equal_or_newer(\"2.7\"): pg.shutdown() else: # Lazy import for non-CUDA backends. from torch.distributed.distributed_c10d import _shutdown_backend _shutdown_backend(pg) _unregister_process_group(pg.group_name) stateless_init_torch_distributed_process_group ¶ stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str, ) -> ProcessGroup A replacement for torch.distributed.init_process_group that does not pollute the global state. The created ProcessGroup object can be used for some operations such as allreduce, because it does not depend on the global rank. However, some operations such as broadcast cannot be used because it depends on the global rank. TODO: ask for help from PyTorch team if we need the broadcast operation.¶ This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. Source code in vllm/distributed/utils.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529def stateless_init_torch_distributed_process_group( host: str, port: int, rank: int, world_size: int, backend: str ) -> ProcessGroup: \"\"\" A replacement for `torch.distributed.init_process_group` that does not pollute the global state. The created ProcessGroup object can be used for some operations such as `allreduce`, because it does not depend on the global rank. However, some operations such as `broadcast` cannot be used because it depends on the global rank. # TODO: ask for help from PyTorch team if we need the `broadcast` operation. This function is useful when we are not sure about the total number of processes in the process group. For example, we may have process 1, 2, ..., 8 who want to communicate, and process 9 might be the same process as process 1, or it might be a different process; process 10 might be the same process as process 5, or it might be a different process. In this case, how can we reliably form a communication channel within process 9 and 10, without affecting the communication channel within process 1, 2, ..., 8? One possible solution is to figure out if process 9 and 10 are the same as process 1 and 5 beforehand, and then form a communication channel based on the information, adjusting the ranks and world_size etc. However, figuring out the information is not always easy, and it will interfere with the main communication channel. Our solution is to always form a communication channel with process 1, 2, ..., 8, and then use this function to form another communication channel with process 9 and 10. This way, regardless of whether process 9 and 10 are the same as process 1 and 5, the main communication channel is always formed with process 1, 2, ..., 8, and the additional communication channel is formed with process 9 and 10. \"\"\" init_method = get_tcp_uri(host, port) backend = Backend(backend) # it is basically string timeout = _get_default_timeout(backend) store, rank, world_size = next( rendezvous(init_method, rank, world_size, timeout=timeout) ) store.set_timeout(timeout) group_rank = rank group_size = world_size # Use a PrefixStore to avoid accidental overrides of keys used by # different systems (e.g. RPC) in case the store is multi-tenant. prefix_store = PrefixStore(init_method, store) try: from vllm.platforms import current_platform return current_platform.stateless_init_device_torch_dist_pg( backend=backend, prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) except NotImplementedError: # If platform doesn't implement stateless_init_device_torch_dist_pg, it # will raise a NotImplementedError. In this case, we fall back to gloo. return init_gloo_process_group( prefix_store=prefix_store, group_rank=group_rank, group_size=group_size, timeout=timeout, ) supports_custom_op ¶ supports_custom_op() -> bool Source code in vllm/utils/torch_utils.py 669 670def supports_custom_op() -> bool: return hasattr(torch.library, \"custom_op\") suppress_stdout ¶ suppress_stdout() Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") Source code in vllm/utils/system_utils.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89@contextlib.contextmanager def suppress_stdout(): \"\"\" Suppress stdout from C libraries at the file descriptor level. Only suppresses stdout, not stderr, to preserve error messages. Suppression is disabled when VLLM_LOGGING_LEVEL is set to DEBUG. Example: with suppress_stdout(): # C library calls that would normally print to stdout torch.distributed.new_group(ranks, backend=\"gloo\") \"\"\" # Don't suppress if logging level is DEBUG if envs.VLLM_LOGGING_LEVEL == \"DEBUG\": yield return stdout_fd = sys.stdout.fileno() stdout_dup = os.dup(stdout_fd) devnull_fd = os.open(os.devnull, os.O_WRONLY) try: sys.stdout.flush() os.dup2(devnull_fd, stdout_fd) yield finally: sys.stdout.flush() os.dup2(stdout_dup, stdout_fd) os.close(stdout_dup) os.close(devnull_fd) tensor_model_parallel_all_gather ¶ tensor_model_parallel_all_gather( input_: Tensor, dim: int = -1 ) -> Tensor All-gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 17 18 19 20 21def tensor_model_parallel_all_gather( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"All-gather the input tensor across model parallel group.\"\"\" return get_tp_group().all_gather(input_, dim) tensor_model_parallel_all_reduce ¶ tensor_model_parallel_all_reduce(input_: Tensor) -> Tensor All-reduce the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 12 13 14def tensor_model_parallel_all_reduce(input_: torch.Tensor) -> torch.Tensor: \"\"\"All-reduce the input tensor across model parallel group.\"\"\" return get_tp_group().all_reduce(input_) tensor_model_parallel_gather ¶ tensor_model_parallel_gather( input_: Tensor, dst: int = 0, dim: int = -1 ) -> Tensor | None Gather the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 31 32 33 34 35def tensor_model_parallel_gather( input_: torch.Tensor, dst: int = 0, dim: int = -1 ) -> torch.Tensor | None: \"\"\"Gather the input tensor across model parallel group.\"\"\" return get_tp_group().gather(input_, dst, dim) tensor_model_parallel_reduce_scatter ¶ tensor_model_parallel_reduce_scatter( input_: Tensor, dim: int = -1 ) -> Tensor Reduce-Scatter the input tensor across model parallel group. Source code in vllm/distributed/communication_op.py 24 25 26 27 28def tensor_model_parallel_reduce_scatter( input_: torch.Tensor, dim: int = -1 ) -> torch.Tensor: \"\"\"Reduce-Scatter the input tensor across model parallel group.\"\"\" return get_tp_group().reduce_scatter(input_, dim)",
      "code": ""
    }
  ],
  "links": [
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/",
    "https://docs.vllm.ai/en/latest/",
    "https://docs.vllm.ai/en/latest/usage/",
    "https://docs.vllm.ai/en/latest/contributing/",
    "https://docs.vllm.ai/en/latest/benchmarking/",
    "https://docs.vllm.ai/en/latest/api/",
    "https://docs.vllm.ai/en/latest/cli/",
    "https://docs.vllm.ai/en/latest/community/contact_us/",
    "https://docs.vllm.ai/en/latest/getting_started/quickstart/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/gpu/",
    "https://docs.vllm.ai/en/latest/getting_started/installation/cpu/",
    "https://docs.vllm.ai/en/latest/examples/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/async_llm_streaming/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/audio_language/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/automatic_prefix_caching/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/basic/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/batch_llm_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/chat_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/context_extension/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/data_parallel/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/disaggregated-prefill-v1/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/disaggregated_prefill/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/encoder_decoder_multimodal/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/kv_load_failure_recovery/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/llm_engine_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/llm_engine_reset_kv/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/load_sharded_state/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/logits_processor/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/lora_with_quantization_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/metrics/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/mistral-small/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/mlpspeculator/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/multilora_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/openai_batch/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/prefix_caching/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/prompt_embed_inference/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen2_5_omni/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen3_omni/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/qwen_1m/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/reproducibility/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_colocate/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_online_quant/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/rlhf_utils/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/save_sharded_state/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/simple_profiling/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/skip_loading_weights_in_engine_init/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/spec_decode/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/structured_outputs/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/torchrun_dp_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/torchrun_example/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/vision_language/",
    "https://docs.vllm.ai/en/latest/examples/offline_inference/vision_language_multi_image/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/api_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/chart-helm/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/dashboards/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_encoder/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_prefill/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_serving/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/disaggregated_serving_p2p_nccl_xpyd/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/elastic_ep/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/gradio_openai_chatbot_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/gradio_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/kv_events_subscriber/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/multi-node-serving/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/multi_instance_data_parallel/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_for_multimodal/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_required/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_xlam/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_client_with_tools_xlam_streaming/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_tool_calls_with_reasoning/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_with_reasoning/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_chat_completion_with_reasoning_streaming/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_completion_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client_with_mcp_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_responses_client_with_tools/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_transcription_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/openai_translation_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/opentelemetry/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/prometheus_grafana/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/prompt_embed_inference_with_openai_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/ray_serve_deepseek/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/retrieval_augmented_generation_with_langchain/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/retrieval_augmented_generation_with_llamaindex/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/run_cluster/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/sagemaker-entrypoint/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/streamlit_openai_chatbot_webserver/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/structured_outputs/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/token_generation_client/",
    "https://docs.vllm.ai/en/latest/examples/online_serving/utils/",
    "https://docs.vllm.ai/en/latest/examples/others/lmcache/",
    "https://docs.vllm.ai/en/latest/examples/others/logging_configuration/",
    "https://docs.vllm.ai/en/latest/examples/others/tensorize_vllm_model/",
    "https://docs.vllm.ai/en/latest/examples/pooling/classify/",
    "https://docs.vllm.ai/en/latest/examples/pooling/embed/",
    "https://docs.vllm.ai/en/latest/examples/pooling/plugin/",
    "https://docs.vllm.ai/en/latest/examples/pooling/pooling/",
    "https://docs.vllm.ai/en/latest/examples/pooling/score/",
    "https://docs.vllm.ai/en/latest/examples/pooling/token_classify/",
    "https://docs.vllm.ai/en/latest/examples/pooling/token_embed/",
    "https://docs.vllm.ai/en/latest/usage/v1_guide/",
    "https://docs.vllm.ai/en/latest/usage/faq/",
    "https://docs.vllm.ai/en/latest/usage/metrics/",
    "https://docs.vllm.ai/en/latest/usage/reproducibility/",
    "https://docs.vllm.ai/en/latest/usage/security/",
    "https://docs.vllm.ai/en/latest/usage/troubleshooting/",
    "https://docs.vllm.ai/en/latest/usage/usage_stats/",
    "https://docs.vllm.ai/en/latest/serving/offline_inference/",
    "https://docs.vllm.ai/en/latest/serving/openai_compatible_server/",
    "https://docs.vllm.ai/en/latest/serving/context_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/data_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/distributed_troubleshooting/",
    "https://docs.vllm.ai/en/latest/serving/expert_parallel_deployment/",
    "https://docs.vllm.ai/en/latest/serving/parallelism_scaling/",
    "https://docs.vllm.ai/en/latest/serving/integrations/langchain/",
    "https://docs.vllm.ai/en/latest/serving/integrations/llamaindex/",
    "https://docs.vllm.ai/en/latest/deployment/docker/",
    "https://docs.vllm.ai/en/latest/deployment/k8s/",
    "https://docs.vllm.ai/en/latest/deployment/nginx/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/anyscale/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/anything-llm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/autogen/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/bentoml/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/cerebrium/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/chatbox/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/dify/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/dstack/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/haystack/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/helm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/hf_inference_endpoints/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/litellm/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/lobe-chat/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/lws/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/modal/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/open-webui/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/retrieval_augmented_generation/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/skypilot/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/streamlit/",
    "https://docs.vllm.ai/en/latest/deployment/frameworks/triton/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kaito/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kserve/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kthena/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kubeai/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/kuberay/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llamastack/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llm-d/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/llmaz/",
    "https://docs.vllm.ai/en/latest/deployment/integrations/production-stack/",
    "https://docs.vllm.ai/en/latest/training/rlhf/",
    "https://docs.vllm.ai/en/latest/training/trl/",
    "https://docs.vllm.ai/en/latest/configuration/",
    "https://docs.vllm.ai/en/latest/configuration/conserving_memory/",
    "https://docs.vllm.ai/en/latest/configuration/engine_args/",
    "https://docs.vllm.ai/en/latest/configuration/env_vars/",
    "https://docs.vllm.ai/en/latest/configuration/model_resolution/",
    "https://docs.vllm.ai/en/latest/configuration/optimization/",
    "https://docs.vllm.ai/en/latest/configuration/serve_args/",
    "https://docs.vllm.ai/en/latest/models/supported_models/",
    "https://docs.vllm.ai/en/latest/models/generative_models/",
    "https://docs.vllm.ai/en/latest/models/pooling_models/",
    "https://docs.vllm.ai/en/latest/models/extensions/fastsafetensor/",
    "https://docs.vllm.ai/en/latest/models/extensions/runai_model_streamer/",
    "https://docs.vllm.ai/en/latest/models/extensions/tensorizer/",
    "https://docs.vllm.ai/en/latest/models/hardware_supported_models/cpu/",
    "https://docs.vllm.ai/en/latest/models/hardware_supported_models/xpu/",
    "https://docs.vllm.ai/en/latest/features/",
    "https://docs.vllm.ai/en/latest/features/automatic_prefix_caching/",
    "https://docs.vllm.ai/en/latest/features/batch_invariance/",
    "https://docs.vllm.ai/en/latest/features/custom_arguments/",
    "https://docs.vllm.ai/en/latest/features/custom_logitsprocs/",
    "https://docs.vllm.ai/en/latest/features/disagg_encoder/",
    "https://docs.vllm.ai/en/latest/features/disagg_prefill/",
    "https://docs.vllm.ai/en/latest/features/interleaved_thinking/",
    "https://docs.vllm.ai/en/latest/features/lora/",
    "https://docs.vllm.ai/en/latest/features/mooncake_connector_usage/",
    "https://docs.vllm.ai/en/latest/features/multimodal_inputs/",
    "https://docs.vllm.ai/en/latest/features/nixl_connector_usage/",
    "https://docs.vllm.ai/en/latest/features/prompt_embeds/",
    "https://docs.vllm.ai/en/latest/features/reasoning_outputs/",
    "https://docs.vllm.ai/en/latest/features/sleep_mode/",
    "https://docs.vllm.ai/en/latest/features/spec_decode/",
    "https://docs.vllm.ai/en/latest/features/structured_outputs/",
    "https://docs.vllm.ai/en/latest/features/tool_calling/",
    "https://docs.vllm.ai/en/latest/features/quantization/",
    "https://docs.vllm.ai/en/latest/features/quantization/auto_awq/",
    "https://docs.vllm.ai/en/latest/features/quantization/auto_round/",
    "https://docs.vllm.ai/en/latest/features/quantization/bitblas/",
    "https://docs.vllm.ai/en/latest/features/quantization/bnb/",
    "https://docs.vllm.ai/en/latest/features/quantization/fp8/",
    "https://docs.vllm.ai/en/latest/features/quantization/gguf/",
    "https://docs.vllm.ai/en/latest/features/quantization/gptqmodel/",
    "https://docs.vllm.ai/en/latest/features/quantization/inc/",
    "https://docs.vllm.ai/en/latest/features/quantization/int4/",
    "https://docs.vllm.ai/en/latest/features/quantization/int8/",
    "https://docs.vllm.ai/en/latest/features/quantization/modelopt/",
    "https://docs.vllm.ai/en/latest/features/quantization/quantized_kvcache/",
    "https://docs.vllm.ai/en/latest/features/quantization/quark/",
    "https://docs.vllm.ai/en/latest/features/quantization/torchao/",
    "https://docs.vllm.ai/en/latest/contributing/deprecation_policy/",
    "https://docs.vllm.ai/en/latest/contributing/dockerfile/dockerfile/",
    "https://docs.vllm.ai/en/latest/contributing/incremental_build/",
    "https://docs.vllm.ai/en/latest/contributing/profiling/",
    "https://docs.vllm.ai/en/latest/contributing/vulnerability_management/",
    "https://docs.vllm.ai/en/latest/contributing/model/",
    "https://docs.vllm.ai/en/latest/contributing/model/basic/",
    "https://docs.vllm.ai/en/latest/contributing/model/registration/",
    "https://docs.vllm.ai/en/latest/contributing/model/tests/",
    "https://docs.vllm.ai/en/latest/contributing/model/multimodal/",
    "https://docs.vllm.ai/en/latest/contributing/model/transcription/",
    "https://docs.vllm.ai/en/latest/contributing/ci/failures/",
    "https://docs.vllm.ai/en/latest/contributing/ci/nightly_builds/",
    "https://docs.vllm.ai/en/latest/contributing/ci/update_pytorch_version/",
    "https://docs.vllm.ai/en/latest/design/io_processor_plugins/",
    "https://docs.vllm.ai/en/latest/design/lora_resolver_plugins/",
    "https://docs.vllm.ai/en/latest/design/plugin_system/",
    "https://docs.vllm.ai/en/latest/design/arch_overview/",
    "https://docs.vllm.ai/en/latest/design/cuda_graphs/",
    "https://docs.vllm.ai/en/latest/design/dbo/",
    "https://docs.vllm.ai/en/latest/design/debug_vllm_compile/",
    "https://docs.vllm.ai/en/latest/design/fused_moe_modular_kernel/",
    "https://docs.vllm.ai/en/latest/design/huggingface_integration/",
    "https://docs.vllm.ai/en/latest/design/hybrid_kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/design/logits_processors/",
    "https://docs.vllm.ai/en/latest/design/metrics/",
    "https://docs.vllm.ai/en/latest/design/mm_processing/",
    "https://docs.vllm.ai/en/latest/design/moe_kernel_features/",
    "https://docs.vllm.ai/en/latest/design/multiprocessing/",
    "https://docs.vllm.ai/en/latest/design/optimization_levels/",
    "https://docs.vllm.ai/en/latest/design/p2p_nccl_connector/",
    "https://docs.vllm.ai/en/latest/design/paged_attention/",
    "https://docs.vllm.ai/en/latest/design/prefix_caching/",
    "https://docs.vllm.ai/en/latest/design/torch_compile/",
    "https://docs.vllm.ai/en/latest/benchmarking/cli/",
    "https://docs.vllm.ai/en/latest/benchmarking/sweeps/",
    "https://docs.vllm.ai/en/latest/benchmarking/dashboard/",
    "https://docs.vllm.ai/en/latest/api/vllm/",
    "https://docs.vllm.ai/en/latest/api/vllm/beam_search/",
    "https://docs.vllm.ai/en/latest/api/vllm/collect_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/connections/",
    "https://docs.vllm.ai/en/latest/api/vllm/env_override/",
    "https://docs.vllm.ai/en/latest/api/vllm/envs/",
    "https://docs.vllm.ai/en/latest/api/vllm/forward_context/",
    "https://docs.vllm.ai/en/latest/api/vllm/logger/",
    "https://docs.vllm.ai/en/latest/api/vllm/logits_process/",
    "https://docs.vllm.ai/en/latest/api/vllm/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/pooling_params/",
    "https://docs.vllm.ai/en/latest/api/vllm/sampling_params/",
    "https://docs.vllm.ai/en/latest/api/vllm/scalar_type/",
    "https://docs.vllm.ai/en/latest/api/vllm/scripts/",
    "https://docs.vllm.ai/en/latest/api/vllm/sequence/",
    "https://docs.vllm.ai/en/latest/api/vllm/tasks/",
    "https://docs.vllm.ai/en/latest/api/vllm/tracing/",
    "https://docs.vllm.ai/en/latest/api/vllm/version/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/image/",
    "https://docs.vllm.ai/en/latest/api/vllm/assets/video/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layer/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/selector/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/backends/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/chunked_local_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/cross_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/encoder_only_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/layers/mm_encoder_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/chunked_prefill_paged_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/flashmla/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/merge_attn_states/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/paged_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/pallas_kv_cache_update/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/prefix_prefill/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/rocm_aiter_mla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_decode_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_merge_attn_states/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_reshape_and_cache_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/triton_unified_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/ops/vit_attn_wrappers/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/fa_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/kv_sharing_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/attention/utils/kv_transfer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/datasets/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/latency/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/startup/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/throughput/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/endpoint_request_func/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/ready_checker/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/lib/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/cli/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/param_sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/plot/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/plot_pareto/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/serve_sla/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/server/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/sla_sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/benchmarks/sweep/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/activation_quant_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/base_static_graph/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/caching/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/collective_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/compiler_interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/counter/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/cuda_graph/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/decorators/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fix_functionalization/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fusion_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/fx_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/inductor_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/matcher_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/monitor/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/noop_elimination/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/partition_rules/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/pass_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/piecewise_backend/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/post_cleanup/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/qk_norm_rope_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/rocm_aiter_fusion/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/sequence_parallelism/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/torch25_custom_graph_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/vllm_inductor_pass/",
    "https://docs.vllm.ai/en/latest/api/vllm/compilation/wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/compilation/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/device/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/ec_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/kv_events/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/kv_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/load/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/model/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/observability/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/parallel/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/pooler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/profiler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/speculative/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/speech_to_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/structured_outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/config/vllm/",
    "https://docs.vllm.ai/en/latest/api/vllm/device_allocator/",
    "https://docs.vllm.ai/en/latest/api/vllm/device_allocator/cumem/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/communication_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_events/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/parallel_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/tpu_distributed_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/all2all/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/all_reduce_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/base_device_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cuda_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/cuda_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/custom_all_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/mnnvl_compat/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl_allocator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/pynccl_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/quick_all_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/ray_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/shm_broadcast/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/shm_object_storage/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/symm_mem/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/tpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/device_communicators/xpu_communicator/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_transfer_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/example_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/ec_transfer/ec_connector/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/async_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/eplb_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/rebalance_execute/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/eplb/policy/default/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_transfer_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/decode_bench_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/example_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_mp_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/mooncake_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/multi_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/nixl_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/offloading_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/multi_process_adapter/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/lmcache_integration/vllm_v1_adapter/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_connector/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/distributed/kv_transfer/kv_connector/v1/p2p/tensor_memory_pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/arg_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/async_llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/engine/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/api_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/chat_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/constants/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/context/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/launcher/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/llm/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/logger/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/renderer/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/responses_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/score_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/ssl/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/tool/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/tool_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/anthropic/serving_messages/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/collect_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/main/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/openai/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/run_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/types/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/latency/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/main/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/startup/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/sweep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/cli/benchmark/throughput/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/api_server/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/cli_args/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/orca_metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/run_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_chat/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_chat_stream_harmony/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_completion/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_models/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_responses/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/serving_transcription/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/speech_to_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/harmony_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/openai/parser/responses_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/classify/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/conftest/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/embed/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/pooling/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/pooling/score/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/sagemaker/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/sagemaker/routes/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/cache/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/disagg/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/elastic_ep/middleware/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/health/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/instrumentator/server_info/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/lora/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/profile/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/profile/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rlhf/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rlhf/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rpc/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/rpc/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/sleep/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/sleep/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/api_router/",
    "https://docs.vllm.ai/en/latest/api/vllm/entrypoints/serve/tokenize/serving/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/data/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/parse/",
    "https://docs.vllm.ai/en/latest/api/vllm/inputs/preprocess/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/dump_input/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/formatter/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/lazy/",
    "https://docs.vllm.ai/en/latest/api/vllm/logging_utils/log_time/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/lora_model/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/lora_weights/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/model_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/peft_helper/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/resolver/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/worker_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/base_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/column_parallel_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/replicated_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/row_parallel_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/layers/vocal_parallel_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/ipex_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/ipex_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/torch_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/torch_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/fused_moe_lora_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/kernel_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_expand_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_kernel_metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/lora_shrink_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/triton_ops/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/xla_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/ops/xla_ops/lora_ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_selector/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/punica_xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/lora/punica_wrapper/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/custom_op/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/parameter/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/activation/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/attention_layer_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/batch_invariant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/conv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/kda/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/layernorm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/lightning_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/pooler/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/resampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/vocab_parallel_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_delta_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_o/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/chunk_scaled_dot_kkt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/cumsum/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/fused_recurrent/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/index_py/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/kda/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/l2norm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/layernorm_guard/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/op/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/solve_tril/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fla/ops/wy_fast/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/all2all_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/batched_deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/cpu_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/cutlass_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deep_gemm_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deepep_ht_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/deepep_ll_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutedsl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutlass_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_cutlass_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/flashinfer_trtllm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_batched_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_marlin_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe_method_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/fused_moe_modular_method/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/gpt_oss_triton_kernels_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/layer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/modular_kernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_align_block_size/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_pallas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_permute_unpermute/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/moe_torch_iterative/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/pplx_prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/prepare_finalize/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/rocm_aiter_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/routing_simulator/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/shared_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/topk_weight_and_reduce/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/triton_deep_gemm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/trtllm_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/unquantized_fused_moe_method/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/fused_moe/zero_expert_fused_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/linear_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_mixer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_mixer2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/mamba_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/short_conv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/causal_conv1d/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/layernorm_gated/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/mamba_ssm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_bmm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_chunk_scan/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_chunk_state/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_combined/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/mamba/ops/ssd_state_passing/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/auto_round/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/awq_triton/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/base_config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/bitsandbytes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/cpu_wna16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/deepspeedfp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/experts_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fbgemm_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/fp_quant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gguf/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/gptq_marlin_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/hqq_marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/inc/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/input_quant_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/ipex_quant/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kv_cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/modelopt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/moe_wna16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/mxfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/petit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/ptpc_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/qutlass_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/rtn/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/schema/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/torchao/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/tpu_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/compressed_tensors/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/compressed_tensors_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/triton_scaled_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_scheme/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a4_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a8_int/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a16_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w4a16_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a8_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_w8a16_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/schemes/compressed_tensors_wNa16/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/module/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/compressed_tensors/transform/schemes/linear_qutlass_nvfp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/allspark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/bitblas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/conch/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/cutlass/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/dynamic_4bit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/exllama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/MPLinearKernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/machete/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/marlin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/mixed_precision/xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/aiter/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/cutlass/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/ScaledMMLinearKernel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/triton/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/kernels/scaled_mm/xla/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/quark/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/quark_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_ocp_mx/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_scheme/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_w8a8_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/quark/schemes/quark_w8a8_int8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/allspark_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/bitblas_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/flashinfer_fp4_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/flashinfer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/fp8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/gptq_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/int8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/layer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/machete_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_fp4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_fp8/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_test/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/marlin_utils_test_24/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp4_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp6_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/mxfp8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/nvfp4_emulation_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/nvfp4_moe_support/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/ocp_mx_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/petit_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/quant_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/quantization/utils/w8a8_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/deepseek_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dual_chunk_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dynamic_ntk_alpha_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/dynamic_ntk_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/ernie45_vl_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/linear_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/llama3_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/llama4_vision_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/mrope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/ntk_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/phi3_long_rope_scaled_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/xdrope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/layers/rotary_embedding/yarn_scaling_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/base_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/bitsandbytes_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/default_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/dummy_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/gguf_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/online_quantization/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/runai_streamer_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/sharded_state_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tensorizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tensorizer_loader/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/model_loader/weight_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/adapters/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/afmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aimv2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/apertus/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/arcee/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/arctic/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aria/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/audioflamingo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/aya_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/baichuan/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bailing_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bee/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bert/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bert_with_rope/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/blip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/blip2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/bloom/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/chameleon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/chatglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/clip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/cohere2_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/commandr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dbrx/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepencoder/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_v2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dots1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/dots_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie45_vl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ernie_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/exaone/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/exaone4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/fairseq2_llama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/falcon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/falcon_h1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/flex_olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/fuyu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3n/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gemma3n_mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_1v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4_moe_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/glm4v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_bigcode/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_j/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_neox/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gpt_oss/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granite/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granite_speech/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoehybrid/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/granitemoeshared/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/gritlm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/grok1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/h2ovl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hunyuan_v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hunyuan_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/hyperclovax_vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/idefics2_vision_model/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/idefics3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interfaces/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interfaces_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/intern_vit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internlm2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internlm2_ve/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interns1/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/interns1_vit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/internvl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jais/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jais2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/jina_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/keye/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/keye_vl1_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/kimi_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/kimi_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lfm2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lfm2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/lightonocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama4_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llama_eagle3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_next_video/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/llava_onevision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/longcat_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/longcat_flash_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mamba/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mamba2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/midashenglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mimo_v2_flash/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpm_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minicpmv/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_m2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_text_01/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/minimax_vl_01/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral_large_3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mistral_large_3_eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mixtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mllama4/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mlp_speculator/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/modernbert/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/module_mapping/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/molmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/moonvit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/mpt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nano_nemotron_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_nas/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nemotron_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/nvlm_d/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmo2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/olmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/opencua/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/openpangu/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/openpangu_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/opt/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/orion/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ouro/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ovis2_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/paddleocr_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/paligemma/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/persimmon/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi3v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm_audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phi4mm_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/phimoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/pixtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/plamo2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/plamo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_5_omni_thinker/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_5_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_rm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen2_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_next_mtp/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_omni_moe_thinker/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen3_vl_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/qwen_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/radio/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/roberta/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/rvl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/seed_oss/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/siglip/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/siglip2navit/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/skyworkr1v/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/smolvlm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/solar/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/stablelm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/starcoder2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/step3_text/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/step3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/swin/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/tarsier/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/telechat2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/teleflm/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/terratorch/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/ultravox/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/vision/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/voxtral/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/voxtral_streaming/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/whisper/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/whisper_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/zamba2/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/causal/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/legacy/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/pooling/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/models/transformers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/deep_gemm_warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/model_executor/warmup/kernel_warmup/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/audio/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/evs/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/hasher/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/image/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/inputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/parse/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/processing/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/profiling/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/multimodal/video/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/cuda/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/rocm/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/platforms/xpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/io_processors/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/io_processors/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/lora_resolvers/",
    "https://docs.vllm.ai/en/latest/api/vllm/plugins/lora_resolvers/filesystem_resolver/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/layerwise_profile/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/profiler/wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/lazy_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/ray/ray_env/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/abs_reasoning_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/basic_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/deepseek_r1_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/deepseek_v3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/ernie45_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/glm4_moe_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/gptoss_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/granite_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/holo2_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/hunyuan_a13b_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/identity_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/minimax_m2_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/mistral_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/olmo3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/qwen3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/seedoss_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/reasoning/step3_reasoning_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/deepseek_v32/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/deepseek_v32_encoding/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/detokenizer_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/hf/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/mistral/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/protocol/",
    "https://docs.vllm.ai/en/latest/api/vllm/tokenizers/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/abstract_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv31_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/deepseekv32_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/ernie45_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/functiongemma_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/gigachat3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/glm4_moe_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/glm47_moe_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/granite_20b_fc_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/granite_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/hermes_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/hunyuan_a13b_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/internlm2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/jamba_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/kimi_k2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/llama4_pythonic_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/llama_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/longcat_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/minimax_m2_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/minimax_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/mistral_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/olmo3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/openai_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/phi4mini_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/pythonic_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/qwen3coder_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/qwen3xml_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/seed_oss_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/step3_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/tool_parsers/xlam_tool_parser/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/config/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/config_parser_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/dynamic_module/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/gguf_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/repo_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/runai_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/s3_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/tokenizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/chat_templates/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/chat_templates/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/afmoe/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/arctic/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/chatglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/dotsocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/falcon/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/flex_olmo/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/hunyuan_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/jais/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/kimi_linear/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/kimi_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/lfm2_moe/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/midashenglm/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/mistral/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/mlp_speculator/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/moonvit/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/nemotron/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/nemotron_h/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/olmo3/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/qwen3_next/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/radio/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/step3_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/tarsier2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/ultravox/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/algos/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/configs/speculators/base/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/bagel/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/deepseek_ocr/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/deepseek_vl2/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/hunyuan_vl/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/hunyuan_vl_image/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/ovis/",
    "https://docs.vllm.ai/en/latest/api/vllm/transformers_utils/processors/ovis2_5/",
    "https://docs.vllm.ai/en/latest/api/vllm/triton_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/triton_utils/importing/",
    "https://docs.vllm.ai/en/latest/api/vllm/usage/",
    "https://docs.vllm.ai/en/latest/api/vllm/usage/usage_lib/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/argparse_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/async_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/cache/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/collection_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/counter/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/deep_gemm/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/flashinfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/func_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/gc_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/hashing/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/import_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/jsontree/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/math_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/mem_constants/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/mem_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/nccl/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/network_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/nvtx_pytorch_hooks/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/platform_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/profiling/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/registry/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/serial_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/system_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/tensor_schema/",
    "https://docs.vllm.ai/en/latest/api/vllm/utils/torch_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/cudagraph_dispatcher/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_cache_interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/serial_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/cpu_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flash_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flashinfer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/flex_attention/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/gdn_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/linear_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba1_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba2_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mamba_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/pallas/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_aiter_fa/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_aiter_unified_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/rocm_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/short_conv_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/tree_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/triton_attn/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/aiter_triton_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/common/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/cutlass_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashattn_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashinfer_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashmla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/flashmla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/indexer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/rocm_aiter_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/rocm_aiter_mla_sparse/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/attention/backends/mla/triton_mla/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/block_pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/encoder_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_coordinator/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/kv_cache_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/single_type_kv_cache_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/async_scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/request_queue/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/scheduler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/core/sched/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/async_llm/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/coordinator/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/core/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/core_client/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/detokenizer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/exceptions/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/input_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/llm_engine/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/output_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/parallel_sampling/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/engine/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/multiproc_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_distributed_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/ray_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/executor/uniproc_executor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/abstract/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/arc_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backend/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/factory/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/lru_manager/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/mediums/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/spec/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backends/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/backends/cpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/cpu_gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/kv_offload/worker/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/loggers/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/perf/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/prometheus/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/ray_wrappers/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/reader/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/metrics/stats/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/pool/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/pool/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/rejection_sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/builtin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/interface/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/logits_processor/state/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/bad_words/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/logprobs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/penalties/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/ops/topk_topp_sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/sample/tpu/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/medusa/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/ngram_proposer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/suffix_decoding/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/spec_decode/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_guidance/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_lm_format_enforcer/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_outlines/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_types/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/backend_xgrammar/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/request/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/structured_output/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/block_table/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/cpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/dp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ec_connector_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_ubatch_wrapper/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/kv_connector_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/lora_model_runner_mixin/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/tpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ubatch_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/ubatching/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/worker_base/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/workspace/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/xpu_model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/xpu_worker/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/async_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/attn_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/block_table/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/cudagraph_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/dp_utils/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/input_batch/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/model_runner/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/states/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/structured_outputs/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/metrics/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/metrics/logits/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/gumbel/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/logprob/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/metadata/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/min_p/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/output/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/penalties/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/sample/sampler/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/eagle/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/eagle_cudagraph/",
    "https://docs.vllm.ai/en/latest/api/vllm/v1/worker/gpu/spec_decode/rejection_sample/",
    "https://docs.vllm.ai/en/latest/cli/serve/",
    "https://docs.vllm.ai/en/latest/cli/chat/",
    "https://docs.vllm.ai/en/latest/cli/complete/",
    "https://docs.vllm.ai/en/latest/cli/run-batch/",
    "https://docs.vllm.ai/en/latest/cli/bench/latency/",
    "https://docs.vllm.ai/en/latest/cli/bench/serve/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/plot/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/plot_pareto/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/serve/",
    "https://docs.vllm.ai/en/latest/cli/bench/sweep/serve_sla/",
    "https://docs.vllm.ai/en/latest/cli/bench/throughput/",
    "https://docs.vllm.ai/en/latest/community/meetups/",
    "https://docs.vllm.ai/en/latest/community/sponsors/",
    "https://docs.vllm.ai/en/latest/governance/collaboration/",
    "https://docs.vllm.ai/en/latest/governance/committers/",
    "https://docs.vllm.ai/en/latest/governance/process/"
  ]
}