{
  "title": "Colors for the balls",
  "content": "BALL_COLORS = [\n    '#f8b862', '#f6ad49', '#f39800', '#f08300', '#ec6d51',\n    '#ee7948', '#ed6d3d', '#ec6800', '#ec6800', '#ee7800',\n    '#eb6238', '#ea5506', '#ea5506', '#eb6101', '#e49e61',\n    '#e45e32', '#e17b34', '#dd7a56', '#db8449', '#d66a35'\n]\n\n@dataclass\nclass Ball:\n    x: float\n    y: float\n    vx: float\n    vy: float\n    radius: float\n    color: str\n    number: int\n    spin: float = 0.0\n\ndef move(self):\n        self.x += self.vx\n        self.y += self.vy\n        self.vy += GRAVITY\n        self.vx *= FRICTION\n        self.vy *= FRICTION\n        self.spin *= SPIN_FRICTION\n\ndef collide_with_ball(self, other: 'Ball'):\n        dx = other.x - self.x\n        dy = other.y - self.y\n        distance = math.hypot(dx, dy)\n        \n        if distance < self.radius + other.radius:\n            # Calculate collision normal\n            nx = dx / distance\n            ny = dy / distance\n            \n            # Calculate relative velocity\n            dvx = other.vx - self.vx\n            dvy = other.vy - self.vy\n            \n            # Calculate impulse\n            impulse = 2 * (dvx * nx + dvy * ny) / (1/self.radius + 1/other.radius)\n            \n            # Apply impulse\n            self.vx += impulse * nx / self.radius\n            self.vy += impulse * ny / self.radius\n            other.vx -= impulse * nx / other.radius\n            other.vy -= impulse * ny / other.radius\n            \n            # Separate balls to prevent sticking\n            overlap = (self.radius + other.radius - distance) / 2\n            self.x -= overlap * nx\n            self.y -= overlap * ny\n            other.x += overlap * nx\n            other.y += overlap * ny\n            \n            # Transfer some spin\n            transfer = impulse * 0.01\n            self.spin -= transfer\n            other.spin += transfer\n\nclass HeptagonBounceSimulator:\n    def __init__(self, root):\n        self.root = root\n        self.canvas = tk.Canvas(root, width=WIDTH, height=HEIGHT, bg='white')\n        self.canvas.pack()\n        \n        self.balls = self.create_balls()\n        self.heptagon_angle = 0\n        self.last_time = 0\n        self.running = True\n        \n        self.root.bind('<space>', self.toggle_pause)\n        self.root.bind('<Escape>', lambda e: root.destroy())\n        \n        self.last_time = self.root.after(0, self.update)\n    \n    def create_balls(self) -> List[Ball]:\n        balls = []\n        for i in range(20):\n            # Start all balls at center with small random velocity\n            angle = np.random.uniform(0, 2 * math.pi)\n            speed = np.random.uniform(0.5, 2)\n            vx = math.cos(angle) * speed\n            vy = math.sin(angle) * speed\n            \n            balls.append(Ball(\n                x=CENTER_X,\n                y=CENTER_Y,\n                vx=vx,\n                vy=vy,\n                radius=BALL_RADIUS,\n                color=BALL_COLORS[i],\n                number=i+1,\n                spin=np.random.uniform(-2, 2)\n            ))\n        return balls\n    \n    def toggle_pause(self, event):\n        self.running = not self.running\n        if self.running:\n            self.last_time = self.root.after(0, self.update)\n    \n    def get_heptagon_vertices(self) -> List[Tuple[float, float]]:\n        vertices = []\n        for i in range(7):\n            angle = math.radians(self.heptagon_angle + i * 360 / 7)\n            x = CENTER_X + HEPTAGON_RADIUS * math.cos(angle)\n            y = CENTER_Y + HEPTAGON_RADIUS * math.sin(angle)\n            vertices.append((x, y))\n        return vertices\n    \n    def check_ball_heptagon_collision(self, ball: Ball):\n        vertices = self.get_heptagon_vertices()\n        closest_dist = float('inf')\n        closest_normal = (0, 0)\n        closest_edge = None\n        \n        # Check collision with each edge of the heptagon\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            \n            # Vector from p1 to p2\n            edge_x = p2[0] - p1[0]\n            edge_y = p2[1] - p1[1]\n            edge_length = math.hypot(edge_x, edge_y)\n            \n            # Normalize edge vector\n            edge_x /= edge_length\n            edge_y /= edge_length\n            \n            # Normal vector (perpendicular to edge, pointing inward)\n            nx = -edge_y\n            ny = edge_x\n            \n            # Vector from p1 to ball\n            ball_to_p1_x = ball.x - p1[0]\n            ball_to_p1_y = ball.y - p1[1]\n            \n            # Project ball onto edge normal\n            projection = ball_to_p1_x * nx + ball_to_p1_y * ny\n            \n            # If projection is negative, ball is outside the heptagon\n            if projection < ball.radius:\n                # Find closest point on edge to ball\n                edge_proj = ball_to_p1_x * edge_x + ball_to_p1_y * edge_y\n                edge_proj = max(0, min(edge_length, edge_proj))\n                closest_x = p1[0] + edge_proj * edge_x\n                closest_y = p1[1] + edge_proj * edge_y\n                \n                # Distance from ball to closest point on edge\n                dist = math.hypot(ball.x - closest_x, ball.y - closest_y)\n                \n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_normal = (nx, ny)\n                    closest_edge = (p1, p2)\n        \n        if closest_dist < ball.radius:\n            # Calculate bounce response\n            dot_product = ball.vx * closest_normal[0] + ball.vy * closest_normal[1]\n            \n            # Apply bounce with elasticity\n            ball.vx -= (1 + ELASTICITY) * dot_product * closest_normal[0]\n            ball.vy -= (1 + ELASTICITY) * dot_product * closest_normal[1]\n            \n            # Add some spin based on impact\n            edge_vec = (closest_edge[1][0] - closest_edge[0][0], \n                        closest_edge[1][1] - closest_edge[0][1])\n            edge_length = math.hypot(edge_vec[0], edge_vec[1])\n            if edge_length > 0:\n                edge_vec = (edge_vec[0]/edge_length, edge_vec[1]/edge_length)\n                # Cross product of velocity and edge direction\n                spin_effect = (ball.vx * edge_vec[1] - ball.vy * edge_vec[0]) * 0.1\n                ball.spin += spin_effect\n            \n            # Move ball outside the heptagon to prevent sticking\n            penetration = ball.radius - closest_dist\n            ball.x += penetration * closest_normal[0]\n            ball.y += penetration * closest_normal[1]\n    \n    def update(self):\n        if not self.running:\n            return\n        \n        # Clear canvas\n        self.canvas.delete('all')\n        \n        # Update heptagon rotation\n        self.heptagon_angle += ROTATION_SPEED / 60  # Assuming ~60 FPS\n        \n        # Draw heptagon\n        vertices = self.get_heptagon_vertices()\n        self.canvas.create_polygon(vertices, outline='black', fill='', width=2)\n        \n        # Update and draw balls\n        for i, ball in enumerate(self.balls):\n            # Move ball\n            ball.move()\n            \n            # Check collisions with heptagon\n            self.check_ball_heptagon_collision(ball)\n            \n            # Draw ball\n            self.canvas.create_oval(\n                ball.x - ball.radius, ball.y - ball.radius,\n                ball.x + ball.radius, ball.y + ball.radius,\n                fill=ball.color, outline='black'\n            )\n            \n            # Draw number with rotation based on spin\n            angle = ball.spin * 10  # Scale spin for visible rotation\n            self.canvas.create_text(\n                ball.x, ball.y,\n                text=str(ball.number),\n                font=('Arial', 10, 'bold'),\n                angle=angle\n            )\n        \n        # Check ball-ball collisions\n        for i in range(len(self.balls)):\n            for j in range(i + 1, len(self.balls)):\n                self.balls[i].collide_with_ball(self.balls[j])\n        \n        # Schedule next update\n        self.last_time = self.root.after(16, self.update)  # ~60 FPS\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    root.title('Bouncing Balls in a Spinning Heptagon')\n    simulator = HeptagonBounceSimulator(root)\n    root.mainloop()\n```\n\n## :detective: Extra Findings & Tips\n\n1. We find using lower KV cache quantization (4bit) seems to degrade generation quality via empirical tests - more tests need to be done, but we suggest using `q8_0` cache quantization. The goal of quantization is to support longer context lengths since the KV cache uses quite a bit of memory.\n2. We found the `down_proj` in this model to be extremely sensitive to quantitation. We had to redo some of our dyanmic quants which used 2bits for `down_proj` and now we use 3bits as the minimum for all these matrices.\n3. Using `llama.cpp` 's Flash Attention backend does result in somewhat faster decoding speeds. Use `-DGGML_CUDA_FA_ALL_QUANTS=ON` when compiling. Note it's also best to set your CUDA architecture as found in <https://developer.nvidia.com/cuda-gpus> to reduce compilation times, then set it via `-DCMAKE_CUDA_ARCHITECTURES=\"80\"`\n4. Using a `min_p=0.01`is probably enough. `llama.cpp`defaults to 0.1, which is probably not necessary. Since a temperature of 0.3 is used anyways, we most likely will very unlikely sample low probability tokens, so removing very unlikely tokens is a good idea. DeepSeek recommends 0.0 temperature for coding tasks.\n\n[^1]: MUST USE 8bit - not 4bit\n\n[^2]: CPU threads your machine has\n\n[^3]: Approx 2 for 24GB GPU. Approx 18 for 80GB GPU.",
  "code_samples": [],
  "headings": [
    {
      "level": "h2",
      "text": ":detective: Extra Findings & Tips",
      "id": ":detective:-extra-findings-&-tips"
    }
  ],
  "url": "llms-txt#colors-for-the-balls",
  "links": []
}