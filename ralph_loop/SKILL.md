---
name: ralph-loop
description: |
  Ralph Loop 迭代式開發方法論。透過多輪迭代讓 AI 自主精進工作，
  適合需要反覆審查、測試驅動開發、或需要多階段完成的複雜任務。
  核心概念：「Ralph is a Bash loop」- 持續迭代直到達成完成標準。
  ⚠️ 關鍵原則：每回合執行「相同任務」並評估進展，而非拆分成不同步驟！
triggers:
  - "ralph"
  - "loop"
  - "迭代"
  - "反覆執行"
  - "多輪"
  - "深度審查"
  - "ralph loop"
  - "自我修正"
---

# Ralph Loop 迭代式開發方法論

一種讓 AI 自主進行多輪迭代精進的開發方法，直到滿足明確的完成標準。

## 🚨 最重要的原則（必讀）

> **每回合執行「相同的任務」，基於上一輪的成果持續精進，而非把任務拆分成不同步驟依序執行！**

這是 Ralph Loop 最常見的誤用。請在開始前確認：

### ✅ 執行前檢查清單

在開始 Ralph Loop 之前，問自己：

1. [ ] 我的每一回合是否執行**完全相同**的任務？
2. [ ] 我是否在每回合結束時評估「完成承諾」是否達成？
3. [ ] 達成完成承諾後，我是否會**立即結束**而非繼續執行剩餘回合？
4. [ ] 我是否避免了「回合 1 做 A、回合 2 做 B、回合 3 做 C」的模式？

**如果任何一項答案為否，請重新規劃執行方式！**

## 核心概念

> **"Ralph is a Bash loop"** - 同一個命令反覆執行，直到條件滿足

Ralph Loop 的本質是一個自我參照的迭代循環：
1. Claude 處理任務
2. 評估：完成承諾是否達成？
3. 若未達成 → 執行**相同任務**，利用上輪成果繼續精進
4. 每輪迭代都能看到前幾輪的修改結果
5. 直到滿足完成承諾（Completion Promise）→ **立即結束**

## ⚠️ 正確執行方式（重要）

### ✅ 正確做法：每回合執行相同任務，基於上輪成果精進

```
任務：「深度審查系統一致性」
完成承諾：「系統穩定易操作」

回合 1: 深度審查系統一致性 → 發現 3 個問題 → 修正 → 檢查完成承諾 → 未達成
回合 2: 深度審查系統一致性 → 基於回合1的修正繼續審查 → 發現 1 個問題 → 修正 → 未達成
回合 3: 深度審查系統一致性 → 基於回合2的修正繼續審查 → 無新問題 → ✓ 達成！結束
```

**特點**：
- 每回合執行**完全相同**的審查任務
- 每回合**基於前一輪的成果**繼續精進
- 每回合結束時檢查是否達成完成承諾
- 達成即結束，不必用完所有回合

### ❌ 錯誤做法：將任務拆分成不同步驟

```
回合 1: 審查專案結構      ← 錯誤！這是步驟 1
回合 2: 審查配置一致性    ← 錯誤！這是步驟 2
回合 3: 審查文檔完整性    ← 錯誤！這是步驟 3
回合 4: 建立測試框架      ← 錯誤！這是步驟 4
回合 5: 實作單元測試      ← 錯誤！這是步驟 5
...
```

**問題**：
- 這是「分階段執行」而非「迭代式精進」
- 無法體現 loop 的本質：反覆執行同一任務直到完成
- 失去了自我修正的機會
- 每回合做不同的事 = 這不是 loop！

### 🔴 常見誤用警示

以下是**絕對禁止**的執行模式：

| 禁止模式 | 為何錯誤 |
|----------|----------|
| 回合 1 建框架、回合 2 寫測試、回合 3 實作功能 | 這是順序執行，不是迭代 |
| 一開始就規劃好 10 個不同的任務 | 這是任務清單，不是 loop |
| 每回合做新的事情 | 違反「同一任務反覆執行」原則 |
| 必須用完所有回合才結束 | 應該達成承諾就結束 |

### 正確 vs 錯誤對比

| 項目 | 正確做法 | 錯誤做法 |
|------|----------|----------|
| 每回合任務 | **相同** | 不同 |
| 任務關係 | 基於上輪成果**持續精進** | 執行**下一個步驟** |
| 完成承諾檢查 | **每回合**檢查 | 最後才檢查 |
| 提前結束 | 達成即結束 | 必須完成所有步驟 |
| 本質 | **迭代精進** | 順序執行 |
| 類比 | `while (!done) { doSameTask(); }` | `steps.forEach(step => step());` |

## 實際案例對比

### ✅ 正確案例：深度審查系統程式碼

**任務**：「深度審查系統程式碼並修正問題」
**完成承諾**：「所有測試通過且無 TypeScript 錯誤」

```
回合 1:
  - 執行「深度審查系統程式碼並修正問題」
  - 發現：3 個 TypeScript 錯誤、5 個測試失敗
  - 修正：修復 2 個 TypeScript 錯誤
  - 檢查完成承諾 → 未達成，繼續

回合 2:
  - 執行「深度審查系統程式碼並修正問題」（同樣的任務！）
  - 基於回合 1 的成果，繼續審查
  - 發現：還有 1 個 TypeScript 錯誤、3 個測試失敗
  - 修正：修復剩餘的 TypeScript 錯誤、2 個測試
  - 檢查完成承諾 → 未達成，繼續

回合 3:
  - 執行「深度審查系統程式碼並修正問題」（同樣的任務！）
  - 基於回合 2 的成果，繼續審查
  - 發現：0 個 TypeScript 錯誤、1 個測試失敗
  - 修正：修復最後一個測試
  - 檢查完成承諾 → ✓ 達成！結束（只用了 3 回合）
```

### ❌ 錯誤案例：同樣的目標但拆分成步驟

**任務**：「深度審查系統程式碼並修正問題」
**完成承諾**：「所有測試通過且無 TypeScript 錯誤」

```
回合 1: 審查規格文件     ← 錯誤！這是步驟不是迭代
回合 2: 建立測試框架     ← 錯誤！
回合 3: 實作服務層測試   ← 錯誤！
回合 4: 實作路由層測試   ← 錯誤！
回合 5: 修復 TypeScript  ← 錯誤！
...
回合 10: 完成！          ← 必須用完所有回合

這不是 Ralph Loop，這是任務清單！
```

## 使用語法

### 基本格式

```
執行 ralph loop，反覆執行 N 回合 "<任務描述>"，保證完成 "<完成承諾>"
```

### 參數說明

| 參數 | 說明 | 範例 |
|------|------|------|
| **回合數** | 最大迭代次數 | 10 回合 |
| **任務描述** | 每輪要執行的工作 | "深度審查並優化" |
| **完成承諾** | 明確的完成標準 | "所有測試通過" |

## 範例指令

### 範例 1：程式碼品質審查

```
執行 ralph loop，反覆執行 5 回合 "審查程式碼品質並修正問題"，
保證完成 "無 lint 錯誤且測試覆蓋率達 80%"
```

### 範例 2：功能實作

```
執行 ralph loop，反覆執行 10 回合 "實作用戶認證功能並測試"，
保證完成 "所有測試通過且無安全漏洞"
```

### 範例 3：效能優化

```
執行 ralph loop，反覆執行 8 回合 "分析效能瓶頸並優化"，
保證完成 "回應時間低於 100ms"
```

### 範例 4：文檔完善

```
執行 ralph loop，反覆執行 3 回合 "審查文檔完整性並補充"，
保證完成 "所有公開 API 都有文檔說明"
```

## 有效的提示設計

### 好的提示特徵

1. **明確的完成標準**
   - 可測量的里程碑
   - 客觀的驗證方式
   - 例如：「測試通過」、「無錯誤」、「覆蓋率達標」

2. **單一明確任務**
   - 每回合執行相同的任務
   - 任務本身可包含多個檢查點
   - 例如：「審查系統一致性並修正問題」（每回合都執行這個）

3. **自我修正流程**
   - 強調測試驅動開發
   - 每輪檢查前輪結果
   - 修正發現的問題

4. **迭代保護**
   - 設定合理的最大回合數
   - 避免無限循環
   - 通常 5-10 回合足夠

### 範例：完整的多階段提示

```
執行 ralph loop，反覆執行 10 回合，每回合執行：
1. 檢查當前程式碼狀態
2. 運行測試套件
3. 分析失敗的測試
4. 修正問題
5. 驗證修正結果

保證完成 "所有 50 個測試用例通過，無 TypeScript 錯誤"
```

## 適用場景

### 最適合 Ralph Loop 的任務

| 場景 | 原因 | 範例 |
|------|------|------|
| **測試驅動開發** | 有自動化驗證 | 修復測試失敗 |
| **程式碼重構** | 可驗證正確性 | 逐步重構模組 |
| **Lint 修正** | 明確的錯誤列表 | 修復所有 ESLint 錯誤 |
| **新專案建立** | 需要多次調整 | 建立完整專案結構 |
| **效能優化** | 可量化改進 | 達成效能目標 |

### 不適合 Ralph Loop 的任務

| 場景 | 原因 |
|------|------|
| **主觀設計決策** | 無客觀完成標準 |
| **單次操作** | 不需要迭代 |
| **不明確的成功指標** | 無法判斷何時完成 |
| **需要人工審查** | 每輪都需人工確認 |

## 執行流程

```
┌─────────────────────────────────────────┐
│           Ralph Loop 開始               │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  回合 1: 執行任務                        │
│  ├── 分析當前狀態                        │
│  ├── 執行指定工作                        │
│  └── 評估結果                           │
└─────────────────┬───────────────────────┘
                  │
          完成承諾達成？
          ├── 是 ──────────────────────────┐
          │                                │
          ▼ 否                             ▼
┌─────────────────────────────────────────┐
│  回合 2-N: 繼續迭代                      │  ┌──────────────┐
│  ├── 檢查前輪結果                        │  │  完成！       │
│  ├── 識別剩餘問題                        │  │  輸出總結     │
│  ├── 修正問題                           │  └──────────────┘
│  └── 重新評估                           │
└─────────────────┬───────────────────────┘
                  │
          達到最大回合？
          ├── 是 → 輸出當前狀態，標記未完成
          └── 否 → 繼續下一回合
```

## 最佳實踐

### 1. 設定合理的回合數

| 任務類型 | 建議回合數 |
|----------|-----------|
| 簡單修正 | 3-5 回合 |
| 中等複雜度 | 5-8 回合 |
| 複雜任務 | 8-15 回合 |
| 大型重構 | 10-20 回合 |

### 2. 明確的完成標準

```
# 好的完成標準
✓ "所有測試通過"
✓ "TypeScript 編譯無錯誤"
✓ "覆蓋率達 80%"
✓ "無 ESLint 警告"

# 不好的完成標準
✗ "程式碼品質好"
✗ "看起來不錯"
✗ "差不多完成"
```

### 3. 每輪任務要具體

```
# 好的任務描述
✓ "執行測試，修復失敗的測試，驗證修復結果"
✓ "分析效能瓶頸，優化最慢的函數，測量改進"

# 不好的任務描述
✗ "改進程式碼"
✗ "做一些優化"
```

## 與其他方法的結合

### Ralph Loop + 測試驅動開發 (TDD)

```
執行 ralph loop，反覆執行 10 回合：
1. 運行測試套件
2. 選擇一個失敗的測試
3. 編寫最小程式碼使其通過
4. 重構（保持測試通過）
5. 繼續下一個失敗測試

保證完成 "所有測試通過"
```

### Ralph Loop + Code Review

```
執行 ralph loop，反覆執行 5 回合：
1. 審查程式碼安全性
2. 審查程式碼效能
3. 審查程式碼可讀性
4. 修正發現的問題
5. 驗證修正

保證完成 "無高優先級問題"
```

## 輸出格式

每輪迭代應輸出：

```markdown
## 回合 N/總數

### 本輪執行
- [x] 完成的工作項目 1
- [x] 完成的工作項目 2
- [ ] 未完成項目（下輪處理）

### 當前狀態
- 測試：X 通過 / Y 失敗
- 錯誤：N 個待修正

### 下輪計劃
- 優先處理項目 A
- 然後處理項目 B

### 完成進度
[████████░░] 80% - 距離完成承諾還需 X 項
```

## 注意事項

### 🚨 核心原則（最重要）

1. **每回合執行相同任務**：這是 Ralph Loop 的本質！
   - ✅ 正確：每回合都執行「審查並修正問題」
   - ❌ 錯誤：回合 1 做 A、回合 2 做 B、回合 3 做 C

2. **基於上輪成果精進**：不是重新開始，而是持續改進
   - ✅ 正確：「基於上一輪的修正，繼續審查」
   - ❌ 錯誤：「現在開始做下一個步驟」

3. **達成即結束**：不需要用完所有回合
   - ✅ 正確：完成承諾達成 → 立即結束
   - ❌ 錯誤：必須執行完所有 10 個回合

### 其他注意事項

4. **避免無限循環**：始終設定 `--max-iterations`
5. **可驗證的標準**：完成承諾必須可以客觀驗證
6. **保存進度**：每輪都應該有可見的進展
7. **適時中止**：如果連續幾輪無進展，考慮調整策略

### 自我檢查問題

在每回合開始前問自己：
- 「我這回合做的事情，和上回合是否相同？」→ 應該是「是」
- 「我是否在上回合的成果基礎上繼續精進？」→ 應該是「是」
- 「如果完成承諾已達成，我會停下來嗎？」→ 應該是「是」

## 參考資料

- [Ralph Wiggum Plugin](https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum)
- [Claude Code 官方文檔](https://docs.anthropic.com/claude-code)

---

**Ralph Loop** - 讓 AI 透過持續迭代達成高品質輸出的開發方法論
