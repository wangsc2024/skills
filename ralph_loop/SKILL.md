---
name: ralph-loop
description: |
  Ralph Loop 迭代式開發方法論。透過多輪迭代讓 AI 自主精進工作，
  適合需要反覆審查、測試驅動開發、或需要多階段完成的複雜任務。
  核心概念：「Ralph is a Bash loop」- 持續迭代直到達成完成標準。
triggers:
  - "ralph"
  - "loop"
  - "迭代"
  - "反覆執行"
  - "多輪"
  - "深度審查"
  - "ralph loop"
  - "自我修正"
---

# Ralph Loop 迭代式開發方法論

一種讓 AI 自主進行多輪迭代精進的開發方法，直到滿足明確的完成標準。

## 核心概念

> **"Ralph is a Bash loop"** - 持續迭代的反饋機制

Ralph Loop 的本質是一個自我參照的迭代循環：
1. Claude 處理初始任務
2. 完成一輪工作後評估結果
3. 如未達成完成標準，繼續下一輪迭代
4. 每輪迭代都能看到前幾輪的修改結果
5. 直到滿足完成承諾（Completion Promise）

## ⚠️ 正確執行方式（重要）

### 正確做法：每回合執行相同任務

```
任務：「深度審查系統一致性」
完成承諾：「系統穩定易操作」

回合 1: 深度審查系統一致性 → 發現 3 個問題 → 修正 → 檢查完成承諾 → 未達成
回合 2: 深度審查系統一致性 → 發現 1 個問題 → 修正 → 檢查完成承諾 → 未達成
回合 3: 深度審查系統一致性 → 無新問題 → 檢查完成承諾 → ✓ 達成！結束
```

**特點**：
- 每回合執行**完全相同**的審查任務
- 每回合結束時檢查是否達成完成承諾
- 達成即結束，不必用完所有回合

### ❌ 錯誤做法：將任務拆分成不同步驟

```
回合 1: 審查專案結構      ← 錯誤！這是步驟 1
回合 2: 審查配置一致性    ← 錯誤！這是步驟 2
回合 3: 審查文檔完整性    ← 錯誤！這是步驟 3
...
```

**問題**：
- 這是「分階段執行」而非「迭代式精進」
- 無法體現 loop 的本質：反覆執行同一任務直到完成
- 失去了自我修正的機會

### 正確 vs 錯誤對比

| 項目 | 正確做法 | 錯誤做法 |
|------|----------|----------|
| 每回合任務 | 相同 | 不同 |
| 完成承諾檢查 | 每回合檢查 | 最後才檢查 |
| 提前結束 | 達成即結束 | 必須完成所有步驟 |
| 本質 | 迭代精進 | 順序執行 |

## 使用語法

### 基本格式

```
執行 ralph loop，反覆執行 N 回合 "<任務描述>"，保證完成 "<完成承諾>"
```

### 參數說明

| 參數 | 說明 | 範例 |
|------|------|------|
| **回合數** | 最大迭代次數 | 10 回合 |
| **任務描述** | 每輪要執行的工作 | "深度審查並優化" |
| **完成承諾** | 明確的完成標準 | "所有測試通過" |

## 範例指令

### 範例 1：程式碼品質審查

```
執行 ralph loop，反覆執行 5 回合 "審查程式碼品質並修正問題"，
保證完成 "無 lint 錯誤且測試覆蓋率達 80%"
```

### 範例 2：功能實作

```
執行 ralph loop，反覆執行 10 回合 "實作用戶認證功能並測試"，
保證完成 "所有測試通過且無安全漏洞"
```

### 範例 3：效能優化

```
執行 ralph loop，反覆執行 8 回合 "分析效能瓶頸並優化"，
保證完成 "回應時間低於 100ms"
```

### 範例 4：文檔完善

```
執行 ralph loop，反覆執行 3 回合 "審查文檔完整性並補充"，
保證完成 "所有公開 API 都有文檔說明"
```

## 有效的提示設計

### 好的提示特徵

1. **明確的完成標準**
   - 可測量的里程碑
   - 客觀的驗證方式
   - 例如：「測試通過」、「無錯誤」、「覆蓋率達標」

2. **單一明確任務**
   - 每回合執行相同的任務
   - 任務本身可包含多個檢查點
   - 例如：「審查系統一致性並修正問題」（每回合都執行這個）

3. **自我修正流程**
   - 強調測試驅動開發
   - 每輪檢查前輪結果
   - 修正發現的問題

4. **迭代保護**
   - 設定合理的最大回合數
   - 避免無限循環
   - 通常 5-10 回合足夠

### 範例：完整的多階段提示

```
執行 ralph loop，反覆執行 10 回合，每回合執行：
1. 檢查當前程式碼狀態
2. 運行測試套件
3. 分析失敗的測試
4. 修正問題
5. 驗證修正結果

保證完成 "所有 50 個測試用例通過，無 TypeScript 錯誤"
```

## 適用場景

### 最適合 Ralph Loop 的任務

| 場景 | 原因 | 範例 |
|------|------|------|
| **測試驅動開發** | 有自動化驗證 | 修復測試失敗 |
| **程式碼重構** | 可驗證正確性 | 逐步重構模組 |
| **Lint 修正** | 明確的錯誤列表 | 修復所有 ESLint 錯誤 |
| **新專案建立** | 需要多次調整 | 建立完整專案結構 |
| **效能優化** | 可量化改進 | 達成效能目標 |

### 不適合 Ralph Loop 的任務

| 場景 | 原因 |
|------|------|
| **主觀設計決策** | 無客觀完成標準 |
| **單次操作** | 不需要迭代 |
| **不明確的成功指標** | 無法判斷何時完成 |
| **需要人工審查** | 每輪都需人工確認 |

## 執行流程

```
┌─────────────────────────────────────────┐
│           Ralph Loop 開始               │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  回合 1: 執行任務                        │
│  ├── 分析當前狀態                        │
│  ├── 執行指定工作                        │
│  └── 評估結果                           │
└─────────────────┬───────────────────────┘
                  │
          完成承諾達成？
          ├── 是 ──────────────────────────┐
          │                                │
          ▼ 否                             ▼
┌─────────────────────────────────────────┐
│  回合 2-N: 繼續迭代                      │  ┌──────────────┐
│  ├── 檢查前輪結果                        │  │  完成！       │
│  ├── 識別剩餘問題                        │  │  輸出總結     │
│  ├── 修正問題                           │  └──────────────┘
│  └── 重新評估                           │
└─────────────────┬───────────────────────┘
                  │
          達到最大回合？
          ├── 是 → 輸出當前狀態，標記未完成
          └── 否 → 繼續下一回合
```

## 最佳實踐

### 1. 設定合理的回合數

| 任務類型 | 建議回合數 |
|----------|-----------|
| 簡單修正 | 3-5 回合 |
| 中等複雜度 | 5-8 回合 |
| 複雜任務 | 8-15 回合 |
| 大型重構 | 10-20 回合 |

### 2. 明確的完成標準

```
# 好的完成標準
✓ "所有測試通過"
✓ "TypeScript 編譯無錯誤"
✓ "覆蓋率達 80%"
✓ "無 ESLint 警告"

# 不好的完成標準
✗ "程式碼品質好"
✗ "看起來不錯"
✗ "差不多完成"
```

### 3. 每輪任務要具體

```
# 好的任務描述
✓ "執行測試，修復失敗的測試，驗證修復結果"
✓ "分析效能瓶頸，優化最慢的函數，測量改進"

# 不好的任務描述
✗ "改進程式碼"
✗ "做一些優化"
```

## 與其他方法的結合

### Ralph Loop + 測試驅動開發 (TDD)

```
執行 ralph loop，反覆執行 10 回合：
1. 運行測試套件
2. 選擇一個失敗的測試
3. 編寫最小程式碼使其通過
4. 重構（保持測試通過）
5. 繼續下一個失敗測試

保證完成 "所有測試通過"
```

### Ralph Loop + Code Review

```
執行 ralph loop，反覆執行 5 回合：
1. 審查程式碼安全性
2. 審查程式碼效能
3. 審查程式碼可讀性
4. 修正發現的問題
5. 驗證修正

保證完成 "無高優先級問題"
```

## 輸出格式

每輪迭代應輸出：

```markdown
## 回合 N/總數

### 本輪執行
- [x] 完成的工作項目 1
- [x] 完成的工作項目 2
- [ ] 未完成項目（下輪處理）

### 當前狀態
- 測試：X 通過 / Y 失敗
- 錯誤：N 個待修正

### 下輪計劃
- 優先處理項目 A
- 然後處理項目 B

### 完成進度
[████████░░] 80% - 距離完成承諾還需 X 項
```

## 注意事項

1. **避免無限循環**：始終設定 `--max-iterations`
2. **可驗證的標準**：完成承諾必須可以客觀驗證
3. **保存進度**：每輪都應該有可見的進展
4. **適時中止**：如果連續幾輪無進展，考慮調整策略

## 參考資料

- [Ralph Wiggum Plugin](https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum)
- [Claude Code 官方文檔](https://docs.anthropic.com/claude-code)

---

**Ralph Loop** - 讓 AI 透過持續迭代達成高品質輸出的開發方法論
